<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C 标准库</title>
    <url>/2021/11/25/C/C-%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<h2 id="标准输入输出-lt-stdio-h-gt"><a href="#标准输入输出-lt-stdio-h-gt" class="headerlink" title="标准输入输出 &lt;stdio.h&gt;"></a>标准输入输出 &lt;stdio.h&gt;</h2><p>stdio standard input and output</p>
<p>stdin 标准输入<br>stdout 标准输出<br>stderr 标准错误输出</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>int getchar(void)</td>
<td>从标准输入（一般是键盘）中一次读取一个字符</td>
</tr>
<tr>
<td>int putchar(int)</td>
<td>将字符送至标准输出上</td>
</tr>
<tr>
<td>int printf(char *format, arg1, …)</td>
<td>格式化输出</td>
</tr>
<tr>
<td>int scanf(char *format, …)</td>
<td>格式化输入</td>
</tr>
<tr>
<td>int sscanf(char *string, char *format, arg1, …)</td>
<td>从一个字符串中读取字符序列</td>
</tr>
<tr>
<td>FILE *fopen(char *name, char *mode)</td>
<td>打开文件</td>
</tr>
<tr>
<td>int getc(FILE *fp)</td>
<td>从文件中返回下一个字符</td>
</tr>
<tr>
<td>int putc(int c, FILE *fp)</td>
<td>将字符写入文件中</td>
</tr>
<tr>
<td>int fscanf(FILE *fp, char *format,…)</td>
<td>文件格式化输入</td>
</tr>
<tr>
<td>int fprintf(FILE *fp, char *format,…)</td>
<td>文件格式化输出</td>
</tr>
<tr>
<td>int fclose(FILE *fp)</td>
<td>关闭文件</td>
</tr>
<tr>
<td>int feeor(FILE *fp)</td>
<td>流中出现错误，返回非零值</td>
</tr>
<tr>
<td>int feof(FILE *fp)</td>
<td>到达文件结尾，返回非零值</td>
</tr>
<tr>
<td>char *fgets(char *line, int maxline, FILE *fp)</td>
<td>从文件中读取下一个输入行，并放在字符数组中</td>
</tr>
<tr>
<td>int fput(char *line, FILE *fp)</td>
<td>将字符串写入到文件中</td>
</tr>
</tbody></table>
<h2 id="字符串操作-lt-string-h-gt"><a href="#字符串操作-lt-string-h-gt" class="headerlink" title="字符串操作 &lt;string.h&gt;"></a>字符串操作 &lt;string.h&gt;</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>strcat(char *s, char *t)</td>
<td>将t指向的字符串连接到s指向的字符串的末尾</td>
</tr>
<tr>
<td>strncat(char *s, char *t, int n)</td>
<td>将t指向的字符串中前n个字符连接到s指向的字符串的末尾</td>
</tr>
<tr>
<td>strcmp(char *s, char *t)</td>
<td>比较字符串大小</td>
</tr>
<tr>
<td>strncmp(char *s, char *t, int n)</td>
<td>比较字符串前n个字符大小</td>
</tr>
<tr>
<td>strcpy(char *s, char *t)</td>
<td>将t指向的字符串复制到s指向的位置</td>
</tr>
<tr>
<td>strlen(char *s)</td>
<td>返回s指向的字符串的长度</td>
</tr>
<tr>
<td>strchr(char *s, int c)</td>
<td>在s指向的字符串中查找c，返回第一次出现的位置的指针</td>
</tr>
<tr>
<td>strrchr(char *s, int c)</td>
<td>在s指向的字符串中查找c，返回最后一次出现的位置的指针</td>
</tr>
</tbody></table>
<h2 id="字符操作-lt-ctype-h-gt"><a href="#字符操作-lt-ctype-h-gt" class="headerlink" title="字符操作 &lt;ctype.h&gt;"></a>字符操作 &lt;ctype.h&gt;</h2><p>isalpha<br>isupper<br>islower<br>isdigit<br>isalnum<br>isspace<br>toupper<br>tolower</p>
<h2 id="通用-lt-stdlib-h-gt"><a href="#通用-lt-stdlib-h-gt" class="headerlink" title="通用 &lt;stdlib.h&gt;"></a>通用 &lt;stdlib.h&gt;</h2><p>atof<br>malloc<br>calloc<br>free<br>exit<br>system<br>frand</p>
<h2 id="数学函数-lt-math-h-gt"><a href="#数学函数-lt-math-h-gt" class="headerlink" title="数学函数 &lt;math.h&gt;"></a>数学函数 &lt;math.h&gt;</h2><p>sin<br>cos<br>atan2<br>exp<br>log<br>log10<br>pow<br>sqrt<br>fabs</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C 介绍</title>
    <url>/2021/11/24/C/C-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>为了编写Unix系统，早期使用汇编语言，为了编写Unix系统，创建了C。但其发展早已超出了作为Unix操作系统的初衷。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>1973年 C语言诞生。<br>1978 K&amp;R 《The C Programming Language》 出版。<br>1983 ANSI（American National Standards Institute 美国国家标准学会）成立C标准委员会，建立C语言的标准。<br>1989 ANSI发布了第一个完整的C标准 ANSI X3.159-1989，简称C89。<br>1990 ISO（International Standard Organization 国际标准化组织）发布了 ISO/IEC 9899:1990，内容与C89一致，简称 C90。<br>1999 ISO发布了ISO/IEC 9899:1999， 简称 C99。<br>2011 ISO发布了ISO/IEC 9899:2011， 简称 C11。<br>2018 ISO发布了ISO/IEC 9899:2018， 简称 C18。</p>
<h2 id="基于C的语言"><a href="#基于C的语言" class="headerlink" title="基于C的语言"></a>基于C的语言</h2><p>C++：包含了所有C的特性，增加了类和其它特性以支持面向对象编程。<br>Java：基于C++，所以也继承了许多C的特性。<br>C#：由C++和Java发展起来的一门语言。<br>Prel: 脚本语言，发展过程中采取了许多C的特性。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>运行速度快、高效 </li>
<li>功能强大</li>
<li>灵活 为了系统编程设计，但不是只能编写系统。非法的操作在C中是允许的。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>危险性高</li>
<li>没有模块化</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>数据类型</li>
<li>流程控制语句</li>
<li>函数</li>
<li>编译 预处理阶段对程序文本进行宏替换、包含其它源文件以及进行条件编译。</li>
<li>处理大部分计算机能够处理的对象，如字符、数字、地址。</li>
<li>不提供直接处理复合对象的操作。</li>
<li>单线程</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>C 语法</title>
    <url>/2021/11/24/C/C-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数据类型、运算符、表达式"><a href="#数据类型、运算符、表达式" class="headerlink" title="数据类型、运算符、表达式"></a>数据类型、运算符、表达式</h2><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><ul>
<li>数字及字母组成，以字母开头。</li>
<li>“_”被看作是字母，用来命名较长的变量名。</li>
<li>库例程的名字通常以下划线开头，因此变量不要以下划线开头。</li>
<li>严格区分大小写。</li>
<li>关键字不能用作变量，关键字中的字符小写。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>名称</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字符型</td>
<td>一个字节</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>所用机器中整数的最自然长度</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点型</td>
<td>-</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型</td>
<td>-</td>
</tr>
</tbody></table>
<h4 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h4><p>short/long 限定整型： short通常为16位，long通常为32位。<br>signed/unsigned: 限定char类型或任何整型。不带限定符的对象是否带符号取决于具体机器实现。<br>long double ： 表示高精度的浮点数。浮点型的长度取决于具体的实现。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="define"><a href="#define" class="headerlink" title="define"></a>define</h4><p>定义： #define 常量名 常量值 （宏定义）<br>常量类型通过后缀可以判断。无符号常量以u/U结尾。<br>const: 变量的值不能被修改。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举是一个常量整型值的列表。<br>定义： enum 枚举名 { 常量名[=值]… }<br>没有显示指定，第一个值为0，显示指定部分值，按最后一个指定值递增。</p>
<h4 id="define-VS-enum"><a href="#define-VS-enum" class="headerlink" title="define VS enum"></a>define VS enum</h4><p>enum常量值可以自动生成。<br>调试程序可以以符号形式打印出枚举变量的值。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>所有变量必须先声明后使用。<br>初始化表达式 变量名的后面紧跟一个等号以及一个表达式。<br>默认情况下，外部变量与静态变量将被初始化为0。未经显示初始化的自动变量的值为未定义值。</p>
<p>限定符<br>const 指定变量的值不能被修改。数组中所有元素的值都不能被修改。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>算术  + - * / %</li>
<li>关系  &gt; &gt;= &lt; &lt;=</li>
<li>相等性  == !=</li>
<li>逻辑  &amp;&amp; || （短路功能） ！</li>
<li>自增/自减  ++ –</li>
<li>按位  &amp; | ! ^ &lt;&lt; &gt;&gt; ~ （只能作用与整型）（算术移位/逻辑移位）</li>
<li>赋值  =</li>
<li>三元  ?:</li>
</ul>
<p>优先级<br><img src="/images/pasted-7.png" alt="upload successful"></p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>算术类型转换 运算时两个操作数类型不同，进行运算钱把“较低”的类型提升为“较高”的类型。（float不会自动转换为double）<br>赋值类型转换 超出的高位部分将被丢弃。<br>强制类型转换 显示类型转换 （类型名）表达式</p>
<p>char类型是较小的整型，因此在算术表达式中可以自由使用char类型的变量。</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>用运算符将运算对象连接起来的式子。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>语句： 表达式后加上一个分号（；）。分号是语句结束符。<br>程序块： 复合语句，把一组声明和语句用一对花括号（{}）括在一起。</p>
<ul>
<li>if-else 用于条件判定。</li>
<li>else-if 用于多路判定。</li>
<li>switch 多路判定语句，使用常量表达式。</li>
<li>while 循环体执行前对终止条件进行测试。</li>
<li>for 循环体执行前对终止条件进行测试；包含continue时可以和while转换。（包含简单的初始化和变量递增时更合适）</li>
<li>do-while 循环体执行后对终止条件进行测试，循环体被至少执行一次。</li>
<li>break 从switch中跳出，或在for、while、do-while最内层跳出。</li>
<li>continue 使for、while、do-while开始下一次的循环。</li>
<li>goto 跳到标号处执行。适合深度嵌套的处理过程。尽可能少的使用。</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名(参数声明表) &#123;</span><br><span class="line">    声明和语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果函数定义中省略了返回值类型，则默认为int类型。</li>
<li>声明函数参数类型及返回值类型。 返回值类型 函数名（参数类型）;。</li>
<li>没有声明过的函数会被隐式声明，返回值被假定为int类型，但并不对其参数进行假设。</li>
<li>函数不能嵌套定义。</li>
<li>没有参数使用void进行声明。</li>
<li>支持变长参数 … 。</li>
</ul>
<ul>
<li>自动变量 局部作用域变量。控制流进入变量作用域是系统自动为其分配存储空间，并在离开作用域时释放空间的一类变量。</li>
<li>外部变量 在函数外定义的全局变量。作用域：变量的定义处开始，到本程序文件的结尾。</li>
<li>内部变量 局部变量，指在一个函数内部或复合语句内部定义的变量。</li>
<li>全局变量 对所有程序文件都是可见的。</li>
</ul>
<h3 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h3><p>定义C中变量/函数的范围和声明周期。包括auto、register、static、extern。</p>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>只能修饰局部变量，局部变量的默认值。</p>
<h4 id="register"><a href="#register" class="headerlink" title="register"></a>register</h4><p>变量使用频率较高，将变量放在机器的寄存器上，使得程序更小，执行速度更快。但编译器可以忽略此选项。<br>register 声明只适用于自动变量以及函数的形式参数。</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li>静态变量 声明对象的作用域限定于被编译源文件的剩余部分。</li>
<li>静态函数 除了函数声明所在的文件外，其它文件都无法访问。</li>
<li>局部静态变量 一直占据存储空间。</li>
</ul>
<h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><p>只声明外部变量，不能初始化。<br>用于提供一个全局变量的引用。<br>声明后可在外部变量定义前使用该变量，或由其它源文件做定义。</p>
<h3 id="main函数参数"><a href="#main函数参数" class="headerlink" title="main函数参数"></a>main函数参数</h3><ul>
<li>int argc</li>
<li>char *argv[]</li>
</ul>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>包含函数声明和宏定义，被多个源文件中引用共享。<br>主要用于保存程序的声明。</p>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>预处理器是编译过程中单独执行的第一个步骤。</p>
<ul>
<li>文件包含 处理 #include 指令。</li>
<li>宏替换  替换 #define 变量。</li>
<li>条件包含  预处理执行的过程中进行计算。</li>
</ul>
<h2 id="指针、数组"><a href="#指针、数组" class="headerlink" title="指针、数组"></a>指针、数组</h2><p>指针： 一种保存变量地址的变量。<br>间接引用运算符： *。<br>取址运算符： &amp;。<br>void指针表示 无类型指针，没有特定的类型，因此可以指向任何类型的数据。参数声明表示可以是任意类型的指针。</p>
<h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><p>C中以传值的方式将参数值传递给被调用函数，被调用函数不能直接修改主调函数中变量的值。<br>指针参数使得被调用函数能够访问和修改主调函数中对象的值。<br>指针参数： 类型 *参数名， 。<br>返回指针： 类型 *函数名(…) {…} 。</p>
<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>数组： 存储在相邻内存区域中的对象组成的集合。<br>数组定义： 类型 变量[长度]; 。<br>指针加1： 指向指针所指对象的下一个对象。<br>通过数组和下标实现的表达式可等价的通过指针和偏移量实现。<br>当把数组作为参数传递给函数时，实际传递的是该数组第一个元素的地址，即一个存储地址值的变量，即指针。所以函数定义中，形参 char c[] 和 char *c 是等价的。<br>也可以将子数组的起始位置的指针传给函数，即将数组的一部分传递给了函数。</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>相同类型的指针之间的赋值运算。<br>指针同整数之间的加法和减法运算。<br>指向相同数组中元素的两个指针间的减法或比较运算。<br>将指针赋值为0或指针与0之间的比较运算。</p>
<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>存储指针的数组。指向指针的指针。<br>定义: 类型 *变量名[长度] 。<br>初始化： 字面量初始化。</p>
<h3 id="复杂声明"><a href="#复杂声明" class="headerlink" title="复杂声明"></a>复杂声明</h3><p>指针的指针 ： 类型 **参数名<br>数组的指针 ： 类型 (*参数名)[长度]<br>指针数组 ： 类型 *参数名[长度]<br>函数返回指针 : 类型 *函数名(…)<br>函数指针 ： 类型 (*函数名)(参数…)<br>？？？ ： 类型 (*(*函数名())[])()<br>？？？ ： 类型 (*(*函数名[长度])())[长度]</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>结构是一个或多个变量的集合。将一组相关的变量看作一个单元而不是各自读离的实体，因此有助于组织复杂的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct [结构标记] &#123;</span><br><span class="line">    类型 结构成员;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构成员、结构标记和普通变量可以采用相同名字而不会冲突。<br>声明： struct {…} x, y, z; 与基本类型变量声明一致。<br>成员运算符： . 。<br>初始化： 定义时初始化， 赋值初始化（结构名.成员）。<br>结构可以嵌套。</p>
<h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><p>向函数传参</p>
<ul>
<li><p>传递结构成员</p>
</li>
<li><p>传递结构  值传递，在函数里修改成员并不会影响原结构</p>
</li>
<li><p>传递结构指针<br>返回结构： struct 结构名 函数名(…) 。</p>
</li>
<li><p>结构数组</p>
</li>
<li><p>结构指针 struct 结构名 *函数名(…)</p>
</li>
<li><p>类型定义  typedef， 用来建立新的数据类型名。</p>
</li>
</ul>
<h2 id="联合-共用体"><a href="#联合-共用体" class="headerlink" title="联合/共用体"></a>联合/共用体</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union 共用体名 &#123;</span><br><span class="line">    类型 成员;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>共用体的所有成员占用同一段内存，占用的内存等于最长的成员占用的内存。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>js prototye</title>
    <url>/2021/07/29/JS/js-prototye/</url>
    <content><![CDATA[<ol>
<li><strong>proto</strong> 和 contructor 是对象属性，prototype是函数属性（函数也是对象）。</li>
<li><strong>proto</strong> 由一个对象指向它的原型对象。</li>
<li>prototype 从一个函数指向所创建实例的原型对象。</li>
<li>contructor 从一个对象指向给对象的构造函数。</li>
</ol>
<h2 id="prototype-的目的"><a href="#prototype-的目的" class="headerlink" title="prototype 的目的"></a>prototype 的目的</h2><p>共享方法、共享属性、面向对象</p>
<ol>
<li>函数内部定义的变量及函数，只能在内部调用，是私有的，外部无法访问。</li>
<li>函数添加静态变量及函数，通过函数对象本身可以访问，但是通过实例访问不到。</li>
<li>函数内部通过this添加变量及函数，创建实例时详单与做了拷贝，无法共享。（函数本身拷贝没有意义，且浪费资源）</li>
</ol>
<p>故，只要创建一个函数，就为该函数创建一个prototype属性，prototype本身是个对象，其contructor属性指向该函数本身，其__proto__属性指向Function.prototype。</p>
<h2 id="对象创建方式及区别"><a href="#对象创建方式及区别" class="headerlink" title="对象创建方式及区别"></a>对象创建方式及区别</h2><ol>
<li>字面量创建<br> <strong>proto</strong> 指向Object.prototype。</li>
<li>函数对象<br> <strong>proto</strong> 指向Function.prototype。<br> prototype 指向 该对象的prototype。</li>
<li>new创建<ol>
<li>生成一个新对象</li>
<li>设置对象__proto__指向函数的prototype属性。</li>
<li>绑定this</li>
<li>返回</li>
</ol>
</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code>内部使用this变量，使用new调用创建。
构造函数生成的实例对象都有__proto__属性，指向构造函数的prototype。
利用构造函数继承属性，利用原型对象继承方法。（组合继承）
</code></pre>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><pre><code>构造函数的另一种写法。
语法糖。
</code></pre>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><pre><code>1. 原型链继承
2. 构造函数继承
3. 组合继承
其它。。。
</code></pre>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>vue</title>
    <url>/2021/07/29/JS/vue/</url>
    <content><![CDATA[<ul>
<li>ES6在语言的层面上实现了模块化。浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li>
</ul>
<p>VUE项目打包后通过nginx代理找不到js/css文件</p>
<ul>
<li><p>nginx代理后路径为 root 路径 + location 路径</p>
</li>
<li><p>需要修改VUE static 打包路径为 location 路径 + static (相对路径)</p>
</li>
<li><p>需要修改VUE index.html 打包路径为 location 路径下的index.html  或者 修改 nginx 配置 try_files 为 location 路径/index.html</p>
<p>  __dirname ： js文件当前绝对路径（仅在js文件中有效）<br>  path： node 内置模块<br>  index: 打包后 index.html 文件路径 （绝对路径）<br>  assetRoot: 指向包含应用程序的所有静态资源的根目录<br>  assetsSubDirectory: 静态资源要存放的路径， 相对于 assetRoot 的路径<br>  assetsPublicPath: 代表打包后，index.html里面引用资源的的地址 （相对路径/绝对路径）</p>
</li>
</ul>
<p>eslint 文件/设置中 区别，关系<br>-文件：运行项目后，通过控制台才发现语法错误。<br>-设置：在开发过程中，就根据ESlint规则修改代码。（不必支持项目）<br>IDEA中配置：Setting -&gt;Preferences -&gt; Languages &amp; Frameworks -&gt; JavaScript -&gt; Code Quality Tools -&gt; Eslint ，然后勾选Enable单选框。</p>
<pre><code>    IDEA webpack配置
- 当在“设置/首选项”|语言和框架|JavaScript|Webpack中打开项目或编辑指定的webpack.config.js时，IntelliJ IDEA在后台分析配置，并根据收到的信息，正确理解项目解析根和解析别名。由于对项目配置的理解，IntelliJ IDEA为JavaScript文件中的导入和导出符号提供了更精确的代码完成。
</code></pre>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>ElasticSearch简介</title>
    <url>/2023/09/10/Elastic/%EF%BC%881%EF%BC%89ElasticSearch%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="文档和索引"><a href="#文档和索引" class="headerlink" title="文档和索引"></a>文档和索引</h2><ul>
<li>分布式文档存储。</li>
<li>存储复杂数据结构，使用JSON存储。</li>
<li>集群部署，多节点访问最新数据。</li>
</ul>
<hr>
<ul>
<li>近实时（within 1 second） 全文检索。</li>
<li>使用倒排索引支持快速全文检索。</li>
<li>分词。</li>
</ul>
<hr>
<ul>
<li>index -&gt; document -&gt; filed。</li>
<li>键值对存储。</li>
<li>不同类型的字段存储在不同的索引中，text存储在倒排索引中，数据和地理坐标存储在BKD树。</li>
</ul>
<hr>
<ul>
<li>schema-less。</li>
<li>dynamic mapping。</li>
</ul>
<hr>
<ul>
<li>自定义mapping以控制字段的存储和索引。<ul>
<li>区分全文检索和精准匹配。</li>
<li>基于指定语言进行分词。</li>
<li>优化字段匹配方式。</li>
<li>使用自定义数据格式。</li>
<li>指定无法自动检测的数据类型，如get_point、get_shape。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>单个字段使用多种分词方式。如一个字段有test和keyword。</li>
</ul>
<hr>
<ul>
<li>保存时分词，查询时也进行分词。</li>
</ul>
<h2 id="查询和分词"><a href="#查询和分词" class="headerlink" title="查询和分词"></a>查询和分词</h2><ul>
<li>文档存储和检索，基于Apache Lucene搜索引擎库。</li>
<li>ElasticSearch提供了简单易用的REST API。</li>
<li>测试方面，可以通过命令行，Kibana的控制台。</li>
<li>应用集成时，使用对应语言的ElasticSearch Client。</li>
<li>Java、JavaScript、Go、.Net、PHP、Perl、Python、Ruby。</li>
</ul>
<hr>
<ul>
<li>REST APIs支持结构化查询，全文查询，和包含两者的复杂查询。</li>
<li>结构化查询类型于sql。</li>
</ul>
<hr>
<ul>
<li>模糊查询、近似查询、前缀匹配、自动填充建议。</li>
<li>支持高性能查询数值型和地理坐标类型。</li>
</ul>
<hr>
<ul>
<li>JSON-Style query language（Query DSL）。</li>
<li>SQL-style queries。JDBC、ODBC驱动。</li>
</ul>
<hr>
<ul>
<li>聚合，可以构建复杂的数据摘要，并获得世俗据的指标、模式、趋势。</li>
<li>聚合使用相同的数据结构，也是非常快的。</li>
<li>实时。</li>
</ul>
<hr>
<ul>
<li>聚合与查询同时进行。</li>
<li>聚合基于查询结果，因此聚合也可以包含查询结果。</li>
</ul>
<hr>
<ul>
<li>机器学习。<ul>
<li>偏差。</li>
<li>统计稀有度。</li>
<li>异常侦测。</li>
</ul>
</li>
</ul>
<h2 id="可扩展性和分片"><a href="#可扩展性和分片" class="headerlink" title="可扩展性和分片"></a>可扩展性和分片</h2><ul>
<li>高可用，可扩展。 只需添加节点到集群。<ul>
<li>index是物理分片的逻辑分组。每个分片是个自包含索引。</li>
<li>文档分布在多个分片上，分片分布在多个节点上，确保冗余。</li>
<li>主分片、副本分片。副本分片是主分片的拷贝。</li>
<li>主分片的数量在创建索引时固定，副本分片可随时调整。</li>
</ul>
</li>
<li>分片越多，维护索引的开销就越大。</li>
<li>分片越大，需要移动时，时间越长。</li>
</ul>
<hr>
<ul>
<li>可靠的链接，将节点置于同一数据中心或相邻的数据中心。</li>
<li>高可用，将节点置于不同的数据中心。</li>
<li>CCR，跨集群复制。</li>
<li>跨集群复制是主动-被动的。</li>
<li>辅助集群的索引是只读的。</li>
</ul>
<hr>
<ul>
<li>企业级，安全、管理、监控集群。 - Kibana</li>
<li>Kibana，数据汇总，索引生命周期管理。</li>
</ul>
]]></content>
      <categories>
        <category>Elastic</category>
      </categories>
  </entry>
  <entry>
    <title>ElasticSearch安装</title>
    <url>/2023/09/11/Elastic/%EF%BC%882%EF%BC%89ElasticSearch%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Linux下安装"><a href="#Linux下安装" class="headerlink" title="Linux下安装"></a>Linux下安装</h2><ul>
<li>下载</li>
<li>解压</li>
<li>运行</li>
</ul>
<h2 id="Windows下安装"><a href="#Windows下安装" class="headerlink" title="Windows下安装"></a>Windows下安装</h2><ul>
<li>下载</li>
<li>解压</li>
<li>运行</li>
</ul>
<h2 id="Java（JVM）版本"><a href="#Java（JVM）版本" class="headerlink" title="Java（JVM）版本"></a>Java（JVM）版本</h2><ul>
<li>ElasticSearch中内置了OPENJDK，推荐使用内置JVM。</li>
<li>使用ES_JAVA_HOME环境变量替换内置Java。</li>
<li>替换内置Java需注意Java版本。</li>
<li>内置JVM是ElasticSearch的一部分，会随着ES一起更新，并负责解决安全事项及bugs。</li>
<li>内置JVM在jdk目录下，如果使用自定义JVM需要移除。</li>
</ul>
<h2 id="重要配置"><a href="#重要配置" class="headerlink" title="重要配置"></a>重要配置</h2><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><ul>
<li>data目录，存储数据。</li>
<li>log目录，存储日志。</li>
<li>默认在$ES_HOME目录下。</li>
<li>$ES_HOME目录下的文件在升级过程中存在删除风险。</li>
<li>强烈推荐在yml中配置path.data与path.logs，不要放在$ES_HOME目录下。</li>
</ul>
<h3 id="多路径配置"><a href="#多路径配置" class="headerlink" title="-多路径配置-"></a>-多路径配置-</h3><ul>
<li>在7.13.0中弃用。</li>
<li>在多个配置路径中都保存。</li>
<li>如果有一个路径磁盘使用率过高，则所有路径都不能添加分片。</li>
<li>推荐添加多个节点，而不是多个路径。</li>
</ul>
<h3 id="多路径配置迁移"><a href="#多路径配置迁移" class="headerlink" title="多路径配置迁移"></a>多路径配置迁移</h3><ul>
<li>使用硬件/软件虚拟化。</li>
<li>迁移，滚动升级。<ul>
<li>关闭节点</li>
<li>修改配置</li>
<li>启动节点</li>
<li>下个节点…</li>
</ul>
</li>
</ul>
<h3 id="集群名称配置"><a href="#集群名称配置" class="headerlink" title="集群名称配置"></a>集群名称配置</h3><ul>
<li>cluster.name</li>
<li>只有节点配置集群名称时才能加入到集群中。</li>
<li>集群名称默认为elasticsearch。</li>
<li><strong>不要在不同的环境中使用相同的集群名称，避免节点加入到错误的集群。</strong></li>
</ul>
<h3 id="节点名称"><a href="#节点名称" class="headerlink" title="节点名称"></a>节点名称</h3><ul>
<li>node.name</li>
<li>节点名称在许多API中会返回。</li>
<li>节点名称默认为主机名。</li>
</ul>
<h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><ul>
<li>network.host</li>
<li>默认使用127.0.0.1。</li>
<li><em><strong>配置后表示在使用生产模式，而不是开发模式。</strong></em></li>
</ul>
<h3 id="发现和集群信息配置"><a href="#发现和集群信息配置" class="headerlink" title="发现和集群信息配置"></a>发现和集群信息配置</h3><ul>
<li>discovery.seed_hosts</li>
<li>生产模式按需配置。</li>
<li>开箱急用，默认扫描同服务下9300~9305端口。</li>
<li>发现其他服务下的节点，需要配置。</li>
<li>列表。</li>
<li>可配置IP/IPV6地址，域名及端口。</li>
<li>默认端口9300，可配置。</li>
</ul>
<hr>
<ul>
<li>cluster.initial_master-nodes</li>
<li>如果master-eligible节点没有固定的名称或者地址，可以使用配置动态发现。</li>
<li>自动引导本质上不安全。</li>
<li>通过配置的节点可以被优先选举为master节点。</li>
<li><em><strong>启动成功之后移除每个节点中的配置。</strong></em></li>
<li><em><strong>不要在重启集群或添加新节点时使用该配置。</strong></em></li>
<li>配置必须与节点名称保持一致。</li>
</ul>
<h3 id="堆大小配置"><a href="#堆大小配置" class="headerlink" title="堆大小配置"></a>堆大小配置</h3><ul>
<li>ES根据节点角色及内存大小，自动设置堆内存大小。（要求Java14）</li>
<li>推荐使用自动计算。</li>
</ul>
<h3 id="堆转存路径设置"><a href="#堆转存路径设置" class="headerlink" title="堆转存路径设置"></a>堆转存路径设置</h3><ul>
<li>内存溢出时转存到数据目录。</li>
<li>Linux、Windows、MacOS默认在安装目录下的root目录。</li>
<li>jvm.options</li>
</ul>
<h3 id="GC日志设置"><a href="#GC日志设置" class="headerlink" title="GC日志设置"></a>GC日志设置</h3><ul>
<li>jvm.options</li>
</ul>
<h3 id="临时目录"><a href="#临时目录" class="headerlink" title="临时目录"></a>临时目录</h3><ul>
<li>/temp</li>
</ul>
<h3 id="JVM错误级别日志"><a href="#JVM错误级别日志" class="headerlink" title="JVM错误级别日志"></a>JVM错误级别日志</h3><ul>
<li>Linux、Windows、MacOS默认在安装目录下的logs目录。</li>
<li>jvm.options</li>
</ul>
<h3 id="集群备份"><a href="#集群备份" class="headerlink" title="集群备份"></a>集群备份</h3><ul>
<li>快照。</li>
</ul>
<h2 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a>安全配置</h2><h2 id="安全审计配置"><a href="#安全审计配置" class="headerlink" title="安全审计配置"></a>安全审计配置</h2><p>…</p>
]]></content>
      <categories>
        <category>Elastic</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA 配置</title>
    <url>/2021/11/16/IDE/IDEA-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>since IntelliJ IDEA 2021.2.3.</p>
</blockquote>
<h3 id="换行显示"><a href="#换行显示" class="headerlink" title="换行显示"></a>换行显示</h3><blockquote>
<p>Settings -&gt; Editor -&gt; General =&gt; Soft Wraps</p>
</blockquote>
<p>可以设置要换行显示的文件格式</p>
<h3 id="文件末尾不加空行"><a href="#文件末尾不加空行" class="headerlink" title="文件末尾不加空行"></a>文件末尾不加空行</h3><blockquote>
<p>Settings -&gt; Editor -&gt; General =&gt; On Save</p>
</blockquote>
<p>ensure every saved file ends with a line break</p>
<h3 id="side-by-side"><a href="#side-by-side" class="headerlink" title="side-by-side"></a>side-by-side</h3><blockquote>
<p>Settings -&gt; Appearance &amp; Behavior -&gt; Appearance =&gt; Tool Windows</p>
</blockquote>
<p>Side-by-side layout on the left/right<br>左上、左下/右上、右下 显示为一行两列还是两行一列</p>
<h3 id="左侧隐藏文件-文件夹"><a href="#左侧隐藏文件-文件夹" class="headerlink" title="左侧隐藏文件/文件夹"></a>左侧隐藏文件/文件夹</h3><blockquote>
<p>Settings -&gt; Editor -&gt; File Types =&gt; Ignored Files and Folders</p>
</blockquote>
<h3 id="编辑页标签"><a href="#编辑页标签" class="headerlink" title="编辑页标签"></a>编辑页标签</h3><blockquote>
<p>Settings -&gt; Editor -&gt; General -&gt; Editor Tabs</p>
</blockquote>
<p>靠右显示、按字典序、修改标记、不显示关闭标签（Shift + 左键 = 关闭）、上限50</p>
<h3 id="打开项目不打开ReadMe"><a href="#打开项目不打开ReadMe" class="headerlink" title="打开项目不打开ReadMe"></a>打开项目不打开ReadMe</h3><blockquote>
<p>Settings -&gt; Advanced Setting =&gt; Startup</p>
</blockquote>
<p>Open README.md file if there are no open files on project startup</p>
<h3 id="隐藏底部工具栏与两边工具栏"><a href="#隐藏底部工具栏与两边工具栏" class="headerlink" title="隐藏底部工具栏与两边工具栏"></a>隐藏底部工具栏与两边工具栏</h3><blockquote>
<p> View -&gt; Appearance -&gt; Tool Windows Bars</p>
</blockquote>
<p>取消勾选</p>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/2020/02/05/Java/AOP/</url>
    <content><![CDATA[<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect Oriented Programing），面向切面编程，是对OOP的补充，通过预编译方式或运行期动态代理实现程序功能的统一维护的一种技术。</p>
<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>将与业务无关的代码，如日志记录，性能监控，事务处理等从业务逻辑代码中划分出来，将它们独立到非业务逻辑方法中，使得与业务方法解耦，并且在改变相关逻辑的时候不影响业务逻辑的代码。</p>
<h2 id="AOP-术语"><a href="#AOP-术语" class="headerlink" title="AOP 术语"></a>AOP 术语</h2><ul>
<li>切面（Aspect）：切面是一个横切关注点。</li>
<li>连接点（JointPoint）：连接点是具体执行增强的点，比如方法执行，构造器调用，成员赋值。</li>
<li>切点（PointCut）：匹配连接点的正则表达式，是连接点的集合。</li>
<li>通知（Advice）：对连接点的进行的操作。</li>
<li>织入（Weaving）：把切面应用到目标对象，并创建代理对象的过程。切面在指定的连接点被织入到目标对象。</li>
</ul>
<h2 id="四-AOP流行框架比较"><a href="#四-AOP流行框架比较" class="headerlink" title="四. AOP流行框架比较"></a>四. AOP流行框架比较</h2><p>当下最流行的AOP框架为Spring AOP 及 AspectJ。</p>
<h3 id="1-能力和目标"><a href="#1-能力和目标" class="headerlink" title="1. 能力和目标"></a>1. 能力和目标</h3><ul>
<li>Spring AOP<br>  旨在通过Spring IOC 提供一个简单的AOP实现。<br>  不是一个完整的AOP解决方案，只能用于被Spring容器管理的bean。</li>
<li>AspectJ<br>  完整的AOP解决方案，比Spring AOP复杂。<br>  可以在应用于所有领域对象。<h3 id="2-织入时机"><a href="#2-织入时机" class="headerlink" title="2. 织入时机"></a>2. 织入时机</h3></li>
<li>Spring AOP<br>  只能在运行时织入。</li>
<li>AspectJ<br>  可以在编译期，加载期，编译后（jar包和字节码文件）。<h3 id="3-依赖"><a href="#3-依赖" class="headerlink" title="3. 依赖"></a>3. 依赖</h3></li>
<li>Spring AOP<br>  使用JDK动态代理或者CGLIB代理。</li>
<li>AspectJ<br>  不依赖任何运行时环境，只需要AspectJ compiler(ajc)在运行前完成织入。<h3 id="4-连接点"><a href="#4-连接点" class="headerlink" title="4. 连接点"></a>4. 连接点</h3></li>
<li>Spring AOP<br>  由于要使用代理模式，所以不能作用域final类，static方法，final方法。<br>  只支持方法执行连接点。</li>
<li>AspectJ<br>  没有限制。<br>  方法调用，方法执行，构造器调用，构造器执行，静态初始化执行，对象初始化，成员引用，成员赋值，处理器执行，通知执行。<h3 id="5-复杂度"><a href="#5-复杂度" class="headerlink" title="5. 复杂度"></a>5. 复杂度</h3></li>
<li>Spring AOP<br>  不需要额外的编译器，只能和Spring管理的bean一起工作。</li>
<li>AspectJ<br>  需要引入ajc并重新打包。<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3></li>
</ul>
<table>
<thead>
<tr>
<th>Spring AOP</th>
<th>AspectJ</th>
</tr>
</thead>
<tbody><tr>
<td>Implemented in pure Java</td>
<td>Implemented using extensions of Java programming language</td>
</tr>
<tr>
<td>No need for separate compilation process</td>
<td>Needs AspectJ compiler (ajc) unless LTW is set up</td>
</tr>
<tr>
<td>Only runtime weaving is available</td>
<td>Runtime weaving is not available. Supports compile-time, post-compile, and load-time Weaving</td>
</tr>
<tr>
<td>Less Powerful – only supports method level weaving</td>
<td>More Powerful – can weave fields, methods, constructors, static initializers, final class/methods, etc…</td>
</tr>
<tr>
<td>Can only be implemented on beans managed by Spring container</td>
<td>Can be implemented on all domain objects</td>
</tr>
<tr>
<td>Supports only method execution pointcuts</td>
<td>Support all pointcuts</td>
</tr>
<tr>
<td>Proxies are created of targeted objects, and aspects are applied on these proxies</td>
<td>Aspects are woven directly into code before application is executed (before runtime)</td>
</tr>
<tr>
<td>Much slower than AspectJ</td>
<td>Better Performance</td>
</tr>
<tr>
<td>Easy to learn and apply</td>
<td>Comparatively more complicated than Spring AOP</td>
</tr>
</tbody></table>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.baeldung.com/spring-aop-vs-aspectj">https://www.baeldung.com/spring-aop-vs-aspectj</a></p>
<p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象。</p>
<p>织入时期：编译器（aspectj），装载器（cglib），运行期</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>BeanValidation</title>
    <url>/2020/02/05/Java/BeanValidation/</url>
    <content><![CDATA[<h2 id="Bean-Validation"><a href="#Bean-Validation" class="headerlink" title="Bean Validation"></a>Bean Validation</h2><pre><code>Bean Validation是一个运行时的数据验证框架，为JavaBean验证定义了相应的元数据模型和Api。
</code></pre>
<table>
<thead>
<tr>
<th>JSR版本</th>
<th>Bean Validation版本</th>
<th>发布时间</th>
<th>hibernate实现版本</th>
<th>apache BLal实现版本</th>
</tr>
</thead>
<tbody><tr>
<td>303</td>
<td>1.0</td>
<td>2009年javaee 6</td>
<td>4.3.1.Final</td>
<td>0.5</td>
</tr>
<tr>
<td>349</td>
<td>1.1</td>
<td>2013年javaee 7</td>
<td>5.1.1.Final</td>
<td>1.1.1</td>
</tr>
<tr>
<td>380</td>
<td>2.0</td>
<td>2017年javaee 8</td>
<td>6.0.1.Final</td>
<td>2.0.3</td>
</tr>
</tbody></table>
<h2 id="Hibernate-Validation"><a href="#Hibernate-Validation" class="headerlink" title="Hibernate Validation"></a>Hibernate Validation</h2><pre><code>hibernate validation是对这个规范的实践，他提供了相应的实现，并增加了一些其他校验注解(后期规范更新，hibernate将重复的标记了@Departure)，他们位于org.hibernate.validator.constraints包下。
</code></pre>
<h2 id="Spring-Validataion"><a href="#Spring-Validataion" class="headerlink" title="Spring Validataion"></a>Spring Validataion</h2><pre><code>spring validation对hibernate validation进行了二次封装，在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类（BindingResult）中。
</code></pre>
<h2 id="Validated-和-Valid-的区别"><a href="#Validated-和-Valid-的区别" class="headerlink" title="@Validated 和 @Valid 的区别"></a>@Validated 和 @Valid 的区别</h2><ul>
<li>@Validted 支持分组校验，@Valid不支持。</li>
<li>@Valid支持嵌套验证，@Validated不支持。</li>
<li>@Validated可以将校验结果绑定到BindingResult中，而不抛出异常。<br>  必须一个校验对象一个BindingResult，一一对应且紧随其后。</li>
<li>在没有分组校验及嵌套校验的情况下， 效果一致。</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><pre><code>https://beanvalidation.org
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Lombok 填坑</title>
    <url>/2021/06/24/Java/Lombok-%E5%A1%AB%E5%9D%91/</url>
    <content><![CDATA[<h2 id="lombok-getset生成"><a href="#lombok-getset生成" class="headerlink" title="lombok getset生成"></a>lombok getset生成</h2><p>属性名第一个字母小写，第二个字母大写<br>lombok生成的为 getXX<br>java官方默认的为 getxX</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Stream原理</title>
    <url>/2020/09/09/Java/Stream%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><p>Java 8 中定义了四种流，分别是Stream、IntStream、LongStream、DoubleStream。每种流的操作、参数等都有区别。</p>
<h3 id="BaseStream"><a href="#BaseStream" class="headerlink" title="BaseStream"></a>BaseStream</h3><p>所有流接口的父级接口。</p>
<h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><p>工具类。</p>
<h3 id="StreamSupport"><a href="#StreamSupport" class="headerlink" title="StreamSupport"></a>StreamSupport</h3><p>创建流的工具，多用于类库</p>
<h2 id="PipelineHelper"><a href="#PipelineHelper" class="headerlink" title="PipelineHelper"></a>PipelineHelper</h2><p>流水线，通过其将流串起来。</p>
<h3 id="AbstractPipeline"><a href="#AbstractPipeline" class="headerlink" title="AbstractPipeline"></a>AbstractPipeline</h3><p>抽象类，定义了流水线串联起来的属性，及一些方法。</p>
<h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>与流类型，也分为四类。ReferencePipeline、IntPipeline、LongPipeline、DoublePipeline。</p>
<h4 id="ReferencePipeline"><a href="#ReferencePipeline" class="headerlink" title="ReferencePipeline"></a>ReferencePipeline</h4><p>引用类型的流水线，抽象类，其实现类主要有，Head、StatelessOp、StatefulOp，分别表示第一个、无状态的和有状态。</p>
<h2 id="OP"><a href="#OP" class="headerlink" title="OP"></a>OP</h2><p>操作</p>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><h4 id="有状态的操作"><a href="#有状态的操作" class="headerlink" title="有状态的操作"></a>有状态的操作</h4><ul>
<li>distinct</li>
<li>sorted</li>
<li>limit</li>
<li>skip<h4 id="无状态的操作"><a href="#无状态的操作" class="headerlink" title="无状态的操作"></a>无状态的操作</h4></li>
<li>map</li>
<li>filter</li>
<li>peek<h3 id="结束操作"><a href="#结束操作" class="headerlink" title="结束操作"></a>结束操作</h3>TerminalOP。<h4 id="短路操作"><a href="#短路操作" class="headerlink" title="短路操作"></a>短路操作</h4></li>
<li>match</li>
<li>find<h4 id="非短路操作"><a href="#非短路操作" class="headerlink" title="非短路操作"></a>非短路操作</h4></li>
<li>foreach</li>
<li>reduce</li>
</ul>
<h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><p>真正的执行者。</p>
<h3 id="TerminalSink"><a href="#TerminalSink" class="headerlink" title="TerminalSink"></a>TerminalSink</h3><p>标识是结束操作。</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>返回值。</p>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>通过ForkJoinTask来实现并行流的处理。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="编码流程"><a href="#编码流程" class="headerlink" title="编码流程"></a>编码流程</h3><ol>
<li>创建一个stream</li>
<li>添加中间操作，包括有状态、无状态操作</li>
<li>添加结束操作</li>
<li>如果有返回值，接收返回值</li>
</ol>
<h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><ol>
<li>创建steam，其类型为Head</li>
<li>每一步中间操作，创建一个新的stream，其类型为StatelessOp或StatefulOp，并在新的steam中保存上一个stream的引用</li>
<li>对于结束操作，创建一个新的TerminalSink</li>
<li>通过stream中的引用，逆序对每一个中间操作创建一个Sink，因为Sink继承自Consumer，在accpet中调用下流sink</li>
<li>接收返回值</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>String</title>
    <url>/2021/11/15/Java/String/</url>
    <content><![CDATA[<p>在C/C++中，字符串作为字符的数组被实现。而在Java中，字符串是作为对象实现，字符串实际上是对象类型。</p>
<p>Java字面量：<br>    基本数据类型<br>    字符串<br>    数组 - 实际也是对象？</p>
<p>字符串常量池： 在类加载时，在堆（方法区？）中创建一个对象，然后将它的引用存放在池中（还是方法区？）的一个常量表中。并且不会被垃圾回收。</p>
<p>使用new创建字符串，是在运行期创建的。</p>
<p>String s1 = “abc”;<br>String s2 = new String(“abc”);<br>s1.equals(s2) &amp;&amp; s1 != s2 &amp;&amp; s1.value == s2.value<br>字符串的值使用数组实现，在java中也是对象，s1，s2 的值都指向常量池中的数组对象。</p>
<p>String intern(): 把自身替换为常量池中的引用</p>
<p>字符串拼接：<br>    字面量拼接： 优化为一个字面量<br>    字面量和变量拼接： 使用StringBuilder优化<br>    int + char -&gt; char<br>    int + string -&gt; string<br>    string + 任意 -&gt; string</p>
<p>String 实现方式<br>    Jdk 6 char[]、offset、count、hash<br>    Jdk 7、8  char[]、hash<br>    Jdk 9  byte[]、coder、hash  </p>
<p>数组：<br>    数据是对象，但不是从某个类实例化来的，而是由JVM直接创建的，其父类是Object。<br>    每个数据都对应一个Class对象，通过RTTI，可以检查数据的运行时类型，签名，基类等。</p>
<pre><code>数组        RTTI
char[]        [C
int[]        [I
long[]        [J
float[]        [F
String[]    [Ljava.lang.String;
</code></pre>
<p>字面量初始化<br>int          直接定义, int i = 1;<br>short         2个字节以内的int，short s = (short)1;<br>long        l/L 结尾<br>byte        1个字节以内的byte，byte b = (byte)1;<br>float        f/F 结尾<br>double        整数+d/D结尾或小数<br>char        单引号<br>boolean     true/false<br>string        双引号<br>[]            大括号{} （简化了new）</p>
<p>null        null</p>
<p>null：<br>    null是一种数据类型，但可以忽略。<br>    null是关键字，是所有对象类型的默认值。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>validate</title>
    <url>/2020/07/14/Java/validate/</url>
    <content><![CDATA[<h2 id="JSR303-JSR-349"><a href="#JSR303-JSR-349" class="headerlink" title="JSR303, JSR-349"></a>JSR303, JSR-349</h2><p>JSR303是一项标准,JSR-349是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，他们位于javax.validation.constraints包下，只提供规范不提供实现。</p>
<p>@Null 被注释的元素必须为null<br>@NotNull 被注释的元素必须不为null<br>@AssertTrue 被注释的元素必须为true<br>@AssertFalse 被注释的元素必须为false<br>@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>@Size(max, min) 被注释的元素的大小必须在指定的范围内<br>@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内<br>@Past 被注释的元素必须是一个过去的日期<br>@Future 被注释的元素必须是一个将来的日期<br>@Pattern(value) 被注释的元素必须符合指定的正则表达式</p>
<h2 id="hibernate-validation"><a href="#hibernate-validation" class="headerlink" title="hibernate validation"></a>hibernate validation</h2><p>hibernate validation是对这个规范的实践（不要将hibernate和数据库orm框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，他们位于org.hibernate.validator.constraints包下。<br>@Email 被注释的元素必须是电子邮箱地址<br>@Length 被注释的字符串的大小必须在指定的范围内<br>@NotEmpty 被注释的字符串的必须非空<br>@Range 被注释的元素必须在合适的范围内</p>
<h2 id="spring-validation"><a href="#spring-validation" class="headerlink" title="spring validation"></a>spring validation</h2><p>spring validation对hibernate validation进行了二次封装，在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中</p>
<ul>
<li>注意，必须相邻，如果有多个参数需要校验，形式可以如下。valid(@Validated Person person, BindingResult fooBindingResult ，@Validated Bar bar, BindingResult barBindingResult);即一个校验类对应一个校验结果。</li>
<li>校验结果会被自动填充</li>
<li>不加BindingResult ，会抛出BindException</li>
</ul>
<ol>
<li><p>@Validate 和 @Valid 的区别<br>而<br>而万能的spring为了给开发者提供便捷，对hibernate validation进行了二次封装，显示校验validated bean时，你可以使用spring validation或者hibernate validation，而spring validation另一个特性，便是其在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中。这无疑便捷了我们的web开发。<br>@Validate 支持分组验证，@Valid 支持嵌套验证</p>
</li>
<li><p>@Validate 用在方法入参和类上面的区别（能否用在方法上）</p>
</li>
<li><p>spring controller 验证</p>
</li>
<li><p>方法参数验证</p>
</li>
<li><p>自定义校验注解</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>对比</title>
    <url>/2022/06/22/Java/%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h2 id="DskipTests-VS-Dmaven-test-skip-true"><a href="#DskipTests-VS-Dmaven-test-skip-true" class="headerlink" title="-DskipTests VS -Dmaven.test.skip=true"></a>-DskipTests VS -Dmaven.test.skip=true</h2><ul>
<li>-DskipTests: 不执行测试用例，但编译测试用例类。</li>
<li>-Dmaven.test.skip=true: 不执行测试用例，也不编译测试用例类。</li>
</ul>
<h2 id="数据库存储-JSON-VS-多表关联"><a href="#数据库存储-JSON-VS-多表关联" class="headerlink" title="数据库存储 JSON VS 多表关联"></a>数据库存储 JSON VS 多表关联</h2><ul>
<li>JSON字段不固定，任意性强。 考虑使用NoSQL（MongoDB、Redis）。</li>
<li>存储JSON数据只是为了展示。</li>
<li>程序每次JSON耗时。</li>
<li>JSON反序列化效率与多表关联查询效率（TODO）。</li>
</ul>
<h2 id="left-join-on-and-VS-where"><a href="#left-join-on-and-VS-where" class="headerlink" title="left join on and VS where"></a>left join on and VS where</h2><ul>
<li>left join左表所有数据及右表匹配的数据。</li>
<li>on后的and条件可以用于右表中不匹配的数据。</li>
<li>where用于对生成的临时表做过滤。</li>
<li>如果在on中添加对左表的过滤，则不会生效。</li>
</ul>
<h2 id="pom-vs-yml-profile"><a href="#pom-vs-yml-profile" class="headerlink" title="pom vs yml profile"></a>pom vs yml profile</h2><h2 id="Swagger2-VS-Open-API"><a href="#Swagger2-VS-Open-API" class="headerlink" title="Swagger2 VS Open API"></a>Swagger2 VS Open API</h2><h2 id="IDEA-版本"><a href="#IDEA-版本" class="headerlink" title="IDEA 版本"></a>IDEA 版本</h2><h2 id="JSONObject-VS-Map-lt-String-Object-gt"><a href="#JSONObject-VS-Map-lt-String-Object-gt" class="headerlink" title="JSONObject VS Map&lt;String, Object&gt;"></a>JSONObject VS Map&lt;String, Object&gt;</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS8</title>
    <url>/2020/02/05/Linux/CentOS8/</url>
    <content><![CDATA[<blockquote>
<p>最近centos 8发布，而且之前系统安装软件、文件路径都不太符合现在所理解的一些规范，所以准备重新安装系统。</p>
</blockquote>
<h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><h3 id="机器配置"><a href="#机器配置" class="headerlink" title="机器配置"></a>机器配置</h3><ul>
<li>型号： HP200 Pro G1 MT（(J1800)）</li>
<li>处理器： Intel Celeron J1800(2.41GHz/L3 1M)，双核双线程</li>
<li>内存： 4G DDR3 1600</li>
<li>硬盘： 500G机械硬盘</li>
</ul>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol>
<li>阿里云下载centos8 iso镜像，制作U盘启动。</li>
<li>开机时不插键盘，出现键盘找不到时，插入usb键盘，按esc，设置引导。</li>
<li>选择最小安装，设置磁盘分区，开启网络配置，开始安装。</li>
</ol>
<h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><table>
<thead>
<tr>
<th>路径</th>
<th>格式</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>/boot</td>
<td>-</td>
<td>512MB</td>
</tr>
<tr>
<td>/boot/efi</td>
<td>-</td>
<td>256MB</td>
</tr>
<tr>
<td>swap</td>
<td>-</td>
<td>8GB</td>
</tr>
<tr>
<td>/home</td>
<td>-</td>
<td>150GB</td>
</tr>
<tr>
<td>/var</td>
<td>-</td>
<td>50GB</td>
</tr>
<tr>
<td>/</td>
<td>-</td>
<td>260GB左右(剩余全部)</td>
</tr>
</tbody></table>
<h3 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>主板键盘为ps/2接口，只能通过ps/2接口进入BIOS设置（ps/2转usb转换头也不行）。<blockquote>
<p>开机时不插键盘，出现键盘找不到时，插入usb键盘，按esc。</p>
</blockquote>
</li>
<li>镜像开机时选择install选项后不出现安装界面。<blockquote>
<p>选择install选项，按e键进入编辑页面，将label设置为/dev/sdb4，按ctrl+X执行安装。<br>PS1: 可以先修改为linux dd查看设备，确定之后在修改。<br>PS2：在引导系统中，按Ctrl + Shift + Delete 组合键重启。</p>
</blockquote>
</li>
<li>使用DVD镜像安装时，提示 Pane is DEAD，而使用虚拟机安装是没有问题的。<blockquote>
<p>使用网络版镜像安装，在设置安装源时，先联网，然后选择从网络安装，设置镜像仓库地址。<br>PS：网络版镜像应该不是官网的，而是阿里云提供的。</p>
</blockquote>
</li>
</ul>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>/usr/local 安装系统软件<br>/opt 安装临时软件，存储安装包（压缩包安装方式）<br>/var 放日志文件</p>
<h3 id="开放端口及服务"><a href="#开放端口及服务" class="headerlink" title="开放端口及服务"></a>开放端口及服务</h3><ul>
<li>查看指定区域(public)所有开启的端口号/服务<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports / --list-service</span><br></pre></td></tr></table></figure></li>
<li>开放端口/服务（防火墙重启生效）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp / --add-service=http --permanent</span><br></pre></td></tr></table></figure></li>
<li>查看所有服务<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><ul>
<li>查看自带的，yum search docker 发现自带的不是我们想要的。</li>
<li>下载docker-ce repo<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li>安装containerd.io依赖<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm</span><br></pre></td></tr></table></figure></li>
<li>安装docker<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure></li>
<li>设置开机启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><ul>
<li>安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure></li>
<li>设置开机启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure></li>
<li>nginx配置文件路径：/etc/nginx/nginx.conf</li>
<li>nginx日志文件路径：/var/nginx</li>
</ul>
<p>  nginx路径/结尾</p>
<ul>
<li>在某些情况下，Nginx内部重定向规则会被启动，例如，当 URL 指向一个目录并且在最后没有包含“/”时，Nginx 内部会自动的做一个 301 重定向</li>
<li>location<ul>
<li>以/结尾：url与location路径完全匹配</li>
<li>不以/结尾：模糊匹配，以location路径开头。</li>
</ul>
</li>
<li>proxy_pass<ul>
<li>以/结尾：访问服务proxy + (uri - location)路径</li>
<li>ip/域名结尾：访问服务proxy + url路径</li>
<li>其它：访问服务proxy + (uri - location)路径 (字符串拼接，没有/)</li>
</ul>
</li>
<li>root<ul>
<li>一致</li>
</ul>
</li>
</ul>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><blockquote>
<p>通过docker安装mysql服务，简单，省事。<br>但是docker容器具有临时性，而mysql的数据要持久化，所以通过docker启动MySQL，然后通过挂载卷的方式保存数据，是否是个好的选择呢？</p>
</blockquote>
<ul>
<li>拉取镜像<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:8</span><br></pre></td></tr></table></figure></li>
<li>启动容器<br>  将容器设置为自动重启，这样服务器开机或docker服务重启时会自动启动容器。<br>  使用 -e 选项为mysql设置root账号密码。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root --restart=always --name mysql mysql:8</span><br></pre></td></tr></table></figure>
<ul>
<li>进入容器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h3><blockquote>
<p>使用docker安装jenkins，方便，省事。</p>
</blockquote>
<ul>
<li>拉取镜像<br>  使用latest版本<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jenkinsci/blueocean</span><br></pre></td></tr></table></figure></li>
<li>启动容器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -u root -d -p 8080:8080 -v /var/jenkins_data:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock --restart=always --name jenkins jenkinsci/blueocean</span><br></pre></td></tr></table></figure></li>
<li>获取admin默认密码</li>
<li>自定义安装插件</li>
<li>创建管理员用户密码</li>
</ul>
<h4 id="填坑-1"><a href="#填坑-1" class="headerlink" title="填坑"></a>填坑</h4><ol>
<li>启动jenkins容器，配置nginx代理，静态资源访问不到</li>
<li>开启防火墙，启动jenkins容器，开放8080端口，内网访问不到</li>
<li>在2的前提下，关闭防火墙，内网可以访问，但是jenkins提示离线</li>
<li>开机启动docker，firewalld，然后关闭防火墙，启动容器，启动不起来，提示： docker: Error response from daemon: driver failed programming external connectivity on endpoint jenkins (0a8069842c234eaae6d36192f62b5d9503926c0167cae15711300168103c5b1e):  (iptables failed: iptables –wait -t nat -A DOCKER -p tcp -d 0/0 –dport 8080 -j DNAT –to-destination 172.17.0.2:8080 ! -i docker0: iptables: No chain/target/match by that name.</li>
<li>最终解决办法：开机启动docker，firewallld, 然后关闭防火墙，docker服务重启，然后启动容器，ok！（问题，怎么能不关闭防火墙）<br>PS: 每次防火墙重启时都需要重启docker服务。</li>
</ol>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><blockquote>
<p>github国内访问有点慢，有时候提交需要等好一会儿，而且自己的那点代码，感觉放在开源网站有点low，所以决定在自己服务器安装一个git服务器，等项目做的有点水平了，在放到github上去。</p>
</blockquote>
<h4 id="ssh版本"><a href="#ssh版本" class="headerlink" title="ssh版本"></a>ssh版本</h4><blockquote>
<p>Protocol 2</p>
</blockquote>
<h4 id="git协议选择"><a href="#git协议选择" class="headerlink" title="git协议选择"></a>git协议选择</h4><blockquote>
<p>通过查看git官网文档，git有四种可选择的协议来传输资料，分别是local，git，ssh，http。<br>其中local是本地协议，不能通过网络访问，git协议缺乏授权机制。<br>http协议安装比较复杂，等后期对相关知识更加了解在做。<br>暂时选择git协议，使用密钥的方式进行授权，添加访问用户时需要添加公钥到服务器。</p>
</blockquote>
<h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><ol>
<li>安装git软件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure></li>
<li>创建git用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adduser git (不用设置密码)</span><br></pre></td></tr></table></figure></li>
<li>在git根目录下创建.ssh文件夹</li>
<li>在git/.ssh目录下创建 authorized_keys 文件，用来存放用户公钥。</li>
<li>设置git目录所属用户为git，.ssh目录权限为700，authorized_keys 文件权限为600。</li>
<li>限制git账号使用ssh连接。<br>git-shell: 登录成功后自动退出的shell<br>查看git-shell命令路径： where is git-shell<br>修改/etc/passwd中 git账号登录后的shell为git-shell全路径</li>
<li>打开RSA认证。<br>修改配置文件/etc/ssh/sshd_config 中 设置<br>RSAAuthentication yes(centos 7.4 已弃用，忽略不设置)<br>PubkeyAuthentication yes<br>AuthorizedKeysFile .ssh/authorized_keys<h4 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h4><blockquote>
<p>在git目录下新建.git结尾文件夹，进入文件夹，创建一个裸仓库。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init --bare</span><br></pre></td></tr></table></figure>
<h4 id="填坑-2"><a href="#填坑-2" class="headerlink" title="填坑"></a>填坑</h4></li>
</ol>
<ul>
<li>git用户密码<blockquote>
<p>git用户不必设置密码，没有必要。</p>
</blockquote>
</li>
<li>权限问题<blockquote>
<p>git用户根目录下的所有文件及目录都应该属于git用户，每次创建完git仓库时也要修改目录所属用户，否则会提示 无权限访问。</p>
</blockquote>
</li>
<li>公钥<blockquote>
<p>使用 &gt;&gt; 操作可以将公钥追加到文件里面。<br>使用 &gt; 操作会清空文件的内容，并把新内容添加到文件里面。</p>
</blockquote>
</li>
<li>git clone<blockquote>
<p>在使用 TortoiseGit 进行git clone 的时候，需要勾选 Load Putty Key 选项，并选择私钥。<br>在使用 git bash clone的时候需要保证当前用户目录.ssh文件夹下面存在私钥。</p>
</blockquote>
</li>
<li>RSA<blockquote>
<p>RSAAuthentication 是对ssh 1版本的支持，在本环境中，使用ssh 2，所以没有这个配置，忽略即可。<br>如果自己手动加上了这个配置，在查看日志文件时会有警告。</p>
</blockquote>
</li>
<li>bare<blockquote>
<p>裸仓库即不包含工作目录的仓库。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2021/11/28/Linux/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>/bin 系统普通用户命令</li>
<li>/sbin root命令</li>
<li>/usr/bin 系统普通用户命令</li>
<li>/usr/sbin root命令</li>
<li>/etc 系统默认配置目录</li>
<li>/root </li>
<li>/home </li>
<li>/lib 函数库</li>
<li>/media 光盘</li>
<li>/mnt U盘、硬盘</li>
<li>/misc 磁带</li>
<li>/proc 内存的过载点</li>
<li>/sys 内存的过载点</li>
<li>/temp 临时目录</li>
<li>/usr 系统资源</li>
<li>/var 系统可变文档</li>
<li>/boot 启动目录</li>
</ul>
<h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><ul>
<li>0 关机</li>
<li>1 单用户模式</li>
<li>2 不完全的命令行</li>
<li>3 完全的命令行</li>
<li>4 系统保留</li>
<li>5 图形界面</li>
<li>6 重启</li>
</ul>
<p>查看： run level<br>修改： init x<br>修改开始时级别： /etc/inittab</p>
<h2 id="用户、用户组"><a href="#用户、用户组" class="headerlink" title="用户、用户组"></a>用户、用户组</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>/etc/group 存储当前系统中所有用户组信息 （组名称:组密码占位符:组编号:组中用户名列表）</li>
<li>/etc/gshadow 存储当前系统中用户组的密码信息 （组名称:组密码:组管理者:组中用户列表）</li>
<li>/etc/passwd 存储用户组中用户信息 （用户名:密码占位符:用户编号:用户组编号:用户注释信息:用户主目录:shell类型）</li>
<li>/etc/shadow 存储用户密码信息 （用户:密码:……）</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>添加用户组： groupadd 组名</li>
<li>修改用户组名称： groupmod -n 新组名 旧组名</li>
<li>修改用户组编号： groupmod -g 编号 组名</li>
<li>删除用户组：groupdel 组名</li>
<li>添加用户： useradd 用户名</li>
<li>修改用户： usermod -l 旧名 新名</li>
<li>删除用户： userdel 用户名</li>
<li>锁定： passwd 用户名 -l</li>
<li>解锁： passwd 用户名 -u</li>
<li>清除命令： passwd 用户名 -d</li>
</ul>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [选项] 模式 文件名</span><br><span class="line">chown [组名:]用户名 文件名</span><br><span class="line">chgrp 组名 文件名</span><br></pre></td></tr></table></figure>
<p>-R 递归</p>
<h2 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩/解压缩"></a>压缩/解压缩</h2><p>压缩文件格式： .zip、.gz、.bz2、.tar.gz、.tar.gz2</p>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><ul>
<li>-c 打包、-x 解压、 -t 查看</li>
<li>-v 显示过程</li>
<li>-f 指定打包后的文件名</li>
<li>-z .tar.gz格式 -j .tar.bz2格式</li>
</ul>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><ul>
<li>压缩文件 zip *.zip *</li>
<li>压缩目录 zip -r *.zip 目录</li>
<li>解压缩 unzip 压缩文件</li>
</ul>
<h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><ul>
<li>压缩文件 gzip 源文件 （源文件消失）</li>
<li>压缩目录 gzip  -r 目录</li>
<li>解压 gunzip 压缩文件</li>
<li>解压 gzip -d 压缩文件</li>
</ul>
<h3 id="bzip"><a href="#bzip" class="headerlink" title="bzip"></a>bzip</h3><ul>
<li>压缩文件 bzip2 源文件</li>
<li>不能压缩目录</li>
<li>解压 bzip2 -d 压缩文件</li>
<li>解压 bunzip2 压缩文件</li>
</ul>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul>
<li>查看级别 map -f 命令  -&gt;  whatis 命令</li>
<li>查找  map -k 命令  -&gt;  apropos 命令</li>
</ul>
<h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><h2 id="ssh操作"><a href="#ssh操作" class="headerlink" title="ssh操作"></a>ssh操作</h2><ul>
<li>ctrl + L  清屏</li>
<li>ctrl + c  强制退出</li>
<li>ctrl + u  删除至行首</li>
<li>ctrl + a  Home</li>
<li>ctrl + e  End</li>
<li>ctrl + r  在历史命令搜索</li>
<li>ctrl + z  放入后台</li>
</ul>
<h2 id="VI操作模式"><a href="#VI操作模式" class="headerlink" title="VI操作模式"></a>VI操作模式</h2><p>visual interface<br>命令模式、输入模式、底行模式</p>
<ul>
<li>:w 保存</li>
<li>:q 退出</li>
<li>:! 强制执行</li>
<li>:ls 列出当前打开文件</li>
<li>:n 切换到下一个打开的文件</li>
<li>:N 切换到上一个打开的文件</li>
<li>:15 定位到15行</li>
<li>/xxx 向后搜索</li>
<li>?xxx 向前搜索</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>命令格式： 命令 [选项] [参数]</p>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>print working directory</p>
<ul>
<li>~ 当前用户家目录</li>
<li><h1 id="管理员用户"><a href="#管理员用户" class="headerlink" title="管理员用户"></a>管理员用户</h1></li>
<li>$ 普通用户</li>
</ul>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ul>
<li>-a all</li>
<li>-l long 文件类型（-、d、l、…）</li>
<li>-d 目录属性</li>
<li>-h human 人性化显示</li>
<li>-i inode i结点</li>
</ul>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [原文件/目录] [目标文件/目录]</span><br></pre></td></tr></table></figure>

<h3 id="创建目录-mkdir"><a href="#创建目录-mkdir" class="headerlink" title="创建目录 mkdir"></a>创建目录 mkdir</h3><ul>
<li>-p 递归创建</li>
</ul>
<h3 id="删除-rm"><a href="#删除-rm" class="headerlink" title="删除 rm"></a>删除 rm</h3><ul>
<li>-f force 强制</li>
<li>-r 删除目录</li>
</ul>
<h3 id="复制-cp"><a href="#复制-cp" class="headerlink" title="复制 cp"></a>复制 cp</h3><ul>
<li>-r 目录</li>
<li>-p 连带文件属性复制</li>
<li>-d 若源文件是链接文件，则复制链接属性</li>
</ul>
<h3 id="链接-ln"><a href="#链接-ln" class="headerlink" title="链接 ln"></a>链接 ln</h3><p>ln [原文件] [目标文件]<br>-s 软链接</p>
<h3 id="文件搜索-locate"><a href="#文件搜索-locate" class="headerlink" title="文件搜索 locate"></a>文件搜索 locate</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate 文件名</span><br></pre></td></tr></table></figure>

<h3 id="命令搜索"><a href="#命令搜索" class="headerlink" title="命令搜索"></a>命令搜索</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">where is 命令</span><br><span class="line">which 命令</span><br></pre></td></tr></table></figure>
<p>where 查看命令所在位置-b 和帮助文档-m<br>which 查看命令所在位置和别名</p>
<h3 id="字符串搜索-grep"><a href="#字符串搜索-grep" class="headerlink" title="字符串搜索 grep"></a>字符串搜索 grep</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [选项] 字符串 文件名</span><br></pre></td></tr></table></figure>
<ul>
<li>-i 忽略大小写</li>
<li>-v 取反</li>
</ul>
<h3 id="文件搜索-find"><a href="#文件搜索-find" class="headerlink" title="文件搜索 find"></a>文件搜索 find</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [搜索目录] [搜索条件（通配符）]</span><br></pre></td></tr></table></figure>
<ul>
<li>atime 文件访问时间</li>
<li>ctime 改变文件属性时间</li>
<li>mtime 改变内容时间</li>
<li>-10 10天内修改</li>
<li>+10 10天前修改</li>
<li>10 10天前当天修改</li>
<li>-size 25k/+25k/-25k</li>
<li>-inum</li>
<li>-a and</li>
<li>-o or</li>
</ul>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><ul>
<li>-l 本地磁盘</li>
<li>-a 所有文件系统</li>
<li>-h 1024 进制换算</li>
<li>-H 1000 进制换算</li>
<li>-T 分区类型</li>
<li>-t 显示指定类型</li>
<li>-x 不显示指定类型</li>
</ul>
<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount ntfs-3g 目录 目录</span><br><span class="line">umount 目录</span><br></pre></td></tr></table></figure>

<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li>du 统计磁盘上的文件大小<ul>
<li>-b -k -m</li>
<li>-h -H </li>
<li>-s 指定统计目标</li>
</ul>
</li>
<li>fdish 添加MBR分区</li>
<li>parted 添加GPT/MBR分区</li>
<li>mkfs 格式化</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux软件安装</title>
    <url>/2021/11/28/Linux/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="源码包安装"><a href="#源码包安装" class="headerlink" title="源码包安装"></a>源码包安装</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>C语言编译器gcc</li>
<li>源码包 *.tar.gz</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>解压缩</li>
<li>进入解压缩目录</li>
<li>./config 软件配置与检查</li>
<li>make / make clean 编译</li>
<li>make install 编译安装</li>
<li>启动</li>
</ol>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>直接删除安装目录即可。</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><ul>
<li>源码保存位置 /usr/local/src/</li>
<li>安装位置 /usr/local</li>
</ul>
<h2 id="RPM安装"><a href="#RPM安装" class="headerlink" title="RPM安装"></a>RPM安装</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>软件包名-版本-发布次数.适合平台.适合硬件平台.rpm</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>树依赖、环形依赖、库文件依赖/模块依赖</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>rpm -ivh 包全名<br>-i install 安装<br>-e erase 卸载<br>-v verbose 显示详细信息<br>-h hase 显示进度</p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>rpm -uvh 包全名<br>-u upgrade 升级</p>
<h3 id="卸载-1"><a href="#卸载-1" class="headerlink" title="卸载"></a>卸载</h3><p>rpm -e 包名<br>-e erase 卸载</p>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>rpm -v 包名<br>-v validate 校验</p>
<h3 id="查询命令"><a href="#查询命令" class="headerlink" title="查询命令"></a>查询命令</h3><ul>
<li>-q query</li>
<li>-a all</li>
<li>-i information</li>
<li>-p package</li>
<li>-l list</li>
<li>-f file</li>
</ul>
<h3 id="默认安装路径"><a href="#默认安装路径" class="headerlink" title="默认安装路径"></a>默认安装路径</h3><p>rpm包安装位置由rpm包确定，可以指定prefix，但不建议。<br>/etc/ 配置文件<br>/usr/share/doc/ 软件使用手册<br>/usr/bin/ 可执行命令<br>/usr/shar/man/ 帮助文件<br>/usr/lib/ 程序所使用函数库</p>
<h3 id="文件提取"><a href="#文件提取" class="headerlink" title="文件提取"></a>文件提取</h3><p>rpm2cpio 包全名 | epio -idu 文件绝对路径</p>
<h2 id="yum在线安装"><a href="#yum在线安装" class="headerlink" title="yum在线安装"></a>yum在线安装</h2><p>服务器使用最小化安装，用什么装什么，尽量不卸载。</p>
<h3 id="yum源文件"><a href="#yum源文件" class="headerlink" title="yum源文件"></a>yum源文件</h3><p>/etc/yum.repos.d/Centos-Base.repo</p>
<ul>
<li>[base]: 容器名称</li>
<li>name: 容器说明</li>
<li>mirrorlist: 镜像站点</li>
<li>baseurl: yum源服务器地址</li>
<li>enable: 是否生效，默认1，1生效，0无效</li>
<li>gpgcheck: RPM数字证书，1生效，0无效</li>
<li>gpgkey: 数字证书公钥文件保存位置</li>
</ul>
<h3 id="配置光盘yum源"><a href="#配置光盘yum源" class="headerlink" title="配置光盘yum源"></a>配置光盘yum源</h3><ol>
<li>挂载光盘</li>
<li>使默认失效，修改名字</li>
<li>修改光盘配置yum源</li>
</ol>
<h3 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h3><ul>
<li>yum list</li>
<li>yum search 关键字</li>
<li>yum -y install 包名</li>
<li>yum -y update 包名</li>
<li>yum -y remove 包名</li>
<li>yum grouplist</li>
<li>yum groupinstall 软件组名</li>
<li>yum groupremove 软件组名</li>
</ul>
<h2 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h2><p>eg nginx</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h3><ul>
<li>优点 开源，安装功能可配置，卸载方便，干净。</li>
<li>缺点 编译时间长，编译出错重复安装，安装步骤多。<h3 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h3></li>
<li>优点 安装、升级、查询、卸载简单，速度快。</li>
<li>缺点 不开源，不灵活，依赖性强。<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3></li>
<li>优点 简单、迅速、方便。</li>
<li>缺点 软件版本、功能不能自定义。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>WSL2</title>
    <url>/2021/06/03/Linux/WSL2/</url>
    <content><![CDATA[<h1 id="WSL2"><a href="#WSL2" class="headerlink" title="WSL2"></a>WSL2</h1><blockquote>
<p>How/Why</p>
</blockquote>
<h2 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h2><p>一、 更新windows<br>    wsl2需要： ×64架构 需要1903及更高<br>    下载windows易升，从1909版本升级到20H2。</p>
<p>二、 启用windows功能<br>    适用于Linux的Windows子系统<br>    虚拟机平台  wsl2需要</p>
<p>三、 登录microsoft账号，加入windows预览体验计划    只是简化安装需要<br>    下载ubuntu，windows terminal</p>
<p>四、 wsl2<br>    下载linux内核更新包并运行<br>    设置默认版本为2</p>
<h2 id="安装centos"><a href="#安装centos" class="headerlink" title="安装centos"></a>安装centos</h2><ol>
<li>下载镜像 <a href="https://github.com/CentOS/sig-cloud-instance-images/tree/CentOS-8-x86_64">https://github.com/CentOS/sig-cloud-instance-images/tree/CentOS-8-x86_64</a></li>
<li>windows安装Chocolatey</li>
<li>通过Chocolatey安装LxRunOffline</li>
<li>通过LxRunOffline安装centos<br> LxRunOffline.exe  install -n centos -d E:\WSL\CentOS -f  E:\WSL\centos-8-x86_64.tar.xz<pre><code> -n 名称
 -d 安装路径
 -f 文件路径
</code></pre>
 启动： LxRunOffline run -n centos</li>
<li>安装VcXsrc<br> 需要VcXsrc来显示</li>
<li>安装图形界面<br> yum install -y epel-release<br> yum groupinstall -y “Xfce”<br> 重启<br> export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk ‘{print $2; exit;}’):0.0<br> startxfce4 export DISPLAY=172.20.128.1:0.0</li>
</ol>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>LxRunOffline.exe  install -n c8 -d D:\WSL2\WSL_C8 -f  E:\down\centos-8-x86_64.tar.xz</li>
<li>yum install net-tools -y</li>
<li>yum -y install xorg-x11-xauth</li>
<li>yum -y install firefox ( libXcomposite libXcursor libXft libXi libXinerama libXrandr libXrender libXtst libXpm )</li>
<li>yum -y install mesa-libGL</li>
</ol>
<p>yum -y install which</p>
<p>bat启动文件<br>.\config.xlaunch<br>start /min wsl -d c8 idea</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>安装jdk： yum install -y java-1.8.0-openjdk</li>
<li>安装mysql: yum install -y mysql-server</li>
<li>安装maven：下载、解压、设置环境变量</li>
<li>安装node：yum install -y nodejs</li>
<li>安装git：yum install -y git</li>
<li>安装svn：</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>selinux，firewalld，iptable</title>
    <url>/2020/02/05/Linux/selinux%EF%BC%8Cfirewalld%EF%BC%8Ciptable/</url>
    <content><![CDATA[<p>selinux  ( /etc/selinux/config)<br>    安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。<br>    SELinux 主要由美国国家安全局开发。2.6 及以上版本的 Linux 内核都已经集成了 SELinux 模块。<br>    SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）。</p>
<p>firewalld<br>    firewall能够允许哪些服务可用，那些端口可用…. 属于更高一层的防火墙。<br>    firewall的底层是使用iptables进行数据过滤，建立在iptables之上。<br>    firewall是动态防火墙，使用了D-BUS方式，修改配置不会破坏已有的数据链接。</p>
<p>iptables<br>    iptables用于过滤数据包，属于网络层防火墙.<br>    在设置iptables后需要重启iptables，会重新加载防火墙模块，而模块的装载将会破坏状态防火墙和确立的连接。会破坏已经对外提供数据链接的程序。可能需要重启程序。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>命令</title>
    <url>/2020/02/05/Linux/%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>x86泛指一系列基于Intel 8086且向后兼容的中央处理器指令集架构<br>x86_64 = x64</p>
<p>Nginx 13: Permission denied</p>
<ol>
<li>nginx user 设置为root</li>
<li>访问的目录/文件不存在</li>
<li>selinux 关闭</li>
</ol>
<p>查看时区 timedatectl<br>查看可设置时区 timedatectl list<br>设置时区 timedatectl set-timezone Asia/Shanghai (设置完之后硬件时间跟着变了，why？)</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>ssh</title>
    <url>/2020/02/05/Linux/ssh/</url>
    <content><![CDATA[<p>SSH （ Secure Shell ），建立在应用层基础上的安全协议</p>
<p>SCP（Secure Copy）、SFTP（SSH File Transfer Protocol）是基于ssh的协议，使用了ssh的加密功能</p>
<p>使用ssh-copy-id命令将公钥复制到远程主机。ssh-copy-id会将公钥写到远程主机的 ~/ .ssh/authorized_key 文件中</p>
<p>SSH之所以能够保证安全，原因在于它采用了非对称加密技术(RSA)加密了所有传输的数据。<br>从客户端来看，SSH提供两种级别的安全验证。<br>第一种级别（基于口令的安全验证）<br>第二种级别（基于密匙的安全验证）</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2020/07/14/Maven/maven/</url>
    <content><![CDATA[<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>版本管理工具。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>maven有三套相互独立的声明周期。<br>不论要执行生命周期的哪一个阶段，都是从这个生命周期的开始执行。</p>
<h3 id="Clean-Lifecycle"><a href="#Clean-Lifecycle" class="headerlink" title="Clean Lifecycle"></a>Clean Lifecycle</h3><ul>
<li>pre-clean</li>
<li>clean</li>
<li>post-clean</li>
</ul>
<h3 id="Default-Lifecycle"><a href="#Default-Lifecycle" class="headerlink" title="Default Lifecycle"></a>Default Lifecycle</h3><ul>
<li>validate</li>
<li>generate-sources</li>
<li>process-sources</li>
<li>generate-resources</li>
<li>process-resources</li>
<li>compile</li>
<li>process-classed</li>
<li>generate-test-sources</li>
<li>process-test-sources</li>
<li>generate-test-resources</li>
<li>process-test-resources</li>
<li>test-compile</li>
<li>process-test-classed</li>
<li>test</li>
<li>prepare-package</li>
<li>package</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>verify</li>
<li>install</li>
<li>deploy</li>
</ul>
<h3 id="Site-Lifecycle"><a href="#Site-Lifecycle" class="headerlink" title="Site Lifecycle"></a>Site Lifecycle</h3><ul>
<li>pre-site</li>
<li>site</li>
<li>post-site</li>
<li>site-deploy</li>
</ul>
<h2 id="pom配置"><a href="#pom配置" class="headerlink" title="pom配置"></a>pom配置</h2><p>pom（project object model）文件是maven的配置文件。设置所有构建的配置。<br>project标签是根标签。<br>modelVersion标签声明pom文件project描述的版本。</p>
<h2 id="pom配置：描述"><a href="#pom配置：描述" class="headerlink" title="pom配置：描述"></a>pom配置：描述</h2><p>name、url、description 用于生成maven文档（mvn site）。</p>
<h2 id="pom配置：常用property"><a href="#pom配置：常用property" class="headerlink" title="pom配置：常用property"></a>pom配置：常用property</h2><h3 id="maven-compile-source-target-release"><a href="#maven-compile-source-target-release" class="headerlink" title="maven.compile.source/target/release"></a>maven.compile.source/target/release</h3><p>对应javac指令的-source、-target参数。</p>
<h3 id="project-build-sourceEncoding-project-reporting-outputEncoding"><a href="#project-build-sourceEncoding-project-reporting-outputEncoding" class="headerlink" title="project.build.sourceEncoding/project.reporting.outputEncoding"></a>project.build.sourceEncoding/project.reporting.outputEncoding</h3><h2 id="pom配置：坐标"><a href="#pom配置：坐标" class="headerlink" title="pom配置：坐标"></a>pom配置：坐标</h2><p>groupId、artifactId、version。<br>仓库jar包路径：[groupId]/[artifactId]/[version]/[artifactId]-[version].jar。</p>
<h2 id="pom配置：继承与子模块"><a href="#pom配置：继承与子模块" class="headerlink" title="pom配置：继承与子模块"></a>pom配置：继承与子模块</h2><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>在父模块打包时可将所有子模块进行打包，如果没有子模块，只打包当前目录。</p>
<h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><p>实现继承，可以继承父模块properties、dependencies、dependencyManagement、…</p>
<h4 id="relativePath"><a href="#relativePath" class="headerlink" title="relativePath"></a>relativePath</h4><p>指定查找父模块的路径。<br>默认情况下，从当前pom.xml的上级目录查找， 为空值时从仓库查找。</p>
<h3 id="modules-与-parent"><a href="#modules-与-parent" class="headerlink" title="modules 与 parent"></a>modules 与 parent</h3><p>modules的功能是打包，parent的功能是继承。两者没有关系。即modules的子模块的parent可以是任意模块。</p>
<h2 id="pom配置：依赖与依赖声明"><a href="#pom配置：依赖与依赖声明" class="headerlink" title="pom配置：依赖与依赖声明"></a>pom配置：依赖与依赖声明</h2><h3 id="dependencyManagement与dependency"><a href="#dependencyManagement与dependency" class="headerlink" title="dependencyManagement与dependency"></a>dependencyManagement与dependency</h3><p>dependencyManagement 只是管理版本，并不下载依赖。<br>dependency 添加依赖。</p>
<h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><ul>
<li>compile 默认值</li>
<li>provided 只在编译器提供，打包的时候过滤，</li>
<li>runtime 强制面向接口编程，不能引入该包的类。</li>
<li>test 编译器与测试阶段，打包的时候过滤。</li>
<li>import 只在dependencyManagement标签且type=pom时有用，会用目标pom的dependencyManagement里的内容替换该依赖。</li>
<li>system 类似provided，但需要显式提供jar路径（systemPath标签），不会在repository中查找。</li>
</ul>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>pom，表示全部引入其它packing类型为pom的内容。与scope=import配合使用。</p>
<h2 id="pom配置：依赖传递"><a href="#pom配置：依赖传递" class="headerlink" title="pom配置：依赖传递"></a>pom配置：依赖传递</h2><ul>
<li>非compile范围的依赖不能传递。</li>
<li>路径最短者优先原则。</li>
<li>路径相同声明优先原则。</li>
<li>optional=true显式声明不传递依赖。</li>
<li>exclusions显式声明过滤依赖。</li>
</ul>
<h2 id="pom配置：打包方式"><a href="#pom配置：打包方式" class="headerlink" title="pom配置：打包方式"></a>pom配置：打包方式</h2><p>packing 默认jar，可选jar、pom、war。</p>
<ul>
<li>jar 调用或者作为服务</li>
<li>pom 一般为父子继承使用</li>
<li>war web项目</li>
</ul>
<h2 id="pom配置：不同环境"><a href="#pom配置：不同环境" class="headerlink" title="pom配置：不同环境"></a>pom配置：不同环境</h2><p>profile标签。</p>
<h2 id="pom配置：plugins"><a href="#pom配置：plugins" class="headerlink" title="pom配置：plugins"></a>pom配置：plugins</h2><p>maven是插件驱动的工具。插件是核心。</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学与技术</title>
    <url>/2021/11/24/Major/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>计算机科学： 研究计算机及周围各种现象和规律的科学。亦即研究计算机系统结构、程序系统（即软件）、人工智能以及计算本身性质和问题的学科。<br>计算机技术： 指计算机领域中所御用的技术方法和技术手段，或指其硬件技术、软件技术及应用技术。</p>
<h2 id="计算机语言分类"><a href="#计算机语言分类" class="headerlink" title="计算机语言分类"></a>计算机语言分类</h2><blockquote>
<ul>
<li>解释型语言：运行时翻译成机器语言。效率比较低，依赖解释器。</li>
<li>编译型语言：运行前需要专门的编译过程，把程序编译为机器语言的文件。程序执行效率高，依赖编译器。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>系统语言：用来书写系统程序的程序设计语言。</li>
<li>脚本语言：用来控制软件应用程序。解释型语言。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>静态语言：在编译期进行类型检查。</li>
<li>动态语言：在运行期进行类型检查。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>强类型语言：强制类型定义的语言。一旦某个变量被定义类型，如果不经过强制转换，则它永远就是该类型。</li>
<li>弱类型语言：弱类型定义的语言。一个变量被定义类型，该变量可根据环境自动进行转换。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>通用语言： 不专用于某一个特定的应用领域。</li>
<li>专用语言： 用于某些特定领域的程序设计语言。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>面向过程： 分析出解决问题所需的步骤，用函数实现步骤，使用时依次调用。</li>
<li>面向对象： 把构成问题的事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</li>
</ul>
</blockquote>
<h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><ul>
<li>1936，图灵机，一种抽象的计算模型。</li>
<li>1946-2，第一台计算机问世，ENIAC。第一代计算机（电子管）。面向机器编程。</li>
<li>1951，汇编语言。</li>
<li>1954，第二代计算机（晶体管）。面向机器编程。</li>
<li>1956，IPL。Information Processing Language。</li>
<li>1957，Fortran formula translation， 第一个编译型语言。</li>
<li>1958，第三代计算机（集成电路）。操作系统、高级编程语言的基础。</li>
<li>1958，LISP。List，Processor，基于列表处理。</li>
<li>1964，Simula 67 面向对象的起源。</li>
<li>1970，第四代计算机（大规模/超规模继承电路）。</li>
<li>1970，Pascal 主要在教学领域。第一个结构化程序设计语言。</li>
<li>1971，Basic</li>
<li>1971-1，第一个4位微处理器芯片Inter 4004，微型计算机时代。</li>
<li>1972，C。初衷为编写Unix操纵系统，发展远不止于此。</li>
<li>1973，Unix操作系统。</li>
<li>1978-6，16位微处理器芯片Inter 8086。</li>
<li>1983，C++ 命令式面向对象语言，以Simula 67 的方式对命令式的编程的面向对象扩展。</li>
<li>1983，Objective-C 另一个对C进行面向对象扩展的语言。</li>
<li>1985，MicroSoft发布Windows 1.0。</li>
<li>1987，PERL。</li>
<li>1989，Internet从军用转向民用。</li>
<li>1990/1991-8-6，HTML。Web服务器：超文本服务器，存储超文本文件的服务器。第一个浏览器。</li>
<li>1991，Python 面向对象解释式脚本语言。</li>
<li>1993，Ruby 纯面向对象解释式脚本语言。</li>
<li>1993，CGI（Common Gateway Interface）。</li>
<li>1995-5，Java。Applet用于浏览器客户端，EE用于浏览器服务端，ME用于小型设备。</li>
<li>1995-6，PHP Web服务器脚本语言。</li>
<li>1995-12，JavaScript 浏览器脚本语言。</li>
<li>1997, UML。被采纳为为面向对象语言建模的国际标准。（不是唯一标准，不是强制标准。）</li>
<li>2001，C# .net平台主语言。</li>
<li>2001，Visual Basic.net</li>
<li>2003，Groovy</li>
<li>2003，Scala</li>
<li>2009，Go</li>
<li>2011，Dart</li>
</ul>
]]></content>
      <categories>
        <category>Major</category>
      </categories>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2023/07/12/RPC/RPC/</url>
    <content><![CDATA[<p>RPC<br>Remote Procedure Call<br>调用远程服务上的方法<br>RMI -&gt;  WebService(Http+XML) -&gt; Http+JSON -&gt; RPC<br>Doubbo:<br>Consumer + Provider + 注册中心 + 监控</p>
<p>一般说的RPC指的是RPC框架，区别于Solar RPC接口</p>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql 填坑</title>
    <url>/2021/06/24/Mysql/Mysql-%E5%A1%AB%E5%9D%91/</url>
    <content><![CDATA[<h2 id="mysql-left-on-where"><a href="#mysql-left-on-where" class="headerlink" title="mysql left on where"></a>mysql left on where</h2><p>过程： from + left 生成中间表 -&gt; 对中间表进行where过滤<br>on 是在生成中间表的时候的条件， 不管on后的条件是否满足，都会返回主表的所有数据<br>where 是对中间表过滤的条件</p>
<h2 id="count-1-VS-count-VS-count-列"><a href="#count-1-VS-count-VS-count-列" class="headerlink" title="count(1) VS count(*) VS count(列)"></a>count(1) VS count(*) VS count(列)</h2><p>执行结果： count(列)会过滤掉null<br>执行效率： 如果只有一列，在count(<em>)效率最高<br>         如果表有逐渐，且包含逐渐，则count(1) &gt; count(</em>) &gt; count(列)<br>执行方式： count()</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title>OAS</title>
    <url>/2020/07/14/default/OAS/</url>
    <content><![CDATA[<h2 id="OAS"><a href="#OAS" class="headerlink" title="OAS"></a>OAS</h2><p>OpenAPI Specification, 开放API声明，是一个API规范，用于描述一整套API接口。</p>
<h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2><p>一个流行的API框架，以OAS为基础，对整个API的开发周期都提供了相应的解决方案，几乎支持所有语言。</p>
<h2 id="springfox-swagger"><a href="#springfox-swagger" class="headerlink" title="springfox-swagger"></a>springfox-swagger</h2><p>用于将swagger集成到spring中来，前身是swagger-springmvc。生成多个json文件。</p>
<h2 id="springfox-swagger2"><a href="#springfox-swagger2" class="headerlink" title="springfox-swagger2"></a>springfox-swagger2</h2><p>生成一个json文件。</p>
<h2 id="springfox-swagger-ui"><a href="#springfox-swagger-ui" class="headerlink" title="springfox-swagger-ui"></a>springfox-swagger-ui</h2><p>页面</p>
<h2 id="springdoc-openapi"><a href="#springdoc-openapi" class="headerlink" title="springdoc-openapi"></a>springdoc-openapi</h2>]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>apache common</title>
    <url>/2020/04/05/default/apache%20common/</url>
    <content><![CDATA[<p>一、Commons BeanUtils<br>说明：针对Bean的一个工具集。由于Bean往往是有一堆get和set组成，所以BeanUtils也是在此基础上进行一些包装。 </p>
<p>二、Commons CLI<br>说明：这是一个处理命令的工具。比如main方法输入的string[]需要解析。你可以预先定义好参数的规则，然后就可以调用CLI来解析。 </p>
<p>三、Commons Codec<br>说明：这个工具是用来编码和解码的，包括Base64，URL，Soundx等等。用这个工具的人应该很清楚这些，我就不多介绍了。 </p>
<p>四、Commons Collections<br>说明：你可以把这个工具看成是java.util的扩展。 </p>
<p>五、Commons Configuration<br>说明：这个工具是用来帮助处理配置文件的，支持很多种存储方式 </p>
<p>六、Commons DBCP<br>说明：Database Connection pool, Tomcat就是用的这个，不用我多说了吧，要用的自己去网站上看说明。 </p>
<p>七、Commons DbUtils<br>说明：我以前在写数据库程序的时候，往往把数据库操作单独做一个包。DbUtils就是这样一个工具，以后开发不用再重复这样的工作了。值得一体的是，这个工具并不是现在流行的OR-Mapping工具（比如Hibernate），只是简化数据库操作，比如 </p>
<p>八、Commons HttpClient<br>说明：这个工具可以方便通过编程的方式去访问网站。 </p>
<p>九、Commons IO<br>说明：可以看成是java.io的扩展，我觉得用起来非常方便。 </p>
<p>十、Commons JXPath<br>说明：Xpath你知道吧，那么JXpath就是基于Java对象的Xpath，也就是用Xpath对Java对象进行查询。这个东西还是很有想像力的。 </p>
<p>十一、Commons Lang<br>说明：这个工具包可以看成是对java.lang的扩展。提供了诸如StringUtils, StringEscapeUtils, RandomStringUtils, Tokenizer, WordUtils等工具类。 </p>
<p>十二、Commons Logging<br>说明：你知道Log4j吗？ </p>
<p>十三、Commons Math<br>说明：看名字你就应该知道这个包是用来干嘛的了吧。这个包提供的功能有些和Commons Lang重复了，但是这个包更专注于做数学工具，功能更强大。 </p>
<p>十四、Commons Net<br>说明：这个包还是很实用的，封装了很多网络协议。 </p>
<ol>
<li>FTP </li>
<li>NNTP </li>
<li>SMTP </li>
<li>POP3 </li>
<li>Telnet </li>
<li>TFTP </li>
<li>Finger </li>
<li>Whois </li>
<li>rexec/rcmd/rlogin </li>
<li>Time (rdate) and Daytime </li>
<li>Echo </li>
<li>Discard </li>
<li>NTP/SNTP </li>
</ol>
<p>十五、Commons Validator<br>说明：用来帮助进行验证的工具。比如验证Email字符串，日期字符串等是否合法。 </p>
<p>十六、Commons Virtual File System<br>说明：提供对各种资源的访问接口。支持的资源类型包括 </p>
<ol>
<li>CIFS </li>
<li>FTP </li>
<li>Local Files </li>
<li>HTTP and HTTPS </li>
<li>SFTP </li>
<li>Temporary Files </li>
<li>WebDAV </li>
<li>Zip, Jar and Tar (uncompressed, tgz or tbz2) </li>
<li>gzip and bzip2 </li>
<li>res </li>
<li>ram<br>这个包的功能很强大，极大的简化了程序对资源的访问。 </li>
</ol>
<p>十七、Commons Transaction<br>说明：提供持久层事务支持 </p>
<p>十六、Commons Proxy<br>说明： 动态代理，拦截器一类的东西 </p>
<p>十八、Commons pool<br>说明： 创建新的对象并初始化的操作，可能会消耗很多的时间。<br>在需要频繁创建并使用这些对象的场景中，为了提供系统性能，通常的做法是，创建一个对象池，将一定数量的对象缓存到这个对象池中。<br>需要使用时直接从对象池中取出对象，使用完后将对象扔回到对象池中即可。<br>Apache的commons pool组件是我们实现对象池化技术的良好助手。 </p>
<p>十九、Commons Launcher<br>说明：创建跨平台可执行程序 </p>
<p>二十、Commons Bean Scripting Framework（BSF）<br>说明：是一个支持在Java应用程序内调用脚本语言 (Script)，并且支持脚本语言直接访问Java对象和方法的一个开源项目。有了它 , 你就能在java application中使用javascript, Python, XSLT, Perl, tcl, ……等一大堆scripting language<br>. 反过来也可以，就是在这些scripting language中调用任何已经注册过了的JavaBean,java object。它提供了完整的API实现通过Java访问脚本语言的引擎。 </p>
<p>二十一、Commons chain<br>说明： 可以在你需要定义和执行一些顺序操作的时候采用Commons Chain。 </p>
<p>二十二、Commons Compress<br>说明： 是一个压缩、解压缩文件的类库。可以操作ar, cpio, Unix dump, tar, zip, gzip, XZ, Pack200 and bzip2格式的文件，功能比较强大 </p>
<p>二十三、Commons Discovery<br>说明： 组件被用以查找可插拔接口的实现实例，它提供了一种通用的实例化这些实现的方式，而且可以管理单例（工厂）的生命周期。 </p>
<p>二十四、 commons exec<br>说明： Apache Commons Exec 是 Apache 上的一个 Java 项目，提供一些常用的方法用来执行外部进程，如下面代码所示： </p>
<p>String line = &quot;AcroRd32.exe /p /h &quot; + file.getAbsolutePath();<br>CommandLine commandLine = CommandLine.parse(line);<br>DefaultExecutor executor = new DefaultExecutor();<br>executor.setExitValue(1);<br>ExecuteWatchdog watchdog = new ExecuteWatchdog(60000);<br>executor.setWatchdog(watchdog);<br>int exitValue = executor.execute(commandLine); </p>
<p>二十五、commons jelly<br>说明：Jelly能够把XML转换成可执行代码,所以Jelly是一个基于XML与Java的脚本和处 理引擎。 Jelly借鉴了JSP定指标签，Velocity, Cocoon和Xdoclet中的脚本引擎的许多优点。Jelly可以用在命令行，Ant或者Servlet之中 </p>
<p>二十六、Commons FileUpload<br>上传下载组件 </p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2020/04/05/default/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li><p>添加远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add &lt;远程仓库名称 一般默认为origin&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>删除远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote remove &lt;远程仓库名称&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>更新/设置远程仓库地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote set-url &lt;远程仓库名称&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>添加远程仓库地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote set-url --add &lt;远程仓库名称&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>设置用户名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>设置邮箱</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>全局设置用户名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>全局设置邮箱</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>其他命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init ...</span><br><span class="line">git add ...</span><br><span class="line">git commit -m &quot;...&quot;</span><br><span class="line">git status</span><br><span class="line">git diff 文件名</span><br><span class="line">git log </span><br><span class="line">git reset --hard HEAD^ / 版本号</span><br><span class="line">git reflog </span><br><span class="line">git checkout -- 文件名</span><br><span class="line">git checkout 分支名</span><br><span class="line">git remote add origin 远程仓库路径</span><br><span class="line">git push -u origin master</span><br><span class="line">git push origin master</span><br><span class="line">git clone</span><br><span class="line">git checkout -b 分支名 = git branch 分支名 + git checkout 分支名 （创建并切换分支）</span><br><span class="line">git merge 分支名</span><br><span class="line">git branch -d</span><br><span class="line">git merge -no-ff -m</span><br><span class="line">git stash</span><br><span class="line">git stash list</span><br><span class="line">git stash apply</span><br><span class="line">git stash drop</span><br><span class="line">git stash pop</span><br><span class="line">git remote</span><br><span class="line">git remote -v</span><br><span class="line">git checkout -b 分支名 origin/分支名</span><br><span class="line">git pull</span><br><span class="line">git branch --set-upstream 分支名 origin/分支名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git init &lt;repo&gt;</span><br><span class="line">git add &lt;file&gt; [ &lt;file&gt; ... ]</span><br><span class="line">git commit -m &lt;message&gt;</span><br><span class="line">git status</span><br><span class="line">git diff &lt;file&gt;</span><br><span class="line">git log [--pretty=oneline] （提交历史）</span><br><span class="line">git reset --hard HEAD^ / HEAD~&lt;num&gt; / &lt;commit id&gt;</span><br><span class="line">git reflog （命令历史）</span><br><span class="line">git diff -- HEAD &lt;file&gt;</span><br><span class="line">git checkout -- &lt;file&gt;</span><br><span class="line">git rm &lt;file&gt;</span><br><span class="line">git remote add origin &lt;URL&gt;</span><br><span class="line">git push -u orgin &lt;branch&gt;</span><br><span class="line">git clone &lt;URL&gt;</span><br><span class="line">git checkout -b &lt;branch&gt; = git branch &lt;branch&gt; + git checkout &lt;branch&gt; = git switch - c &lt;branch&gt;</span><br><span class="line">git branch</span><br><span class="line">git checkout &lt;branch&gt;</span><br><span class="line">git merge &lt;branch&gt;</span><br><span class="line">git branch -d &lt;branch&gt;</span><br><span class="line">git switch &lt;branch&gt;</span><br><span class="line">git log --graph</span><br><span class="line">git merge --no-ff [-m &lt;message&gt;] &lt;branch&gt;</span><br><span class="line">git stash</span><br><span class="line">git stash list</span><br><span class="line">git stash apply</span><br><span class="line">git stash drop</span><br><span class="line">git stash pop</span><br><span class="line">git stash apply stash@&#123;&lt;num&gt;&#125;</span><br><span class="line">git cherry-pick &lt;commit id&gt;</span><br><span class="line">git branch -D &lt;branch&gt;</span><br><span class="line">git remote</span><br><span class="line">git remote -v</span><br><span class="line">git checkout -b &lt;branch&gt; origin/&lt;branch&gt;</span><br><span class="line">git pull</span><br><span class="line">git branch --set-upstream &lt;branch&gt; origin/&lt;branch&gt;</span><br><span class="line">git rebase</span><br><span class="line">git tag &lt;tag&gt;</span><br><span class="line">git tag</span><br><span class="line">git tag &lt;tag&gt; &lt;commit id&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>websocket</title>
    <url>/2020/04/05/default/websocket/</url>
    <content><![CDATA[<ul>
<li>socket 与 websocket<br>socket 网络层的抽象接口，用来实现计算机之间的通信。不同的操作系统做了不同的实现。<br>java中的socket与serverSocket应该是对操作系统的实现做了封装。<br>WebSocket是应用层协议，基于http，全双工通信模式，用来实现浏览器和服务器的长连接。</li>
</ul>
<p>背景<br>    后端： spring boot + websocket<br>    前端： vue + websocket + stomp</p>
<p>心跳配置<br>    后端： [n1, n2]<br>        n1表示 后端给前端发送ping的间隔<br>        n2表示 前端应该给后端发送ping的间隔<br>    前端： [m1, m2]<br>        m1表示 前端发送给后端ping的间隔<br>        m2表示 前端检查后端消息发送的间隔</p>
<p>心跳frame<br>    心跳帧的数据为 0x0A(\n)</p>
<p>解释<br>    心跳要客户端和服务端都要接收和发送数据，否则心跳不能维持，必须保证四个数字都不能为0。<br>    前端发送ping，间隔取 n2,m1 最大值，打印为ping<br>    后端定时器间隔取 n1,n2 最小值，读间隔取 m1,n2 最大值 乘3, 写间隔取 m2, n1 最大值，定时器执行，lastWriteTime为上次发送消息的时间（只有发送Message才会更新），lastReadTime为接收消息的时间<br>    前端检验间隔取 n1,m2 最大值<br>    前端接收后端发送心跳，打印为pong</p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>xml</title>
    <url>/2020/07/14/default/xml/</url>
    <content><![CDATA[<h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><pre><code>xmlns:
    定义标签，定义默认命名空间。
    命名空间可防止在任何元素的开始标签上。
xmlsns:xsi
    xml schema instance
    使用dtd实现，用来描述xsd。
    业界默认使用&quot;http://www.w3.org/2001/XMLSchema-instance&quot;。
xsi:schemaLocation
    指定xsd文件的位置。
    形式为“key value”，中间用空格分开，key为命名空间的值，value为xsd文件的位置。
</code></pre>
<h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h2><pre><code>document type definition
验证xml文件的规范性。
可内部定义，也可外部引入，也可内外结合。外部引入分为私有（SYSTEM）和公共（PUBLIC）。
</code></pre>
<h2 id="XSD"><a href="#XSD" class="headerlink" title="XSD"></a>XSD</h2><pre><code>xml schema definition
基于XML的DTD代替者。
</code></pre>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>开源协议</title>
    <url>/2022/05/30/default/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><h2 id="Apache-License"><a href="#Apache-License" class="headerlink" title="Apache License"></a>Apache License</h2><h2 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h2><h2 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h2><h2 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h2>]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/2021/11/11/default/%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>减轻数据库的压力。</p>
<h3 id="选择考虑"><a href="#选择考虑" class="headerlink" title="选择考虑"></a>选择考虑</h3><p>本地缓存/分布式缓存。<br>轻量级<br>线程安全<br>高并发<br>过期</p>
<h2 id="成员变量、静态变量"><a href="#成员变量、静态变量" class="headerlink" title="成员变量、静态变量"></a>成员变量、静态变量</h2><p>本地缓存，性能一般，线程不安全，可以配合线程池实现过期。</p>
<h2 id="guavaCache"><a href="#guavaCache" class="headerlink" title="guavaCache"></a>guavaCache</h2><p>本地缓存，性能高，轻量级，线程安全，支持高并发，一个实例过期时间只能配置一个。</p>
<h2 id="EhCache"><a href="#EhCache" class="headerlink" title="EhCache"></a>EhCache</h2><p>hibernate 默认的缓存。</p>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>分布式缓存</p>
<h2 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h2><p>分布式缓存</p>
<h2 id="springCache"><a href="#springCache" class="headerlink" title="springCache"></a>springCache</h2><p>对缓存使用的抽象。</p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>项目分层</title>
    <url>/2020/09/04/default/%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B1%82/</url>
    <content><![CDATA[<h2 id="项目分层"><a href="#项目分层" class="headerlink" title="项目分层"></a>项目分层</h2><ul>
<li>阿里规约</li>
</ul>
<p><img src="/images/pasted-5.png" alt="upload successful"></p>
<ul>
<li>终端显示层<br>前端、JSP</li>
<li>开放接口<br>RPC接口、http接口</li>
<li>web层<br>负责请求转发、基本参数校验</li>
<li>service层<br>负责具体的业务逻辑处理、复用性低</li>
<li>manager层  <br>通用业务处理。可以是 1.第三方接口的封装。2.service层的通用业务。3.dao层的组合服用。</li>
<li>dao层  <br>数据访问</li>
</ul>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>Session、Cookie、Token、JWT</title>
    <url>/2020/09/11/web/Session%E3%80%81Cookie%E3%80%81Token%E3%80%81JWT/</url>
    <content><![CDATA[<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>会话，在服务端保存用户信息。</p>
<h3 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>服务器保存用户信息，导致session占据过多的内存。</li>
<li>网站采用集群部署，需要考虑session共享的问题。</li>
<li>多个应用共享session时，需要考虑蛞蝓问题。</li>
<li>如果交由cookie处理，需要考虑浏览器禁止cookie或不支持cookie的问题。</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>浏览器实现的一种数据存储功能。在客户端保存信息。</p>
<h3 id="填坑-1"><a href="#填坑-1" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>移动端对cookie支持不是很好。</li>
<li>容易被篡改，需要验证。</li>
<li>存储大小限制。</li>
<li>存储个数限制。</li>
<li>无法跨域。</li>
</ul>
<h2 id="Cookie-VS-Session"><a href="#Cookie-VS-Session" class="headerlink" title="Cookie VS Session"></a>Cookie VS Session</h2><ul>
<li>安全性</li>
<li>存取值的类型</li>
<li>有效期</li>
<li>存储大小</li>
</ul>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>令牌。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>用户通过用户名密码</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>无状态 （负载均衡器可以将请求转发到任意服务器）</li>
<li>可扩展 （可以扩展为第三方应用程序）</li>
<li>安全性 （可以蛞蝓）</li>
</ul>
<h3 id="填坑-2"><a href="#填坑-2" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>需要加密。</li>
<li>token传输方式。（header、payload、url）</li>
</ul>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>Json Web Token 是一个轻量级的认证规范，这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。其本质是一个token，是一种紧凑的URL安全方法，用于在网络通信的双方之间传递。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Header.Payload.Signature</p>
<h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><p>JSON对象，描述JWT的元数据。</p>
<h5 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h5><p>实际需要传递的数据。JWT官方规定了7个字段，供选用。</p>
<table>
<thead>
<tr>
<th>name</th>
<th></th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>iss</td>
<td>issuer</td>
<td>签发人</td>
</tr>
<tr>
<td>exp</td>
<td>expiration time</td>
<td>过期时间</td>
</tr>
<tr>
<td>sub</td>
<td>subject</td>
<td>主题</td>
</tr>
<tr>
<td>aud</td>
<td>audience</td>
<td>受众</td>
</tr>
<tr>
<td>nbf</td>
<td>not before</td>
<td>生效时间</td>
</tr>
<tr>
<td>iat</td>
<td>issued at</td>
<td>签发时间</td>
</tr>
<tr>
<td>jti</td>
<td>jwt id</td>
<td>编号</td>
</tr>
</tbody></table>
<h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>对前两部分的签名，防止数据篡改。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>对于SSO来说，每个系统都需要去CAS系统认证，如果使用jwt的话，可以通过算法来验签，而不需要通过数据库或者http接口验证。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>web发展</title>
    <url>/2020/09/11/web/web%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ol>
<li>web项目<ol>
<li>创建空项目，创建对应的文件夹，如果选择ide创建，则会默认创建文件夹，及选择的web版本。</li>
<li>配置文件编译输出位置，及编译输出目录，归档方式<br>exploded 文件夹<br>archive war包形式</li>
<li>配置运行环境，即tomcat，配置发布方式，发布路径。<br>端口配置和访问路径是怎么生效的呢？？？</li>
<li>静态文件是热加载，改动java文件需要重启服务。</li>
<li>添加需要的jar包。</li>
<li>servlet2.x 规范： web.xml WEB-INF classes lib</li>
<li>必要时需要tomcat配置（如端口）。IDE怎么实现界面配置改的端口。</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>model1模式<br>jsp + javabean</p>
</li>
<li><p>model2模式 （MVC）<br>jsp + servlet + javabean</p>
</li>
<li><p>maven，项目管理工具<br>通过maven，可以优化项目创建目录，打包方式，jar包管理。</p>
</li>
<li><p>servlet3.0规范<br>基于注解， 省略web.xml</p>
</li>
<li><p>maven tomcat 插件</p>
</li>
</ol>
<p>web.xml  servlet 规范？？？</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 缺点</title>
    <url>/2021/06/24/%E5%85%83/Hexo-%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h2 id="分类-标签"><a href="#分类-标签" class="headerlink" title="分类/标签"></a>分类/标签</h2><p>每篇文章的分类、标签都是输入的，而不是选择的，导致后面会忘记前期添加过哪些数据。</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>用markdown的表格做数据很别扭，没有直接用表单，来生成表格来的舒服。</p>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>Heox文章规范</title>
    <url>/2020/07/15/%E5%85%83/Heox%E6%96%87%E7%AB%A0%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<blockquote>
<p>在此列举出一些规则，之后编写文章时都应遵循这些规则。该规则逐渐丰富。</p>
</blockquote>
<ul>
<li>文章最高使用二级标题，逐级递减，不适用一级标题。</li>
<li>文章添加分类，根据Hexo的描述，使用二级分类。</li>
</ul>
<p><img src="/images/pasted-0.png" alt="upload successful"></p>
<ul>
<li>缩进，还没有找到好的缩进方式。</li>
</ul>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/2020/03/28/%E5%85%83/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h1><blockquote>
<p>GitHub Pages 允许开发者自定义项目的首页，代替直接展示代码的方式。</p>
</blockquote>
<h2 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h2><blockquote>
<p>GitHub Pages 默认的静态网站生成工具，通过项目中的相应的配置文件，可以自动打包部署。</p>
</blockquote>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><blockquote>
<p>静态网站生成工具，可以通过配置使GitHub支持。</p>
</blockquote>
<h2 id="Jekyll-VS-Hexo"><a href="#Jekyll-VS-Hexo" class="headerlink" title="Jekyll VS Hexo"></a>Jekyll VS Hexo</h2><ul>
<li>本地开发预览<blockquote>
<p>Jekyll 需要搭建完整的Ruby环境。<br>Hexo 需要搭建NodeJS环境。</p>
</blockquote>
</li>
<li>迁移<blockquote>
<p>GitHub Pages中对Jekyll的支持，使得我们太多去关心Jekyll的配置以及插件，这会在迁移过程中造成一定的影响。因为不知道配置是什么，及使用了哪些插件。<br>Hexo的配置是自定义的。  </p>
</blockquote>
<h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><blockquote>
<p>由于GitHub访问速度问题，也可使用Gitee Pages功能，其概念和GitHub概念相似。  </p>
</blockquote>
<h3 id="GitHub-Pages-VS-Gitee-Pages"><a href="#GitHub-Pages-VS-Gitee-Pages" class="headerlink" title="GitHub Pages VS Gitee Pages"></a>GitHub Pages VS Gitee Pages</h3><blockquote>
<p>Gitee 支持Jekyll、Hexo、Hugo，GitHub只支持Jekyll。<br>GitHub 支持自动打包部署，检测到代码提交时执行。Gitee个人免费版不知道自动打包部署，需要手动进行。<br>GitHub 支持自定义域名。Gitee个人免费版不支持。<br>GitHub 只支持master、gh-pages分支，当使用根路径访问时只支持master分支。Gitee支持任意分支。</p>
</blockquote>
<h2 id="自动打包部署"><a href="#自动打包部署" class="headerlink" title="自动打包部署"></a>自动打包部署</h2><blockquote>
<p>对于支持自动打包部署的情况，只需要提交源码到对应的分支就行，会自动打包并部署。<br>而不支持自动打包部署的情况，需要在本地通过命令生成部署到对应的分支。而将源码提交到另一个分支。</p>
</blockquote>
</li>
</ul>
<h1 id="Hexo-搭建过程"><a href="#Hexo-搭建过程" class="headerlink" title="Hexo 搭建过程"></a>Hexo 搭建过程</h1><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><blockquote>
<p>hexo init命令需要空文件夹，git clone会生成一个不为空的文件夹，所以创建过程中需要按以下步骤进行。</p>
</blockquote>
<ol>
<li>初始化hexo项目<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hexo init &lt;dir name&gt;</span><br></pre></td></tr></table></figure>
PS: 如不指定目录名称，则在当前文件夹下初始化，要求该文件夹为空。</li>
<li>初始化git仓库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li>关联远程仓库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><blockquote>
<p>项目目录下的_config.yml为站点配置文件，themes/?/_config.yml为主题配置文件。将主题文件复制到source/_data/next.yml进行修改。</p>
</blockquote>
<ol>
<li>网站配置<br>其中 language为主题要求的值。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">&lt;title&gt;</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&lt;subtitle&gt;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&lt;description&gt;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&lt;keywords&gt;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">&lt;author&gt;</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/shanghai</span></span><br></pre></td></tr></table></figure></li>
<li>URL 配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">&lt;url&gt;</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year:month/:category/:post_title/</span></span><br></pre></td></tr></table></figure></li>
<li>发布配置<br>可配置多个<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;url&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li>
<li>主题配置<br>使用最新NexT主题<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure></li>
<li>CNAME配置<br>如需自定义域名，且手动打包部署，则CNAME配置应跳过渲染。相对路径为source。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">CNAME</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><ol>
<li>菜单配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure></li>
<li>样式配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure></li>
<li>pjax配置<br>页面局部刷新功能<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
添加依赖<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pjax themes/next/source/lib/pjax</span><br></pre></td></tr></table></figure></li>
<li>其他配置<br>每个配置的地方都有注释说明。</li>
</ol>
<ul>
<li>图标 favicon</li>
<li>头像 avatar</li>
<li>代码高亮样式 highlight_theme</li>
<li>局部页面刷新 pjax</li>
<li>中英文之间空格 pangu</li>
<li>阅读进度条 reading_progress</li>
<li>github_banner</li>
<li>书签 bookmark</li>
<li>评论 gitalk</li>
<li>公式 math</li>
<li>搜索 search</li>
<li>RSS</li>
<li>捐赠 reward</li>
</ul>
<h1 id="文章与页面"><a href="#文章与页面" class="headerlink" title="文章与页面"></a>文章与页面</h1><ol>
<li>新建文章<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
layout为scaffolds中定义的模板，默认为post</li>
<li>新建页面<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page archives/categories/tags/about</span><br></pre></td></tr></table></figure>
在各自index.md中修改其type为主题菜单配置中名称，除about外，其它都不需要编辑。</li>
<li>搜索页面<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-gengerator-searchdb</span><br></pre></td></tr></table></figure>
站点配置中新增<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">    <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
主题配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>404页面</li>
</ol>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo admin后台管理</title>
    <url>/2020/07/15/%E5%85%83/hexo-admin%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>使用hexo搭建博客之后，通过在编辑器里面来记录文章总归不是一个好的方式，而hexo admin提供了后台管理的页面来通过页面管理文章。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-admin</span><br></pre></td></tr></table></figure>
<p>安装好之后会在根目录下生成一个配置文件，该配置文件可以保存页面settings中的配置。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>管理页面中deploy功能需要添加配置。</p>
<ol>
<li>在_config.yml 中添加amdin发布命令的脚本路径。</li>
<li>创建脚本文件。</li>
</ol>
<p>PS: 该功能没有实现 </p>
<h2 id="线上"><a href="#线上" class="headerlink" title="线上"></a>线上</h2><p>github Pages是静态网站，不支持。支持其它动态的服务器。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>hexo admin 可以在编辑器内复制图片，图片将保存在images文件夹下，可自定义。<br>windows复制的图片需要去掉...\。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol>
<li>Posts页面没有分类，所有文章放在一起，看起来比较乱。</li>
<li>新建文章能否按照分类按文件夹存放。</li>
<li>添加分类和标签时只能输入，不能选择。</li>
<li>不能编辑文章的描述，该描述影响列表页面的内容。</li>
</ol>
<p>PS：<br>（1）. 可以在文章编辑界面上方修改文章路径。<br>（2）. 可以在_config.yml中添加 metadata - description 支持。</p>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>语法</title>
    <url>/2021/11/11/%E5%85%83/%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li>标题、列表 下一行前面不要空格<blockquote>
<p>示例</p>
<blockquote>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p> 有空格</p>
</blockquote>
</blockquote>
</li>
</ol>
<blockquote>
<blockquote>
<h4 id="标题-1"><a href="#标题-1" class="headerlink" title="标题"></a>标题</h4><p>没有空格</p>
</blockquote>
</blockquote>
<ol start="2">
<li>列表完了之后要空一行</li>
</ol>
<blockquote>
<p>示例</p>
<blockquote>
<ul>
<li>aaa<br>123123</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>aaa</li>
</ul>
</blockquote>
</blockquote>
<p>123123</p>
<blockquote>
<blockquote>
<ul>
<li>ccc</li>
</ul>
</blockquote>
</blockquote>
<ol start="3">
<li>列表嵌套<br>子列表前面加四个空格</li>
</ol>
<blockquote>
<p>示例</p>
<blockquote>
<ul>
<li>1 - 1<ul>
<li>1 - 2 - 1</li>
<li>1 - 2 - 2</li>
</ul>
</li>
<li>1 - 2</li>
</ul>
</blockquote>
</blockquote>
<ol start="4">
<li>段落 使用空行<blockquote>
<p>示例<br>1 - 1<br>1 - 2</p>
<p>2 - 1</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>计算机求解任何问题都离不开程序设计，而程序设计的实质是数据表示和数据处理，数据表示的核心是数据结构，数据处理的核心是算法。所以 程序 = 数据结构 + 算法。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>数据<br>信息的载体，在计算机科学中指所有能输入到计算机中并能被计算机程序识别和处理的符号集合。</li>
<li>数据元素<br>数据的基本单位，通常作为一个整体进行考虑和处理。</li>
<li>数据项<br>数据元素中不可分割的最小单位。</li>
<li>数据结构<br>相互之间存在一种或多种特定关系的数据元素的集合。<ul>
<li>逻辑结构<br>指数据元素之间逻辑关系的整体。面向要解决的问题。</li>
<li>物理结构<br>又称为存储结构，是数据的逻辑结构在计算机中的表示。面向计算机。</li>
</ul>
</li>
<li>结构<br>数据元素相互之间的关系称为结构。</li>
<li>元素/结点<br>数据元素在计算机中的映像。</li>
<li>数据类型<br>一组值的集合以及定义于这个值集上的一组操作的总称。</li>
<li>抽象数据类型（ADT）<br>是一个数据结构以及定义在该结构上的一组操作的总称。<ul>
<li>原子类型<br>变量的值是不可分解的。</li>
<li>固定聚合类型<br>值由确定数目的成分按某种结构组成。</li>
<li>可变聚合类型<br>值由不确定数目的成分按某种结构组成。</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构。<br>数据结构通常指数据的逻辑结构。</p>
<p>逻辑结构根据数据元素之间关系的不同特性分类：</p>
<ul>
<li>集合： 数据元素之间属于同一个集合。</li>
<li>线性结构： 数据元素之间存在一对一的线性关系。</li>
<li>树形结构： 数据元素之间存在一对多的层次关系。</li>
<li>图状结构： 数据元素之间存在多对多的任意关系。</li>
</ul>
<p>集合是数据元素之间关系极为松散的一种结构，因此也可以用其它结构来表示它。</p>
<p>根据数据元素之间关系的不同表示方法，顺序映象和非顺序映象，得到两种不同的存储结构：顺序存储结构和链式存储结构。<br>顺序存储结构： 把逻辑上相邻的结点存储在物理位置相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现。 通常借助数组来实现。<br>链式存储结构： 结点间的关系由附加的指针字段来表示。 通常借助指针来实现。</p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>抽象数据类型和数据类型实质上是一个概念。抽象的意义在于数据类型的数学抽象特性，且抽象数据类型的范畴更长，不局限于处理器已定义并实现的数据类型。<br>抽象数据类型通常包含定义、表示和实现3个部分。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>解决问题的方法或过程。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>输入</li>
<li>输出</li>
<li>有限行</li>
<li>确定性</li>
<li>可行性</li>
</ul>
<h3 id="算法与程序"><a href="#算法与程序" class="headerlink" title="算法与程序"></a>算法与程序</h3><p>程序是对一个算法使用某种程序设计语言的具体实现。算法可用任何一种程序设计语言实现。并不是所有的程序都是算法（有限性）。</p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ul>
<li>分治法</li>
<li>动态规划</li>
<li>贪心算法</li>
<li>回溯法</li>
<li>分支限界法</li>
</ul>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>计算机中最重要的资源是时间资源和空间资源，其概念类同，计量方法相似，且空间复杂性分析相对简单，所以更注重时间算法复杂性的分析。<br>通常有三种情况：最好情况、最坏情况、平均情况。使用O表示。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-二叉排序树</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8810%EF%BC%89-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<p>二叉排序树（Binary Sort Tree）, 又称二叉搜索/查找树（Binary Search Tree）。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ol>
<li>左子树上所有结点的值小于[等于]它根节点的值。</li>
<li>右子树上所有结点的值大于[等于]它根节点的值。</li>
<li>左右子树也均是二叉排序树。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>查找<br>平均查找长度： 每个结点的深度的总和/总结点数。</li>
<li>插入<br>新插入的结点一定是一个新添加的叶子结点，并且时查找不成功时查找路径上访问的最后一个结点的子结点。</li>
<li>删除<ol>
<li>删除结点为叶子结点，直接删除</li>
<li>删除结点只有一个孩子结点，则继承给删除结点的父节点。</li>
<li>删除结点有两个孩子结点。<br>1.</li>
</ol>
</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="平衡二叉搜索树（AVL）"><a href="#平衡二叉搜索树（AVL）" class="headerlink" title="平衡二叉搜索树（AVL）"></a>平衡二叉搜索树（AVL）</h3><p>每个结点的左右子树的高度差绝对值最多为1。</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li>LL 右旋</li>
<li>RR 左旋</li>
<li>LR 左旋 -&gt; LL 右旋</li>
<li>RL 右旋 -&gt; RR 左旋</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入为叶子结点，向上旋转。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>向下旋转为叶子结点, 删除。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>结点是红色或者黑色。</li>
<li>根节点是黑色。</li>
<li>所有叶子结点都是黑色（叶子结点是Null结点）。</li>
<li>每个红色结点的两个叶子结点都是黑色（路径中不能有两个连续的红色结点）。</li>
<li>从任一结点到其每个叶子结点的路径都包含相同数目的黑色结点。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-哈希表</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8811%EF%BC%89-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表，将关键码映射为散列表中适当存储位置的函数称为散列函数，所得的存储位置称为散列地址。</p>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>H(key) = a * key + b (a、b为常熟)<br>特点： 单调、均匀、不会产生冲突。<br>适用于事先知道关键码的分布，且关键码集合不是很大且连续性较好的情况。</p>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>H(key) = key % p (p为某个适当的正整数)<br>最简单、最常用的构造散列函数的方法，且不要求事先知道关键码的分布。</p>
<h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p>根据关键码在各个位上的分布情况，选取分布比较均匀的若干位组成散列地址。<br>适用于事先知道关键码的分布且关键码中有若干位分布较均匀的情况。</p>
<h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>对关键码平方后，按散列表大小，取中间的若干位作为散列地址。<br>通常用在事先不知道关键码的分布且关键码的位数不是很大的情况。</p>
<h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>将关键码从左到右分割称位数相等的几部分，然后叠加求和，取后几位作为散列地址。<br>叠加方法：<br>    移位叠加： 将各部分的最后一位对齐相加。<br>    间界叠加： 从一端向另一端沿各部分分界来回折叠后，最后一位对齐相加。<br>适用于关键码的位数很多，且关键码的每一位分布都不均匀的情况。事先不需要知道关键码的分布。</p>
<h2 id="处理冲突方法"><a href="#处理冲突方法" class="headerlink" title="处理冲突方法"></a>处理冲突方法</h2><h3 id="开放定址法-（闭散列表）"><a href="#开放定址法-（闭散列表）" class="headerlink" title="开放定址法 （闭散列表）"></a>开放定址法 （闭散列表）</h3><p>关键码得到的散列地址一旦产生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>
<ul>
<li>线性探测法<br>  从冲突位置的下一个位置起，依次寻找空的散列地址。 Hi = (H(key) + di) % m</li>
<li>二次探测法</li>
<li>随机探测法</li>
</ul>
<h3 id="拉链法-（开散列表）"><a href="#拉链法-（开散列表）" class="headerlink" title="拉链法 （开散列表）"></a>拉链法 （开散列表）</h3><p>将所有散列地址相同的记录存储在一个单链表中，称为同义词子表，在散列表中存储的是所有同义词子表的头指针。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="拉链哈希表"><a href="#拉链哈希表" class="headerlink" title="拉链哈希表"></a>拉链哈希表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class HashTable&lt;E&gt; &#123;</span><br><span class="line">    Node[] tables;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-堆</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8812%EF%BC%89-%E5%A0%86/</url>
    <content><![CDATA[<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li>完全二叉树。</li>
<li>每个结点的值都小于或等于其左右孩子结点的值（小根堆）。</li>
<li>每个结点的值都大于或等于其左右孩子结点的值（大根堆）。</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>优先队列<br>在优先队列中，元素被赋予优先级。<br>当访问元素时，具有最高优先级的元素最先出队。<br>通常采用堆数据结构来实现。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-B-树</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8813%EF%BC%89-B-%E6%A0%91/</url>
    <content><![CDATA[<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ol>
<li>所有的叶子结点都出现在同一层，并且不带信息。叶子结点的双亲称为终端结点。</li>
<li>树中每个系结点至多有m棵子树。</li>
<li>若根节点不是终端结点，则至少有两棵子树。</li>
<li>除根结点之外的所有非终端结点至少有 m/2 棵子树。</li>
<li>所有的非终端结点都包含数据。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>查找</li>
<li>插入</li>
<li>删除</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>3阶的B-树。</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>一个结点包含一个或者两个关键码。</li>
<li>每个内部结点有2个孩子（包含一个关键码）或3个孩子（包含两个关键码）。</li>
<li>所有叶子结点都在树的同一层。</li>
</ol>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>查找从根节点开始，如果根节点不包含被查找的关键码k，那么查找就在可能包含关键码k的子树中继续进行。存储在根节点中的关键码确定哪一个子树是正确的子树。</p>
<h3 id="2-3-4"><a href="#2-3-4" class="headerlink" title="2-3-4"></a>2-3-4</h3><p>2-3-4 树是4阶的B-树。</p>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ol>
<li>2结点包含一个元素和两个儿子。</li>
<li>3结点包含两个元素和三个儿子。</li>
<li>4结点包含三个元素和四个儿子。</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h4><p>1，具有m棵子树的结点含有m个关键码，即每一个关键码对应一颗子树。<br>2. 关键码Ki是它所对应的子树的根节点中最大/最小的关键码。<br>3. 所有的终端结点包含了全部的关键码信息，以及指向关键码记录的指针。<br>4. 各终端结点按关键码的大小次序链在一起，形成单链表，并设置头指针。</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><p>B*树是B+树的变体，在B+树的非根结点和非叶子结点在添加指向兄弟的指针。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-线性表</title>
    <url>/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%881%EF%BC%89-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>线性表是线性结构的典型代表。是一种最基本、最简单的数据结构，数据元素直接仅具有单一的前驱和后继关系。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>是n（n&gt;=0）个具有相同类型的数据元素的有限序列。<br>相邻两个元素之间存在序偶关系。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>返回长度</li>
<li>获取指定位置元素</li>
<li>返回第一个匹配的元素</li>
<li>获取前驱</li>
<li>获取后继</li>
<li>在指定位置插入元素</li>
<li>删除指定位置的元素</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>用一段地址连续的存储单元一次存储线性表的数据元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要确定数组的长度，来分配固定长度的数组空间。<br>只要确定了存储顺序的起始地址，计算任一元素的存储地址时间是相等的。</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>用指针将存储线性表中数据元素的结点串联起来。只包含后继结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; head;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果以Node来实现链表，则需要一个空头结点。如果以List来实现，则List本身充当了空头节点，且可以添加其它属性。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul>
<li>头插法 在链表头部插入元素</li>
<li>尾插法 在链表尾部插入元素</li>
</ul>
<h3 id="循环列表"><a href="#循环列表" class="headerlink" title="循环列表"></a>循环列表</h3><p>将尾结点的后继指向头结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; head;</span><br><span class="line">    Node&lt;E&gt; last;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>包含前驱结点和后继结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; head;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序表VS链表"><a href="#顺序表VS链表" class="headerlink" title="顺序表VS链表"></a>顺序表VS链表</h3><ul>
<li>时间性能<br>顺序表： 随机访问快<br>链表： 插入和删除快</li>
<li>空间性能<br>顺序表： 需要预先分配一定长度的储存空间。<br>链表： 不需要预分配空间。</li>
</ul>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>用数组来表示单链表，用数组元素的下标来模拟单链表的指针。<br>由于它是利用数组定义的，属于静态存储分配，因此叫做静态链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node[] elements;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        int cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入和删除时只需修改游标（cur），但是没有解决存储分配带来的表长难以确定问题。</p>
<h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>将数组和指针结合起来，将数组中存储数据元素的单元改为存储指向该元素的指针。</p>
<p>保持了顺序表随机存取的优点，改进了插入和删除操作的时间性能，但是没有解决存储分配带来的表长难以确定问题。</p>
<p>Java中对象中存储的就是指针。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>线性表合并 O(m * n)<br>有序线性表合并 O(m + n)</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>大整数求和（顺序表）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-栈</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89-%E6%A0%88/</url>
    <content><![CDATA[<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>限定仅在表尾（栈顶）进行插入和删除操作的线性表。<br>具有后进先出（LIFO）的特性。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取长度</li>
<li>出栈</li>
<li>入栈</li>
<li>获取栈顶元素</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Stack&lt;E&gt; &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两栈共享空间：<br>    使用一个数组来存储两个栈，一个栈的栈底尾数组的始端，另一个栈的栈底为该数组的末端，每个栈从各自的端点向中间延伸。</p>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>通常用单链表实现。<br>使用头插法，将头指针指向栈顶元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Stack&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; node;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序栈-VS-链栈"><a href="#顺序栈-VS-链栈" class="headerlink" title="顺序栈 VS 链栈"></a>顺序栈 VS 链栈</h3><ul>
<li>时间性能<br>实现基本操作都只需要常数时间。</li>
<li>空间性能<br>顺序栈： 初始化时需要确定长度，有存储个数限制和空间浪费问题。<br>链栈： 每个元素都需要一个指针域，产生了结构性开销。</li>
</ul>
<p>使用过程中元素个数变化较大时，适合用链栈；反之，适合使用顺序栈。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>进制转换<br>表达式求值，括号匹配<br>递归</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-队列</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>只允许在一端（队头）进行插入操作，在另一端（队尾）进行删除操作的线性表。<br>具有先进先出（FIFO）的特性。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取队列长度</li>
<li>获取对头元素</li>
<li>出队</li>
<li>入队</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>可优化出队操作的开销，需要设置对头、队尾两个指针。<br>可用一个数据元素的空间，来解决队空和队满的判定。或添加一个标志。或者使用个数判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Queue&lt;E&gt; &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链队列"><a href="#单链队列" class="headerlink" title="单链队列"></a>单链队列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Queue&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; front;</span><br><span class="line">    Node&lt;E&gt; rear;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环队列-VS-链队列"><a href="#循环队列-VS-链队列" class="headerlink" title="循环队列 VS 链队列"></a>循环队列 VS 链队列</h3><ul>
<li>时间性能<br>实现基本操作都只需要常数时间O(1)。</li>
<li>空间性能<br>循环队列： 初始化时需要确定长度，有存储个数限制和空间浪费问题。<br>链队列： 每个元素都需要一个指针域，产生了结构性开销。</li>
</ul>
<p>使用过程中元素个数变化较大时，适合用链队列；反之，适合使用循环队列。</p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Queue&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; front;</span><br><span class="line">    Node&lt;E&gt; rear;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>阻塞队列<br>当队列为空时，获取元素的操作将被阻塞，直到其它线程往队列中插入新的元素。<br>当队列是满是，插入元素的操作将被阻塞，直到其它线程从队列中取出元素。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-串</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89-%E4%B8%B2/</url>
    <content><![CDATA[<p>字符串一般简称串。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>由零个或多个字符组成的有限序列。</p>
<h2 id="串VS线性表"><a href="#串VS线性表" class="headerlink" title="串VS线性表"></a>串VS线性表</h2><ul>
<li>逻辑结构： 串的数据对象约束为字符集。</li>
<li>操作： 线性表已单个元素作为操作对象，串以串的整体作为操作对象。</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>长度：串中字符的数目。<br>空串：零个字符的串<br>子串：串中任意个连续的字符组成的子序列。<br>主串：包含子串的串。<br>位置：字符在序列中的序号。<br>空格串： 由一个或多个空格组成的串。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>复制</li>
<li>判断是否为空</li>
<li>获取长度</li>
<li>拼接</li>
<li>字串</li>
<li>指定位置之后第一次出现字串的位置</li>
<li>替换</li>
<li>指定位置插入/删除</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h3><p>C中超过长度截断。Java中不允许超过已分配长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">    char[] value;</span><br><span class="line">    int length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆分配存储"><a href="#堆分配存储" class="headerlink" title="堆分配存储"></a>堆分配存储</h3><p>C中使用malloc和free控制内存，实际是基于复制实现。</p>
<h3 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h3><p>每个结点可以存放一个字符，也可以存放多个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line">    int length;</span><br><span class="line">    </span><br><span class="line">    class Node &#123;</span><br><span class="line">        char[] value;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><ul>
<li>BF算法（brute force 暴力）</li>
<li>KMP算法</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-数组</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%885%EF%BC%89-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>由类型相同的数据元素构成的有序集合，每个数据元素称为一个数组元素（简称元素），每个元素受n（n&gt;=1）个线性关系的约束，每个元素在n个线性关系中的序号称为该元素的下标，并称该数组为n维数组。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>数据元素本身可以具有某种结构，但属于同一数据类型。<br>一维数据可以看作一个线性表，二维数据可以看作线性表的线性表，以此类推。所以，数组是线性表的推广。<br>数组一般不做插入和删除操作。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>初始化</li>
<li>赋值</li>
<li>取值</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><ul>
<li>按行优先存储</li>
<li>按列优先存储</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h3><p>矩阵是很多科学与工程计算问题中的处理对象。<br>特殊矩阵： 有很多值相同的元素并且由一定的分布规律。（为多个值相同的元素只分配一个存储空间）<br>稀疏矩阵： 有很多零元素。（对零元素不分配存储空间）</p>
<h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>在一个n阶方阵中，有a<sub>ij</sub>=a<sub>ji</sub>。</p>
<h4 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h4><p>主对角线以上为常熟c，为下三角矩阵，主对角线以下为常数c，为上三角矩阵。</p>
<h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p>所有非零元素都集中在以主对角线为中心的带状区域，除了主对角线和它的上下若干条对角线的元素外，所有其它元素都为零。</p>
<h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p>零元素居多的矩阵。</p>
<ul>
<li>三元组顺序表</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>三元组-矩阵转置<br>三元组-快速转置<br>矩阵相加<br>矩阵相乘</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-广义表</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%886%EF%BC%89-%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是线性表的推广，允许元素拥有其自身结构。是一种非连续性的数据结构。<br>任何一个非空列表，其表头可能是原子，也可能是列表。其表尾一定是列表。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>原子 广义表中的单个元素。</li>
<li>子表 广义表中的广义表。</li>
<li>表头 当广义表非空时，第一个元素为表头。</li>
<li>表尾 除表头元素外，其余元素组成的表。</li>
</ul>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><ul>
<li>创建</li>
<li>复制</li>
<li>获取表的长度</li>
<li>获取表的深度</li>
<li>判断表是否为空</li>
<li>获取表头元素</li>
<li>获取表尾元素</li>
<li>插入元素</li>
<li>删除第一个元素</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>广义表中的数据元素可以拥有不同的结构，难以用顺序存储结构表示。</p>
<h3 id="头尾链表存储"><a href="#头尾链表存储" class="headerlink" title="头尾链表存储"></a>头尾链表存储</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class GList&lt;E&gt; &#123;</span><br><span class="line">    boolean isAtom;</span><br><span class="line">    E item;</span><br><span class="line">    GList&lt;E&gt; head, tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展式链表存储"><a href="#扩展式链表存储" class="headerlink" title="扩展式链表存储"></a>扩展式链表存储</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class GList&lt;E&gt; &#123;</span><br><span class="line">    boolean isAtom;</span><br><span class="line">    E item;</span><br><span class="line">    GList&lt;E&gt; head;</span><br><span class="line">    GList&lt;E&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>m元多项式</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>递归</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-二叉树</title>
    <url>/2021/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%887%EF%BC%89-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>二叉树适合计算机存储和处理。且所有的树结构都可以转为二叉树。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>n（n&gt;=0）个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>每个结点最多有两棵子树，不存在度大于2的结点。</li>
<li>二叉树是有序的，即使只有一棵子树，也要区分是左子树还是右子树。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取深度</li>
<li>获取根节点</li>
<li>获取结点的值</li>
<li>给结点赋值</li>
<li>获取左孩子结点</li>
<li>获取后孩子结点</li>
<li>获取兄弟结点</li>
<li>在指定位置插入孩子结点</li>
<li>删除指定位置的孩子结点</li>
<li>遍历</li>
</ul>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ul>
<li>斜树<br>所有结点都只有左子树称为左斜树，所有结点都只有右子树称为右斜树。</li>
<li>满二叉树<br>所有分支结点都存在左右子树，且所有的叶子结点都在同一层上。</li>
<li>完全二叉树<br>对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。<br>满二叉树必定是完全二叉树。</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul>
<li>先序 根 - 左 - 右</li>
<li>中序 左 - 根 - 右</li>
<li>后序 左 - 右 - 根</li>
<li>层序 广度优先，从上到下，从左到右</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>使用一维数组存储所有结点，按完全二叉树层序遍历顺序存储。<br>某结点存储位置为i，则其左孩子存储位置为2<em>i，右孩子存储位置为2</em>i+1。<br>会造成存储空间的浪费。<strong>顺序存储结构一般仅适用于存储完全二叉树。</strong></p>
<h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p>二叉树每个结点对应一个链表结点，数据元素包含左右孩子的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BiTNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; leftChild;</span><br><span class="line">    Node&lt;E&gt; rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h3><p>二叉树每个结点对应一个链表结点，数据元素包含父节点指针及左右孩子的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BiTNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; parent;</span><br><span class="line">    Node&lt;E&gt; leftChild;</span><br><span class="line">    Node&lt;E&gt; rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线索链表"><a href="#线索链表" class="headerlink" title="线索链表"></a>线索链表</h3><p>按照某种遍历次序对二叉树进行遍历，可以把二叉树中的所有结点排成一个线性序列。<br>一个具有n个结点的二叉链表，在2n个指针域中只有n-1个指针用来存储孩子结点的地址，存在n+1个空指针域。<br>因此，可以使用空指针域存储某种遍历序列中的前驱和后继结点。<br>指向前驱和后继结点的指针称为<strong>线索</strong>，加上线索的二叉树称为线索二叉树，加上线索的二叉链表称为线索链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BiTNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; left, right;</span><br><span class="line">    boolean leftFlag, rightFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在线索链表中，对任意结点，若存在左孩子结点，则左指针指向左孩子结点，否则指向该结点的前驱线索；右指针同理。数据元素包含左右指针，左右指针存放数据标志位。</p>
<p>二叉树遍历次序有4种，相应有四种线索链表：前序线索链表、中序线索链表、后序线索链表、层序线索链表。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>哈夫曼树、哈夫曼编码</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>遍历 - 递归<br>遍历 - 非递归算法<br>线索二叉树的遍历<br>深度</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-树</title>
    <url>/2021/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%888%EF%BC%89-%E6%A0%91/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>有n个结点的有限集合。<br>或者是空树，空树中不包含任何结点；或者是非空树，有且仅有一个特定的根节点，其余结点可分为m个互不相交的有限集，其每一个又是一棵树，且称为根的子树。<br>树的定义是递归的。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取深度</li>
<li>获取根节点</li>
<li>获取结点的值</li>
<li>给结点赋值</li>
<li>获取父节点</li>
<li>获取最左孩子结点</li>
<li>获取右兄弟结点</li>
<li>在指定位置插入孩子结点</li>
<li>删除指定位置的孩子结点</li>
<li>遍历</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul>
<li>前序遍历 根-左-右</li>
<li>后序遍历 左-右-根</li>
<li>层序遍历 树的广度遍历，从上到下，从左到右</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>静态链表。数组存放所有树结点，数据元素包含父节点在数组中的下标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    int parentCur;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode[];</span><br></pre></td></tr></table></figure>

<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>多重链表: 数据元素包含所有子节点的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多重链表的长度由树的度决定，会造成很大一部分的空间浪费。实际中不宜采用</p>
<p>孩子链表: 数据元素包含一个链表，链接所有子节点的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode&lt;E&gt; firstChilde;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双亲孩子表示法"><a href="#双亲孩子表示法" class="headerlink" title="双亲孩子表示法"></a>双亲孩子表示法</h3><p>双亲表示法+孩子链表表示法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode&lt;E&gt; parent;</span><br><span class="line">    TreeNode&lt;E&gt; firstChilde;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>二叉链表表示法。数据元素包含<em>结点的第一个子结点</em>及<em>右兄弟结点</em>的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode&lt;E&gt; nextSibling;</span><br><span class="line">    TreeNode&lt;E&gt; firstChilde;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>遍历<br>深度<br>回溯</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-图</title>
    <url>/2021/11/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%889%EF%BC%89-%E5%9B%BE/</url>
    <content><![CDATA[<p>图的存储结构应根据具体问题的要求来设计，文中列出的是常用的存储结构。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>在图结构中，任意两个顶点之间都可能有关系。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>图是由顶点的有穷非空集合和顶尖之间边的集合组成。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>查找顶点在图中位置</li>
<li>获取顶点值</li>
<li>设置顶点值</li>
<li>获取第一个邻接顶点</li>
<li>获取下一个邻接顶点</li>
<li>添加新顶点</li>
<li>删除顶点及相关的弧</li>
<li>添加弧</li>
<li>删除弧</li>
<li>遍历</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>深度优先遍历<br>广度优先遍历</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>图没有顺序存储结构，但可借助数组表示元素之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum GraphType &#123; DG, DN, UNG, UDN &#125; // 有向图，有向网，无向图，无向网</span><br></pre></td></tr></table></figure>
<h3 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class GNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    GNode[] next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个结点的度都不一样。若按最大度来存储，则可能造成很大的空间浪费；若按结点各自的度来存储，给操作带来不便。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>用一维数组存储顶点的信息，用二维数组存储图中边的信息，存储顶点之间的邻接关系的二维数组称为邻接矩阵。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    V[] vs;</span><br><span class="line">    Arc[][] as;</span><br><span class="line">    int vexnum, arcnum;</span><br><span class="line">    GraphType type;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        int adj; // 对无权图，用0、1表示是否相邻，对有权图，则为权值。</span><br><span class="line">        A item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>对图中每个顶点建立一个单链表，第i个单链表的结点表示依附于顶点vi的边（对有向图是以顶点vi为尾的弧）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    VNode[] vs;</span><br><span class="line">    GraphType type;</span><br><span class="line">    int vexum, arcnum; </span><br><span class="line">    </span><br><span class="line">    class VNode&lt;V, A&gt; &#123;</span><br><span class="line">        V item;</span><br><span class="line">        Arc&lt;A&gt; firstArc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        A item;</span><br><span class="line">        Arc&lt;A&gt; next;</span><br><span class="line">        int adjvex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>有向图的存储结构。将有向图的邻接表和逆邻接表结合起来的一种链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    VNode[] vs;</span><br><span class="line">    int vexnum, arcnum;</span><br><span class="line">    </span><br><span class="line">    class VNode&lt;V&gt; &#123;</span><br><span class="line">        V item;</span><br><span class="line">        Arc&lt;A&gt; firstIn, firstOut;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        Arc&lt;A&gt; head, tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链接多重表"><a href="#链接多重表" class="headerlink" title="链接多重表"></a>链接多重表</h3><p>无向图的存储结构。每一条边用一个结点表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    VNode[] vs;</span><br><span class="line">    int vexnum, arcnum;</span><br><span class="line">    </span><br><span class="line">    class VNode&lt;V&gt; &#123;</span><br><span class="line">        V item;</span><br><span class="line">        Arc&lt;A&gt; firstIn, firstOut;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        Arc&lt;A&gt; head, tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>深度/广度优先遍历<br>最小生成树<br>    普利姆算法<br>    克鲁斯卡尔算法<br>有向无环图 拓扑排序<br>最短路径</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-疑难解答</title>
    <url>/2021/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88X%EF%BC%89-%E7%96%91%E9%9A%BE%E8%A7%A3%E7%AD%94/</url>
    <content><![CDATA[<h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><table>
<thead>
<tr>
<th>结构</th>
<th>数据元素名称</th>
<th>数据元素关系</th>
</tr>
</thead>
<tbody><tr>
<td>线性结构</td>
<td>数据元素</td>
<td>前驱、后继</td>
</tr>
<tr>
<td>树结构</td>
<td>结点</td>
<td>双亲结点、孩子结点、兄弟结点</td>
</tr>
<tr>
<td>图结构</td>
<td>顶点</td>
<td>邻接</td>
</tr>
<tr>
<td>索引</td>
<td>记录</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="数组是一种数据结构么"><a href="#数组是一种数据结构么" class="headerlink" title="数组是一种数据结构么"></a>数组是一种数据结构么</h2><p>是一种数据结构。<br>数组是最基础的数据结构，所以几乎所有的程序设计语言都把数组设定为固定的基础变量类型。<br>在Java中，数据的ADT由底层实现，操作方式不同于其它的操作方式，有它独特的操作方式。如直接赋值，下标访问，初始化等。<br>当数组维度为1时，退化为顺序表。</p>
<h2 id="物理结构-存储结构"><a href="#物理结构-存储结构" class="headerlink" title="物理结构/存储结构"></a>物理结构/存储结构</h2><p>有说法：常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等。（百度百科：数据结构）<br>也有说法： 数据元素之间的关系有两种不同的表示方法：顺序映象和非顺序映象，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。（百度百科：存储结构）</p>
<p>根据物理结构的定义：数据及其逻辑结构在计算机中的表示。而其逻辑结构指的是数据元素之间的关系，即通过该元素，如何找到接下来的元素，即顺序存储和链式存储。<br>对于顺序存储，其关联元素位置由当前位置计算得出，不需要存储。而链式存储，关联元素位置需要存储。</p>
<p>所以，数据的存储结构就是指顺序存储结构和链式存储结构。</p>
<h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><p>树、二叉树、森林是不同的数据结构。二叉树并不是树的一种特殊情况，而是平行的概念，都属于树结构。<br>树、二叉树其定义与性质都不相同。<br>如果二叉树只是在树的定义上，新增了一条或多条，则二叉树可以理解为一种特殊的树。</p>
<h2 id="线性结构与线性表"><a href="#线性结构与线性表" class="headerlink" title="线性结构与线性表"></a>线性结构与线性表</h2><p>线性结构只有线性表么，队列、栈只是一种特殊的线性表，数组与广义表是线性表的推广，不属于线性结构，所以线性结构只有线性表。<br>一维数组也是线性结构。<br>所以线性结构不只是线性表。那还有其它的线性结构么？ - 串</p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><p>抽象数据类型是与程序设计语言相关的。每种语言对同一种数据结构所定义的抽象数据类型是不一致的。<br>抽象数据类型在面向对象中相当于接口，其不同的实现方式相当于实现类。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-线性结构</title>
    <url>/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><p>有序数据元素的集合。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>集合中必存在唯一的“第一个元素”；</li>
<li>集合中必存在唯一的“最后的元素”；</li>
<li>除最后元素外，其它数据元素均有唯一的“后继”；</li>
<li>除第一个元素外，其它数据元素均有唯一的“前驱”。</li>
</ol>
<h2 id="常用结构"><a href="#常用结构" class="headerlink" title="常用结构"></a>常用结构</h2><ul>
<li>线性表<ul>
<li>顺序表</li>
<li>单链表</li>
<li>循环链表</li>
<li>双向链表</li>
<li>静态链表</li>
</ul>
</li>
<li>栈</li>
<li>队列</li>
</ul>
<h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>不是线性结构，是由线性结构组成。</p>
<ul>
<li>数组</li>
<li>广义表</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-图状结构</title>
    <url>/2021/11/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89-%E5%9B%BE%E7%8A%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h2><p>数据元素对于关系的前驱和后继个数不加限制，即任意的关系，称为图形结构。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>顶点： 数据元素<br>简单图： 不存在顶点到其自身的边，且同一条边不重复出现<br>无向图： 任意两个顶底之间的边都是无向边<br>弧: 有向边<br>邻接：任意两个顶点存在边，则两个顶点互为邻接点<br>依附：边依附于顶点<br>无向完全图：无向图中，任意两个顶点之间都存在边<br>有向完全图： 有向图中，任意两顶点之间存在方向互为相反的两条弧<br>顶点的度： 无向图中，依附于该顶点的边的个数<br>顶点的入度： 有向图中，以该顶点为弧头的弧的个数<br>顶点的出度： 有向图中，以该顶点为弧为的弧的个数</p>
<p>权：对边赋予有意义的数值量<br>网：边上带权的图称为网</p>
<p>路径： 两顶点之间的路径是一个顶点序列<br>路径长度： 路径上边的数目<br>回路/环： 第一个顶点和最后一个顶点相同的路径<br>简单路径： 顶点不重复出现的路径<br>简单回路： 除了第一个和最后一个顶点，其余顶点不重复出现的回路</p>
<p>连通图： 无向图中，若任意的两个顶点之间有路径，则称该图是连通图<br>连通分量： 非连通图的极大连通子图<br>强连通图： 有向图中，对任意结点i、j，从顶点i到j均有路径，则称该有向图是强连通图<br>强连通分量： 非强连通图的极大强连通子图</p>
<p>生成树：…<br>生成森林：…</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>深度优先遍历<br>广度优先遍历</p>
<h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><ul>
<li>邻接矩阵<br>用一维数组存储顶点的信息，用二维数组存储图中边的信息，存储顶点之间的邻接关系的二维数组称为邻接矩阵。</li>
<li>邻接表</li>
<li>十字链表</li>
<li>链接多重表</li>
<li>最小生成树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-树形结构</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><p>层次的嵌套结构。树形结构的外层和内层有相似的结构。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>结点：数据元素<br>结点的度： 结点所拥有子树的个数<br>树的度： 树中个结点度的最大值<br>叶子结点： 度为0的结点<br>分支结点： 度不为0的结点<br>树的深度：树中所有结点的最大层数<br>层序编号：按照从上到下，从左到右的次序依次编号<br>有序树： 结点的各子树从左到右是有次序的。交换了结点各子树的相对位置，则构成不同的树。<strong>在数据结构中讨论的树一般是有序树</strong><br>森林： m棵互不相交的树的集合</p>
<h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><ul>
<li>二叉树</li>
<li>树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-排序</title>
    <url>/2021/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>排序的目的： 便于查找。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>记录： 数据元素。</li>
<li>趟： 将待排序的记录序列扫描一遍称为一趟。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>稳定排序 相等的记录排序前后相对位置不变。</li>
<li>不稳定排序 相等的记录排序前后相对位置可能改变。</li>
</ul>
<ul>
<li>内部排序 待排序记录放在内存中的排序过程。</li>
<li>外部排序 待排序记录数量很大，排序过程中需对外存进行访问的排序过程。</li>
</ul>
<h2 id="内部排序算法"><a href="#内部排序算法" class="headerlink" title="内部排序算法"></a>内部排序算法</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>依次将待排序序列中的每一个记录插入到一个已经排好序的序列中，直到全部记录都排好序。</p>
<p>当序列中的记录基本有序，或待排序记录较少时，是最佳的排序方式。数据量大时效率低。</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先将整个待排序记录序列分割成若干个子序列，在子序列中分别进行直接插入排序，待整个序列基本有序时，对全体记录进行一次直接插入排序。<br>是对直接插入排序的一种改进。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>两两比较相邻记录，如果反序则交换，直到没有反序的记录为止。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>首先选一个轴值，将待排序的记录划分为独立的两部分，然后分别对这两部分重复该过程，知道整个序列有序。<br>是对冒泡排序的一种改进。</p>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>第i趟排序在待排序序列中选取关键码最小的记录，并和第i个记录交换，作为有序序列的第i个记录。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>将待排序的记录序列构造称一个堆，然后将堆顶记录移走，并将剩余的记录再调整成堆，直到堆中只有一个记录为止。<br>是对简单选择排序的一种改进。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将若干有序序列逐步归并，最终归并为一个有序序列。<br>二路归并排序： 归并排序中最简单的排序方法，两两归并。</p>
<h3 id="桶式排序"><a href="#桶式排序" class="headerlink" title="桶式排序"></a>桶式排序</h3><p>假设待排序记录的值都在 0~m-1之间，设置m个桶，首先将值为i的记录分配到第i个桶中，然后再将各个桶中的记录依次收集起来。</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>将关键码看成由若干个子关键码复合而成，然后借助分配和收集操作采用LSD方法进行排序。</p>
<h2 id="各排序算法比较"><a href="#各排序算法比较" class="headerlink" title="各排序算法比较"></a>各排序算法比较</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th>稳定排序</th>
<th>平均时间复杂度</th>
<th>最坏时间复杂度</th>
<th>空间复杂度</th>
<th>简单性</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td>稳定</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>简单算法</td>
</tr>
<tr>
<td>希尔排序</td>
<td>不稳定</td>
<td>O(n*logn)~O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>改进算法</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>稳定</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>简单算法</td>
</tr>
<tr>
<td>快速排序</td>
<td>不稳定</td>
<td>O(n*logn)</td>
<td>O(n^2)</td>
<td>O(logn)~O(n)</td>
<td>改进算法</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>不稳定</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>简单算法</td>
</tr>
<tr>
<td>堆排序</td>
<td>不稳定</td>
<td>O(n*logn)</td>
<td>O(n*logn)</td>
<td>O(1)</td>
<td>改进算法</td>
</tr>
<tr>
<td>归并排序</td>
<td>稳定</td>
<td>O(n*logn)</td>
<td>O(n*logn)</td>
<td>O(n)</td>
<td>改进算法</td>
</tr>
<tr>
<td>桶式排序</td>
<td>稳定</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(m)</td>
<td>简单算法</td>
</tr>
<tr>
<td>基数排序</td>
<td>稳定</td>
<td>O(d(n+m))</td>
<td>O(d(n+m))</td>
<td>O(m)</td>
<td>改进算法</td>
</tr>
</tbody></table>
<p>n越小，采用简单排序算法约合适，n越大，采用改进算法约合适。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-索引</title>
    <url>/2021/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%85%AD%EF%BC%89-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>如果数据规模很大或者需要长期保存，则必须以文件的形式存储在外存。<br>索引是为了加快查找速度而设计的一种数据结构，索引技术是组织大型数据库及磁盘文件的一种重要技术。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li><p>记录 数据元素</p>
</li>
<li><p>文件 指存储在外存上的记录集合</p>
</li>
<li><p>索引 将关键码与它对应的记录相关联的过程。一个索引隶属于一个文件，由多个索引项组成。</p>
</li>
<li><p>索引项 至少包含关键码和关键码对应的记录在存储器中的位置等信息。</p>
</li>
<li><p>静态索引 文件创建时生成索引结构，只有当文件再组织是才发生改变。</p>
</li>
<li><p>动态索引 文件创建是生成的索引，在文件执行插入、删除等操作时，索引结构本身也随之发生改变。</p>
</li>
<li><p>线性索引/索引表 索引项组织为线性结构。</p>
</li>
<li><p>树形索引 索引项组织为树形结构。</p>
</li>
<li><p>多级索引 对索引再建立一个索引。</p>
</li>
</ul>
<h2 id="线性索引技术"><a href="#线性索引技术" class="headerlink" title="线性索引技术"></a>线性索引技术</h2><ul>
<li>稠密索引</li>
<li>分开索引</li>
<li>多重表</li>
<li>倒排表</li>
</ul>
<h2 id="树形索引"><a href="#树形索引" class="headerlink" title="树形索引"></a>树形索引</h2><p>树形索引多用于动态索引，常采用链式存储结构实现。<br>二叉排序树时一种最基本的树形索引，许多其它索引都是从它发展而来的。</p>
<ul>
<li>2-3树</li>
<li>B-树</li>
<li>B+树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-查找表</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%9F%A5%E6%89%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>查找表是由同一种数据元素构成的集合。<br>集合中的元素之间存在着完全松散的关系，也可以用其它数据结构来表示它。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol>
<li>查询某个特定的数据元素是否在表中；</li>
<li>检索某个特定的数据元素的各种属性；</li>
<li>在查找表中插入一个数据元素；</li>
<li>从查找表中删除某个数据元素。</li>
</ol>
<ul>
<li>静态查找表 只有查找操作，没有插入删除的查找表</li>
<li>动态查找表 有插入删除的查找表</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>关键码 可以标识一个记录的数据项</li>
<li>键值 关键码的值</li>
<li>主关键码 可以唯一地标识一个记录的关键码</li>
<li>此关键码 不能唯一标识一个记录的关键码</li>
<li><strong>查找结构</strong> 面向查找操作的数据结构</li>
</ul>
<h2 id="查找结构"><a href="#查找结构" class="headerlink" title="查找结构"></a>查找结构</h2><ul>
<li>线性表 适用于静态查找<ul>
<li>顺序表的查找</li>
<li>有序表的查找</li>
<li>折半查找技术</li>
<li>分块查找/索引顺序表查找</li>
</ul>
</li>
<li>树表 适用于动态查找<ul>
<li>二叉排序树</li>
<li>B-树</li>
</ul>
</li>
<li>散列表 均使用<ul>
<li>散列技术</li>
</ul>
</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>关心整体性能。<br>平均查找长度。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-分治法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89-%E5%88%86%E6%B2%BB%E6%B3%95/</url>
    <content><![CDATA[<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同。递归地解这些子问题，然后将各子问题的解合并到原问题的解。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>归并排序</li>
<li>快速排序</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-动态规划</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>与分治法类型，也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。<br>与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。</p>
<p>如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。为了达到这个目的，可以用一个表记录所有已解决的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>找出最优解的性质，并刻画其结构特征；</li>
<li>递归地定义最优值；</li>
<li>以自底向上的方式计算出最优值；</li>
<li>根据计算最优值是得到的信息，构造最优解。</li>
</ol>
<h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><h3 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h3><p>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p>
<h3 id="重叠子问题性质"><a href="#重叠子问题性质" class="headerlink" title="重叠子问题性质"></a>重叠子问题性质</h3><p>每次产生的子问题并不总是新问题，有些子问题被反复计算多次。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>矩阵连乘</li>
<li>最长公共子序列</li>
<li>0-1背包问题</li>
<li>最优二叉搜索树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-贪心算法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%883%EF%BC%89-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>贪心算法总是做出在当前看来最好的选择。贪心算法并不从整体最优考虑，它所做出的选择只是在某种意义上的局部最优选择。贪心算法得到的最终结果也是整体最优的。</p>
<h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><p>贪心算法通过一系列的选择得到问题的解。它所做出的每一个选择都时当前状态下的最好选择，即贪心选择。</p>
<h3 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h3><p>指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。</p>
<h3 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h3><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</p>
<h2 id="贪心-VS-动态规划"><a href="#贪心-VS-动态规划" class="headerlink" title="贪心 VS 动态规划"></a>贪心 VS 动态规划</h2><p>都要求问题具有最优子结构性质。</p>
<p>在动态规划算法中，每步所做出的选择往往依赖于相关子问题的解。因而只有解出相关子问题后，才能做出选择。<br>而在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择，然后再去解做出这个选择后产生的相应的子问题。</p>
<p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做出依次贪心选择就将所求问题简化为规模更小的子问题。</p>
<p>0-1背包问题与背包问题。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>哈夫曼编码</li>
<li>单源最短路径<br>  给定带权有向图G=(V, E)，其中每条边的权时非负实数。另外，还给定V中的一个顶点，称为源。计算从源到所有其它各顶点的最短路长度（路上各边权之和）。</li>
<li>最小生成树<ul>
<li>Prim 算法</li>
<li>Kruskal 算法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-回溯法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%884%EF%BC%89-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>从开始结点（根节点）出发，以深度优先方式搜索整个解空间。这个开始结点称为活结点，同时也称为当前的扩展结点。在当前扩展结点处，搜索向纵深方向移至一个新结点。这个新节点成为新的活结点，并称为当前扩展结点。如果在当前扩展结点处不能再向纵深方向移动，则当前扩展结点就称为死结点。此时，应往回移动（回溯）至最近的活结点处，并使这个活结点成为当前扩展结点。回溯法以这种工作方式递归地再解空间中搜索，直至找到所要求的解或解空间中已无活结点时为止。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>针对所给问题，定义问题的解空间；</li>
<li>确定易于搜索的解空间结构；</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ul>
<li>递归回溯 用递归方法实现回溯法。</li>
<li>迭代回溯 用树的非递归深度优先遍历算法，可将回溯法表示为一个非递归迭代过程。</li>
</ul>
<h2 id="解空间树"><a href="#解空间树" class="headerlink" title="解空间树"></a>解空间树</h2><ul>
<li>子集树<br>当所给问题是从n各元素的集合S中找出S满足某种性质的子级时，相应的解空间树称为子集树。<br>通常有2^n+1个结点，2^n个叶子结点。遍历需要Ω(2^n)计算时间。</li>
<li>排列树<br>当所给问题时确定n各元素满足某种性质的排列时，相应的解空间树称为排列树。<br>通常有n!个叶子结点。遍历需要Ω(n!)计算时间。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>0-1背包问题</li>
<li>最大团问题</li>
<li>图的m着色问题</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-分支限界法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%885%EF%BC%89-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>以广度优先或以最小耗费/最大效益有限的方式搜索问题的解空间树。每一个活结点只有依次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点将被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。</p>
<h2 id="分支限界-VS-回溯"><a href="#分支限界-VS-回溯" class="headerlink" title="分支限界 VS 回溯"></a>分支限界 VS 回溯</h2><p>都是在解空间树上搜索问题解的算法。</p>
<p>回溯法的求解目标时找出解空间树中满足约束条件的所有解。而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p>
<p>求解目标不同，导致堆解空间树的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树。而分支限界法以广度优先或以最小耗费优先的方式搜索解空间树。</p>
<h2 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h2><ul>
<li>队列式分支限界法<br>将活结点表组织成一个队列，并按队列的FIFO原则选取下一个结点为当前扩展结点。</li>
<li>优先队列式分支限界法<br>将活结点的表组织成一个优先队列，并按优先队列中规定的结点优先级选取优先级最高的下一个结点成为当前扩展结点。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>单源最短路径问题</li>
<li>0-1背包问题</li>
<li>最大团问题</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>CRLF</title>
    <url>/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CRLF/</url>
    <content><![CDATA[<h1 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h1><blockquote>
<p>How/Why</p>
</blockquote>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul>
<li>windows 使用crlf回车换行</li>
<li>linux使用lf换行</li>
<li>macos 之前使用cr回车，现在使用lf换行</li>
</ul>
<h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><ul>
<li>idea 编辑文件使用系统默认换行符即可。</li>
<li>git默认配置 atuocrlf=true，检出/提交时会自动转换换行符。</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>原码、补码、反码</title>
    <url>/2020/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/</url>
    <content><![CDATA[<h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>用二进制表示，用最高位表示符号。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>直观。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>负数的运算通过累加器来实现，原码的方式不支持减法。</p>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>正数的反码是其本身，负数的反码是除符号位，其它位取反。</p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ul>
<li>符号位与数值一起参与运算</li>
<li>循环进位（最高位相加有进位时，送到最低位相加）</li>
<li>结果也是反码。<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4>解决减法问题<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li>
</ul>
<p>+0 和 -0 有两种表示方法。</p>
<h4 id="循环进位"><a href="#循环进位" class="headerlink" title="循环进位"></a>循环进位</h4><ul>
<li>两个正数相加，进位表示溢出</li>
<li>两个负数相加，若结果不溢出，产生进位</li>
<li>一正一负相加，若结果为负，没有进位，若结果为正，产生进位。</li>
</ul>
<p>反码加法按照 循环进位 的法则来算才能保证其正确性。</p>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>正数的补码是其本身，负数的补码符号位不变，其余各位取反，最后+1。</p>
<h4 id="运算-1"><a href="#运算-1" class="headerlink" title="运算"></a>运算</h4><ul>
<li>符号位参与运算</li>
<li>最高位相加后若出现进位，则舍弃</li>
<li>结果也是补码<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4>解决 +0 -0问题，有更大的表示范围。</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="模"><a href="#模" class="headerlink" title="模"></a>模</h3><p>计量系统的计数范围，如时针的模是12。</p>
<h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>两个正数a,b，如果除以正数m所得余数相同，则称a，b对于模同余。</p>
<h3 id="负数取模"><a href="#负数取模" class="headerlink" title="负数取模"></a>负数取模</h3><p>x mod y = x - y * ⌈x / y⌉ (向上取整) </p>
<h3 id="补码、反码"><a href="#补码、反码" class="headerlink" title="补码、反码"></a>补码、反码</h3><p>补码、反码和原码同余，只是模不同。</p>
<p>在不考虑溢出的情况下，如果a、b同余，则 a + c = b + c。所以，负数的加法可以通过反码、补码来计算。</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>字符编码</title>
    <url>/2022/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>在计算机中，所有的数据在存储和运算时都要使用二进制数表示（计算机用高电平和低电平分别表示1和0）。<br>编码是信息从一种形式或格式转换成另一种形式的过程。用预先定义的方法将信息、数据转换成规定的电脉冲信号。<br>解码，是编码的逆过程。</p>
<p>字符是各种文字和符号的总称。包括各国家文字、标点符号、图形符号、数字等。<br>字符集是多个字符的集合。<br>常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集。<br>计算机要准确的处理各种字符集文字，就需要进行字符编码，以便计算机能够识别和存储各种文字。</p>
<p>字符编码，也称字集码，是把字符集中的字符，编码为指定集合中某一对象，以便文本在计算机中存储和通过通信网络的传递。</p>
<h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>American Standard Code for Information Interchange，美国信息交换标准代码。<br>1967年由ANSI（美国国家标准学会）指定。最后一次更新是在1986年，共定义了128个字符。<br>是一种标准的单字节字符编码方案，用于基于文本的数据。<br>最初是美国国家标准，供不同计算机在相互通信时用作共同遵守的西文字符编码标准，后来被国家标准化组织（ISO）定为国际标准（ISO 646），适用于所有拉丁文字母。</p>
<p>表达方式：标准ASCII码使用7位（首位规定为0）二进制数组合来表示128中可能的字符。</p>
<h2 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO-8859-1"></a>ISO-8859-1</h2><p>是单字节编码，向下兼容ASCII。<br>除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。</p>
<h2 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h2><p>信息交换用汉字编码字符集。<br>由中国国家标准总局1980年发布，1981年5月1日开始实施的一套国家标准。<br>在使用GB2312的程序中，通常采用EUC存储方法，以便兼容于ASCII。<br>每个汉字及符号以两个字节来表示。第一个字节称为高位字节（或区字节），第二个字节称为低位字节（或位字节）。</p>
<h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>汉字内码扩展规范。<br>全国信息技术标准化技术委员会于1995年10月制定，1995年12月正式发布。<br>GBK向下与GB2312兼容，向上支持ISO 10646国际标准。是在GB2312标准基础上扩展。</p>
<p>2000年已被GB18030-2000国家强制标准替代。<br>2005年GB118030-2005发布，替代了GB18030-2000。</p>
<h2 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a>Big5</h2><p>又称为大五码或五大码，是使用繁体中文社区最常用的电脑汉字字符集标准。<br>Big5是一套双字节字符集，使用了双八码存储方法，以两个字节来存放一个字。</p>
<h2 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h2><p>并不是某一种特定的字符编码，而是在不同的系统中，ANSI表示不同的编码。只存在于Windows系统。<br>在中文系统中，使用GB2312/GBK；在繁体中文系统中，使用Big5；在英文系统中，使用ASCII。</p>
<h2 id="UCS与Unicode"><a href="#UCS与Unicode" class="headerlink" title="UCS与Unicode"></a>UCS与Unicode</h2><p>UCS，通用字符集（Universal Character Set），是由ISO 1984年创建的ISO 10646标准所定义的标准字符集。<br>格式：UCS-2（用两个字节编码）、UCS-4（用4个字节编码）。</p>
<p>Unicode是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制码，以满足跨语言、跨平台进行文本转换、处理的要求。<br>1990年开始研发，1994年正式发布1.0版，2021年9月14日发布14.0版。<br>格式：UTF-16（以16位无符号整数为单位）、UTF-32（以32位无符号整数为单位）、UTF-8（以字节为单位）。<br>UTF： Unicode Transformation Format。<br>多字节的Unicode编码方式定义了一个字节顺序标记，它是一个特殊的非打印字符，可以把它包含在文档的开头来只是所使用的字节顺序（big/little-endian）。</p>
<p>由于Unicode名字更好记，因而它使用更为广泛。</p>
<h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>需要1个或2个16位长的码元来表示。因此这是一个变长表示。<br>当两个字节能够表示时，直接使用两个字节表示。<br>两个字节能够表示65536个字符，一般使用的字符基本在这个范围内。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>是针对Unicode的一种可变长度字符编码。可以用来表示Unicode标准中的任何字符。编码中的第一个字节与ASCII兼容。</p>
<p>格式：首位为0，表示一个字节，首位10表示两个字节，首位110表示三个字节，首位1110表示四个字节，多字节其余字节以10开头。</p>
<h2 id="UTF-16-VS-UTF-8"><a href="#UTF-16-VS-UTF-8" class="headerlink" title="UTF-16 VS UTF-8"></a>UTF-16 VS UTF-8</h2><p>UTF-8是ASCII的一个超集，所以现存的ASCII不需要转换。<br>存储英文，UTF-16会造成浪费，UTF-8使用一个字节，UTF-16使用两个字节。<br>存储中文，UTF-8会造成浪费，UFT-8使用三个字节，UTF-16使用两个字节。（UTF-8更多空间来表示规则）<br>UTF-16如果时定长可进行随机访问。</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2020/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>最近做小数计算，发现double比long的最大值大了好多，甚至float最大值都比long最大值大，而float是32位存储空间，long是64位存储空间，带着这个疑问，进行深入探索。<br>PS: 本文所提到的所有类型，以Java语言为准。</p>
</blockquote>
<h2 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>存储空间(bit)</th>
<th>存储范围</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1</td>
<td>0/1</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>-128~127</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>0~65536</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>-2,147,483,648~2,147,483,647</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>-9,223,372,036,854,775,808~9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>-3.4028235E38~3.4028235E38</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>-1.7976931348623157E308~1.7976931348623157E308</td>
</tr>
</tbody></table>
<h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><p>想要保存比long最大值还大的整数，使用BigInteger，性能会有所降低。</p>
<h3 id="double-VS-long"><a href="#double-VS-long" class="headerlink" title="double VS long"></a>double VS long</h3><ul>
<li>double和long都是64位，double最大值远大于long最大值<blockquote>
<p>存储方式不一样，double中可以使用阶数存储。<br>double 64位 = 1位符号 + 11位阶码（带符号） + 52位尾数</p>
</blockquote>
</li>
<li>E308，为何是308次方<blockquote>
<p>log(2^(2^10-1)) 大于308小于309。 2^10-1: 阶码最大值，阶码首位为符号，正数从0开始。log(2^X): 计算机中2为阶底，转为以10为阶底。</p>
</blockquote>
</li>
<li>double有效数字为16位，long有效数字为19<blockquote>
<p>使用阶数存储，但是需要丢失末尾的精确度，会四舍五入。<br>2^52 = 4,503,599,627,370,496, 最大值为16位数，所以有效数字为16位。</p>
</blockquote>
</li>
</ul>
<h3 id="float-VS-int"><a href="#float-VS-int" class="headerlink" title="float VS int"></a>float VS int</h3><p>与double、long同理</p>
<h2 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h2><p>二进制浮点数算术标准。Java中float，double都符合该标准。</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>进制转换</title>
    <url>/2020/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="十进制-gt-二进制"><a href="#十进制-gt-二进制" class="headerlink" title="十进制 -&gt; 二进制"></a>十进制 -&gt; 二进制</h2><p>除二取余，余数倒序。</p>
<h2 id="二进制-gt-十进制"><a href="#二进制-gt-十进制" class="headerlink" title="二进制 -&gt; 十进制"></a>二进制 -&gt; 十进制</h2><p>按权展开相加。</p>
<h2 id="二进制-gt-八进制"><a href="#二进制-gt-八进制" class="headerlink" title="二进制 -&gt; 八进制"></a>二进制 -&gt; 八进制</h2><p>3位二进制数按权展开相加得到一位八进制数。</p>
<h2 id="八进制-gt-二进制"><a href="#八进制-gt-二进制" class="headerlink" title="八进制 -&gt; 二进制"></a>八进制 -&gt; 二进制</h2><p>八进制数同故宫除2取余法，得到二进制数，每个八进制为三个二进制，不足时在最左边补零。</p>
<h2 id="二进制-gt-十六进制"><a href="#二进制-gt-十六进制" class="headerlink" title="二进制 -&gt; 十六进制"></a>二进制 -&gt; 十六进制</h2><p>4位二进制数按权展开相加得到一位十六进制数。</p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>区块链简介</title>
    <url>/2023/07/08/%E5%8C%BA%E5%9D%97%E9%93%BE/String/</url>
    <content><![CDATA[<pre><code>账号：
    账号密码：没有信任的第三方系统，无法存储账号密码
    账号 -&gt; 公钥
    密码 -&gt;  私钥
    通过私钥计算出公钥。外界无法通过公钥计算出私钥
    椭圆加密曲线函数： 无法反算，但有初始条件很容易验证。
交易过程： 
    上一个区块的hash + 交易记录 + 随机数，取哈希，结果要满足一个很难达到的限制条件。
    需要计算随机数。竞争记账。
    记账验证。
区块：
    块头：
        头哈希：这页账单的hash值
        父哈希：上页账单的hash值
    块体： 交易记录
    时间戳
UTXO模型：
    UTXO： Unspent Transaction Output 未花费的交易输出
    只记录交易过程，不记录余额
分叉、最长链原则：（双花）
    少数服从多数，少数的结果是不被承认的
    等待6个区块，确认是否有效
读写权限：
    交易者与记账者
    类型：
        公有链：任何人可读取、可发送交易且交易能获得有效确认，任何人都能参与共识过程   可获得奖励
        联盟链：共识过程（数据写入）受到预选节点控制，或许允许每个人都可读取   不需要、没有奖励
        私有链：唯一组织
骨骼：加密算法
    非对称加密算法
        RSA
        ECC（椭圆曲线加密）
    哈希函数：梅克尔树、区块指针、比特币挖矿
        任务长度消息压缩成固定长度的二进制串
        MD4、MD5、Sha-1、Sha-256、...
    使用：
        私钥：用于生成签名
        公钥：用于验证签名
        地址：公钥hash得出，公钥太长，地址较短
        签名：用于验证是公钥持有者发出
    梅克尔书：
        将大量的交易数据通过层次化的哈希，递归生产根哈希值，记录在区块头中
        快速归纳和校验区块数据的存在性和完整性
灵魂：共识机制
    拜占庭将军问题（分布式系统中的共识问题）
        延时、消息丢失、服务器宕机、攻击者
        三种安全模型：非拜占庭容错模型、拜占庭容错模型、经济模型
    ELP定理、CAP定理
    分布式系统的共识机制
        非拜占庭容错（适用于分布式数据库）：Paxos、Raft
        拜占庭容错（适用于分布式账本、区块链）：PoW、PoS、DPoS、PBFT
    比特币共识机制的特点：随机性、抗女巫攻击、激励机制
    PoW： 工作量证明        --- 比特币、莱特币、以太坊
    PoS: 权益证明        ---公链量子链、以太坊（2020后）
    DPoS: 授权权益证明    ---EOS、Bitshares
    PBFT算法（拜占庭容错算法）：强一致性，不会产生分叉
术语：
    不可篡改：难以篡改
    创造信任：去信任化
    去中介化
    溯源
    安全
    透明
    匿名
以太坊：
    1.0 比特币  点对点电子现金系统
    2.0  以太坊  金融领域、泛金融领域
    以太坊： 建议在区块链技术上的去中心化应用平台。图灵完备。支持智能合约。应用平台。
    图灵完备：一切可计算的问题都能计算。
    智能合约：预置触发条件、预置响应规则。区块链提供可信任执行环境。
    DApp： 去中心化App。
    发币：基于以太坊发行代币。首次代币发行（ICO）。
3.0 
    
</code></pre>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>VPN</title>
    <url>/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/</url>
    <content><![CDATA[<h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p>Virtual Private Network，虚拟专用网络。<br>远程访问技术，利用公用网络架设专用网络。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul>
<li>L2TP</li>
<li>IPSec</li>
<li>PPTP</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>VPN服务器</li>
<li>VPN软件</li>
<li>VPN硬件</li>
<li>集成VPN</li>
</ul>
<h2 id="VPN网关"><a href="#VPN网关" class="headerlink" title="VPN网关"></a>VPN网关</h2><p>可以实现点对点、点对网、网对网等多种互通形式。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>协议</title>
    <url>/2022/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名 -&gt; IP。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>无状态协议。<br>request/response</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>SSL/TLS<br>对称加密、非对称加密、协商密钥、数字证书。<br>客户端识别数字证书的合法性。<br>浏览器内置证书。</p>
<p>双向验证。</p>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>IP：点对点，不可靠<br>TCP：端对端，可靠</p>
<p>TCP 三次握手、四次挥手</p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>TCP/IP标准没有规定应用程序与协议软件如何接口的细节，而是允许系统设计者能够选择有关API的具体实现细节。<br>一般情况： 应用程序调用网络请求 -》 系统调用 -》 操作系统 -》 内部过程处理。<br>Socket是一个API，是应用程序和操作系统之间的接口。 应用程序 -》 Socket API -》 操作系统 -》 内部过程处理。</p>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>Socket.accept会随机开启一个端口进行网络连接，为什么这个端口可以通过防火墙处理。<br>防火墙实现： 分组、应用 组合方式。<br>socket开的端口应该是和原socket属于同一分组。</p>
<p>客户端连接服务器，这个端口也是随机开的，也不需要防火墙处理。<br>出端口、入端口。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>数字化、信息化。<br>本文网络指计算机网络。</p>
<h3 id="三网"><a href="#三网" class="headerlink" title="三网"></a>三网</h3><ul>
<li>电信网络 提供电话、电报、传真等服务。</li>
<li>有线电视网络 利用光缆或同轴电缆来传送广播电视信号或本地播放的电视信号的网络。提供各种电视节目。</li>
<li>计算机网络 计算机通信网。能够迅速传送数据，获取各种资料。</li>
</ul>
<h3 id="三网融合"><a href="#三网融合" class="headerlink" title="三网融合"></a>三网融合</h3><p>相互渗透，互相兼容，并逐步整合称为全世界统一的信息通信网络。</p>
<h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>网络 由若干结点和连接这些结点的链路组成。</li>
<li>互联网 网络的网络。网络把计算机连接在一起，而互联网把网络连接在一起。</li>
<li>因特网 世界上最大的互联网络。</li>
<li>网络互联 硬件+软件。</li>
<li>ISP 因特网服务提供商（Internet Service Provider）。</li>
</ul>
<h3 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h3><ol>
<li>第一阶段： 从单个网络ARPANET向互联网发展。</li>
<li>第二阶段： 三级结构的互联网。主干网、地区网、校园网/企业网。</li>
<li>第三阶段： 多层次ISP结构的互联网。</li>
</ol>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>计算机通信： 主机A的某个进程和主机B的另一个进程进行通信。</p>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ul>
<li>C/S 客户-服务器模式。</li>
<li>p2p 对等方式（peer to peer）。</li>
</ul>
<h3 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h3><ul>
<li>电路交换 整个报文的比特流连续地从源点直达重点。</li>
<li>报文交换 整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li>
<li>分组交换 单个分组传送到相邻结点（整个报文的一部分），存储下来后查找转发表，转发到下一个结点。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="按网络作用范围"><a href="#按网络作用范围" class="headerlink" title="按网络作用范围"></a>按网络作用范围</h3><ul>
<li>广域网WAN Wide Area Network</li>
<li>城域网MAN Metropolitan Area Network</li>
<li>局域网LAN Local Area Network</li>
<li>个人区域网PAN Personal Area Network</li>
</ul>
<h3 id="按使用者"><a href="#按使用者" class="headerlink" title="按使用者"></a>按使用者</h3><ul>
<li>公用网</li>
<li>专用网</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>速率 传输数据的速率。</li>
<li>带宽 网络的通信线路传送数据的能力。表示在单位时间内从网络的某一点到另一点所能通过的最高数据率。</li>
<li>吞吐量 单位时间内通过某个网络的数据量。</li>
<li>时延 数据从网络的一端传送到另一端的时间。总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延。</li>
<li>时延带宽积 传播时延 * 带宽。</li>
<li>往返时间RTT Round-Trip Time。从数据发送方发送数据开始，到发送方收到来自接收方的确认。</li>
<li>利用率 </li>
</ul>
<h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>为进行网络中的数据交换而建立的规则、标准或约定，称为网络协议。主要由以下三要素组成：</p>
<ul>
<li>语法 数据与控制信息的结构或格式。</li>
<li>语义 需要发出何种控制信息，完成何种动作以及做出何种响应。</li>
<li>同步 事件实现顺序的详细说明。</li>
</ul>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>各层之间是独立的、灵活性好、结构上可分隔开、易于实现和维护、能促进标准化工作。</p>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>把计算机网络的各层及其协议的集合，称为网络的体系结构。即计算机的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义。<br>体系结构是抽象的，而实现则是具体的。</p>
<h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI/RM: 开放系统互联模型（Open Systems Interconnection Reference Model）。</p>
<ul>
<li>⑦ 应用层 用户接口</li>
<li>⑥ 表示层 数据的表现形式，特定功能的实现</li>
<li>⑤ 会话层 对应用回话的管理同步</li>
<li>④ 传输层 可靠与不可靠的传输，传输前的错误检测，监控。</li>
<li>③ 网络层 提供逻辑地址，选路</li>
<li>② 数据链路层 成帧，用MAC地址访问媒介，错误检测与修正</li>
<li>① 物理层 设备之间的比特流传输，物理接口，电气特性。</li>
</ul>
<p>OSI七层模型只获得了一些理论研究的成果，以失败告终。</p>
<h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><ul>
<li>应用层 应用层+表示层+会话层</li>
<li>传输层</li>
<li>网络互联层</li>
<li>网络接口层 数据链路层+物理层</li>
</ul>
<p>实际事实标准。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>一般用来表示向某一个方向传送信息的媒体。<br>根据双方信息交互方式分类：</p>
<ul>
<li>单工通信 只能有一个方向的通信而美誉反方向的交互。（无线电广播、有线电广播、电视广播）</li>
<li>半双工通信 通信的双方都可以发送信息，单不能双方同时发送。</li>
<li>全双工通信 通信的双方可以同时发送和接受信息。</li>
</ul>
<h3 id="适配器-网卡"><a href="#适配器-网卡" class="headerlink" title="适配器/网卡"></a>适配器/网卡</h3><p>适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的。而适配器和计算机之间的通信是通过计算机主板上的I/O总线以并行传输方式进行的。</p>
<h3 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h3><p>非对称数字用户线ADSL技术是用数字技术对现有模拟电话用户线进行改造。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>是一种计算机局域网技术。</p>
<h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><p>PPP point to point protocol 点对点协议。<br>PPPOE PPP Over Ethernet 以太网上的点对点协议。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>任务：为分组交换网上的不同主机提供通信服务。<br>协议： IP</p>
<p>正向查询： 域名 -&gt; IP<br>反向查询： IP -&gt; 域名</p>
<h3 id="网段"><a href="#网段" class="headerlink" title="网段"></a>网段</h3><table>
<thead>
<tr>
<th>网段</th>
<th>最大网络数</th>
<th>ip范围</th>
<th>最大主机数</th>
<th>私有ip范围</th>
<th>子网掩码</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>2^7-2</td>
<td>1.0.0.0-126.255.255.255</td>
<td>2^24-2</td>
<td>10.0.0.0-10.255.255.255</td>
<td>255.0.0.0</td>
</tr>
<tr>
<td>B</td>
<td>2^14</td>
<td>128.0.0.0-191.255.255.255</td>
<td>2^16-2</td>
<td>172.16.0.0-172.31.255.255</td>
<td>255.255.0.0</td>
</tr>
<tr>
<td>C</td>
<td>2^21</td>
<td>192.0.0.0-223.255.255.255</td>
<td>2^8-2</td>
<td>192.168.0.0-192.168.255.255</td>
<td>255.255.255.0</td>
</tr>
</tbody></table>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>任务： 向两个主机中进程之间的通信提供通用的数据传输服务。<br>协议： TCP、UDP</p>
<ul>
<li>TCP 传输控制协议 提供面向连接的，可靠的数据传输服务。数据传输的单位是报文段。</li>
<li>UDP 用户数据报协议 提供无连接的，不可靠的数据传输服务。数据传输的单位是用户数据报。</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>任务： 通过应用进程间的交互来完成特定网络应用。<br>协议： 应用进程间通信和交互的规则。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>Domain Name System，域名系统。</p>
<h4 id="域名空间结构"><a href="#域名空间结构" class="headerlink" title="域名空间结构"></a>域名空间结构</h4><ul>
<li>. 便于分级管理，根域。</li>
<li>顶级域名/一级域名</li>
<li>二级域名</li>
<li>主机名</li>
</ul>
<h4 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h4><p>递归查询： 成功相应/失败相应。允许向其它DNS插叙<br>迭代查询： 服务器收到一次查询返回一次结果，结果不定。</p>
<h2 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h2><p>无线局域网 WLAN<br>无线城域网 WMAN<br>无线局域网标准 IEEE 802.11 凡使用802.11系列协议的局域网又称为WiFI。</p>
<h2 id="移动通信"><a href="#移动通信" class="headerlink" title="移动通信"></a>移动通信</h2><p>种类： 蜂窝移动通信（使用最多）、卫星移动通信、集群移动通信、无绳电话通信…<br>第一代蜂窝移动通信：1G<br>第二代蜂窝移动通信：2G…</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="TCP-IP连接"><a href="#TCP-IP连接" class="headerlink" title="TCP/IP连接"></a>TCP/IP连接</h3><p>三次握手，四次挥手</p>
<h3 id="常见协议端口"><a href="#常见协议端口" class="headerlink" title="常见协议端口"></a>常见协议端口</h3><ul>
<li>FTP 文件传输协议 20 21</li>
<li>SSH 安全shell协议 22</li>
<li>telnet 远程登录协议 23</li>
<li>DNS 域名系统 53</li>
<li>HTTP 超文本传输协议 80</li>
<li>HTTPS 43</li>
<li>SMTP 简单邮件传输协议 25</li>
<li>POP3 邮局协议3代 110</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-创建型-单例（Singleton ）</title>
    <url>/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一个类只有一个实例，且该类能自行创建这个实例。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时才创建对象。线程不安全。</p>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次加载时创建对象。</p>
<h3 id="双重锁校验"><a href="#双重锁校验" class="headerlink" title="双重锁校验"></a>双重锁校验</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>volatile + synchronize 保证原子性、可见性、顺序性。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInner.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类只有第一次访问该类时才会加载，只访问外部类不会加载。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE,;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>减少内存开销，避免对资源的多重占用。</li>
</ul>
</li>
<li>缺点<ul>
<li>扩展困难，违背开闭原则。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>在一些特定的场合，需要每次返回的实例对象都是同一个。如Spring中创建bean。</li>
<li>懒汉模式最简单解决方式，在getInstance方法上添加synchronized，但是每次调用都会加锁。</li>
<li>类加载器不一致会导致所有形式都出现多个实例。自行指定类加载器，并指定同一个类加载器。</li>
<li>把所有方法和变量都定义为静态的，与单例区别。<ol>
<li>静态方法没有状态，单例有状态。</li>
<li>静态方法加载时全部加载到内存，单例方法调用时将该方法加载到内存。</li>
</ol>
</li>
<li>单例不适合继承。1. 构造器的访问权限； 2. 所有派生类的共享同一个实例变量。</li>
<li>违反单一职责。 负责管理自己的实例，且对外提供方法。</li>
<li>static修饰的意义：<ol>
<li>修饰方法，构造器私有化，只能通过static方法获取对象实例。</li>
<li>修饰变量，static引用会被存放在静态方法区中，避免被垃圾回收。否则，需要将单例对象的引用保存在另一个不会被回收的对象中。</li>
</ol>
</li>
<li>单例状态化，多个单例作为一个状态仓库向外提供服务。</li>
<li>单例无状态化，提供工具性质的功能。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>线程池、缓存、注册表、日志。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-创建型-原型（Prototype）</title>
    <url>/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。</p>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instance</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Instance instanceA = <span class="keyword">new</span> Instance();</span><br><span class="line">        Instance instanceB = <span class="keyword">new</span> Instance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Prototype prototypeA = <span class="keyword">new</span> Prototype();</span><br><span class="line">        Prototype prototypeB = prototypeA.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>实现Cloneable接口；</li>
<li>实现clone方法，调用super.clone();，修改返回值，处理异常；</li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>隐藏创建新实例的复杂性。</li>
<li>某些时候，复制对象比创建新对象更有效。</li>
</ul>
</li>
<li>缺点<ul>
<li>对象的复制有时相当复杂。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>在Java中将原型模式变成了clone方法的使用。</li>
<li>深拷贝：显式调用嵌套对象的clone方法，嵌套对象都得实现cloneable接口。</li>
<li>使用子类clone对象时，子类得实现cloneable接口，父类不需要实现。</li>
<li>基类实现clone，可以将导出类转为基类进行clone，会保留导出类的属性。恢复时丢失类型。</li>
<li>集合类基本都实现了自己的clone方法。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-创建型-工厂（Factory）</title>
    <url>/2021/12/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<h2 id="简单工厂-静态工厂"><a href="#简单工厂-静态工厂" class="headerlink" title="简单工厂/静态工厂"></a>简单工厂/静态工厂</h2><p>将创建对象的操作解耦，以便扩展。<br>严格来说，不是一种设计模式。</p>
<h3 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        String type = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductA();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductB();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单工厂实现"><a href="#简单工厂实现" class="headerlink" title="简单工厂实现"></a>简单工厂实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product ac = SimpleFactory.createProduct(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ac.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul>
<li>简单工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>解耦。客户端只关心参数，而不关心产品的创建。</li>
<li>使用静态方法，不需要创建对象。</li>
</ul>
</li>
<li>缺点<ul>
<li>简单工厂使用了static，无法继承扩展。</li>
</ul>
</li>
</ul>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。<br>相比于简单工厂，不同的工厂类创建产品的过程可能是不一样的。</p>
<h3 id="一般实现-1"><a href="#一般实现-1" class="headerlink" title="一般实现"></a>一般实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        String type = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductA();</span><br><span class="line">                <span class="comment">// product.doingA();</span></span><br><span class="line">                <span class="comment">// product.doingB();</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductB();</span><br><span class="line">                <span class="comment">// product.doingC();</span></span><br><span class="line">                <span class="comment">// product.doingA();</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> ProductA();</span><br><span class="line">        <span class="comment">// product.doingA();</span></span><br><span class="line">        <span class="comment">// product.doingB();</span></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> ProductB();</span><br><span class="line">        <span class="comment">// product.doingC();</span></span><br><span class="line">        <span class="comment">// product.doingA();</span></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> AFactory();</span><br><span class="line">        Product product = factory.createProduct();</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><ul>
<li>抽象工厂</li>
<li>具体工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>抽象出抽象工厂、抽象产品；</li>
<li>创建具体产品，具体工厂；</li>
<li>实现具体工厂创建产品；</li>
<li>修改客户端调用方式。</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>解耦，典型的解耦框架。</li>
<li>灵活性增强，扩展时只需添加新的工厂及产品，无需修改现有类。</li>
</ul>
</li>
<li>缺点<ul>
<li>产品过多会导致类很多。</li>
<li>抽象产品只能创建一种产品。（可用抽象工厂模式改善）</li>
</ul>
</li>
</ul>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul>
<li>客户端从要知道创建哪个产品，改为要知道用哪个工厂创建产品，意义何在<br>对象的创建是复杂的过程，客户端只需知道产品是由谁创建的，而不需关系是怎么创建的。</li>
<li>工厂所创建对象的过程到底是不是复杂的<br>我觉得不一定是很复杂的过程，但总归不是new一个对象那么简单。如果只是new，那用简单工厂就可以实现了。而每个工厂创建的过程应该是不尽相同的，由此产生了差异化，从而需要抽象工厂的角色。<br>创建对象所做的初始化工作不只是像赋值那么简单。– 切割、封装。</li>
<li>抽象工厂与抽象产品是同级的概念，其各自可以有多级，每有一级抽象工厂，就可以有一次抽象产品与之对应（也可以用上级抽象产品对应）。</li>
<li>具体工厂可以是一个简单工厂，直接new对象，或者通过类型new不同的对象。</li>
<li>只有一个具体工厂的情况<br>存在多个产品，如果后续还可能扩展，则使用工厂方法，如后续不太可能扩展，则使用简单工厂。<br>只有一个产品，那可以考虑使用其他的模式，或者不使用。</li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>提供一个创建一组相关或相互依赖对象的接口，且无须指定所要产品的具体类，得到同族的不同等级的产品。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>产品等级结构 产品的继承结构。</li>
<li>产品族 指由同一个工厂生产的，位于不同产品等级结构中的一组产品。</li>
</ul>
<h3 id="模式实现-1"><a href="#模式实现-1" class="headerlink" title="模式实现"></a>模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product1</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1A</span> <span class="keyword">extends</span> <span class="title">Product1</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1B</span> <span class="keyword">extends</span> <span class="title">Product1</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product2</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2A</span> <span class="keyword">extends</span> <span class="title">Product2</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2B</span> <span class="keyword">extends</span> <span class="title">Product2</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    Product1 product1;</span><br><span class="line">    Product2 product2;</span><br><span class="line">    Factory factory;</span><br><span class="line">    Product (Factory factory) &#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">constitute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.product1 = factory.createProduct1();</span><br><span class="line">        <span class="keyword">this</span>.product2 = factory.createProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Product1 <span class="title">createProduct1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Product2 <span class="title">createProduct2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product1 <span class="title">createProduct1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product1 product1 = <span class="keyword">new</span> Product1A();</span><br><span class="line">        <span class="comment">// product1.doingA();</span></span><br><span class="line">        <span class="comment">// product1.doingB();</span></span><br><span class="line">        <span class="keyword">return</span> product1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product2 <span class="title">createProduct2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product2 product2 = <span class="keyword">new</span> Product2A();</span><br><span class="line">        <span class="comment">// product2.doingA();</span></span><br><span class="line">        <span class="comment">// product2.doingB();</span></span><br><span class="line">        <span class="keyword">return</span> product2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product1 <span class="title">createProduct1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product1 product1 = <span class="keyword">new</span> Product1B();</span><br><span class="line">        <span class="comment">// product1.doingC();</span></span><br><span class="line">        <span class="comment">// product1.doingA();</span></span><br><span class="line">        <span class="keyword">return</span> product1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product2 <span class="title">createProduct2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product2 product2 = <span class="keyword">new</span> Product2B();</span><br><span class="line">        <span class="comment">// product2.doingC();</span></span><br><span class="line">        <span class="comment">// product2.doingA();</span></span><br><span class="line">        <span class="keyword">return</span> product2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product(<span class="keyword">new</span> AFactory());</span><br><span class="line">        product.constitute();</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">        product = <span class="keyword">new</span> Product(<span class="keyword">new</span> BFactory());</span><br><span class="line">        product.constitute();</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h3><ul>
<li>抽象工厂</li>
<li>具体工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
</ul>
<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><ol>
<li>从产品出抽象出相关或有依赖关系的产品族；</li>
<li>抽象出产品等级结构；</li>
<li>创建抽象工厂及具体工厂；</li>
<li>返回抽象工厂，创建产品族产品并使用。</li>
</ol>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>保证客户端始终只使用同一个产品族中的对象。</li>
</ul>
</li>
<li>缺点<ul>
<li>产品族扩展困难，要增加一个系列的某一产品，既要修改抽象工厂，又要修改具体工厂。</li>
</ul>
</li>
</ul>
<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><ul>
<li>当系统中只存在一个等级结构的产品时，抽象工厂模式退化为工厂方法模式。</li>
<li>一组相关或相互依赖的对象，那么这些对象是怎么使用的呢？怎么才能表现出相关或相互依赖的特性？<br>在Head First中，有一个更大的对象，产品是对象的一部分，客户端实际需要的是一个大产品，而抽象工厂创建的是每个小产品，最后由大产品的容器进行组装返回给客户端。<br>还有其它形式？</li>
<li>当产品之间没有关系时，不符合使用抽象工厂的条件。</li>
<li>当产品之间有关系，而使用了多个工厂方法时，不能保证产品之间的关系是正确的。</li>
</ul>
<h2 id="工厂方法-与-抽象工厂"><a href="#工厂方法-与-抽象工厂" class="headerlink" title="工厂方法 与 抽象工厂"></a>工厂方法 与 抽象工厂</h2><ul>
<li>实现方式 工厂方法使用继承，抽象工厂使用组合。</li>
<li>使用方式 实例化一个工厂方法的工厂，由工厂创建产品对象；实例化一个抽象工厂的工厂，然后将它传入一个针对抽象类型的方法中，由该方法创建产品（使用工厂方法模式）并进行组装。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>Calendar (工厂方法) ？<br>Collection (抽象工厂) ？</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-创建型-建造者（Builder）</title>
    <url>/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。<br>将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。</p>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public set ... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.setA(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        product.setB(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// product.set...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partA</span><span class="params">(String a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partB</span><span class="params">(String b)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Product <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partA</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        product.setA(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partB</span><span class="params">(String b)</span> </span>&#123;</span><br><span class="line">        product.setB(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.partA(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        builder.partB(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>产品</li>
<li>抽象建造者</li>
<li>具体建造者</li>
<li>指挥者</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>隐藏内部实现。</li>
<li>实现可以被替换。</li>
</ul>
</li>
<li>缺点<ul>
<li>需要具备更多的领域知识。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>当一个类的构造函数参数个数超过4个，而且这些参数有些式可选的参数，考虑使用建造者模式。</li>
<li>可以使用不同的具体建造者来改变创建的顺序。</li>
<li>产品里的各个部分可以有不同的实现，由此扩展出多个具体建造者。 –类似于工厂方法模式。</li>
<li>与工厂模式的区别： 建造者注重产品细节、组成过程，工厂模式注重产品整体。</li>
<li>当只有一个产品，及顺序可以暴露给客户端时，即由客户端充当指挥者角色，可以省略抽象建造者，以内部类形式完成建造功能。</li>
<li>链式调用。每一步都返回对当前对象的引用。Lombok的支持。</li>
<li>“池”的使用，属性较多，且属性之间存在依赖和约束关系。</li>
<li>建造者模式的变种：客户端充当指挥者角色，builder链式调用，set返回this等。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>  StringBuilder</li>
<li>Mybatis<br>  SqlSessionFactoryBuilder</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-比较与组合</title>
    <url>/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%AF%94%E8%BE%83%E4%B8%8E%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="工厂方法-VS-抽象工厂"><a href="#工厂方法-VS-抽象工厂" class="headerlink" title="工厂方法 VS 抽象工厂"></a>工厂方法 VS 抽象工厂</h2><ul>
<li>抽象工厂创建的是一系列相关或相互依赖的产品，工厂方法创建的是单个产品。</li>
</ul>
<h2 id="工厂方法-VS-建造者"><a href="#工厂方法-VS-建造者" class="headerlink" title="工厂方法 VS 建造者"></a>工厂方法 VS 建造者</h2><ul>
<li>工厂方法更关注对象整体，建造者更关注创建的细节和顺序。</li>
</ul>
<h2 id="抽象工厂-VS-建造者"><a href="#抽象工厂-VS-建造者" class="headerlink" title="抽象工厂 VS 建造者"></a>抽象工厂 VS 建造者</h2><ul>
<li>都是创建复杂对象，都有整体和部分的概念。</li>
<li>非常类似，差别细微。在反复使用中体会。</li>
</ul>
<h2 id="适配器-VS-装饰器"><a href="#适配器-VS-装饰器" class="headerlink" title="适配器 VS 装饰器"></a>适配器 VS 装饰器</h2><ul>
<li>都是包装对象。</li>
<li>适配器改变接口，而装饰器不改变接口。</li>
<li>装饰器扩展功能，而适配器负责转发。</li>
</ul>
<h2 id="代理-VS-装饰器"><a href="#代理-VS-装饰器" class="headerlink" title="代理 VS 装饰器"></a>代理 VS 装饰器</h2><ul>
<li>装饰器增加对象的行为。</li>
<li>代理控制对象的访问。</li>
</ul>
<h2 id="代理-VS-适配器"><a href="#代理-VS-适配器" class="headerlink" title="代理 VS 适配器"></a>代理 VS 适配器</h2><ul>
<li>适配器会改变适配对象的接口。</li>
<li>代理实现相同的接口。</li>
</ul>
<h2 id="模板方法-VS-策略"><a href="#模板方法-VS-策略" class="headerlink" title="模板方法 VS 策略"></a>模板方法 VS 策略</h2><ul>
<li>策略使用组合，模仿方法使用继承。</li>
<li>策略针对的是整个算法，模仿方法实现的只是算法的一部分。</li>
</ul>
<h2 id="策略-VS-状态"><a href="#策略-VS-状态" class="headerlink" title="策略 VS 状态"></a>策略 VS 状态</h2><ul>
<li>类图一样，意图不同。</li>
<li>状态改变内部的状态，客户端不需要知道具体是哪个。</li>
<li>策略客户端必须指定使用哪种策略。</li>
</ul>
<h2 id="单例-工厂"><a href="#单例-工厂" class="headerlink" title="单例 + 工厂"></a>单例 + 工厂</h2><ul>
<li>使用单例来创建工厂，由工厂创建产品。</li>
</ul>
<h2 id="装饰器-工厂"><a href="#装饰器-工厂" class="headerlink" title="装饰器 + 工厂"></a>装饰器 + 工厂</h2><h2 id="装饰器-建造者"><a href="#装饰器-建造者" class="headerlink" title="装饰器 + 建造者"></a>装饰器 + 建造者</h2><h2 id="工厂-策略"><a href="#工厂-策略" class="headerlink" title="工厂 + 策略"></a>工厂 + 策略</h2>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-结构型-享元（Flyweight）</title>
    <url>/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BA%AB%E5%85%83/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>运用共享技术有效地支持大量细粒度对象的复用。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象享元</li>
<li>具体享元</li>
<li>非共享具体享元</li>
<li>享元工厂</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>减少运行时创建对象的数量，节省内存。</li>
<li>将对象的状态集中管理。</li>
</ul>
</li>
<li>缺点<ul>
<li>单个的逻辑实例无法拥有独立而不同的行为。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>单纯享元模式。 所有的享元对象都是可以共享的。不存在非共享享元类。</li>
<li>复合享元模式。 将一些单纯享元使用组合模式加以组合，可以形成复合享元模式。</li>
<li>享元中常出现工厂，用来维护存放内部状态的对象。</li>
<li>享元是一个用来提高程序效率和性能的模式。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-结构型-代理（Proxy）</title>
    <url>/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>为另一个对象提供一个替身或占位符以控制对这个对象的访问。<br>被代理的对象可以是远程的对象（远程代理）、创建开销大的对象（虚拟代理）或需要安全控制的对象。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// handling...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject target;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// proxy handling...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象主题</li>
<li>真实主题</li>
<li>代理主题</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>对于开销很大的对象，只有在使用时才创建。</li>
<li>使用Proxy进行授权访问。</li>
<li>使用Proxy进行copy-on-write操作。</li>
<li>代理模式变体<ul>
<li>远程代理</li>
<li>虚拟代理</li>
<li>保护代理</li>
<li>缓存代理</li>
<li>同步代理</li>
<li>智能引用代理</li>
<li>防火墙代理</li>
<li>CopyOnWrite代理</li>
</ul>
</li>
<li>代理与装饰器<br>  装饰器为对象增加行为，而代理是控制对象的访问。</li>
<li>代理与适配器<br>  适配器会改变适配对象的接口，而代理则实现相同的接口。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-结构型-外观（Facade）</title>
    <url>/2021/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E5%A4%96%E8%A7%82/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SubSystemA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SubSystemB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SubSystemC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystemA subSystemA;</span><br><span class="line">    <span class="keyword">private</span> SubSystemB subSystemB;</span><br><span class="line">    <span class="keyword">private</span> SubSystemC subSystemC;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">(SubSystemA subSystemA, SubSystemB subSystemB, SubSystemC subSystemC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subSystemA = subSystemA;</span><br><span class="line">        <span class="keyword">this</span>.subSystemB = subSystemB;</span><br><span class="line">        <span class="keyword">this</span>.subSystemC = subSystemC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subSystemA.actionA();</span><br><span class="line">        subSystemB.actionA();</span><br><span class="line">        subSystemB.actionB();</span><br><span class="line">        subSystemC.actionC();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>外观</li>
<li>子系统</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>LoD的典型应用。</li>
<li>降低子系统与客户端的耦合度。</li>
<li>减少了客户处理的对象数目。</li>
<li>降低了大型软件系统中的编译依赖性。</li>
</ul>
</li>
<li>缺点<ul>
<li>不符合开闭原则。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>数据库JDBC的封装。</li>
<li>没有封装子系统，只提供简化接口。客户端依然能访问系统完整的功能。</li>
<li>可以为子系统创建多个外观。</li>
<li>可以将子系统与客户端解耦。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
<li>Slf4j</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-结构型-桥接（Bridge）</title>
    <url>/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将抽象和行为划分开来，各自独立，但能动态的结合。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象类</li>
<li>扩充抽象类</li>
<li>行为类接口</li>
<li>具体行为类</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>抽象和行为分离。</li>
</ul>
</li>
<li>缺点<ul>
<li>增加系统的理解与设计难度。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>存在两个变化维度，抽象部分与行为部分。<br>  当只有要给变化维度时，抽象部分不变，行为部分实现抽象。<br>  当有两个维度变化时，将行为部分再抽象出一个接口，原抽象部分依赖新抽象的行为部分的接口。</li>
<li>抽象类依赖行为类。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-结构型-组合（Composite）</title>
    <url>/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用于把一组相似的对象当作一个单一的对象。<br>依据属性结构来组合对象，用来表示部分以及整体层次。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象构件</li>
<li>树叶构件</li>
<li>树枝构件</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>一致地处理单个对象和组合对象，简化客户端代码。</li>
</ul>
</li>
<li>缺点<ul>
<li>设计较复杂。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>规定：需要在接口内部定义一个用于访问和管理组合体的对象们。</li>
<li>用树型方式创建对象的结构，树里面包含了组合以及个别的对象。</li>
<li>能把相同的操作应用在组合和个别对象上。即忽略组合对象和个别对象之间的差别。</li>
<li>组合使用到迭代器模式。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-结构型-装饰器（Decorator）</title>
    <url>/2021/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorate</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorate</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Component <span class="title">getComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorateA</span> <span class="keyword">extends</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorate</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do ...</span></span><br><span class="line">        getComponent().action();</span><br><span class="line">        <span class="comment">// do ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorateB</span> <span class="keyword">extends</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorate</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(component);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do ...</span></span><br><span class="line">    <span class="keyword">super</span>.action();</span><br><span class="line">    <span class="comment">// do ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象构件</li>
<li>具体构件</li>
<li>抽象装饰者 继承自抽象构件。</li>
<li>具体装饰者</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>不修改现有类的情况下，扩展现有类功能。比继承更加灵活。</li>
<li>完全遵循开闭原则。</li>
<li>通过使用不同的具体装饰器类，及其不同的排列组合，可以产生出大量不同的组合。</li>
</ul>
</li>
<li>缺点<ul>
<li>装饰器比继承更加复杂。</li>
<li>会增加许多子类，过度使用增加程序复杂性。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>利用继承达到类型匹配，而不是利用继承获得行为。</li>
<li>可以扩展：不只是增强功能，而且可以感知其它装饰器的存在。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<ul>
<li>FilterInputStream</li>
<li>FilterOutputStream</li>
</ul>
</li>
<li>Mybatis<ul>
<li>CachingExecutor</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-结构型-适配器（Adapter）</title>
    <url>/2021/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.action();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>目标 客户端所期望的接口。</li>
<li>适配者 </li>
<li>适配器 </li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>复用了现存的类。</li>
<li>将目标类与适配者解耦。</li>
<li>符合开闭原则。</li>
</ul>
</li>
<li>缺点<ul>
<li>增加系统复杂性。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>没有各自类的源代码，或者不愿意为了一个应用而修改各自的接口。</li>
<li>实现一个适配器所需要进行的工作，与目标接口的大小成正比。</li>
<li>按照定义，此处的接口并不是Java中的interface，而是具体的实现类。其接口的功能已经实现。如果未实现，此处只需要实现即可，不需要适配。</li>
<li>对象适配器：使用组合实现。类适配器：使用多重继承（Java中不支持）。<br>类适配器的意义在于，使用多重继承，就可以不用在适配器中定义不需要重写的方法，而这是对象适配器必须进行的工作。<br>如果使用内部类实现多重继承，内部类应继承Target，外围类继承Adaptee，而这时，仍需要在内部类中定义Adaptee中的所有方法，调用其外部类的父类的实现。而这样做的话，和对象适配器就没有什么差别乐。</li>
<li>双向适配器。实现两个接口（Java中的interface），将Target和Adaptee都作为成员变量，并实现所有方法。</li>
<li>适配器不是在设计时添加的，而是解决问题的一种方式。</li>
<li>适配器类（对接口的方法做空实现）：简化的适配器，适配者和适配器都扩展自目标接口，所以合二为一。且有将目标转换位适配器接口的行为。 – 默认适配器。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<ul>
<li>InputStreamReader</li>
<li>OutputStreamWriter</li>
</ul>
</li>
<li>Spring<ul>
<li>SpringValidatorAdapter</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-行为型-中介者（Mediator）</title>
    <url>/2022/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E4%B8%AD%E4%BB%8B%E8%80%85/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立的改变它们之间的交互。<br>是迪米特法则的典型应用。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象中介者</li>
<li>具体中介者</li>
<li>抽象同事类</li>
<li>具体同事类</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>使多对多的关系变成了一对多的关系。</li>
<li>降低系统复杂性。</li>
<li>提高可修改扩展性。</li>
</ul>
</li>
<li>缺点<ul>
<li>同事类过多会使中介者庞大，难以维护。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>在事件驱动类应用中比较多。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-行为型-命令（Command）</title>
    <url>/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象命令</li>
<li>具体命令</li>
<li>实现者</li>
<li>请求者</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>降低系统耦合度。</li>
<li>扩展性良好。</li>
<li>配合组合模式，实现宏命令。</li>
<li>配合备忘录模式，实现命令恢复与撤销。</li>
</ul>
</li>
<li>缺点<ul>
<li>可能产生大量命令类。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>是对行为进行封装的典型模式。</li>
<li>方法的请求者与方法的实现者之间经常存在紧密的耦合关系，不利于软件功能的维护与扩展。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<ul>
<li>Swing中的菜单命令。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-行为型-备忘录（Memento）</title>
    <url>/2022/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后需要时能将该对象恢复到原先保存的状态。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>发起人</li>
<li>备忘录</li>
<li>管理者</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>提供了一种恢复状态的机制。</li>
<li>实现了内部状态的封装。</li>
</ul>
</li>
<li>缺点<ul>
<li>资源消耗大。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>在Jsp + JavaBean中的应用： 表单校验的时候提示警告，同时显示已经输入的表项。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-行为型-模板方法（Template）</title>
    <url>/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMethod1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMethod2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteMethod1 concreteMethod1 = <span class="keyword">new</span> ConcreteMethod1();</span><br><span class="line">        concreteMethod1.step1();</span><br><span class="line">        concreteMethod1.step2();</span><br><span class="line">        concreteMethod1.step3();</span><br><span class="line">        ConcreteMethod2 concreteMethod2 = <span class="keyword">new</span> ConcreteMethod2();</span><br><span class="line">        concreteMethod2.step1();</span><br><span class="line">        concreteMethod2.step2();</span><br><span class="line">        concreteMethod2.step3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">        step3();</span><br><span class="line">        hook();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">step1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hook</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 钩子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMethod1</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMethod2</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Template template = <span class="keyword">new</span> ConcreteMethod1();</span><br><span class="line">        template.templateMethod();</span><br><span class="line">        template = <span class="keyword">new</span> ConcreteMethod2();</span><br><span class="line">        template.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象模板 包括模板方法与基本方法，基本方法有抽象方法、具体方法、钩子方法。</li>
<li>具体实现</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>抽象算法骨架；</li>
<li>提取公关部分；</li>
<li>实现具体方法。</li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>封装了不变部分，扩展了可变部分。</li>
<li>父类提取了公共的部分代码，便于代码复用。</li>
</ul>
</li>
<li>缺点<ul>
<li>子类执行的结果会影响父类的结果，导致一种反向控制结构，提高了代码阅读的难度。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>将变化的事物与保持不变的事物分离开。</li>
<li>钩子： 一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。</li>
<li>钩子功能：<ol>
<li>算法中可选的部分；</li>
<li>让子类由能力为抽象类做一些决定。</li>
</ol>
</li>
<li>将模板方法设置为final，避免子类修改顺序，将公共方法设置为final，避免子类重写。</li>
<li>策略实现的是整个算法，而模板方法实现的只是算法的一部分。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>Arrays.sort(…) (未使用继承，被实现为static方法，运行时和Comparable组合。)<br>InputStream.read(…)</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-行为型-状态（State）</title>
    <url>/2022/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>环境</li>
<li>抽象状态</li>
<li>具体状态</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>封装了转换规则。</li>
<li>枚举可能的状态，需要事先确定状态种类。</li>
</ul>
</li>
<li>缺点<ul>
<li>会增加系统类和对象的个数。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>一般的状态判断 –》 开关切换状态（不一定需要状态） –》 双向开关切换状态/任意切换 （需要状态）</li>
<li>状态机，由状态寄存器和组合逻辑电路构成，能够根据控制信号按照预先设定的状态进行状态转移。</li>
<li>状态机就是状态转移图。</li>
<li>状态机要素：现态、条件、动作、次态。</li>
<li>状态模式可以允许客户端改变状态的转换行为，而状态机是能够自动改变状态，状态机是一个比较独立且复杂的机制。</li>
<li>与策略模式类图一样，意图不同。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-行为型-策略（Strategy）</title>
    <url>/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>指对象有某个行为，但是在不同的场景中，该行为有不同的算法实现。</p>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (ca) &#123;</span><br><span class="line">            result = computeA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            result = computeB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = computeC();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeA</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeB</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的条件，调用不同的方法。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (ca) &#123;</span><br><span class="line">            result = computeA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            result = computeB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = computeC();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeA</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeB</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">        <span class="keyword">int</span> result = strategy.compute();</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context c = <span class="keyword">new</span> Context(<span class="keyword">new</span> StrategyA());</span><br><span class="line">        <span class="comment">// 根据条件设置具体的策略</span></span><br><span class="line">        <span class="keyword">if</span> (ca) &#123;</span><br><span class="line">            c.setStrategy(<span class="keyword">new</span> StrategyA());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            c.setStrategy(<span class="keyword">new</span> StrategyB());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.setStrategy(<span class="keyword">new</span> StrategyC());</span><br><span class="line">        &#125;</span><br><span class="line">        c.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象出统一接口，根据不同的条件使用对应的对象，调用接口的方法。<br>if可以使用switch代替，也可以将由工厂模式完成，实现工厂+策略的组合使用。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>策略接口</li>
<li>策略具体实现类</li>
<li>容器类/上下文</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>将调用的不同方法抽象出策略接口</li>
<li>将不同方法调整为具体策略实现类</li>
<li>将策略接口注入到之前的上下文对象中</li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>算法、行为可以动态改变。</li>
<li>扩展性良好，只需新增策略类。</li>
<li>可以避免if判断。</li>
</ul>
</li>
<li>缺点<ul>
<li>需要暴露所有策略类。</li>
<li>每个策略都会产生一个新类，造成类过多。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>算法封装成单独的类。</li>
<li>概念中的算法与行为，行为对应的是接口的方法，而接口的方法是不变的，即行为是不变的，变的只是行为的实现，即算法。</li>
<li>容器类存在的意义<ol>
<li>客户端与策略类解耦，改变、新增策略只需修改客户端代码。</li>
<li>根据定义，对象有某个行为，该对象应为上下文对象，而不是客户端对象，客户端只是调用上下文对象的方法，而不关心具体实现。</li>
</ol>
</li>
<li>客户端根据条件设置对应的策略，所以客户端需要知道所有的策略实现。</li>
<li>容器类与策略接口的关系应根据情况确定（持有（能否修改），参数传递）。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>Comparator - Collections<br>RejectedExecutionHandler - ThreadPoolExecutor</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-行为型-观察者（Observer）</title>
    <url>/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>定义了对象之间的一对多依赖，当一个对象改变状态时，所有依赖于它的对象都会收到通知并自动更新。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象主题</li>
<li>具体主题</li>
<li>抽象观察者</li>
<li>具体观察者</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>抽象耦合，降低了耦合关系。复合依赖倒置原则。</li>
<li>建立了一套触发机制。</li>
</ul>
</li>
<li>缺点<ul>
<li>当观察者很多时，通知的发布会花费很多时间，影响程序效率。</li>
<li>可能会导致循环依赖。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>拉模式： 只通知变化而没有具体细节。</li>
<li>推模式： 会通知具体细节。</li>
<li>推模式、拉模式 可以同时实现，以参数作为区别。</li>
<li>Observable是一个类，而不是接口。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<ul>
<li>Observer、Observable。</li>
<li>Swing中的Listener。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-行为型-解释器（Interpreter）</title>
    <url>/2022/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象表达式</li>
<li>非终结表达式</li>
<li>终结表达式</li>
<li>上下文环境</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>可扩展性较好。</li>
<li>增加了新的解释表达式的方式。</li>
</ul>
</li>
<li>缺点<ul>
<li>应用场景比较少。</li>
<li>对于复杂的文法比较难维护。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>文法，语言的语法规则。</li>
<li>解释器在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。</li>
<li>对表达式的解释，在Java中可以用Expression4J或Jep来设计。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-行为型-访问者（Visitor）</title>
    <url>/2022/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将数据结构与数据操作分离。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象访问者</li>
<li>具体访问者</li>
<li>抽象元素</li>
<li>具体元素</li>
<li>对象结构</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>良好的扩展性。</li>
<li>灵活性。</li>
</ul>
</li>
<li>缺点<ul>
<li>增加新的元素类困难。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>一般实现： instanceof。</li>
<li>在Java中，实际上是分离了Collection结构中的元素和对这些元素进行操作的行为。</li>
<li>前提是结构中的对象类型很少改变。</li>
<li>结合反射机制，使用范围更广。</li>
<li>降低稳定的数据结构和易变的操作之间的耦合。</li>
<li>遍历对象结构时，元素调用方法，传入访问者，在通过访问者调用元素，与直接用访问者对元素进行操作有什么区别？ – 元素可能包含本身业务逻辑的相关操作。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-行为型-责任链（Chain of Responsibility）</title>
    <url>/2022/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%B4%A3%E4%BB%BB%E9%93%BE/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><p>增加多个方法。传递调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>扩展性不足，有了新的请求需要修改接口及每个实现。<br>顺序固定。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象处理者</li>
<li>具体处理者</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>将请求发送者和接收者解耦。</li>
<li>简化对象。</li>
<li>增强灵活性，允许动态增加或删除责任。</li>
</ul>
</li>
<li>缺点<ul>
<li>并不保证请求一定会被执行。</li>
<li>不容易观察运行时的特征，有碍于排错。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>纯的责任链： 要么处理，要么交由下家处理，而不能处理了一部分在交由下家处理。</li>
<li>不纯的责任链： 请求可以最终不被任何对象处理。</li>
<li>责任链与观察者<br>责任链一定要有一个统一的接口。</li>
<li>责任链与命令<br>命令需要事先协商客户端和服务端的调用关系。</li>
<li>责任链中每一个处理者拥有对下一个处理者的引用（如果在抽象处理者中保存，和模板方法模式的组合使用）。如果使用列表保存所有的处理者，然后调用，跟责任链是什么关系？？？<br>责任链可以中断对请求的处理，而列表方式需要通过异常方式进行中断。<br>列表方式更像是访问者模式。</li>
<li>链，及链表的结构。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/12/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计面向对象的软件比较困难，而设计可复用的面向对象软件就更加困难。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式对是经验的总结，是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>可复用面向对象软件的基础。<br>代表了最佳的实战。</p>
<h2 id="提出及GOF"><a href="#提出及GOF" class="headerlink" title="提出及GOF"></a>提出及GOF</h2><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides<br>四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented<br>Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。<br>四位作者合称 GOF（四人帮，全拼 Gang of Four）。</p>
<h2 id="设计模式目的"><a href="#设计模式目的" class="headerlink" title="设计模式目的"></a>设计模式目的</h2><p>为了代码可重用性<br>让代码更容易被他人理解<br>保证代码可靠性</p>
<h2 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h2><h3 id="依赖（Dependency）-use-a"><a href="#依赖（Dependency）-use-a" class="headerlink" title="依赖（Dependency） use a"></a>依赖（Dependency） use a</h3><p>表示一个类依赖于另一个类。具体形式为局部变量，静态方法调用，方法参数。<br>类图：虚线 + 普通箭头，从主类指向被依赖类。(- - -&gt;)</p>
<h3 id="关联（Association）-has-a"><a href="#关联（Association）-has-a" class="headerlink" title="关联（Association） has a"></a>关联（Association） has a</h3><p>表现为全局变量。可以是单向，也可以是双向。<br>类图：实线 + 普通箭头，从主类指向被关联类。(—–&gt;)</p>
<h3 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h3><p>强的关联关联。强调一个是整体，一个是部分，但不是组成部分。<br>类图：空心菱形 + 实线 + 普通箭头，从主类指向被关联类。(&lt; &gt;—–&gt;)</p>
<h3 id="组合（Composition）-contain-a"><a href="#组合（Composition）-contain-a" class="headerlink" title="组合（Composition） contain a"></a>组合（Composition） contain a</h3><p>比聚合关系强的关系。强调部分是整体的组成部分，部分和整体拥有一致的生命周期。<br>类图：实心菱形 + 实线 + 普通箭头，从主类指向被关联类。(&lt;·&gt;—–&gt;)</p>
<h3 id="泛化（Generalization）-is-a"><a href="#泛化（Generalization）-is-a" class="headerlink" title="泛化（Generalization） is a"></a>泛化（Generalization） is a</h3><p>表现为继承关系。具体形式为类与类之间的继承管理，接口与接口之间的继承关系。<br>类图：实线 + 三角空心箭头，从子类指向父类。(—–》)</p>
<h3 id="实现-（Realization）-a-kind-of"><a href="#实现-（Realization）-a-kind-of" class="headerlink" title="实现 （Realization） a kind of"></a>实现 （Realization） a kind of</h3><p>表现为实现关系。具体形式为类对接口的实现关系。<br>类图：虚线 + 三角空心箭头，从实现类指向接口。（- - -》）</p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 OCP"></a>开闭原则 OCP</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Open-Close Principle。<br>软件实体应当对扩展开放，对修改关闭。（Software entites should be open for extension, but closed for modification）</p>
</blockquote>
<p>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>对软件测试的影响。</li>
<li>可以提高代码的可复用性。</li>
<li>可以提高软件的可维护性。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p>
<h3 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则 LSP"></a>里氏替换原则 LSP</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Liskov(提出者) Substitution Principle。<br>继承必须确保超类所拥有的性质在子类中仍然成立。（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）</p>
</blockquote>
<p>是继承复用的基础，它反映了基类与子类之间的关系。是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li>里氏替换原则是实现开闭原则的重要方式之一。</li>
<li>克服了继承中重写父类造成的可复用性变差的缺点。</li>
<li>是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li>
<li>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松。</li>
<li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等。</li>
</ul>
<h3 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 DIP"></a>依赖倒置原则 DIP</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Dependence Inversion Principle。<br>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）</p>
</blockquote>
<p>是实现开闭原则的重要途径之一。</p>
<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ul>
<li>依赖倒置原则可以降低类间的耦合性。</li>
<li>依赖倒置原则可以提高系统的稳定性。</li>
<li>依赖倒置原则可以减少并行开发引起的风险。</li>
<li>依赖倒置原则可以提高代码的可读性和可维护性。</li>
</ul>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>通过面向接口编程来降低类间的耦合性。</p>
<ul>
<li>每个类尽量提供接口或抽象类，或者两者都具备。</li>
<li>变量的声明类型尽量是接口或者是抽象类。</li>
<li>任何类都不应该从具体类派生。</li>
<li>使用继承时尽量遵循里氏替换原则。</li>
</ul>
<h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 SRP"></a>单一职责原则 SRP</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Single Responsibility Principle。<br>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。（There should never be more than one reason for a class to change）</p>
</blockquote>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li>
<li>提高类的可读性。复杂性降低，自然其可读性会提高。</li>
<li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li>
<li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p>
<h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 ISP"></a>接口隔离原则 ISP</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Interface Segregation Principle。<br>客户端不应该被迫依赖于它不使用的方法。（Clients should not be forced to depend on methods they do not use）<br>一个类对另一个类的依赖应该建立在最小的接口上。（The dependency of one class to another one should depend on the smallest possible interface）</p>
</blockquote>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li>
<li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li>
<li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li>
<li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li>
<li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li>
</ul>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><ul>
<li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li>
<li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li>
<li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
</ul>
<h3 id="迪米特法则-最小知道原则-LoD"><a href="#迪米特法则-最小知道原则-LoD" class="headerlink" title="迪米特法则/最小知道原则 LoD"></a>迪米特法则/最小知道原则 LoD</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Law of Demeter。<br>只与你的直接朋友交谈，不跟“陌生人”说话。（Talk only to your immediate friends and not to strangers）</p>
</blockquote>
<p>从依赖者的角度来说，只依赖应该依赖的对象。<br>从被依赖者的角度说，只暴露应该暴露的方法。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低了类之间的耦合度，提高了模块的相对独立性。</li>
<li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li>
</ul>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><ul>
<li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li>
<li>在类的结构设计上，尽量降低类成员的访问权限。</li>
<li>在类的设计上，优先考虑将一个类设置成不变类。</li>
<li>在对其他类的引用上，将引用其他对象的次数降到最低。</li>
<li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li>
<li>谨慎使用序列化（Serializable）功能。</li>
</ul>
<h3 id="合成复用原则-CRP"><a href="#合成复用原则-CRP" class="headerlink" title="合成复用原则 CRP"></a>合成复用原则 CRP</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Composite Reuse Principle。<br>在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
</blockquote>
<p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>
<li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>
</ul>
<h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>创建型 在创建对象的同时隐藏创建逻辑的方式。<ul>
<li>工厂方法 解耦。</li>
<li>抽象工厂 创建一系列产品。</li>
<li>单例 对象只有一个实例。</li>
<li>建造者 复杂对象。</li>
<li>原型 基于现有对象创建对象。</li>
</ul>
</li>
<li>结构型 关注类和对象的组合。<ul>
<li>代理 控制对象的访问。</li>
<li>适配器 将一个接口转换为另一个接口。</li>
<li>装饰器 增强功能。</li>
<li>外观 提供统一的接口。</li>
<li>享元 共享相同的对象。</li>
<li>组合 树型结构，一致对待单个对象和组合对象。</li>
<li>桥接 多个维度的变化。</li>
</ul>
</li>
<li>行为型 关注对象之间的通信。<ul>
<li>观察者 一个对象改变时，依赖于它的对象收到通知。</li>
<li>策略 算法可以切换。</li>
<li>模板方法 定义一个算法骨架，将部分实现延迟到子类。</li>
<li>迭代器 一种遍历集合中所有元素的方法。</li>
<li>责任链 链式传递请求，直到有对象进行处理。</li>
<li>命令 将请求和执行分隔开。</li>
<li>状态 状态机。</li>
<li>访问者 将数据结构和数据操作分离。</li>
<li>解释器 解释语言的文法。</li>
<li>备忘录 记录对象的状态。</li>
<li>中介者 添加中介者调用，降低两个类的耦合度。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-行为型-迭代器（Iterator）</title>
    <url>/2022/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象聚合</li>
<li>具体聚合</li>
<li>抽象迭代器</li>
<li>具体迭代器</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<ul>
<li>访问一个聚合对象的内容而无需暴露它的内部表示。</li>
<li>遍历任务交由迭代器完成，简化了聚合类。</li>
<li>支持以不同方式遍历一个聚合。</li>
<li>扩展性良好。增加新的聚合类和迭代器都无须修改原有代码。</li>
<li>封装性良好。为遍历不同的聚合提供一个统一的接口。</li>
</ul>
</li>
<li>缺点<ul>
<li>增加了类的个数，一定程度上增加了复杂性。</li>
</ul>
</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>已经被整合入Java的Collection。在大多数场合下无需自己制造一个Iterator，只要将对象装入Collection中，直接使用Iterator进行对象遍历。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<ul>
<li>Iterator接口。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>log</title>
    <url>/2021/09/03/%E9%A1%B9%E7%9B%AE/log/</url>
    <content><![CDATA[<ol>
<li><p>log path的配置，一般只输出指定路径的日志，那mybatis的日志和启动时打印的日志为什么不在此列</p>
</li>
<li><p>判断当前日志是否可用？？？</p>
</li>
<li><p>日志Facade<br> jcl commons-logging (已停止更新)</p>
<pre><code> 默认使用log4j的实现，找不到则使用jul的实现。
</code></pre>
<p> slf4j (simple log facade for java)</p>
</li>
<li><p>日志实现<br> jul (java.util.logging jdk1.4 开始提供)<br> log4j<br> logback</p>
<pre><code> logback-core
 logback-classic
 logback-access
</code></pre>
<p> log4j2</p>
<pre><code> log4j-api
 log4j-core
</code></pre>
</li>
<li><p>集成使用<br> 部分集成使用需要添加额外适配包</p>
<ol>
<li>jcl+log4j2<br> log4j-jcl</li>
<li>jcl+logback<br> jcl-over-slf4j</li>
<li>slf4j+jul<br> slf4j-jdk14</li>
<li>slf4j+log4j<br> slf4j-log4j12</li>
<li>slf4j+log4j2<br> log4j-slf4j-impl</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>课程</title>
    <url>/2021/11/05/%E9%A1%B9%E7%9B%AE/%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1上"><a href="#1上" class="headerlink" title="1上"></a>1上</h2><ul>
<li>计算机科学与技术导论</li>
<li>高数Ⅰ</li>
<li>程序设计（C）</li>
</ul>
<h2 id="1下"><a href="#1下" class="headerlink" title="1下"></a>1下</h2><ul>
<li>高数Ⅱ</li>
<li>线性代数</li>
<li>面向对象程序设计（C++）</li>
</ul>
<h2 id="2上"><a href="#2上" class="headerlink" title="2上"></a>2上</h2><ul>
<li>概率统计</li>
<li>离散数学</li>
<li>电子技术基础</li>
<li>数据结构（C）</li>
<li>Java程序设计</li>
<li>汇编语言程序设计</li>
</ul>
<h2 id="2下"><a href="#2下" class="headerlink" title="2下"></a>2下</h2><ul>
<li>统一建模语言（UML）</li>
<li>数据库系统</li>
<li>C#程序设计</li>
<li>计算机网络</li>
<li>数字图像处理（Matlab）</li>
<li>算法设计与分析</li>
<li>智能信息处理（Fortran？）</li>
</ul>
<h2 id="3上"><a href="#3上" class="headerlink" title="3上"></a>3上</h2><ul>
<li>J2EE架构与开发</li>
<li>Unix系统原理与应用</li>
<li>Web技术与应用</li>
<li>操作系统</li>
<li>计算机组成原理</li>
<li>软件工程</li>
<li>信息安全概论</li>
</ul>
<h2 id="3下"><a href="#3下" class="headerlink" title="3下"></a>3下</h2><ul>
<li>编译原理</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2022/02/22/%E9%A1%B9%E7%9B%AE/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ul>
<li>面向对象特性</li>
<li>JDK8新特性（接口默认方法、函数式接口、时间日期类、Optional、lambda、方法引用、重复注释、Stream）</li>
<li>Stream操作（map、peek、filter、reduce、flatMap、collect、Collector.joining）</li>
<li>线程池参数（核心线程数、最大线程数、超时时间、时间单位、阻塞队列、线程工厂、拒绝策略）</li>
<li>自带线程池（newFixedThreadPool(n, n, 0, LinkedBlockingQueue), newCachedThreadPool(0, MAX, 60, SynchronousQueue), newSingleThreadPool(1, 1, 0, LinkedBlockingQueue), newScheduledThreadPool()）</li>
<li>线程池队列类型（LinkedBlockingQueue、ArrayBlockingQueue、SynchronousQueue）</li>
<li>线程池默认核心线程数（计算密集型、IO密集型）</li>
<li>线程池执行流程（核心线程数 -&gt; 队列 -&gt; 最大线程池 -&gt; 启动线程 -&gt; 超时时间 -&gt; 允许核心线程过期）</li>
<li>线程间通信（join，Object类wait、notify、notifyAll，Condition类await、signal、signalAll，阻塞队列、CountDownLatch、CyclicBarrier、Callable）</li>
<li>ConcurrentHashMap，线程安全实现方式（分段锁、synchronized+CAS）</li>
<li>锁（乐观，悲观、阻塞，自旋，适应性自旋、公平锁，非公平锁、）</li>
<li>JUC</li>
<li>AQS（定义了一套多线程访问共享资源的同步器框架）</li>
<li>集合</li>
<li>IO/NIO、多路复用（同步阻塞、同步非阻塞/轮询、同步多路复用/异步阻塞、异步非阻塞）</li>
<li>ClassLoader与Claas.forName（Class.forName默认会执行静态初始化，有参数配置）</li>
<li>列表中删除元素（iterator、保存删除）</li>
</ul>
<h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><ul>
<li>HTTP1/HTTP1.1（缓存处理、带宽优化、错误通知（新增24个错误状态响应码）、Host头处理、长连接（一个连接串行发送多个请求，VS多路复用））</li>
<li>HTTP1.1/HTTP2（性能，二进制、多路复用、报头压缩、服务段推送）</li>
<li>WebSocket（基于TCP的全双工通信协议、取代轮询（HTTP只能由客户端发起）、数据格式轻量、通信高效、握手阶段采用HTTP）</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>sql连接查询</li>
<li>SELECT语法顺序（select、distinct、from、join、on、where、group by、having、order by、limit）</li>
<li>SELECT执行顺序（from、on、join、where、group by、having、select、distinct、order by、limit）</li>
<li>sql优化（利用索引，避免全表扫描（in、or、null、where 1=1、前置模糊查询）、减少无效数据的查询（select *、小表在前大表在后、别名）、批量DML、建表（索引、varchar、数字型字段））</li>
<li>数据库优化（分表分库分区）</li>
<li>sql分页方式（limit、limit+offset）</li>
<li>索引及实现方式、类型</li>
<li>如何验证使用了索引（EXPLAIN）</li>
<li>索引失效</li>
<li>事务特性及实现方式</li>
<li>InnoDb（事务、外键、行锁、聚簇索引、性能、自动崩溃恢复）</li>
<li>聚合函数</li>
<li>隔离级别及解决问题（read uncommitted、 read committed【oracle默认】、 repeated read【mysql默认】、 serializable）</li>
<li>传播特性（REQUIRED、NEVER、MANDATORY、SUPPORTS、NOT_SUPPORTED、REQUIRED_NEW、NESTED）</li>
<li>视图（虚拟表）</li>
<li>存储过程（预定义的sql语句，只编译一次）</li>
<li>触发器（触发执行存储过程，insert、update、delete）</li>
<li>EXPLAIN</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>死锁及预防（请求和保持（申请全部资源）、不可抢占（释放已拥有资源）、互斥、循环等待（请求按顺序进行））</li>
<li>线程、进程</li>
</ul>
<h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><ul>
<li>SpringBean生命周期（实例化、属性赋值、Aware相关接口、BeanPostProcessor前置处理、init-method、BeanPostProcessor后置处理、使用、destroy-method）</li>
<li>Spring MVC执行流程（DispatcherServlet.doService、HandlerMapping、HandlerExecutorChain、HandlerAdapter、Controller、ViewResolver）</li>
<li>Spring常用注解</li>
<li>SpringBoot常用注解（@SpringBootApplication、@EnableAutoConfiguration、@ImportAutoConfiguration、@AutoConfiguration…、@Conditional…）</li>
<li>SpringBoot优缺点</li>
<li>SpringBoot Starter</li>
<li>SpringBoot自动配置原理（spring-configuration-metadata.json、@Import、AutoConfigurationImportSelector、spring.factory）</li>
<li>SpringBean作用域（singleton、prototype、request、session、application）</li>
<li>Spring事务，原理，失效情况（调用非public方法、自身调用、捕捉异常没有抛出、捕获异常抛出受检异常）</li>
<li>Spring代理模式（Spring5默认使用JDK动态代理，没有接口时使用Cglib动态代理、SpringBoot2默认使用Cglib动态代理）</li>
<li>SpringAOP（切面、连接点、切点、通知、织入）</li>
<li>SpringIOC（容器，负责控制对象的生命周期及对象间的关系）</li>
<li>@Resource与@Autowired（@Resource，JavaEE注解，Spring提供了支持，默认按名称装配，@Autowired，Spring注解，先按类型，后按成员名称装配，配合@Qualifier按类型+名称）</li>
<li>@Autowire注入方式（构造器、成员、set方法，注入的时机不同。bean是单例且不会改变，使用构造器注入+final）</li>
<li>定时器（@Scheduled，cron、fixedDelay、fixedRated）</li>
<li>Runner（ApplicationRunner、CommandLineRunner）</li>
</ul>
<h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><ul>
<li>一对一、一对多、多对多（associate、collection）</li>
<li>#{}与${}（#{}是预编译处理，${}是属性替换，#{}可以预防sql注入）</li>
<li>标签及原理</li>
<li>分页插件（Mybatis通过RowBounds对象进行逻辑分页，通过插件实现物理分页）</li>
<li>缓存（一级缓存是session级缓存，默认开启，二级缓存通过xml文件cache标签开启）</li>
<li>namespace</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul>
<li>JVM创建普通Java对象过程（栈空间分配、类加载检查，没有加载则先执行类加载、内存分配（指针碰撞、空闲列表）、初始化、对象头设置、构造器、访问定位（句柄、直接指针））</li>
<li>GC</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><ul>
<li>webservices（WSDL）</li>
<li>redis数据类型（string、list、hash、set、zSet）</li>
<li>redis功能（缓存、消息队列、发布创建、分布式锁）</li>
<li>mq</li>
<li>dubbo</li>
<li>zookeeper</li>
</ul>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ul>
<li>Spring Cloud</li>
<li>Eureka服务注册发现（@EnableEurekaServer、@EnableEurekaClient、@EnableDiscoveryClient、配置）</li>
<li>微服务VS单体服务</li>
<li>SpringCloud停止维护</li>
</ul>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ul>
<li>红黑树特性（结点是红色或黑色、根结点是黑色、叶子结点是黑色、每个红色结点的两个子节点是黑色、从任一结点到叶子结点路径中黑色结点个数相同）</li>
<li>B树与B+树（非叶子结点只存储键值信息、所有叶子结点间都有链指针连接、数据全部存在叶子结点中）</li>
<li>B+树与B*树（B*树中非根和非叶子结点保存又兄弟结点的指针）</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>策略模式：ZC根据不同的列车通信类型（CTC、ITC、IXLC）计算移动授权。</li>
<li>模板方法：仿真任务运行，是否到运行时间、日志记录、后续处理。</li>
<li>备忘录：仿真状态保存、背景，及恢复。</li>
<li>享元：仿真数据共享，状态不同。</li>
<li>组合：联锁条件。</li>
<li>原型：仿真设备状态的保存及对比。</li>
<li>外观：仿真创建、初始化。</li>
</ul>
<h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><ul>
<li>VUE特性（单页、MVVM）</li>
<li>生命周期（beforeCreate、Created、beforeMounted、mounted、beforeUpdate、updated、beforeDestroy、destroy）</li>
<li>父子组件传值（prop/emit，refs）</li>
<li>MVVM（源于MVC，分离View和Model，ViewModel监听View及Model的变化）</li>
<li>ES6新特性</li>
</ul>
<h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><ul>
<li>Nginx配置（alias/别名、proxy_pass/反向代理、root/文件系统）、upstream/负载均衡）</li>
<li>docker命令</li>
<li>linux常用命令</li>
<li>防火墙、端口</li>
<li>Git原理</li>
<li>Jenkins原理</li>
</ul>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul>
<li>难点</li>
<li>算法</li>
<li>项目流程</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>项目管理相关名称</title>
    <url>/2023/07/10/%E9%AB%98%E7%BA%A7/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<p>项目名<br>  对内<br>  对外<br>产品名<br>团队名</p>
]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
  </entry>
  <entry>
    <title>高可用</title>
    <url>/2023/07/11/%E9%AB%98%E7%BA%A7/%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<pre><code>集群
主节点，从节点
主从同步
解耦
</code></pre>
]]></content>
      <categories>
        <category>高级</category>
      </categories>
  </entry>
  <entry>
    <title>类加载</title>
    <url>/2021/12/16/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="类的声明周期"><a href="#类的声明周期" class="headerlink" title="类的声明周期"></a>类的声明周期</h2><p>加载 -&gt; 连接（验证 -&gt; 准备 -&gt; 解析） -&gt; 初始化 -&gt; 使用 -&gt; 卸载。<br>类型的加载、连接、初始化过程都是在程序运行期间完成的。</p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>加载、连接、初始化 三个阶段是连续完成的，所以合称为类加载或类初始化。</p>
<h2 id="各阶段功能"><a href="#各阶段功能" class="headerlink" title="各阶段功能"></a>各阶段功能</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>将class文件加载进方法区，在堆上创建class对象。class对象拥有访问方法区中数据的接口。<br>加载来源：</p>
<ul>
<li>从本地系统中直接加载。</li>
<li>从网络上下载.class文件</li>
<li>从zip、jar等归档文件中加载.class文件。</li>
<li>从专用数据库提取.class文件。</li>
<li>将java源文件动态编译为.class文件。</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>文件格式验证、元数据验证、字节码验证、符号引用验证。<br>不是必须的，可通过 -Xverifynone 关闭验证。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为static变量分配内存，并初始化为该数据类型的默认值。<br>如果是final修饰的字面量，则初始化为指定值。并放入常量池。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将符号引用替换为直接引用。<br>为了支持动态绑定，可以在初始化之后在解析。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>一般来说，当对类的是首次主动使用的时候才会导致类的初始化。<br>初始化阶段对static变量赋予指定值。<br>主动使用情况：</p>
<ul>
<li>new创建对象实例。</li>
<li>访问static变量或赋值。（在编译期把结果放入常量池的 static final 字段除外。）</li>
<li>调用static或方法。</li>
<li>反射，如Class.forName()。</li>
<li>初始化子类，父类也会被初始化。</li>
<li>Java虚拟机启动时被标明为启动类的类、Main方法所在的类。</li>
</ul>
<p>不会加载情况：</p>
<ul>
<li>常量在编译阶段会存入调用类的常量池中，使用常量不会加载。</li>
<li>创建数组不会加载。</li>
<li>通过子类引用父类静态属性/方法，只会加载父类。</li>
</ul>
<h3 id="声明周期结束"><a href="#声明周期结束" class="headerlink" title="声明周期结束"></a>声明周期结束</h3><ul>
<li>执行了System.exit()方法。</li>
<li>程序正常执行结束。</li>
<li>程序在执行过程中遇到了异常或错误而异常终止。</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止。</li>
</ul>
<h2 id="接口的加载"><a href="#接口的加载" class="headerlink" title="接口的加载"></a>接口的加载</h2><p>类加载会首先初始化其父类，但是接口只初始化自身，父接口只有用到时才去初始化。</p>
<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>对于子类直接访问父类static变量的情况，会初始化父类，但不会初始化子类。<br>子类直接访问父类static变量，导致父类初始化，说明子类知道这个变量是父类的，即子类的数据已被加载。那就是说子类加载了，但是没有初始化。所以在这种情况下， 加载、连接、初始化 就不是连续进行的了？？？</p>
<h2 id="预加载与按需加载"><a href="#预加载与按需加载" class="headerlink" title="预加载与按需加载"></a>预加载与按需加载</h2><p>Java运行所需要的基本类采用预加载方式，JRE运行时全部加载到内存中。<br>程序中需要使用的自定义类使用按需加载，需要用到的时候再加载。减少内存消耗。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><ul>
<li>委托：加载一个类的请求先交给父类加载器，如果父类加载器找不到或不能加载时，再由子类加载器加载。</li>
<li>可见性：子类的加载器可以看见父类加载器加载的类，而父类加载器看不到子类加载器加载的类。</li>
<li>单一性：一个类只被加载一次。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>安全、性能（避免重复加载，避免核心类被篡改）。</li>
</ul>
<h4 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h4><ul>
<li>基础类无法调用用户类。<br>不知道具体实现类，无法创建对象。<br>如果类A中调用了类B，那么加载B的时候，需要使用A的类加载器去加载B。 如果A是基础类，B是用户类，那么A对应的最上层类加载器，是没办法处理下层的用户类的。</li>
</ul>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>SPI + Thread ClassLoader。</p>
<ol>
<li>SPI只是一种机制/规范，具体加载部分还是使用Thread ClassLoader加载。</li>
<li>使用Thread ClassLoader 破坏了双亲委派机制。</li>
</ol>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>每个classLoader都有一个parent，在创建时指定。AppClassLoader的parent为ExtClassLoader，自定义parent默认为AppClassLoader。</p>
<ul>
<li>引导类加载器。Bootstrap ClassLoader，加载环境变量[sun.boot.class.path]目录下jar和class。</li>
<li>扩展类加载器。Extension ClassLoader，加载环境变量[java.ext.dirs]目录下jar和class。</li>
<li>系统类加载器。System ClassLoader，加载环境变量[java.class.path]目录下jar和class（项目当前路径）。</li>
<li>自定义类加载器。 扩展java虚拟机动态加载类的机制。如加密字节码解密。</li>
<li>上下文类加载器。Context ClassLoader，Thread ClassLoader，线程默认加载器为AppClassLoader，可自行设置更改，子线程会继承父线程的ClassLoader。</li>
</ul>
<h2 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h2><ul>
<li>隐式加载/静态加载 new、static、子类。</li>
<li>显示加载/动态加载 Class.forName()、 ClassLoader.loadClass()。</li>
</ul>
<h2 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h2><p>Launcher是jvm的启动类。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>运行时数据区</title>
    <url>/2021/12/16/Java/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>堆、方法区、程序寄存器、虚拟机栈、本地方法栈。<br>其中 堆、方法区是线程共享的，其它是每个线程各自的数据。</p>
<h2 id="程序寄存器"><a href="#程序寄存器" class="headerlink" title="程序寄存器"></a>程序寄存器</h2><p>每个CPU核心循环执行线程，使用程序寄存器保存当前方法执行的地方，以便下次执行。<br>唯一不会内存溢出的区域。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>保存方法调用栈，每次Java方法调用产生一个栈帧入栈，方法调用结束出栈。<br>每个栈帧包括 局部变量表、操作数栈、动态链接、方法出口。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>编译时确定大小。<br>非static方法第一个参数为调用对象。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>用来准备调用方法参数以及接受方法的返回结果。 ？？？<br>用来处理操作数操作符 ？？？</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>用来完成运行时绑定操作。 – 实现？？？</p>
<h3 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h3><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈功能一致，但针对的时native方法。<br>在HotSpot虚拟机中，虚拟机栈与本地方法栈合二为一。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>字面量等等。<br>永久代。<br>属于类信息的一部分，还是单独保存？？？</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>内存最大的区域，垃圾回收器主要作用的地方。<br>分为新生代（Eden + From Survivor0 + To Survivor1）、老年代。</p>
<h3 id="JVM常见参数"><a href="#JVM常见参数" class="headerlink" title="JVM常见参数"></a>JVM常见参数</h3><ul>
<li>-Xms： 堆容量初始大小。</li>
<li>-Xmx： 堆最大大小。</li>
<li>-Xmn： 新生代容量大小。</li>
<li>-XX:SurvivorRatio: 设置新生代各部分比例。默认为8：1：1。</li>
</ul>
<h2 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h2><p>将方法区改为MetaSpace。<br>把方法区中的字符串常量池保存到堆中。<br>去掉永久代的概念。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java 1.0 ~ Java SE 8新特性</title>
    <url>/2020/07/21/Java/Java%E5%B9%B3%E5%8F%B0/Java%201.0%20~%20Java%20SE%208%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="Java-1-0-（1996-01-23）"><a href="#Java-1-0-（1996-01-23）" class="headerlink" title="Java 1.0 （1996-01-23）"></a>Java 1.0 （1996-01-23）</h2><ul>
<li>Classic VM（虚拟机）</li>
<li>Applet（java小应用程序）</li>
<li>AWT（java图形设计）</li>
</ul>
<h2 id="Java-1-1-（1997-02-19）"><a href="#Java-1-1-（1997-02-19）" class="headerlink" title="Java 1.1 （1997-02-19）"></a>Java 1.1 （1997-02-19）</h2><ul>
<li>JAR</li>
<li>JDBC</li>
<li>JavaBeans</li>
<li>RMI</li>
<li>内部类</li>
<li>反射</li>
</ul>
<h2 id="J2SE-1-2-（1998-12-08）"><a href="#J2SE-1-2-（1998-12-08）" class="headerlink" title="J2SE 1.2 （1998-12-08）"></a>J2SE 1.2 （1998-12-08）</h2><ul>
<li>集合框架</li>
<li>Java IDL（接口描述语言）支持CORBA（平台对象请求代理体系结构）</li>
<li>JIT(Just In Time)编译器</li>
<li>数字签名</li>
<li>控制授权/访问系统资源的策略工具</li>
<li>JFC(Java Foundation Classes)，包括Swing1.0，拖放和Java2D类库</li>
<li>Java Plug-In（运行插件)</li>
<li>JDBC中引入可滚动结果集，BLOB，CLOB，批量更新和用户自定义类型</li>
<li>Applet中添加声音支持</li>
<li>字符串常量做内存映射</li>
</ul>
<h2 id="J2SE-1-3-（2000-05-08）"><a href="#J2SE-1-3-（2000-05-08）" class="headerlink" title="J2SE 1.3 （2000-05-08）"></a>J2SE 1.3 （2000-05-08）</h2><ul>
<li>数学运算</li>
<li>Timer API</li>
<li>Java Sound API</li>
<li>CORBA IIOP实现RMI的通信协议</li>
<li>Java 2D</li>
<li>JAR文件索引</li>
</ul>
<h2 id="J2SE-1-4-（2002-02-13）"><a href="#J2SE-1-4-（2002-02-13）" class="headerlink" title="J2SE 1.4 （2002-02-13）"></a>J2SE 1.4 （2002-02-13）</h2><h3 id="语言增强"><a href="#语言增强" class="headerlink" title="语言增强"></a>语言增强</h3><ul>
<li>断言</li>
</ul>
<h3 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h3><ul>
<li>XML解析器</li>
<li>Java打印服务</li>
<li>Logging API（日志功能）</li>
<li>Java Web Start</li>
<li>JDBC 3.0 API（jdbc高级)</li>
<li>Preferences API</li>
<li>链式异常处理（try-catch-catch…）</li>
<li>引入Image I/O API （图片流)</li>
<li>NIO（高级流）</li>
<li>XSLT转换器</li>
<li>支持IPV6</li>
<li>支持正则表达式</li>
</ul>
<h2 id="Java-SE-5-0-（2004-09-30）"><a href="#Java-SE-5-0-（2004-09-30）" class="headerlink" title="Java SE 5.0 （2004-09-30）"></a>Java SE 5.0 （2004-09-30）</h2><h3 id="语言增强-1"><a href="#语言增强-1" class="headerlink" title="语言增强"></a>语言增强</h3><ul>
<li>泛型</li>
<li>增强for循环</li>
<li>自动装箱拆箱</li>
<li>枚举</li>
<li>可变参数</li>
<li>静态导入</li>
<li>注解</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li>JMM</li>
<li>Introspector 内省</li>
</ul>
<h3 id="APIs-1"><a href="#APIs-1" class="headerlink" title="APIs"></a>APIs</h3><ul>
<li>concurrent</li>
</ul>
<h2 id="Java-SE-6-（2006-12-11）"><a href="#Java-SE-6-（2006-12-11）" class="headerlink" title="Java SE 6 （2006-12-11）"></a>Java SE 6 （2006-12-11）</h2><h3 id="语言增强-2"><a href="#语言增强-2" class="headerlink" title="语言增强"></a>语言增强</h3><p>无</p>
<h3 id="APIs-2"><a href="#APIs-2" class="headerlink" title="APIs"></a>APIs</h3><ul>
<li>java.util.function包</li>
<li>java.util.stream包</li>
<li>java.awt新增Desktop类和SystemTray类</li>
<li>使用JAXB2来实现对象与XML之间的映射</li>
<li>轻量级 Http Server API</li>
<li>插入式注解处理API(lombok使用该特性来实现的)</li>
<li>STAX，处理XML文档的API</li>
<li>Compiler API</li>
<li>对脚本语言的支持（ruby, groovy, javascript）</li>
</ul>
<h2 id="Java-SE-7-（2011-07-28）"><a href="#Java-SE-7-（2011-07-28）" class="headerlink" title="Java SE 7 （2011-07-28）"></a>Java SE 7 （2011-07-28）</h2><h3 id="语言增强-3"><a href="#语言增强-3" class="headerlink" title="语言增强"></a>语言增强</h3><ul>
<li>整数类型能够用二进制来表示（前缀0b/0B）</li>
<li>数字常量支持下划线</li>
<li>switch 支持String字符串类型</li>
<li>泛型实例化类型自动推断，即”&lt;&gt;”</li>
<li>改进可变参的警告和错误</li>
<li>try-with-resources，资源自动关闭</li>
<li>catch捕获多个异常类型，用（|）分隔开</li>
</ul>
<h3 id="APIs-3"><a href="#APIs-3" class="headerlink" title="APIs"></a>APIs</h3><ul>
<li>全新的NIO2.0 API</li>
<li>Fork/join 并行执行任务的框架</li>
</ul>
<h2 id="Java-SE-8-（2014-03-18）"><a href="#Java-SE-8-（2014-03-18）" class="headerlink" title="Java SE 8 （2014-03-18）"></a>Java SE 8 （2014-03-18）</h2><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ul>
<li>lambda 表达式和函数式接口</li>
<li>接口的默认方法</li>
<li>方法引用</li>
<li>重复注释</li>
<li>更好的类型推断</li>
<li>注解的扩展 （扩展了注解可以使用的范围，包括：局部变量，泛型，超类，接口实现，方法的exception声明等）</li>
</ul>
<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><ul>
<li>参数名字</li>
</ul>
<h3 id="APIs-4"><a href="#APIs-4" class="headerlink" title="APIs"></a>APIs</h3><ul>
<li>Optional</li>
<li>Stream</li>
<li>时间日期API</li>
<li>Nashorn javascript引擎</li>
<li>Base64</li>
<li>并行数组 （增加了支持并行的数组处理）</li>
<li>并发 （新增StampedLock、DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder等）</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li>Nashorn引擎 jjs</li>
<li>类依赖分析工具 jdeps</li>
</ul>
<h3 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li>JVM内存永久区被metaspace替换，JVM参数 -XX:PermSize 和 -XX:MaxPermSize 被 -XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 代替。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java平台</category>
      </categories>
  </entry>
  <entry>
    <title>Java SE 9 ~ 11新特性</title>
    <url>/2020/07/21/Java/Java%E5%B9%B3%E5%8F%B0/Java%20SE%209%20~%2011%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="Java-SE-9-2017-09"><a href="#Java-SE-9-2017-09" class="headerlink" title="Java SE 9 (2017-09)"></a>Java SE 9 (2017-09)</h2><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ul>
<li>模块化</li>
<li>接口可定义private方法 （只能在接口内部调用）</li>
<li>try with resource 优化</li>
<li>@SafeVarargs 可用在private方法</li>
</ul>
<h3 id="APIS"><a href="#APIS" class="headerlink" title="APIS"></a>APIS</h3><ul>
<li>jShell</li>
<li>String, StringBuilder, StringBuffer 中的value由char[]改为byte[]</li>
<li>List、Set、Map 添加of方法创建只读集合</li>
<li>InputStream流加强</li>
<li>StreamAPI takeWhile、dropWhile、ofNullable、iterate</li>
<li>Optional增加stream()</li>
<li>垃圾回收机制</li>
</ul>
<h2 id="Java-SE-10-2018-03"><a href="#Java-SE-10-2018-03" class="headerlink" title="Java SE 10 (2018-03)"></a>Java SE 10 (2018-03)</h2><h3 id="语言-1"><a href="#语言-1" class="headerlink" title="语言"></a>语言</h3><ul>
<li>局部变量类型推断</li>
</ul>
<h3 id="APIS-1"><a href="#APIS-1" class="headerlink" title="APIS"></a>APIS</h3><ul>
<li>不可变集合的改进</li>
<li>并行全垃圾回收器 G1</li>
<li>线程本地握手</li>
<li>Optional新增orElseThrow()方法</li>
<li>类数据共享</li>
<li>Unicode 语言标签扩展</li>
<li>根证书</li>
</ul>
<h2 id="Java-SE-11-2018-09-25"><a href="#Java-SE-11-2018-09-25" class="headerlink" title="Java SE 11 (2018-09-25)"></a>Java SE 11 (2018-09-25)</h2><h3 id="语言-2"><a href="#语言-2" class="headerlink" title="语言"></a>语言</h3><ul>
<li>局部变量类型推断加强 var上可以加注解</li>
</ul>
<h3 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h3><ul>
<li>String API isBlank、strip、stripTrailing、stripLeading、repeat、lines.count</li>
<li>Optional API isEmpty…</li>
<li>HttpClient</li>
<li>垃圾回收ZGC</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java平台</category>
      </categories>
  </entry>
  <entry>
    <title>Java SE API</title>
    <url>/2022/01/19/Java/Java%E5%B9%B3%E5%8F%B0/Java%20SE%20API/</url>
    <content><![CDATA[<h3 id="lang-and-util-Base-Libraries"><a href="#lang-and-util-Base-Libraries" class="headerlink" title="lang and util Base Libraries"></a>lang and util Base Libraries</h3><p>java.lang.<em>、java.util.</em> 包提供了基础功能。</p>
<ul>
<li>java.lang 提供java基础类。</li>
<li>java.lang.annotation 注解。</li>
<li>java.lang.instrument 允许Java代理检测运行在JVM上的服务。</li>
<li>java.lang.management 提供监控和管理JVM和底层操作系统的接口。</li>
<li>java.lang.ref 引用对象。</li>
<li>java.lang.reflect 反射。</li>
<li>java.util 集合框架，格式化输入输出，数组工具，事件模型，时间日期，国际化及各种工具类。</li>
<li>java.util.concurrent 并发编程。</li>
<li>java.util.concurrent.atomic 原子类。</li>
<li>java.util.concurrent.locks 锁。</li>
<li>java.util.jar 压缩。</li>
<li>java.util.zip 压缩。</li>
<li>java.util.logging 日志。</li>
<li>java.util.regex 正则表达式</li>
<li>java.util.prefs 存储和检索用户配置和系统配置。</li>
<li>java.util.spi 服务调用接口。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java平台</category>
      </categories>
  </entry>
  <entry>
    <title>Java平台</title>
    <url>/2020/07/21/Java/Java%E5%B9%B3%E5%8F%B0/Java%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<p>Java是由Sun Microsystems公司（简称Sun公司）于1995年5月推出的Java程序设计语言和Java平台的总称。“Write Once, Run Anywhere”。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>Java 平台：用Java语言编写的软件运行的平台，包括SE、ME、EE。JavaSE有两个实现产品：JDK、JRE。</li>
<li>JDK：Java Development Kit，Java开发工具包，包括JVM、Java类库、Java工具。</li>
<li>JRE：Java Runtime Environment，Java运行时环境。</li>
</ul>
<h2 id="Java-发展史"><a href="#Java-发展史" class="headerlink" title="Java 发展史"></a>Java 发展史</h2><ul>
<li>1995-5-23，Oak语言更名为Java，并发布JDK 1.0α2和HotJava 浏览器（1999年停止发展）。10月，发布JDK 1.0β。</li>
<li>1996-1-23，JDK 1.0发布，Java语言第一个正式版本的运行环境。</li>
<li>1997-2-19，JDK 1.1发布。</li>
<li>1998-12-4，Java2平台拆为3个方向，J2SE 1.2（JDK 1.2）发布。</li>
<li>1999-4-27，HotSpot虚拟机发布。</li>
<li>1999-12-12, J2EE 1.2发布。</li>
<li>2000-5-8，J2SE 1.3（JDK 1.3）发布。</li>
<li>2001-9-24，J2EE 1.3发布。</li>
<li>2002-2-13，J2SE 1.4（JDK 1.4）发布。</li>
<li>2003-11-11，J2EE 1.4发布。</li>
<li>2004-9-30，J2SE 5.0（JDK 1.5）发布，修改版本号命名方式，1.x保留为内部命名方式。</li>
<li>2006-11-13，Sun在GPL许可证下开源Java。</li>
<li>2006-12-11，Java SE 6发布，使用Java SE替换J2SE，版本号去掉“.0”。</li>
<li>2006-5-11，Java EE 5发布。</li>
<li>2009-4-20，Oracle以74亿美元收购Sun。</li>
<li>2011-7-28，Java SE 7发布，LTS（2022-7）。</li>
<li>2013-5-28，Java EE 7发布。</li>
<li>2014-3-18，Java SE 8发布，LTS（2030-12）。</li>
<li>2017-8-31，Java EE 8发布。</li>
<li>2018-9-25，Java SE 11发布，LTS（2026-9）。</li>
<li>2019-9-10，Jakarta EE8发布，Java EE更名为Jakarta EE。</li>
<li>2020-11-22，Jakarta EE9发布。</li>
<li>2021-9-17，Java SE 17发布，从此免费提供，LTS（2029-9）。</li>
</ul>
<h2 id="Open-JDK"><a href="#Open-JDK" class="headerlink" title="Open JDK"></a>Open JDK</h2><p>Sun在JavaOne 2006中宣布将成为开源软件，并建立了Open JDK社区。<br>2006-11-13，Sun根据GNU通用公共许可证将Java HotSpot虚拟机和编译器作为免费软件发布。<br>2007-5-8，Sun在GPL下发布了Java类库的完整源代码。</p>
<p>OpenJDK是Java 平台标准版 (Java SE) 的免费开源实现。<br>OpenJDK是由OpenJDK Community 、Oracle、IBM 领导，连同 Alibaba，Amazon，Ampere，Azul，BellSoft，Canonical，Fujitsu，Google，Huawei，Intel，Java Community，JetBrains，London Java Community，Microsoft，Red Hat，SAP，SouJava，SUSE，Tencent，Twitter ，VMWare等第三方共同开发、维护的 JavaSE开源参考实现。</p>
<p>自 Java SE7开始往后的版本，所有的JDK都源自于Open JDK。<br>OpenJDK Community领导的OpenJDK Project是Java SE的官方参考实现，只产生OpenJDK源码，并不提供可以直接使用的二进制文件格式。现在能直接使用的二进制文件格式的 JDK都是被编译之后的程序。<br>OpenJDK官网指向的可下载二进制文件的地址，实际是 Oracle’s OpenJDK builds下载的地址。</p>
<h2 id="Open-JDK-VS-Oracle-JDK"><a href="#Open-JDK-VS-Oracle-JDK" class="headerlink" title="Open JDK VS Oracle JDK"></a>Open JDK VS Oracle JDK</h2><ul>
<li>Open JDK是一个参考模型并且是完全开源的，Oracle JDK是Open JDK的一个实现，并不是完全开源的。</li>
<li>Oracle JDK比Open JDK更稳定。Open JDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。</li>
<li>在响应性和JVM性能方面，Oracle JDK与Open JDK相比提供了更好的性能。</li>
<li>Oracle JDK根据二进制代码许可协议获得许可，而Open JDK根据GPL v2许可获得许可。</li>
</ul>
<h2 id="Java名称及版本"><a href="#Java名称及版本" class="headerlink" title="Java名称及版本"></a>Java名称及版本</h2><p>Java在5的时候改名，但内部还是使用1.x作为版本号。直到9。<br>Java1.x版本用在以下情况：</p>
<ul>
<li>java -version</li>
<li>java -fullversion</li>
<li>javac -source XX</li>
<li>java.version System property</li>
<li>java.vm.version System property</li>
<li>@since XX</li>
<li>JDK安装目录</li>
<li>JRE安装目录</li>
</ul>
<h2 id="Java平台概念图"><a href="#Java平台概念图" class="headerlink" title="Java平台概念图"></a>Java平台概念图</h2><p><img src="/images/pasted-8.png" alt="upload successful"></p>
<p>JDK版本新特性主要包括JVM、Java SE API、工具及其API、语言特性。<br>其中Java SE API指java及javax包的更新，语言特性指编码方式。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java平台</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ</title>
    <url>/2022/06/11/Java/MQ/RocketMQ/</url>
    <content><![CDATA[<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><ul>
<li>异步解耦</li>
<li>流量消峰</li>
<li>数据分发</li>
</ul>
<h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>2011 MetaQ 1.0, 阿里基于kafka的设计用Java完全重写。<br>2012 MetaQ 2.0<br>2012 从内部开源出来 RocketMQ 3.0<br>2016 捐赠给Apache，RocketMQ 4.0</p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul>
<li>NameServer 注册中心 （集群部署）</li>
<li>Broker 消息存储 （主从部署）</li>
<li>Produce 生产者 （集群部署）</li>
<li>Consumer 服务者 （集群部署） </li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>主题（Topic）</li>
<li>分组（Group）  一般作用于事务消息 </li>
<li>消息队列（MessageQueue） 一个Queue对应一个消费者</li>
<li>偏移量（Offset）</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>4.8.0</p>
<ul>
<li>windows修改runbroker.cmd，CLASSPATH添加“”</li>
<li>Linux安装修改conf/broker.conf，添加brokerIP，修改runbroker.sh中的堆内存大小，添加-c参数指定配置文件</li>
<li>安装dashboard/console</li>
</ul>
<h2 id="普通消息发送"><a href="#普通消息发送" class="headerlink" title="普通消息发送"></a>普通消息发送</h2><ul>
<li>同步消息（send（Message））：发送-返回结果，确保消息发送成功。</li>
<li>异步发送（send（Message， SendCallBack））：通过异步监听，回调。 适合发送数据量比较大。</li>
<li>单向发送（sendOneWay）：没有响应。</li>
</ul>
<h2 id="普通消息消费模式"><a href="#普通消息消费模式" class="headerlink" title="普通消息消费模式"></a>普通消息消费模式</h2><ul>
<li>集群消费（默认模式）： 同一个group下，每个消息只会被消费一次。消费队列在Broker中保存。</li>
<li>广播消费： 每一个实例都会消费一遍。 不支持顺序消息，重置消费路径。消费队列保存在消费者客户端（客户端重启从最新的消息开始消费）。</li>
</ul>
<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><ul>
<li>全局顺序消息 指定只使用一个Queue。</li>
<li>部分顺序消息 不同的Queue进项标识。MessageQueueSelector。发生异常 SUSPEND, 不能设置为重新发送。</li>
</ul>
<h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><ul>
<li>Message.setDelayTimeLevel。 延时等级-延时时间。 订单支付</li>
</ul>
<h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><ul>
<li>send(Collection<Message>)。</li>
<li>不能超过4M。 拆分</li>
</ul>
<h2 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h2><ul>
<li>Tag过滤 </li>
<li>SQL过滤 MessageSelector.bySql  Message.putUserProperty</li>
</ul>
<h2 id="消息发送方法和属性"><a href="#消息发送方法和属性" class="headerlink" title="消息发送方法和属性"></a>消息发送方法和属性</h2><ul>
<li>producerGroup： 事务消息比较重要</li>
<li>setDefaultTopicQueueNums 8 </li>
<li>setSendMsgTimeout 3s</li>
<li>setCompressMsgBodyOverHowMuch  4k 超过启用压缩</li>
<li>setRetryTimesWhenSendFailed  2 总共执行3次</li>
<li>setRetryTimesWhenSendAsyncFailed  2 总共执行3次</li>
<li>setRestyAnotherBrokerWhenNotStoreOK false 没有存储成功是否发送到另外一个broker</li>
<li>setMaxMessageSize 4M 允许发送的最大消息长度</li>
</ul>
<h2 id="消息消费方法和属性"><a href="#消息消费方法和属性" class="headerlink" title="消息消费方法和属性"></a>消息消费方法和属性</h2><ul>
<li><p>consumerGroup</p>
</li>
<li><p>setMessageModel 集群/广播</p>
</li>
<li><p>setConsumerFromWhere LAST_OFFSET 指定消费开始偏移量</p>
</li>
<li><p>setConsumerThreadMin 20 消费者最小线程数</p>
</li>
<li><p>setConsumerThreadMax 20 消费者最大线程数</p>
</li>
<li><p>setPullInterval 0</p>
</li>
<li><p>setPullBatchSize 32</p>
</li>
<li><p>setMaxReconsumeTimes -1 16，重试次数，死信消息</p>
</li>
<li><p>setConsumerTimeout 15min 消费超时时间</p>
</li>
<li><p>subscribe</p>
</li>
<li><p>registerMessageListener  MessageListenerOrderly 顺序消息</p>
</li>
<li><p>ACK</p>
</li>
</ul>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><ul>
<li><p>单master模式</p>
</li>
<li><p>多master模式</p>
</li>
<li><p>多master多slaver同步（同步复制，消息保存复制成功才会返回）</p>
</li>
<li><p>多master多slaver异步（异步复制）</p>
</li>
<li><p>刷盘 同步刷盘与异步刷盘</p>
</li>
<li><p>一般采用同步复制+异步刷盘  复制速度 &gt; 刷盘速度</p>
</li>
</ul>
<h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><ul>
<li>顺序、重复 问题</li>
</ul>
<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><ul>
<li>Consumer ACK确认？</li>
<li>消费者模式都消费者指定？不同消费者指定不同的模式？</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>MQ</category>
      </categories>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/2020/07/14/Java/Mybatis/mybatis/</url>
    <content><![CDATA[<ul>
<li>mybatis 基于注解的sql可以不用写script？<br>  script 标签中可以使用xml中的标签来实现复杂语句的查询</li>
<li>mybatis 多个参数时使用@Param 注解指定？<br>  不使用@Param注解：<pre><code>  参数为基本类型，可以有多个
  参数为javabean对象，且只能有一个，使用时直接用对象的属性（注解无法获取多个属性，只能获取嵌套属性）
</code></pre>
  参数为String时，必须指定@Param注解，但是当有多个参数时，可以不用注解，猜想可能是把多个参数自动封装成一个对象了</li>
<li>mybatis 基于注解使用@ResultMap(“?”) 来使用xml中定义的resultmap<br>  只能引用通过@Result注解定义的，并指定名称的resultmap</li>
<li>当方法传入多个参数且包含复杂对象时，使用 对象.属性 来引用，可以使用@Param起别名。如果其中有基本参数类型，直接引用即可。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>spring cloud</title>
    <url>/2020/07/14/Java/Spring/spring%20cloud/</url>
    <content><![CDATA[<ol>
<li>eureka server<br>依赖<br> spring-cloud-starter-eureka-server<br>注解<br> @EnableEurekaServer</li>
</ol>
<p>配置<br>    spirng.application.name server需要么<br>    eureka.clinet.service-url.default-zone ？？？<br>    eureka.clinet.registry-with-eureka 如果有集群，是否注册到其他eureka服务<br>    eureka.client.fetch-registry</p>
<p>自我保护模式<br>数据中心<br>环境</p>
<ol start="2">
<li>eureka clent<br>依赖<br> spring-cloud-starter-eureka<br>注解<br> @EnableEurekaClinet  只能被eureka服务中心发现<br> @EnalbeDisconveryClient  可以被其他服务注册中心发现</li>
</ol>
<p>配置<br>    spring.application.name 指定服务名称<br>    eureka.client.service-url.default-zone<br>    eureka.clent.instance.perfer-ip-address<br>    eureka.client.instance-id  指定服务实例id,默认为 主机名:服务名:端口</p>
<ol start="3">
<li>ribbon 编程式服务间调用、负载均衡<br>依赖<br> spring-cloud-starter-ribbon</li>
</ol>
<p>注解<br>    @LoadBalanced<br>    @RibbonClient</p>
<ol start="4">
<li>feign 声明式服务间调用<br>注解<br> @EnableFeignClients<br> @FeignClient</li>
</ol>
<p>配置<br>    spring.</p>
<p>feign对hystrix的支持<br>feign中callback及callbackfactory的属性设置</p>
<ol start="5">
<li><p>hystrix 熔断处理<br>@HystrixCommand</p>
</li>
<li><p>网关<br>注解<br> @EnableEuulProxy  组合注解</p>
</li>
</ol>
<p>配置<br>    zuul.routes.<em><strong>.path<br>    zuul.routes.</strong></em>.service-id/url</p>
<ol start="7">
<li>config</li>
</ol>
<ol start="8">
<li><p>sleuth 全链路追踪</p>
</li>
<li><p>log<br>ESK  ES、LogStash、Kibana</p>
</li>
</ol>
<p>turbine</p>
<p>通过在不同环境中配置 port，来启动多个spingboot实例  @Import<br>spring mvc Resolver<br>启动异步 @EnableAsync 方法使用@Async(调用方与执行方在两个service里)<br>@Transaction rollbackfor 默认为受检异常<br>starter核心 auto-configuration<br>session、Token、JWT<br>@Mappper<br>springboot parent、dependencies</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>spring-configuration</title>
    <url>/2021/09/03/Java/Spring/spring-configuration/</url>
    <content><![CDATA[<p>spring-configuration-metadata.json<br>    提供spring configuration元数据</p>
<p>spring-boot-configuration-processor<br>    自动生成spring-configuration-processor.json文件</p>
<p>dependency optional true<br>    不传递依赖，需要使用才添加依赖</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2020/07/14/Java/Spring/spring/</url>
    <content><![CDATA[<ul>
<li>MATE-INF<br>  spring.factories</li>
<li>profile / @  spring-boot-starter-parent<br>  手动重新引入maven依赖<br>  父级pom对所有子级生效，子级覆盖父级，子级优先级更高</li>
<li>spring-boot-devtools</li>
</ul>
<p>service实现多个接口，则用任一接口都可注入该对象</p>
<ol>
<li><p>spring IOC<br>加载</p>
<ol>
<li>加载配置文件、读取配置</li>
<li>扫描包</li>
<li>实例化、放入容器</li>
<li>自动注入<br>初始化</li>
<li>请求映射</li>
</ol>
</li>
<li><p>Spring MVC</p>
<ol>
<li><p>加载配置文件、读取配置</p>
</li>
<li><p>扫描包</p>
</li>
<li><p>实例化、放入容器</p>
</li>
<li><p>自动注入</p>
</li>
<li><p>请求映射</p>
</li>
<li><p>请求分发、参数封装、校验等</p>
</li>
</ol>
</li>
</ol>
<p>入口<br>ClassPathXmlApplicationContext<br>AnnotationConfigApplicationContext</p>
<p>注入方式</p>
<ol>
<li>@Controller @Service @Repository @Commonent</li>
<li>@Bean</li>
<li>@Import</li>
<li>FactoryBean</li>
</ol>
<p>注解驱动<br>IOC</p>
<ol>
<li><p>@Configuration<br>配置类相当于配置文件<br>@Bean相当于bean标签，返回值相当于bean标签class，方法名作为默认key，也可自定义<br>@Configuration被@Component注解，本身相当于一个bean</p>
</li>
<li><p>@ComponentScan<br>相当于&lt;context:component-scan /&gt;标签<br>includeFilters、excludeFilters 相当于标签属性  includeFilters 需要将userDefaultFilters置为false<br>@ComponentScans 配置多个<br>自定义TypeFilter<br>3.@Scope<br>Prototype(多实例)、Singleton（单例）、Request、Session<br>Singleton 容器启动会创建对象放入容器<br>Prototype 每次获取时创建新的对象、不会管理</p>
</li>
<li><p>@Lazy<br>针对单例bean，在第一次调用的时候创建并放入容器</p>
</li>
<li><p>@Conditional spring4.x新增<br>按照一定的条件进行判断，满足条件创建bean并放入容器<br>实现Condition接口</p>
</li>
<li><p>@Import<br>value为class，容器中注入该类对象，key为class全限类名<br>实现ImportSelector接口, 返回全限类名数组<br>实现ImportBeanDefinitionRegistrar接口，实现自定义注册BeanDefinition</p>
</li>
<li><p>FactoryBean 接口<br>默认获取到的是getObject返回的bean，加&amp;前缀获取本身</p>
</li>
<li><p>生命周期 自定义<br>xml配置 bean标签属性：init-method destroy-method， @Bean属性 initMethod destroyMethod<br>Bean 实现 InitalizBean、DisposingBean 接口<br>使用@PostConstruct @PreDestroy 注解<br>Bean实现BeanPostProcessor接口 spring 底层对BeanPostProcessor的使用</p>
</li>
<li><p>@Value<br>字面量<br>SPEL、 #{}<br>${} 取配置文件的值  @PropertySource/@PropertySources 指定读取的配置文件， 相当于xml中的&lt;context:property-placeholder /&gt;</p>
</li>
<li><p>自动装配<br>@Autowired 先按类型匹配，如果找到多个，按属性名为key匹配 required 属性指定是否必须<br>@Primary 按类型匹配多个时，注入@Primary注解的bean，而不使用属性名，可使用@Qualifier注入其他bean<br>@Qualifier 按类型匹配多个时，指定按照key去匹配<br>@Resource JSR250 java规范 默认按属性名称注入，可自定义key，无法和@Pramiry、@Qualifier 组合使用，没有required属性<br>@Inject JSR330 java规范 需要添加依赖 javax.inject, 和 @Autowired 规则一样，没有required属性</p>
<p>@Autowired<br>标注在方法上，spring创建容器时会调用标注了该注解的方法  可以 @Bean + 方法参数，注解可省略<br>标注在构造器上 一样  如果只有一个有参构造器，该注解可以省略<br>标注在参数 一样<br>Aware<br>创建对象的时候，调用相应的方法，实现注入<br>使用PostProcessor实现<br>@Profile spring 提供的根据当前环境，动态激活和切换一系列组件的功能<br>激活 默认为”default”<br>虚拟机 -Dspring.profiles.active=<br>代码 applicationContext.getEnvironmet.setProfile() 需要容器创建前设置</p>
</li>
</ol>
<p>AOP<br>切面、切点、通知<br><a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a> @EnableAspectJAutoProxy</p>
<ol>
<li>@Befor @After @AfterReturning @AfterThrowing @Around @PointCut @Aspect @EnableAspectJAutoProxy JointPoint必须是第一个参数</li>
<li>@EnableAspectJAutoProxy -&gt; @Import -&gt; ImportBeanDefinitionRegistrar</li>
</ol>
<p>事务<br>@Transactional <a href="tx:annotation-driver">tx:annotation-driver</a> @EnableTranscationManagement<br>配置事务管理器 PlatformTransactionManage DataSourceTransactionManager</p>
<p>事件<br>@EventListener EventListenerMethodPostPossector, 可在方法上使用<br>@Commonent  +  ApplicationListener</p>
<p>Web Sevlet3.0+以上支持注解<br>Web三大组件 Servlet Filter Listener<br>@WebSevlet<br>@WebFilter<br>@WebListener<br>@WebInitParam<br>ServletContainerInitializer<br>异步请求    支持、开启、配置</p>
<p>MVC<br>@EnableWebMvc  &lt;mvc:annotation-driver /&gt;<br>WebMvcConfigurer接口的方法相当于xml里面的mvc配置</p>
<p>过滤器、拦截器</p>
<p>refresh</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2020/07/14/Java/Spring/springboot/</url>
    <content><![CDATA[<h2 id="spring-boot-maven-plugin"><a href="#spring-boot-maven-plugin" class="headerlink" title="spring-boot-maven-plugin"></a>spring-boot-maven-plugin</h2><p>java并没有提供加载嵌套jar文件的标准方式。 通过该插件，将程序打包为一个可执行的jar文件，该文件可在生产环境中运行。 如果不添加该插件，则打包后无法执行，只能供其它项目引用。</p>
<h2 id="spring-boot-starter-parent"><a href="#spring-boot-starter-parent" class="headerlink" title="spring-boot-starter-parent"></a>spring-boot-starter-parent</h2><p>作为springboot的父级项目，提供以下功能：</p>
<ul>
<li>使用JDK1.8做为默认的编译器级别。</li>
<li>UTF-8源码编码。</li>
<li>dependencyManagement，管理公共依赖的版本。</li>
<li>资源过滤。</li>
<li>插件配置。</li>
</ul>
<p>PS:</p>
<ul>
<li>可以通过在项目中设置属性来覆盖各个依赖项。 ex: 修改spring-data的版本</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-data-releasetrain.version</span>&gt;</span>Fowler-SR2<span class="tag">&lt;/<span class="name">spring-data-releasetrain.version</span>&gt;</span></span><br><span class="line">&lt;/ properties&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于properties和yml文件接受spring样式占位符“${…}”，Maven过滤器被更改为使用”@...@”作为占位符，可通过配置resource.delimiter自定义。</li>
<li>可以不使用默认parent配置，自定义父级依赖。但仍然可以使用scope=import的方式来引入依赖。</li>
</ul>
<h2 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h2><p>是一套方便的依赖描述符，可以获取spring及相关技术的一站式商店，无需查看代码示例并复制粘贴依赖描述符。</p>
<h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><ul>
<li>通常建议将主类放在其他类上方的根包中，并使用@EnableAutoConfiguration注解该类。  </li>
<li>当主类在其他类上方的根包中时，使用@ComponentScan可以不指定basePackage。</li>
</ul>
<h2 id="spring-boot-devtools"><a href="#spring-boot-devtools" class="headerlink" title="spring-boot-devtools"></a>spring-boot-devtools</h2><ul>
<li>默认禁用缓存，某些库可使用缓存来提供性能，例如 thymeleaf。  </li>
<li>通过类加载器来实现自动重启，只丢弃有修改的类并创建一个新类，提高启动速度。  </li>
<li>devtools监控资源类路径，触发重启的唯一方法时更新类路径，更新方式取决于IDE。  </li>
<li>默认情况下，静态资源和模板改变不回触发自动重启。  </li>
<li>可以使用触发文件，可定时/手动更新触发文件以自动重启。</li>
</ul>
<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><ol>
<li>所有的监听器都需继承ApplicationListener<ApplicationEvent>。</li>
<li>所有的事件都需继承ApplicationEvent。</li>
<li>可以自定义事件，自定义监听器，监听器只会监听配置的事件及其子类。</li>
</ol>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ol>
<li>定义。实现HandleInterceptor接口，根据情况实现其对应的方法。</li>
<li>注册。继承WebMvcConfigurationSupport 或 实现WebMvcConfigurer接口，重写addInterceptors方法。<br>PS: 使用拦截器拦截全部请求路径会导致静态资源也不能访问，可以根据情况进行配置。</li>
</ol>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ol>
<li>使用@WebFilfer注解配置。</li>
<li>实现Filter接口。</li>
</ol>
<h2 id="CommandLineRunner-amp-ApplicationRunner"><a href="#CommandLineRunner-amp-ApplicationRunner" class="headerlink" title="CommandLineRunner &amp; ApplicationRunner"></a>CommandLineRunner &amp; ApplicationRunner</h2><p>在SpringApplication.run(…)完成之前调用。</p>
<h2 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h2><ul>
<li>编程方式  </li>
<li>配置文件</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Mockito</title>
    <url>/2022/07/01/Java/UT/Mockito/</url>
    <content><![CDATA[<h2 id="Mockito"><a href="#Mockito" class="headerlink" title="Mockito"></a>Mockito</h2><ul>
<li>when</li>
<li>doReturn</li>
<li>doNothing</li>
<li>thenThrowing</li>
<li>any</li>
<li>anyString</li>
</ul>
<h2 id="Mock-Spy"><a href="#Mock-Spy" class="headerlink" title="Mock Spy"></a>Mock Spy</h2><ul>
<li>Mock 返回数据类型的默认值。</li>
<li>Spy 除打桩方法外，执行原对象的方法。</li>
</ul>
<h2 id="Mock-Mock"><a href="#Mock-Mock" class="headerlink" title="@Mock Mock"></a>@Mock Mock</h2><ul>
<li>Mock需每次创建。</li>
<li>@Mock可直接使用。</li>
</ul>
<h2 id="Mock-MockBean"><a href="#Mock-MockBean" class="headerlink" title="@Mock @MockBean"></a>@Mock @MockBean</h2><ul>
<li>@Mock生成的对象不由spring管理。</li>
<li>@MockBean生成的对象由spring管理，相当于自动替换相应类型的bean。</li>
</ul>
<h2 id="doReturn-when-when-thenReturn"><a href="#doReturn-when-when-thenReturn" class="headerlink" title="doReturn().when() when().thenReturn"></a>doReturn().when() when().thenReturn</h2><ul>
<li>when().thenReturn() 会执行方法并产生结果，并返回指定的结果。</li>
<li>doReturn().when() 不执行方法，直接返回结果。</li>
</ul>
<h2 id="junit4-junit5"><a href="#junit4-junit5" class="headerlink" title="junit4 junit5"></a>junit4 junit5</h2><ul>
<li>org.junit.*  org.junit.jupiter.api.*</li>
<li>@SpringBootTest + @RunWith  =&gt;  @SpringBootTest（组合注解）</li>
</ul>
<h2 id="SpringBootTest-RunWith"><a href="#SpringBootTest-RunWith" class="headerlink" title="@SpringBootTest @RunWith"></a>@SpringBootTest @RunWith</h2><ul>
<li>@SpringBootTest 使用Spring上下文。</li>
<li>@RunWith</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li>Test中注入ServiceA，可以使用@SpyBean注解依赖的ServiceB，但无法使用@SpyBean注解对应的MapperA。（使用@MockBean并指定name属性为MapperA的beanName）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>UT</category>
      </categories>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/2022/06/12/Java/%E5%88%86%E5%B8%83%E5%BC%8F/ElasticSearch/</url>
    <content><![CDATA[<p>V7.17.3</p>
<h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><h3 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h3><ul>
<li>结构化数据 固定格式、有限长度</li>
<li>非结构化数据 不定长，无固定格式</li>
<li>半结构化数据 结合</li>
</ul>
<h2 id="搜索分类"><a href="#搜索分类" class="headerlink" title="搜索分类"></a>搜索分类</h2><ul>
<li>结构化数据： 关系型数据库</li>
<li>非结构化数据： 顺序扫描/全文检索</li>
</ul>
<h2 id="全文检索-1"><a href="#全文检索-1" class="headerlink" title="全文检索"></a>全文检索</h2><ul>
<li>分词</li>
<li>索引</li>
</ul>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><ul>
<li>正排 id -&gt; 内容</li>
<li>倒排 关键词 -&gt; id</li>
<li>倒排索引 数据 -&gt; 分词 -&gt; 去重 -&gt; 排序</li>
</ul>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><ul>
<li><p>分布式、RestFul风格的搜索和数据分析引擎，用Java开发。</p>
</li>
<li><p>Lucene，单机版的搜索引擎，不支持水平扩展，只针对Java语言。</p>
</li>
<li><p>2004年，基于Lucene开发了Comparse。</p>
</li>
<li><p>2010年，重命名为ElasticSearch。</p>
</li>
</ul>
<h2 id="版本新特性"><a href="#版本新特性" class="headerlink" title="版本新特性"></a>版本新特性</h2><h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><ul>
<li>Solr</li>
<li>ElasticSearch</li>
</ul>
<h2 id="Elastic-Stack"><a href="#Elastic-Stack" class="headerlink" title="Elastic Stack"></a>Elastic Stack</h2><p>解决方案，搜索、日志分析、指标分析、安全分析。</p>
<ul>
<li>ElasticSearch</li>
<li>Logstash</li>
<li>Kibana</li>
<li>Beats</li>
</ul>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>ES5 - JDK 8.0</li>
<li>ES6 - JDK 11</li>
<li>ES7 内置JDK，配置优先级： ES_JAVA_HOME &gt; JAVA_HOME &gt; ES_HOME</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="elasticsearch-yml"><a href="#elasticsearch-yml" class="headerlink" title="elasticsearch.yml"></a>elasticsearch.yml</h3><ul>
<li>cluster</li>
<li>node</li>
<li>path</li>
<li>Host</li>
<li>Network<h3 id="JVM-配置"><a href="#JVM-配置" class="headerlink" title="JVM 配置"></a>JVM 配置</h3>占用内存较大。</li>
<li>-Xms</li>
<li>-Xmx</li>
</ul>
<h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><p>索引命名必须小写，不能以_开头</p>
<ul>
<li>创建索引 [PUT /index] {}</li>
<li>删除索引 [DELETE /index]</li>
<li>修改索引 [PUT /index/_setting]</li>
<li>查询索引 [GET /index/..]</li>
<li>是否存在 [HEAD /index]</li>
</ul>
<h2 id="索引属性"><a href="#索引属性" class="headerlink" title="索引属性"></a>索引属性</h2><ul>
<li>aliases</li>
<li>mapping</li>
<li>settings</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>索引</li>
<li>文档</li>
</ul>
<h3 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h3><ul>
<li>_index</li>
<li>_type</li>
<li>_source</li>
<li>version</li>
<li>seq_no 解决并发写数据的问题</li>
<li>primary_term  解决并发写数据的问题</li>
</ul>
<h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><ul>
<li>添加文档 [PUT/POST /index/[_doc/_create]/id]<br>有id时创建新文档，删除旧文档。全局更新。</li>
<li>修改文档 [POST /index/[_update/_updateByQuery]/id]</li>
<li>批量操作 [POST _bulk] 偶数行参数 可以操作不同的index</li>
<li>批量读取 [GET [_mget/_msearch]]</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="检索原理"><a href="#检索原理" class="headerlink" title="检索原理"></a>检索原理</h4><ul>
<li>索引</li>
<li>磁盘IO与预读  局部预读性原理</li>
<li>倒排索引 单词词典、倒排列表、倒排索引项</li>
</ul>
<h4 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query DSL"></a>Query DSL</h4><ul>
<li>GET /index/_doc/_search _doc省略后kibana有提示</li>
<li>默认只返回10条数据，默认from+size&lt;10000</li>
<li>只有text类型分词</li>
<li>from、size 分页</li>
<li>分页查询scroll</li>
<li>sort 排序 （_score 为null）</li>
<li>_source 指定返回某些字段</li>
<li>match_all 查询所有数据</li>
<li>match 对关键字进行分词，然后进行匹配（默认or，可改为and）(其它参数)</li>
<li>match_phrase  短语匹配，要求分词是连续的（slop指定间隔个数）</li>
<li>multi_match 多字段匹配，一个查询条件多个字段</li>
<li>query_string </li>
<li>simple_query_string + | - 替代 AND OR NOT</li>
<li>term filed.keyword 关键词查询，不分词，精确匹配 (term必须使用keyword)  使用filter避免算分</li>
<li>prefix 前缀搜索，匹配分词的前缀，而不是文本的前缀</li>
<li>wildcard 通配符查询，匹配分词</li>
<li>range 范围查询 （当前时间now的用法）</li>
<li>ids 多id查询</li>
<li>fuzzy 模糊查询，针对错别字的情形 fuzziness（最大2）：错误字数、prefix_length：前缀匹配长度</li>
<li>highlight 高亮查询，让符合条件的关键字高亮 可自定义样式</li>
<li>相关性及算分 排序  算法ES5之前使用TF-IDF（同一个词反复出现，分数会很高），之后使用BM25</li>
<li>explain true 查看算分公式</li>
<li>bool 组合查询 must（算分）、should（算分）、must_not（不算分）、filter（不算分） 分数汇总</li>
</ul>
<h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><ul>
<li>dynamic mapping text类型会自动增加子keyword属性</li>
<li>静态映射、动态映射、strict映射 新增字段不同实现</li>
<li>_reindex 重建索引、别名  建新索引 -&gt; reindex -&gt; 删旧索引 -&gt; 使用别名  （文档会怎样？）</li>
<li>index template 只在索引被创建的时候有用</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>AQS</title>
    <url>/2020/07/27/Java/%E5%B9%B6%E5%8F%91/AQS/</url>
    <content><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AbstractQueuedSynchronizer<br>通过双向链表方式实现。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>CountDownLatch</li>
<li>Semaphore</li>
<li>CyclicBarrier</li>
<li>ReentrantLock</li>
<li>Condition</li>
<li>FutureTask</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>CAS</title>
    <url>/2020/07/23/Java/%E5%B9%B6%E5%8F%91/CAS/</url>
    <content><![CDATA[<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>Compare And Swap。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>CAS是一种无锁算法，CAS有3个操作数，主内存值V，工作内存值A，要修改的新值B。当且仅当A和V相同时，将主内存值V改为B，否则什么都不做。  <br>valueOffset: 主内存地址的偏移量。  <br>value：使用volatile关键字保证可见性。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>ABA问题。JDK1.5提供了AtomicStampedReference类来解决，纪录值的版本。</li>
<li>循环时间长开销大。长时间不成功会一直自旋。</li>
<li>只能保证一个共享变量的原子操作。JDK1.5提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里进行CAS操作。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Executor</title>
    <url>/2020/09/10/Java/%E5%B9%B6%E5%8F%91/Executor/</url>
    <content><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java5引入，用于控制线程的启动、执行和关闭。  <br>基于生产者-消费者模式实现。</p>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><h3 id="Executor-1"><a href="#Executor-1" class="headerlink" title="Executor"></a>Executor</h3><p>接口，定义了线程池执行的方法，接收Runnale作为参数，无放回值。</p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>ExecutorService的子类接口，定义了线程池的生命周期。定义了submit方法，返回Future对象。及其它方法。</p>
<h3 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h3><p>ExecutorService 的抽象实现类，对ExecutorService中定义的方法做了默认的实现。</p>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>工具类，提供了一些常用的线程池，常用的线程池创建线程的工厂类。</p>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>常用的线程池，继承自AbastractExecutorService</p>
<h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p>可定时、周期执行的线程池，继承自ThreadPoolExecutor</p>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>可完成拆分合并的线程池，继承自AbstractExecutorService</p>
<h2 id="Executor-VS-Thread"><a href="#Executor-VS-Thread" class="headerlink" title="Executor VS Thread"></a>Executor VS Thread</h2><ul>
<li>性能</li>
<li>同一管理，线程间竞争</li>
<li>扩展性</li>
</ul>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>直接提交任务，而不保持。</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>无界队列，可以对无限多的任务排队</p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>延时队列，延时提交</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>有界队列，可以指定队列的长度。</p>
<h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p>ThreadPoolExecutor是最常用的线程池，该线程池创建需要以下参数。 </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>int</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>long</td>
<td>空闲线程保留最长时间</td>
</tr>
<tr>
<td>timeUnit</td>
<td>java.util.concurrent.TimeUnit</td>
<td>时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>java.util.concurrent.BlockingQueue</td>
<td>指定使用哪一种BlockingQueue</td>
</tr>
<tr>
<td>threadFactory</td>
<td>java.util.concurrent.ThreadFactory</td>
<td>指定线程池创建线程的工厂，默认工厂类为Executors.defaultThreadFactory</td>
</tr>
<tr>
<td>handler</td>
<td>java.util.concurrent.RejectedExecutionHandler</td>
<td>指定当任务超限后的处理方式，默认处理类为AbortPolicy</td>
</tr>
</tbody></table>
<h3 id="jdk提供的线程池"><a href="#jdk提供的线程池" class="headerlink" title="jdk提供的线程池"></a>jdk提供的线程池</h3><table>
<thead>
<tr>
<th>pool</th>
<th>corePoolSize</th>
<th>maximumPoolSize</th>
<th>keepAliveTime</th>
<th>timeUnit</th>
<th>workQueue</th>
<th>threadFactory</th>
<th>handler</th>
</tr>
</thead>
<tbody><tr>
<td>newFixedThreadPool</td>
<td>参数指定</td>
<td>参数指定</td>
<td>0</td>
<td>TimeUnit.MILLISECONDS</td>
<td>LinkedBlockingQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>TimeUnit.MILLISECONDS</td>
<td>LinkedBlockingQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
<tr>
<td>newCachedThreadPool</td>
<td>0</td>
<td>Integer.MAX_VALUE</td>
<td>60</td>
<td>TimeUnit.SECONDS</td>
<td>SynchronousQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>参数指定</td>
<td>Integer.MAX_VALUE</td>
<td>0</td>
<td>NANOSECONDS</td>
<td>DelayedWorkQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
</tbody></table>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>当调用executor.execute提交一个任务时，按照如下顺序处理： </p>
<ol>
<li>如果当前线程数量少于核心线程数，则创建一个新的线程。</li>
<li>如果当前线程数量大于等于核心线程数，但缓冲队列未满，则将新的任务添加到缓冲队列中，按照FIFO原则依次等待执行。</li>
<li>如果当前线程数量大于等于核心线程数，且缓冲队列已满，但当前数量小于最大线程数，则创建新的线程。</li>
<li>如果当前线程数量等于最大线程数，则调用handle方法处理。</li>
</ol>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li>RUNNING （初始状态）</li>
<li>SHUTDOWN （调用shutdown，等待任务执行完毕）</li>
<li>STOP （调用shutdownNow）</li>
<li>TIDYING （所有任务已终止）</li>
<li>TERMINATED （彻底终止）</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>RUNNING -&gt; SHUTDOWN -&gt; TIDYING -&gt; TERMINATED<br>RUNNING -&gt; STOP -&gt; TIDYING -&gt; TERMINATED</p>
<h2 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h2><table>
<thead>
<tr>
<th>类</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>AbortPolicy</td>
<td>throw new RejectedExecutionException</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>直接运行runable.run()</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>丢弃</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃队列头部任务</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Future</title>
    <url>/2020/09/10/Java/%E5%B9%B6%E5%8F%91/Future/</url>
    <content><![CDATA[<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>非阻塞模型。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/pasted-6.png" alt="upload successful"></p>
<h3 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture</h3><p>同时继承接口Runnable和Future。</p>
<h3 id="SchedualedFuture"><a href="#SchedualedFuture" class="headerlink" title="SchedualedFuture"></a>SchedualedFuture</h3><p>延时、定时执行。</p>
<h3 id="ForkJoinFuture"><a href="#ForkJoinFuture" class="headerlink" title="ForkJoinFuture"></a>ForkJoinFuture</h3><p>可被拆分、合并。</p>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>可以被显式完成。  </p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li>NEW</li>
<li>COMPLETING</li>
<li>NORMAL</li>
<li>EXCEPTIONAL</li>
<li>CANCELLED</li>
<li>INTERRUPTING</li>
<li>INTERRUPTED</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>NEW -&gt; COMPLETING -&gt; NORMAL<br>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL<br>NEW -&gt; CANCELLED<br>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2020/07/27/Java/%E5%B9%B6%E5%8F%91/JUC/</url>
    <content><![CDATA[<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>java.utils.concurrent</p>
<h2 id="autmic"><a href="#autmic" class="headerlink" title="autmic"></a>autmic</h2><ul>
<li>AutmicInteger</li>
<li>AutmicBoolean</li>
<li>AutmicLong</li>
<li>AutmicReference</li>
<li>LongAdder</li>
<li>AutmicIntegerArray</li>
<li>AutmicLongArray</li>
<li>AutmicReferenceArray</li>
<li>AutmicStampledReference</li>
</ul>
<h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><ul>
<li>CopyOnWriteArrayList</li>
<li>CopyOnWroteArraySet</li>
<li>ConcurrentSkipListSet</li>
<li>ConcurrentMap</li>
<li>ConcurrentSkipListMap</li>
</ul>
<h2 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h2><ul>
<li>Lock</li>
<li>ReentrantLock</li>
<li>ReadWriteLock</li>
</ul>
<h2 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h2><h2 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>netty</title>
    <url>/2020/09/18/Java/%E5%B9%B6%E5%8F%91/netty/</url>
    <content><![CDATA[<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><h3 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h3><p>线程池，继承自 ScheduledExecutorService。  <br>用做服务器时有两个线程池，分别为接收连接线程池与工作线程池。用作客户端时有一个线程池。  <br>具体实现类有NioEventLoop、DefaultEventLoop、EpollEventloop。</p>
<h3 id="AbstractBootstrap"><a href="#AbstractBootstrap" class="headerlink" title="AbstractBootstrap"></a>AbstractBootstrap</h3><p>启动类。服务器启动类为ServerBootstrap，客户端启动类为Bootstrap。</p>
<h4 id="group"><a href="#group" class="headerlink" title="group"></a>group</h4><p>指定线程池。</p>
<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>指定通道，根据通道可以判断是服务器/客户端、TCP/UDP。</p>
<h4 id="childHandle"><a href="#childHandle" class="headerlink" title="childHandle"></a>childHandle</h4><p>指定消息的处理器。</p>
<h4 id="option、childOption"><a href="#option、childOption" class="headerlink" title="option、childOption"></a>option、childOption</h4><p>通过常量指定TCP/UDP协议的相关配置。如backlog、keepalive等。</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>绑定端口。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>netty的通道。</p>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>继承自Future。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>nio</title>
    <url>/2020/09/18/Java/%E5%B9%B6%E5%8F%91/nio/</url>
    <content><![CDATA[<h2 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h2><p>io通过流来传输数据，而nio通过channel与buffer传输。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>通道。Stream是单向的，而channel是双向的。</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>缓冲区。</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>管理channel。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>synchronized</title>
    <url>/2020/09/17/Java/%E5%B9%B6%E5%8F%91/synchronized/</url>
    <content><![CDATA[<h2 id="synchronized使用及编译"><a href="#synchronized使用及编译" class="headerlink" title="synchronized使用及编译"></a>synchronized使用及编译</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>编译时添加ACC_SYNCHRONIZED标记。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>默认添加try-finally，编译生成一条monitorenter指令和两条monitorexit指令。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果synchronized作用的对象是非静态方法或者对象，则它取得锁是对象锁；如果synchronized作用的对象是静态方法或者类，则它取得的锁是类锁。类锁与对象锁是两把不同的锁。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>重量级锁依赖于系统的同步函数，在linux上使用mutex互斥锁，最底层实现依赖于futex。这些同步函数都涉及到用户态和内核态的切换，进程的上下文切换，成本较高。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>在JVM中，对象在内存中除了本身的数据外还会有对象头，对于普通对象而言，其对象头有两类信息：mark word和类型指针，对于数据而言含会有一份记录数据长度的数据。  <br>类型指针是指向该对象所属类对象的指针。mark word用于存储对象的HashCode、GC分代年龄、锁状态等信息，在32位系统中位32字节，64位系统中为64字节。  <br>Java中任意对象都可以用作锁，锁信息可以存在对象头中。  <br>mark word中存储数据根据锁类型改变，当对象为无状态锁时，存储hashCode，当对象为偏向锁时，存储线程id，当对象为轻量级锁时，存储线程栈中Lock Record的指针，当对象为重量级锁时，存储堆中的monitor对象的指针。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>传统意义上的锁，利用操作系统底层的同步机制实现Java中的线程同步。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>在运行时，同步块中的代码不存在竞争，不同的线程交替执行同步块中的代码。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在运行时，只有一个线程会调用相关同步方法。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>volatile</title>
    <url>/2020/07/23/Java/%E5%B9%B6%E5%8F%91/volatile/</url>
    <content><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>保证了所有线程对这个变量操作时的可见性。</li>
<li>禁止指令重排序。<br>PS: volatile只能保证对单次读/写的原子性，像i++属于复杂指令。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>读 当读一个volatile变量时，会将本地内存的值置为无效，直接从主内存中读取。</li>
<li>写 当写一个volatile变量时，JMM会把本地变量的值刷新到主内存。</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>指令屏障。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>并发模拟</title>
    <url>/2020/07/21/Java/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<ul>
<li>PostMan 请求模拟工具</li>
<li>Apache Bench 网站性能测试工具</li>
<li>Apache JMeter 压力测试工具</li>
<li>Semaphore、CountDownLatch 通过代码模拟测试 </li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/2020/07/21/Java/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>操作系统通过时间片算法来并行执行各个程序。  <br>并发编程是指在同一台处理器上，并发处理多个任务。</p>
</blockquote>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>操作系统进行资源分配的最小单位。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>操作系统能够进行运算调度的最小单位。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>表示一种公共资源或共享数据，同一时间，只允许一个线程访问。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>内存的一部分，用来缓冲输入或输出的数据。</p>
<h2 id="并发编程解决的问题"><a href="#并发编程解决的问题" class="headerlink" title="并发编程解决的问题"></a>并发编程解决的问题</h2><ul>
<li>线程间的通信问题<blockquote>
<p>通信方式</p>
</blockquote>
<ul>
<li>数据共享 通过读写公共内存中的公共状态来隐式进行通信。</li>
<li>消息传递 通过明确的发送消息来显式进行通信（Java中典型的消息传递方式是wait()和notify()）。</li>
</ul>
</li>
<li>线程间的同步问题<blockquote>
<p>同步 指程序用于控制不同线程之间操作发生相对顺序的机制。</p>
</blockquote>
</li>
</ul>
<h2 id="计算机内存模型"><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h2><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>随着CPU技术的发展，CPU的执行速度越来越快，而内存的速度没有多大变化，于是，为了提高CPU利用率，在CPU和内存之间增加高速缓存。  <br>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可分为一级缓存（L1），二级缓存（L2），部分高端CPU还具有三级缓存（L3）。  <br>多CPU/多核CPU每个核心都含有一套L1（L1、L2）缓存，而共享L2（L3）缓存。  <br>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为操作系统引入了一个新的问题—缓存一致性，从而带来更高的复杂度。</p>
<h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>MSI、MESI、MOSI、Synapse、Firefly、Dragon Protocol</p>
<h4 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h4><h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><ul>
<li>M Modified 修改</li>
<li>E Exclusive 独享</li>
<li>S Shared 共享</li>
<li>I Invalid 无效<h5 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h5>高速缓存行数据状态有四种，引起数据状态转换的操作也有四种，所以共有16中状态转换的情况。<br><img src="/images/pasted-1.png" alt="upload successful"><blockquote>
<p>CPU高速缓存通过总线连接，总线还连接了主存。<br>对于Local Read 和 Local Write 操作，不经过总线，不会被其它CPU控制器监听到。<br>对于Remote Read 和 Remote Write 操作，需要其它CPU共同参与，所以这两个操作所有CPU控制器都能监听到，并能知道是不是自己发出的。</p>
</blockquote>
</li>
</ul>
<h5 id="允许状态图"><a href="#允许状态图" class="headerlink" title="允许状态图"></a>允许状态图</h5><p>对于任意给定的高速缓存对，给定高速缓存行的允许状态如图。<br><img src="/images/pasted-2.png" alt="upload successful"></p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是编译器和处理器在执行程序时为了提供性能而做的一些优化。</p>
<p><img src="/images/pasted-4.png" alt="upload successful"></p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="编译器优化的重排序"><a href="#编译器优化的重排序" class="headerlink" title="编译器优化的重排序"></a>编译器优化的重排序</h4><p>编译器在不改变单线程程序语音的前提下，可以重新安排语句的执行顺序。</p>
<h4 id="指令集并行的重排序"><a href="#指令集并行的重排序" class="headerlink" title="指令集并行的重排序"></a>指令集并行的重排序</h4><p>如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
<h4 id="内存系统的重排序"><a href="#内存系统的重排序" class="headerlink" title="内存系统的重排序"></a>内存系统的重排序</h4><p>由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>重排序需要遵循一定的规则，不然其结果可能会影响程序的执行结果。</p>
<h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>数据依赖： 如果两个操作同时访问一个变量，其中一个操作时写操作，此时这两个操作就构成了数据依赖。</p>
<h4 id="控制依赖性"><a href="#控制依赖性" class="headerlink" title="控制依赖性"></a>控制依赖性</h4><h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h4><p>不管如果重排序，都必须保证代码在单线程下的运行正确。</p>
<h3 id="并发重排序"><a href="#并发重排序" class="headerlink" title="并发重排序"></a>并发重排序</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>如果代码中存在控制依赖的时候，会影响指令序列执行的并行度。因此，编译器和处理器会猜测（Speculation）执行来客服控制的相关性，所以重排序破坏了程序顺序规则。<br>程序顺序规则：指定执行顺序于实际代码中的执行顺序时一致的，但是处理器和编译器会进行冲重排序，只要最后的记过不会改变，该重排序就是合理的。  <br>在单线程程序中，由于as-if-serial的存在，对存在控制依赖的操作重排序，不会改变执行结果，但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。  <br>PS：一个线程里面的条件依赖于另一个线程里面的数据。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>内存屏障 Java编译器在适当的位置插入内存屏障指令来禁止特定类型的处理器重排序。</li>
</ul>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据JVM规范，JVM内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈五个部分。</p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li>不可见<blockquote>
<p>多个线程从主存中读取数据，其中一个线程的修改对其它线程不可见。</p>
</blockquote>
</li>
</ul>
<p>使用volatile关键字，表示只能从主存中读取，修改后写回主存。</p>
<ul>
<li>竞争<blockquote>
<p>多个线程同时修改同一份数据。</p>
</blockquote>
</li>
</ul>
<p>使用synchronized关键字，对数据加锁，释放锁之前其它线程不能访问。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>Java Memory Model，Java内存模型,定义了JVM在计算机内存中的工作方式。JVM是整个计算机虚拟模型，所以JMM属于JVM。  <br>在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，JMM就是为了屏蔽系统和硬件的差异。  </p>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>JMM用来描述JVM是如何和计算机内存交互的。而JVM是计算机的一个模型，自然包含内存结构。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>定义程序中各个变量的访问规则。</p>
<h3 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h3><p>JMM规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对象工作内存中的变量，线程间变量值的传递均需要在主内存中来完成。</p>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<h3 id="内存交互操作"><a href="#内存交互操作" class="headerlink" title="内存交互操作"></a>内存交互操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>作用于主内存的变量，把一个变量标识为一条线程独占状态。</td>
</tr>
<tr>
<td>unlock</td>
<td>作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。</td>
</tr>
<tr>
<td>read</td>
<td>作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。</td>
</tr>
<tr>
<td>load</td>
<td>作用于工作内存的变量，把read操作从主内存中得到的变量值存入工作内存的变量副本中。</td>
</tr>
<tr>
<td>use</td>
<td>作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时会执行这个操作。</td>
</tr>
<tr>
<td>assign</td>
<td>作用于工作内存的变量，把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时会执行这个操作。</td>
</tr>
<tr>
<td>store</td>
<td>作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作。</td>
</tr>
<tr>
<td>write</td>
<td>作用于主内存的变量，把store操作从工作内存中一个变量的值传送到主内存的变量中。</td>
</tr>
</tbody></table>
<p>对这8种指定的使用，有以下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li>
<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li>
<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li>
<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>
<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>
</ul>
<h3 id="特新"><a href="#特新" class="headerlink" title="特新"></a>特新</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指一个操作是不可终端的，即使是在多个线程一起执行的情况下，一个操作一旦考试执行，就不会收到其它线程的干扰。<br>JMM内存交互操作，在操作系统里都是不可分隔的单元。被synchronized关键字或其它锁包裹起来的操作也可以认为是原子的。从一个线程观察另一个线程时，看到的都是一个个原子性的操作。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>指在多线程情况下，当一个线程修改了某一个共享变量的值之后，其它线程是否能够立即知道这个修改。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句指“线程内表现为串行的语义”（as-if-serial），后半句值“指令重排序”和普通变量的”工作内存与主内存同步延迟“的现象。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>JMM使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。  <br>重排序需要遵循happens-before规则。</p>
<ul>
<li>程序次序规则(Program Order Rule)：在同一个线程中，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操纵。准确的说是程序的控制流顺序，考虑分支和循环等。</li>
<li>管理锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面（时间上的顺序）对同一个锁的lock操作。</li>
<li>volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面（时间上的顺序）对该变量的读操作。</li>
<li>传递性(Transitivity)：如果操作A 先行发生于操作B，操作B 先行发生于操作C，那么可以得出A 先行发生于操作C。</li>
<li>线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则(Thread Termination Rule)：线程的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时事件的发生。Thread.interrupted()可以检测是否有中断发生。</li>
<li>对象终结规则(Finilizer Rule)：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()的开始。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>锁</title>
    <url>/2020/07/23/Java/%E5%B9%B6%E5%8F%91/%E9%94%81/</url>
    <content><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>在计算机科学中，锁于互斥时一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。</p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。  <br>在Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>对于同一个数据的并发操作，乐观锁认为自己在使用数据的时候不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新乐这个数据。  <br>乐观锁在Java中是通过无锁编程来实现，最常采用的是CAS算法。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>乐观锁多用在读多写少的情况下。</li>
<li>悲观锁多用在读少写多的情况下。</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h3 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别的线程占用，那么此线程就无法获取到这把锁，该线程会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁（spinlock）。</p>
<h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><p>自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<h2 id="无锁、偏向锁、轻量级锁、重量级锁"><a href="#无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="无锁、偏向锁、轻量级锁、重量级锁"></a>无锁、偏向锁、轻量级锁、重量级锁</h2><h2 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>指多个线程按照申请锁的顺寻来获取锁，线程直接进入队列中排队，队列的第一个线程才能获取锁。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>等待锁的线程不会饿死。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>整体吞吐效率相对非公平锁低，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>指多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾排队。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>减少唤起线程的开销，整体的吞吐量高。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>处于等待队列中的线程可能会饿死。</p>
<h2 id="可重入锁、非可重入锁"><a href="#可重入锁、非可重入锁" class="headerlink" title="可重入锁、非可重入锁"></a>可重入锁、非可重入锁</h2><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入该线程的内层方法会自动获取锁。（前提是锁对象得是同一个对象或者class。）</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>可一定程度上避免死锁。</p>
<h2 id="独享锁、共享锁"><a href="#独享锁、共享锁" class="headerlink" title="独享锁、共享锁"></a>独享锁、共享锁</h2><h3 id="独享锁"><a href="#独享锁" class="headerlink" title="独享锁"></a>独享锁</h3><p>也叫排他锁、互斥锁，指该锁一次只能被一个线程所持有，获得该锁的线程既能读数据也能写数据。</p>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>该锁可被多个线程共享，获得共享锁的线程只能读数据，不能写数据。一个线程对某数据加了共享锁后，其它线程只能添加共享锁，不能加独享锁。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>部署应用程序和applet</title>
    <url>/2022/01/13/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%8810%EF%BC%89%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8Capplet/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;10.1 JAR文件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;清单文件（manifest）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;在Windows平台中，可以实用第三方的打包器工具将JAR文件转换成Windows可执行文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;资源。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;10.2 Java Web Start&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Java Web Start是一项在Internet上发布应用程序的技术。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Java Web Start应用程序一般通过浏览器发布。只要Java Web Start应用程序下载到本地就可以启动它，而不需要浏览器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Java Web Start应用程序并不在浏览器窗口内。它将显示在浏览器外的一个属于自己的框架中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;Java Web Start应用程序不使用浏览器的Java实现。浏览器只是在加载Java Wb Start应用程序描述符时启动一个外部应用程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;数字签名应用程序可以被赋予访问本地机器的任意权限。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;受限制的执行环境称为沙箱。在沙箱中运行的代码不能修改或查看用户系统。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;不能运行任何本地可执行程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;不能从本地计算机文件系统中读取任何信息，也不能往本地计算机文件系统中写入任何信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;不能查看除Java版本信息和少数几个无害的操作系统详细信息外的任何有关本地计算机的信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;远程加载的程序不能与除下载程序所在的服务器之外的任何主机通信，这个服务器被称为源主机。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;所有弹出式窗口都会带一个警号信息。这条信息起到了安全的作用，以确保用户不会为本地应用程序弄错窗口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;沙箱限制在很多情况下显得过于严格。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;要想在沙箱外运行，Java Web Start应用程序的JAR文件必须进行数字签名。签名的JAR文件将携带一个可以证明签名者身份的证书。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;JNLP API允许未签名的应用程序在沙箱中运行，同时通过一种安全的途径访问本地资源。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;10.3 applet&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;applet是一种包含在HTML网页中的Java应用程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;在applet开发早期，必须使用Sun的HotJava浏览器来查看包含applet的网页。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;当Netscape在其浏览器中包含了Java虚拟机之后，applet才真正地流行起来。微软的IE浏览器也紧随其后。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;Netscape没有跟上Java的发展，而微软在对旧版Java是否提供支持的问题上举棋不定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;为了解决这个问题，Java发布了一个名为Java Plug-in的工具。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;通过使用各种扩展机制，可以将插件平滑地嵌入到各种浏览器中，使这些浏览器能够利用Sun提供的外部Java运行时环境执行Java applet。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;通过更新插件可以保持使用最新、最棒的Java特性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;一个applet就是一个扩展于java.applet.Applet类的Java类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;10.4 应用程序首选项存储&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;应用程序的用户通常期待能够自行对应用程序进行配置，并能够将其保存起来。日后再次运行这个应用程序时将能够读取这些配置。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;属性映射时一种存储键/值对的数据结构。属性映射经常被用来存放配置信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;实现属性映射的Java类被称为Properties。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;不足： 配置文件不能存放在用户的主目录中； 没有标准的为配置文件命名的规则。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;Preferences类提供了一个与平台无关的中心知识库。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;Preferences的中心知识库具有树状结构。每个节点都有一个用来存放键/值的独立表。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>异常、断言、日志和调试</title>
    <url>/2022/01/13/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%8811%EF%BC%89%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E3%80%81%E6%97%A5%E5%BF%97%E5%92%8C%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;11.1 处理错误&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;对于异常情况，Java使用一种称为异常处理的错误捕获机制处理。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;如果由于出现错误而使得某些操作没有完成，程序应该 返回到一种安全状态，并能够让用户执行一些其他的命令； 或者允许用户保存所有的操作的结果，并以适当的方式终止程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;在Java中，如果某个方法不能够采用正常的途径完整它的任务，就可以通过另外一个路径退出方法。throw。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;调用这个方法的代码也将无法继续执行，异常处理机制开始搜索能够处理这种异常状况的异常处理器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;在Java程序设计语言中，异常对象都是派生于Throwable类的一个实例。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Throwable =&amp;gt; Error、Exception。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;Exception =&amp;gt; RuntimeException、其它异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Java语言规范将派生于Error类或RuntimeException类的所有异常称为未检查异常，所有其它的异常称为已检查异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;编译器将检查是否为所有的已检查异常提供了异常处理器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;对于那些可能被他人使用的Java方法，应该根据异常规范，在方法的首部声明这个方法可能抛出的异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;子类方法中声明的已检查异常不能比超类方法中声明的异常更通用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;如果超类方法没有抛出任何已检查异常，子类也不能抛出任何已检查异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;抛出异常：throw。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;创建异常类：定义一个派生于Exception的类，或者派生于Exception子类的类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;11.2 捕获异常&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;要想捕获一个异常，必须设置try/catch语句块。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么程序将跳过try语句块的其余代码，将执行catch子句中的处理器代码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;如果在try语句块中的代码没有抛出异常，那么程序将跳过catch子句。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;如果方法中的任何代码抛出了一个在catch子句中没有声明的异常类型，那么这个方法就会立刻退出。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;在一个try语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;在Java SE 7中，同一个catch子句中可以捕获多个异常类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;在catch子句中可以抛出一个异常，这样做的目的时改变异常的类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;不管是否由异常被捕获，finally子句中的代码都被执行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;Java SE7提供了try-with-resources。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;堆栈跟踪时一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;printStackTrace、getStackTrace、getAllStackTrace。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;11.3 使用异常机制的技巧&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;异常处理不能代替简单的测试。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;不要过分的细化异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;利用异常层次结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;不要压制异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;在检查错误时，苛刻要比放任更好。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;不要羞于传递异常。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;11.4 使用断言&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;在一个具有自我保护能力的程序中，断言很常用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;断言机制允许在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句将会被自动地移走。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;Java语言引入了关键字assert。有两种形式： assert 条件; 、 assert 条件:表达式;。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;表达式部分的唯一目的是产生一个消息字符串。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;在默认情况下，断言被禁用。可以在运行程序时用-enableassertions或-ea选项启用它。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;启用或禁用断言时类加载器的功能。当断言被禁用时，类加载器将跳过断言代码，不会降低程序运行的速度。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;也可以在某个类或某个包中使用/禁用断言。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;断言失败是致命的、不可恢复的错误。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;断言检查只用于开发和测试阶段。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;断言是一种测试和调试阶段所使用的战术性工具；而日志记录是一种在程序的整个生命周期都可以使用的策略性工具。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;11.5 记录日志&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;可以很容易地取消全部日志记录，或者仅仅取消某个级别的日志，而且打开和关闭这个操作也很容易。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;可以很简单地禁止日志记录的输出，因此，将这些日志代码留在程序中的开销很小。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;日志记录可以被定向到不同的处理器，用于在控制台中显示，用于存储在文件中等。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;日志记录器和处理器都可以对进路进行过滤。过滤器可以根据过滤器实现器指定的标准丢弃那些无用的记录项。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;日志记录可以采用不同的方式格式化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;应用程序可以使用多个日志记录器，它们使用类似包名的这种具有层次结构的名字。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;在默认情况下，日志系统的配置由配置文件控制。如果需要的话，应用程序可以替换这个配置。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;11.6 调试技巧&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;System.out、log。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;每个类中放置一个main方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;JUnit。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;日志代理。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;Throwable.printStackTrace。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;System.err。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;Xlint选项告诉编译器对一些普遍容易出现的代码问题进行检查。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;jconsole。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;jmap。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;Xprof标志。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;11.7 GUI程序排错技巧&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;11.8 使用调试器&quot;}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>泛型程序设计</title>
    <url>/2022/01/13/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%8812%EF%BC%89%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;12.1 为什么要使用泛型程序设计&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;泛型程序设计（Generic programming）意味着编写的代码可以被很多不同类型的对象所重用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;在Java中增加泛型类之前，泛型程序设计使用继承实现的。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;12.2 定义简单泛型类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;一个泛型类就是具有一个或多个类型变量的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;类定义中的类型变量指定方法的返回类型以及域和局部变量的类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;12.3 泛型方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;可以定义一个带有类型参数的简单方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;12.4 类型变量的限定&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;有时，类或方法需要对类型变量加以约束。extends。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;限定类型用&amp;amp;分隔，而逗号用来分隔类型变量。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;在Java的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中第一个。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;12.5 泛型代码和虚拟机&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;虚拟机没有泛型类型对象。所有的对象都属于普通类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;无论何时定义一个泛型类型，都自动提供了一个响应的原始类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;擦除类型变量，并替换为限定类型（无限定的变量用Object）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;泛型方法擦除，桥方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;虚拟机中没有泛型，只有普通的类和方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;所有的类型参数都用它们的限定类型替换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;桥方法被合成来保持多态。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;为保持类型安全性，必要时插入强制类型转换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;设计Java泛型类型时，主要目标时允许泛型代码和遗留代码之间能够互操作。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;12.6 约束与局限性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;不能用基本类型实例化参数类型。（类型擦除，擦除之后，只有Object类型的域，而Object不能存储基本类型的值）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;运行时类型查询只适用于原始类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;不能创建参数化类型的数组。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;Varargs警告。 =&amp;gt;  @SafeVarargs。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;不能实例化类型变量。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;泛型类的静态上下文中类型变量无效。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;不能抛出或捕获泛型类的实例。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;注意擦除后的冲突。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;要想支持擦除的转换，就需要强制限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;12.7 泛型类型的继承规则&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;永远可以将参数化类型转换为一个原始类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;泛型类可以扩展或实现其它的泛型类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;12.8 通配符类型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;通配符类型： ? 。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;通配符限定域类型变量限定十分类似。但是可以指定一个超类型限定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;可以使用无限定的通配符。与原始类型有很大不同。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;通配符捕获。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;12.9 反射和泛型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;现在，Class类是泛型的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;类型参数十分有用，这是因为它允许Class&amp;lt;T&amp;gt;方法的返回类型更加具有针对性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;有时，匹配泛型方法中的Class&amp;lt;T&amp;gt;参数的类型变量很有实用价值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;擦除的类仍然保留一些泛型祖先的微弱记忆。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;为了表达泛型类型声明，Java SE 5.0在java.lang.reflect包中提供了一个新的接口Type。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;Type接口包含了子类型： Class类、TypeVariable接口、WildcardType接口、ParameterizedType接口、GenericArrayType接口。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2022/01/14/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%8813%EF%BC%89%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;13.1 集合接口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Java最初版本只为最常用的数据结构提供了很少的一组类： Vector、Stack、Hashtable、BitSet与Enumeration接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;与现代的数据结构类库的常见情况一样，Java集合类库也将接口与实现分离。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;在Java类库中，集合类的基本接口是Collection接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;迭代器Iterator。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;Java SE 5.0 foreach循环，可以与任何实现了Iterable接口的对象一起工作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Collection接口扩展了Iterable接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Collection与Iterator都是泛型接口，可以编写操作任何集合类型的实用方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;13.2 具体的集合&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;链表。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;数组列表。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;散列集。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;树集。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;对象的比较。Comparable。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;队列与双端队列。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;优先级队列。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;映射表。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;弱散列映射表、链接散列集和链接映射表、枚举集与映射表、标识散列映射表。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;13.3 集合框架&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;框架是一个类的集，它奠定了创建高级功能的基础。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;框架包含很多超类，这些超类拥有非常有用的功能、策略和机制。框架使用者创建的子类可以扩展超类的功能，而不必重新创建这些基本的机制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;Java集合类库构成了集合类的框架。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;视图与包装器。轻量级集包装器、子范围、不可修改的视图、同步视图、检查视图、可选操作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;批操作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;集合与数组之间的转换。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;13.4 算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;泛型集合接口有一个很大的优点，即算法只需要实现一次。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;排序与混排。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;二分查找。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;简单算法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;13.5 遗留的集合&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;Hashtable。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;Enumeration。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;Hashtable子类Properties。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;Vector及子类Stack。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;BitSet。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2022/01/14/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%8814%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;14.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;操作系统中的多任务： 在同一刻运行多个程序的能力。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;并发执行的进程数目并不是由CPU数目制约的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;通常，每一个任务称为一个线程，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;多进程与多线程本质的区别在于每个进程拥有自己的一整套便来给你，而线程则共享数据。共享变量是线程之间的通信比进程之间的通信更有效、更容易。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;在有些操作系统中，与进程相比较，线程更轻量级，创建、销毁一个线程比启动新进程的开销要小得多。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;14.1 什么是线程&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;AWT的事件分派线程一直并行运行，以处理用户界面的事件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;在一个单独的线程中执行一个任务。Runnable。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;14.2 中断线程&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;stop方法可以终止线程，但是已弃用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;interrupt方法可以用来请求终止线程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;当对一个线程调用interrupt方法时，线程的中断状态将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;如果线程被阻塞，就无法检测中断状态。当在一个被阻塞的线程上调用interrupt方法时，阻塞调用将会被InterruptedException异常中断。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过时引起它的注意。被中断的线程可以决定如何响应中断。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;14.3 线程状态&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;New 新创建。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;Runnable 可运行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;Blocked 被阻塞。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;Waiting 等待。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;Timed waiting 计时等待。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;Terminated 被终止。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;现在所有的桌面以及服务器操作系统都使用抢占式调度。但是像手机这样的小型设备可能使用协作式调度。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行（这就是为什么称这个状态为可运行而不是运行）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;14.4 线程属性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;在Java程序设计语言中，每一个线程有一个优先级。默认情况下，一个线程继承它的父线程的优先级。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;线程的优先级时高度依赖于系统的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;守护线程的唯一用途时为其他线程提供服务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;标识该线程为守护线程或用户线程。这一方法必须在线程启动之前调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;线程的run方法不能抛出任何被检测的异常，但是，不被检测的异常会导致线程终止。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;不需要任何catch子句来处理可以被传播的异常。在线程死亡之前，异常被传递到一个未捕获异常的处理器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;如果不安装默认的处理器，默认的处理器为空。如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;线程组是一个可以统一管理的线程集合。现在引入了更好的特性用于线程集合的操作，建议不要在自己的程序中使用线程组。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;14.5 同步&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;竞争条件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;有两种机制防止代码块受并发访问的干扰。synchronized、Lock。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;synchronized关键字自动提供一个锁以及相关的条件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;如果使用锁，就不能使用带资源的try语句。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;通常，可能想要保护若干个操作来更新或检查共享对象的代码块。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;公平锁、常规锁。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;条件对象（条件变量）。await、signalAll。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;从1.0版开始，Java中的每一个对象都有一个内部锁。如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;内部对象锁只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll/notify方法解除等待线程的阻塞状态。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;将静态方法声明为synchronized也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;内部锁和条件存在一些局限。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;有时使用一个对象的锁来实现额外的原子操作，实际上称为客户端锁定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;监视器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;volatile。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;finale变量。可以安全地访问一个共享域。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;原子性。java.util.concurrent.atomic。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;死锁。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;线程局部变量。ThreadLocal。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;线程在调用lock方法来获得另一个线程所持有的锁的时候，很可能发生阻塞。tryLock。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;读/写锁。ReentrantReadWriteLock。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;stop方法天生就不安全。suspend方法会经常导致死锁。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;14.6 阻塞队列&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;对于许多线程问题，可以通过使用一个或多个队列以优雅且安全的方式将其形式化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;生产者线程向队列插入元素，消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列导致线程阻塞。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;阻塞队列的变种：LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue、DelayQueue。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;14.7 线程安全的集合&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;集合返回弱一致性的迭代器。这意味着迭代器不一定能反映出它们被构造之后的所有的修改，但是它们不会将同一个值返回两次，也不会抛出ConcurrentModificationException异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;CopyOnWriteArrayList和CopyOnWriteArraySet是线程安全的集合，其中所有的修改线程对底层数组进行赋值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;任何集合类通过使用同步包装器变成线程安全的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;应该确保没有任何线程通过原始的非同步方法访问数据结构。最便利的方法是确保不保存任何指向原始对象的引用，简单地构造一个集合并立即传递给包装器。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;14.8 Callable与Future&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;Runnable封装一个异步运行的任务。Callable接口是一个参数化的类型。Future返回异步计算的结果。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;14.9 执行器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;构建一个新的线程是有一定代价的，因为设计与操作系统的交互。如果程序中创建了大量的生命周期很短的线程，应该使用线程池。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;另一个使用线程池的理由是减少并发线程的数目。创建大量线程会大大降低性能甚至使虚拟机崩溃。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;执行器（Executor）类有许多静态工厂方法用来构建线程池。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool、newSingleThreadScheduledExecutor。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;调用submit返回Future； 提交Runnable； 提交Callable。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;控制一组相关任务： shutdownNow、invokeAny、invokeAll。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;Java SE 7中新引入了fork-join框架，专门用来支持计算密集型任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;fork-join框架使用了一种有效的智能方法来平衡可用线程的工作负载。这种方法称为工作密取。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;14.10 同步器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;java.util.concurrent包包含了几个帮助管理相互合作的线程集的类。这些机制具有为线程之间的共用集结点模式提供的预置功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;CyclicBarrier，允许线程集等待直至其中预定数目的线程到达一个公共障栅，然后可以选择执行一个处理障栅的动作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;CountDownLatch，允许线程集等待直到计算器减为0。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;Exchanger，允许两个线程在要交换的对象准备好时交换对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;Semaphore，允许线程集等待直到被允许继续运行为止。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;SynchronousQueue，允许一个线程把对象交给另一个线程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;同步队列是一种将生产者和消费者线程配对的机制。当一个线程调用SynchronousQueue的put方法时，它会阻塞直到另一个线程调用take方法为止，反之亦然。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;即使SynchronousQueue类实现了BlockingQueue接口，概念上讲，它依然不是要给队列。它没有包含任何元素，它的size方法总是返回0.&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[109,110]},&quot;v&quot;:&quot;14.11 线程与Swing&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[110,111]},&quot;v&quot;:&quot;Swing不是线程安全的。如果试图在多个线程中操纵用户界面的元素，那么用户界面可能崩溃。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[111,112]},&quot;v&quot;:&quot;将线程与Swing一起使用时，必须遵循两个简单的原则。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;如果一个动作需要花费很长事件，在一个独立的工作器线程中做这件事不要在事件分配线程中作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[113,114]},&quot;v&quot;:&quot;除了事件分配线程，不要在任何线程中接触Swing组件。（单一线程规则）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[114,115]},&quot;v&quot;:&quot;EventQueue、SwingWorker。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>Java程序设计概述</title>
    <url>/2022/01/11/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%881%EF%BC%89Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;1.1 Java 程序设计平台&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Java并不只是一种语言。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Java是一个完整的平台，有一个庞大的库，其中包含了很多可重用的代码和一个提供诸如安全性、跨操作系统系统的可移植性以及自动垃圾收集等服务的执行环境。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;其它语言是什么情况呢？？？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;具有令人赏心悦目的语法和易于理解的语义。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;1.2 Java 白皮书关键术语&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;简单性&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;面向对象  简单地将，面向对象是一种程序设计技术。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;网络技能&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;健壮性&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;安全性&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;体系结构中立&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;可移植性&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;解释型&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;高性能&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;多线程&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;动态性&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;1.3 Java applet 与 Internet&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;在网页中运行Java程序称为applet。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;1.4 Java发展简史&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;在1995年5月23日的SunWorld上展示。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;1996年年初，Sun发布了Java的第一个版本。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;1.5 关于Java的常见误解&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;程序设计语言的成功更多的取决于其支撑系统的能力，而不是优美的语法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;C#借鉴了Java许多好的思想，也省去了一些好的特性，其中最重要的是安全性和平台无关性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;虚拟机和类库的源代码都可以免费获取。但是，只能查看，不能修改，也不能再发布。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;Java虚拟机使用了即时编译器。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>Java程序设计环境</title>
    <url>/2022/01/11/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%882%EF%BC%89Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;2.1 安装Java开发工具箱&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;2.2 选择开发环境&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;2.3 使用命令行工具&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;2.4 选择集成开发环境&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;2.5 运行图形化应用程序&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;2.6 建立并运行applet&quot;}],&quot;p&quot;:{}}"></svg>
</div>


]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>Java的基本程序设计结构</title>
    <url>/2022/01/12/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%883%EF%BC%89Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;3.1 一个简单的Java应用程序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Java对大小写敏感。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;类名标准规范： 类名是以大写字母开头的名词。驼峰命名法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;根据Java语言规范，main方法必须声明为public。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;3.2 注释&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;三种注释。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;单行注释。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;多行注释。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;文档注释。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;3.3 数据类型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;Java是一种强类型语言。意味着必须为每一个变量声明一种类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;8中基本类型。byte、short、int、long、float、double、char、boolean。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;所有的浮点数值计算都遵循IEEE 754规范。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;表示移除和出粗情况的三个特殊的浮点数值： 正无穷大、负无穷大、NaN。（一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;浮点数值不适用于禁止出现舍入误差的计算中。应该使用BigDecimal类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;代码点（code point）是指与一个编码表中的某个字符对应的代码值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;UTF-16编码采用不同长度的编码表示所有Unicode代码点。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;在Java中，char类型用UTF-16编码描述一个代码单元。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;3.4 变量&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;在Java中，每一个变量属于一种类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;在声明变量时，变量所属的类型位于变量名之前。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;变量名必须是一个以字母开头的由字母或数组构成的序列。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;Java中字母和数字的范围更大。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;字母包括‘a’~‘z’、‘A’~‘z’、‘_’、‘$’（只用在Java编译器或其它工具生成的名字中）或在种语言中代表字母的任何Unicode字符。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;数字包括‘0’~‘9’和在某种语言中代表数组的任何Unicode字符。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;不能将变量名命名为Java保留字。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;可以在一行中声明多个变量，不过不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;声明一个变量之后，必须用赋值语句（=）对变量进行显式初始化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;在Java中可以将声明放在代码中的任何地方。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;在Java中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编写风格。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;在Java中，利用关键字final指示常量。习惯上常量名使用全大写。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;3.5 运算符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;算术运算符： +、-、*、/、%。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;使用strictfp关键字标记的方法必须使用严格的浮点计算来产生理想的结果。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;如果将一个类标记为strictfp，这个类中的所有方法都要使用严格的浮点计算。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;自增运算符与自减运算符： ++、--。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;关系运算符与boolean运算符： ==、!=、&amp;lt;、&amp;gt;、&amp;lt;=、&amp;gt;=；&amp;amp;&amp;amp;、||、!。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;三元操作符： ?:。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;位运算符： &amp;amp;、|、~、^。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;数学函数与常量： Math。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;数值类型之间的转换。当使用两个数值进行二元操作时，先要将两个操作数转换为同一种类型，然后再进行计算。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;强制类型转换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;括号与运算符级别。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;枚举类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;3.5 字符串&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;从概念上讲，Java字符串就是Unicode字符序列。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定于类，很自然地叫做String。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;每个用双引号括起来的字符串都是String类的一个实例。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;String类没有提供用于修改字符串的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;equals，检测两个字符串是否相等；==，确定两个字符串是否放置在同一位置上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;空串与Null串。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;代码点与代码单元。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;StringBuilder构建字符串。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;3.7 输入输出&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;标准输出流：System.out.println。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;标准输入流：System.in。Scanner与标准输入流关联。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;格式化输出：标准输出流：System.out.printf。Formattable接口。String.format。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;文件输入：用File对象构造一个Scanner对象。写入文件：PrintWriter。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;3.8 控制流&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;块（即复合语句）是指由一对花括号括起来的若干条简单的Java语句。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;块确定了变量的作用域。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;一个块可以嵌套在另一个块中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;不能在嵌套的两个块中声明同名的变量。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;条件语句：if-else。else部分是可选的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;循环： while（先检测循环条件）、do/while（先执行语句，在检测循环条件。循环体至少执行一次）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;确定循环：for。for语句的3个部分应该对同一个计数器变量进行初始化、检测和更新。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;多重选择：switch语句。case标签可以是：char、byte、short、int、枚举、字符串字面量。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;中断控制流程语句：break、带标签的break、continue。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;标签：用于跳出多重嵌套的循环语句。标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;3.9 大数值&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的而两个很有用的类：BigInteger和BigDecimal。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;这两个类可以处理包含任意长度数字系列的数值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;BigInteger类实现了任意精度的整数运算。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;BigDecimal实现了任意精度的浮点数运算。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;3.10 数组&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;数组是一种数据结构，用来存储同一类型值的集合。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;在声明数组变量时，需要指出数组类型（数据元素类型紧跟[]）和数组变量的名字。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;for each循环，可以用来依次处理数组中的每个元素，而不必为指定下标值而分心。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;在Java中，提供了一种创建数组对象并同时赋予初始值的简化书写形式，不需要调用new。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;在Java中，允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;String args[] 参数标名main方法将接收一个字符串数组，也就是命令行参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;可以使用Arrays类中的sort方法对数值型数组进行排序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;多维数组将使用多个下标访问数组元素。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;Java实际上没有多维数组，只有一维数组。多维数组被解释为“数组的数组”。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;还可以方便地构造一个不规则数组，即数组的每一行有不同的长度。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>对象与类</title>
    <url>/2022/01/12/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%884%EF%BC%89%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;4.1 面向对象程序设计概述&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;一旦确定了这些过程，就要开始考虑存储数据的方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;算法 + 数据结构 = 程序。 算法是第一位的，数据结构是第二位的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;而OOP却调换了这个次序，将数据放在第一位，然后在考虑操作数据的算法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;对于一些规模较小的问题，将其分解为过程的开发方式比较理想。而面向对象更加适用于解决规模较大的问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;类（class）是构造对象的模板或蓝图。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;由类构造（construct）对象的过程称为创建类的实例（instance）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;封装是与对象有关的一个重要概念。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;通过扩展一个类来建立一个新的类的过程称为继承（inheritance）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;对象的三个主要特性：行为、状态、标识。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;传统的过程化程序设计，必须从顶部的main函数开始编写程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;OOP首先从设计类开始，然后再往每个类中添加方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;在类之间，最常见的关系有： 依赖（uses-a）、聚合（has-a）、继承（is-a）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;继承、接口实现、依赖、聚合、关联、直接关联。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;4.2 使用预定义类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;并不是所有类都具有面向对象特征。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;Math类只封装了功能，它不需要也不必隐藏数据。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;要想使用对象，就必须首先构造对象，并指定其初始状态。然后对对象应用方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;在Java程序设计语言中，使用构造器构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;构造器的名字应该与类名相同。new操作符。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;局部变量不会自动地初始化为null，必须通过调用new或将它们设置为null进行初始化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;Data类标识时间点。GregorianCalendar类用来表示日历表示法。扩展类Calendar描述了日历的一般属性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;对实例域做出修改的方法称为更改器方法（mutator method）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;仅访问实例域而不进行修改的方法称为访问器方法（accessor method）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;通常的习惯是在访问器方法名前面加上前缀get，在更改器方法前面加上前缀set。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;4.3 用户自定义类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;要想创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有main方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;使用通配符调用java编译器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;编译时会自动查找依赖的文件进行编译。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;隐式参数（this）与显式参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;基于类的访问权限：一个类的方法可以访问该类的任何一个对象的私有域。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;私有方法private。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;final实例域，构建对象时必须初始化，构建之后不能修改。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;4.4 静态域与静态方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;在绝大多数的面向对象程序设计语言中，静态域被称为类域。术语static只是沿用了C++的叫法，并无实际意义。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;静态常量： static final。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;静态方法是一种不能像对象实施操作的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;可以使用对象调用静态方法。建议使用类名，而不是对象来调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;术语static的历史。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;4.5 方法参数&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;按值调用表示方法接收的是调用者提供的值。按引用调用表示方法接收的是调用者提供的变量地址。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;Java程序设计语言总是采用按值调用。对象引用进行的是值传递。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;4.6 对象构造&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;多个方法有相同的名字、不同的参数，便产生了重载。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋予默认值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;显式域初始化：在类定义中，直接将一个值赋给任何域。（不一定时常量，可以调用方法）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;参数变量用同样的名字将实例域屏蔽起来。this指示隐式参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;构造器调用同一个类的另一个构造器，this。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;初始化块，在一个类的声明中可以包含多个代码块。只要构造类的对象，这些块就会被执行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;在析构器中，最常见的操作是回收分配给对象的存储空间。由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;可以为任何一个类添加finalize方法。将在垃圾回收器清除对象之前调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;4.7 包&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;Java允许使用包（package）将类组织起来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;标准的Java类库分布在多个包中。标准的Java包具有一个层次结构。所有的标准Java包都处于java和javax包层次中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;使用包的主要原因是确保类名的唯一性。Sun建议域名逆序的形式作为包名，并且对于不同的项目使用不同的子包。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;访问另一个包中的共有类： 1. 在每个类名之前添加完整的包名； 2. 使用import语句。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;只能使用*导入一个包。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;import还增加了导入静态方法和静态域的功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;包作用域：可以被同一个包中的所有方法访问。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;4.8 类路径&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;类存储在文件系统的子目录中。类的路径必须与包名匹配。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;类文件也可以存储在JAR文件中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;类路径所列出的目录和归档文件是搜寻类的起始点。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;使用-classpath（或 -cp）选项指定类路径。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;在shell中set CLASSPATH，直到退出shell为止，类路径设置均有效。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;4.9 文档注释&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;javadoc可以由源文件生成一个HTML文档。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;抽取信息： 包、共有类与接口、共有的和受保护的构造器及方法、共有的和受保护的域。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;每个文档注释在标记之后紧跟着自由格式文本。标记由@开始。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;在自由格式文本中，可以使用HTML修饰符。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;没有必要在每一行的开始用*。然而，大部分IDE提供了自动添加*。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;包注释： 1. package.html文件，在body标记之间的所有文本都会被抽取出来； 2. 提供一个package-info.java文件，必须包含javadoc注释。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;抽取：javadoc命令。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;4.10 类设计技巧&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;一定要保证数据私有。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;一定要对数据初始化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;不要在类中使用过多的基本类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;不是所有的域都需要独立的域访问器和域更改器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;将职责过多的类进行分解。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;类名和方法名要能够体现它们的职责。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2022/01/12/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%885%EF%BC%89%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;5.1 类、超类和子类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;关键字extends表明正在构造的新类派生于一个已存在的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;已存在的类称为超类、基类或父类；新类称为子类、派生类或孩子类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;super不是要给对象的引用，不能将super赋给另一个对象变量，它指示一个指示编译器调用超类方法的特殊关键字。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认的构造器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;一个对象变量可以指示多种实际类型的现象被称为多态。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;在运行时能够自动地选择调用哪个方法的现象称为动态绑定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;继承并不仅限于一个层次。由一个公共类派生出来的所有类的集合被称为继承层次。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;有一个用来判断是否应该设计为继承关系的简单规则，就是“is-a”规则，它标名子类的每个对象也是超类的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;is-a规则的另一种表述法是置换法则。它表明程序中出现超累对象的任何地方都可以用子类对象置换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;在Java程序设计语言中，对象变量是多态的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;如果是private方法、static方法、final方法或者构造器，编译器可以准确地知道应该调用哪个方法。静态绑定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;不允许扩展的类被称为final类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;如果在定义类的时候使用了final修饰符就表明这个类是final类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;final类中的所有方法自动地成为final方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;将一个类型强制转换成另外一个类型的过程被称为类型转换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;在进行类型转换之前，先查看一下是否能够成功地转换。instanceof。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;从某种角度看，祖先类更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。abstract。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;除了抽象方法之外，抽象类还可以包含具体数据和具体方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;扩展抽象类由两种选择：1. 将子类标记为抽象类； 2. 定义全部的抽象方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;类即使不含抽象方法，也可以将类声明为抽象类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;抽象类不能被实例化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。protected。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;在实际应用中，要谨慎使用protected属性。（通过派生类可以进行访问）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;受保护的方法更具有实际意义。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;5.2 Object：所有类的超类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;如果没有明确地指出超类，Object就被认为是这个类的超类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;在Java中，只有基本类型不是对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;Object类中的equals方法用于检测一个对象是否等于另外要给对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;在Object类中，这个方法将判断两个对象是否具有相同的引用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;Java语言规范要求equals方法具有：自反性、对称性、传递性、一致性、对于任意非空引用x，x.equals(null)返回false。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;散列码是由对象导出的一个整型值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;如果重新定义equals方法，就必须重新定义hashCode方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;toString方法用于返回表示对象值的字符串。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;5.3 泛型数组列表&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;在许多程序设计语言中，特别是在C语言中，必须在编译时就确定整个数组的大小。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;在Java中，允许在运行时确定数组的大小。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;使用参数类型来增加安全性。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;5.4 对象包装器和自动装箱&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;所有的基本类型都有一个与之对应的类。这些类称为包装器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;对象包装器类时不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;对象包装器类时final，因此不能定义它们的子类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;自动装箱。自动拆箱。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;装箱和拆箱时编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用，虚拟机只是执行这些字节码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;对象包装器另一个好处：可以将某些基本方法放置在包装器中。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;5.5 参数数量可变的方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;Java SE5.0提供了用可变的参数数量调用的方法（...）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;5.6 枚举类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;在比较两个枚举类型的值时，永远不需要调用equals，而直接使用==就可以了。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;可以在枚举类型中添加一些构造器、方法和域。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;所有的枚举类型都是Enum的子类。它们继承了这个类的许多方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;5.7 反射&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;反射库提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵Java代码的程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;获取Class类对象的方法：getClass、Class.forName、.class。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。（int.class）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;虚拟机为每个类型管理一个Class对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;异常有两种类型：未检查异常和已检查异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;对于一个已检查异常，只需要提供一个异常处理器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;反射最重要的内容---检查类的结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;Filed、Method、Constructor分别用于描述类的域、方法和构造器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;利用反射机制可以查看在编译时还不清楚的对象域。Field类中的get方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;Array.newInstance构造新数组。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;反射机制允许调用任意方法。Method.invoke。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;建议仅在必要的时候才使用Method对象，而最好使用接口和内部类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;使用接口进行回调会使得代码的执行速度更快，更易于维护。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;5.8 继承设计的技巧&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;将公共操作和域放在超类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;不要使用受保护的域。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;使用继承实现is-a关系。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;除非所有继承的方法都有意义，否则不要使用继承。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;在覆盖方法时，不要改变预期的行为。 关键在于，在覆盖子类中方法时，不要偏离最初的设计想法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[105,106]},&quot;v&quot;:&quot;使用多态，而非类型信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;不要过多的使用反射。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>接口和内部类</title>
    <url>/2022/01/13/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%886%EF%BC%89%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;6.1 接口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;在Java程序设计语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;接口中的所有方法自动地属于public。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;在实现接口时，必须把方法声明为public。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;接口不是类，不能使用new运算符实例化一个接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;能声明接口的变量，接口变量必须引用实现了接口的类对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;接口中不能包含实例域或静态方法，可以包含常量。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;接口中的域将被自动设为public static final。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;抽象类只能扩展于一个类。接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;6.2 对象克隆&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;当拷贝一个变量时，原始变量与拷贝变量引用同一个对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;clone方法是Object类的一个protected方法。默认的克隆操作是浅拷贝。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Cloneable接口是Java提供的几个标记接口之一。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;6.3 接口与回调&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;由于对象可以携带一些附加的信息，所以传递一个对象比传递一个函数要灵活得多。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;6.4 内部类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;内部类是定义在另一个类中的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;内部类可以对同一个包中的其他类隐藏起来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;嵌套是一种类之间的关系，而不是对象之间的关系。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;嵌套类有两个好处：命名控制和访问控制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;Java内部类还有另外一个功能。内部类的对象有一个隐式引用，它引用了实例化该内部类的外围类对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;内部类是一种编译器现象，与虚拟机无关。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;局部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;局部类有一个优势，即对外部世界可以完全地隐藏起来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;与其他内部类相比较，局部类还可以访问局部变量。不过，那些局部变量必须被声明为final。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;匿名内部类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;匿名类不能有构造器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;静态内部类。使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;只有内部类可以声明为static。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;6.5 代理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;Java SE 1.3 新增加的特性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;要想创建一个代理对象，需要使用Proxy类的newProxyInstance方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;代理类是在程序运行过程中创建的。一旦被创建，就变成了常规类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;所有的代理类都扩展于Proxy类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;所有的代理类都覆盖了Object类中的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;没有定义代理类的名字，Sun虚拟机中的Proxy类将生成一个字符串$Proxy开头的类名。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;对于特定的类加载器和预设的一组接口来说，只能有一个代理类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;代理类一定是public和final。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>图形程序设计</title>
    <url>/2022/01/13/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%887%EF%BC%89%E5%9B%BE%E5%BD%A2%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;7.1 Swing概述&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Java 1.0抽象窗口工具箱AWT。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;基本AWT库采用将处理用户界面元素的任务委派给每个目标平台的本地GUI工具箱的方式，由本地GUI工具箱负责用户界面元素的创建和动作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;将基于对等体的可移植库限制在了最小公分母的范围内。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;1996年，Netscape创建了一种称为IFC（Internet Foundation Class）的GUI库，它采用了与AWT完全不同的工作方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;IFC将按钮、菜单这样的用户界面元素绘制在空白窗口上，而对等体只需要创建和绘制窗口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;因此，Netscape的IFC组件在程序运行的所有平台上的外观和动作都一样。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Sun与Netscape合作完善了这种方式，创建了一个名为Swing的用户界面库。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Swing可库作为Java 1.1 扩展部分使用。现已称为Java SE 1.2标准库的一部分。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;Java基础类库（Java Foundation Class，JFC）十分庞大，特性不仅仅包含了Swing组件，而且还包含了一个可访问性API、一个2D API和一个可拖放API。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Swing没有完全替代AWT，而是基于AWT架构之上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Swing仅仅提供了能力更加强大的用户界面组件。 在采用Swing编写的程序中，还需要使用基本的AWT处理事件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;Swing是指被绘制的用户界面类，AWT是指想事件处理这样的窗口工具箱的底层机制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;在屏幕上显示基于Swing用户界面的元素要比显示AWT的基于对等体组件的速度要慢一些。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;Swing拥有一个丰富、便捷的用户界面元素集合。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;Swing对底层平台依赖的很少，因此于平台相关的bug很少。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;Swing给予不同平台的用户一致的感觉。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;如果在所有平台上用户界面元素看起来都一样，那么它们就有可能与本地控件不一样，而这些平台的用户对此可能不熟悉。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;Swing采用了一种很巧妙的方式来解决这个问题。可以指定专门的观感。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;此外，Sun开发一种称为Metal的独立于平台的观感。Java观感。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;Oracle JavaFX可能会取代Swing。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;7.2 创建框架&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;在Java中，顶层窗口被称为框架。AWT Frame类。Swing JFrame类，扩展于Frame类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;Swing类位于javax.swing包中，报名javax表示这是要给Java扩展包，而不是核心包。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;所有的Swing组件必须由事件分派线程进行配置，线程将鼠标点击和按键控制转移到用户界面组件。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;7.3 框架定位&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;setLocation&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;setBounds&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;setIconImage&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;setTitle&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;setResizable&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;7.4 在组件中显示信息&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;在Java中，框架被设计为放置组件的容器，可以将菜单栏和其他的用户界面元素放置在其中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;在通常情况下，应该在另一组件上绘制信息，并将这个组件添加到框架中。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;7.5 处理2D图形&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;自从Java版本1.0以来，Graphics类就包含绘制直线、矩形和椭圆等方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;Java SE 1.2 引入了Java 2D库，这个库实现了一组功能强大的图形操作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;在1.0的绘制方法中，采用的是整型像素坐标，而Java 2D图形采用的是浮点坐标。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;7.6 使用颜色&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;7.7 文本使用特殊字体&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;7.8 显示图像&quot;}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>事件处理</title>
    <url>/2022/01/13/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%888%EF%BC%89%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;8.1 事件处理基础&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;任何支持GUI的操作环境都要不断地监视按键或点击鼠标这样的事件。操作环境将这些事件报告给正在运行的引用程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;如果有事件产生，每个引用程序将决定如何对它们做出响应。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;对相关的特定事件编写代码，并将这些代码放置在过程中，通过将它们称为事件过程（event procedure）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;每个VB的GUI组件都响应一个固定的事件集，不可能改变VB组件响应的事件集。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;如果使用像原始的C这样的语言进行事件驱动的程序设计，那就需要比那些代码来不断检查事件队列。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Java程序设计环境折中了VB与原始C的事件处理方式，因此，它既有着强大的功能，又具有一定的复杂性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;在AWT所知的事件范围内，完全可以控制事件从事件源到事件监听器的传递过程，并将任何对象指派给事件监听器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;事件源有一些向其注册事件监听器的方法。当某个事件源产生事件时，事件源会向为事件注册的所有事件监听器对象发送一个通告。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;像Java这样的面向对象语言，都将事件的相关信息封装在一个事件对象中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;在Java中，所有的事件对象都最终派生于java.util.EventObject类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;不同的事件源可以产生不同类别的事件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;监听器对象是一个实现了特定监听器接口的类的实例。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;事件源是一个能够注册监听器对象并发送事件对象的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;当事件发生时，事件源将事件对象传递给所有注册的监听器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;监听器对象将利用事件对象中的信息决定如何对象事件做出响应。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;建议使用内部类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;适配器类实现了接口中的所有方法，但每个方法没有做任何事情。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;8.2 动作&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;通常，激活一个命令可以有多种方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;在AWT事件模型中，将所有事件连接到同一个监听器上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;Swing包提供了一种非常实用的机制来封装命令，并将它们连接到多个事件源，这就是Action接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;Action接口扩展于ActionListener接口，可以在任何需要ActionListener对象的地方实用Action对象。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;8.3 鼠标事件&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;8.4 AWT事件继承层次&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;AWT将事件分为低级事件和语义事件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;语义事件是表示用户动作的事件。低级事件是形成那些事件的事件。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>Swing用户界面组件</title>
    <url>/2022/01/13/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/%EF%BC%889%EF%BC%89Swing%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;9.1 Swing和MVC设计模式&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;9.2 布局管理概述&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;9.3 文本输入&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;9.4 选择组件&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;9.5 菜单&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;9.6 复杂的布局管理&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;9.7 对话框&quot;}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷I</category>
      </categories>
  </entry>
  <entry>
    <title>脚本、编译与注解处理</title>
    <url>/2022/01/17/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%8810%EF%BC%89%E8%84%9A%E6%9C%AC%E3%80%81%E7%BC%96%E8%AF%91%E4%B8%8E%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;10.1 Java平台的脚本&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;脚本引擎是要一个可以执行用某种特定语言编写的脚本的类库。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;可以通过在类路径中提供必要的JAR文件来添加对额外的语言支持。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;一旦拥有了引擎，就可以直接调用脚本。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;可以在同一个引擎上调用多个脚本。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;可以通过脚本上下文来重定向脚本的标准输入和输出。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;在使用许多脚本引擎时，都可以调用脚本语言的函数，而不必对处理实际的脚本代码的计算。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;10.2 编译器API&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;编译Java代码的Java程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;有许多工具都需要调用Java编译器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;控制程序代码的来源。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;控制类文件的位置。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;监听在编译过程中产生的错误和警告信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;在后台运行编译器。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;10.3 使用注解&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;注解是那些插入到源代码中使用其他工具可以对其进行处理的标签。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;这些工具可以在源码层次上进行操作，或者可以处理编译器在其中放置了注解的类文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;注解不会改变程序的编译方式。Java编译器对于包含注解和不包含注解的代码会生成相同的虚拟机指令。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;为了能够受益于注解，需要选择一个处理工具，然后向处理工具可以理解的代码中插入注解，之后运用该处理工具处理代码。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;10.4 注解语法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;注解是由注解接口来定义的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;单值注解。value。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;所有的注解接口都隐式地扩展自java.lang.annotation.Annotation接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;注解元素的类型：基本类型、String、Class、enum类型、注解类型、由前面类型组成的数组。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;注解是由编译器计算而来的，所有的元素值必须是编译期常量。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;10.5 标准注解&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;用于编译的注解。@Deprecated、@SuppressWarnings、@Override、@Generated。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;用于资源管理的注解。@PostConstruct、@PreDestroy、@Resource。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;元注解。@Target、@Retention、@Documented、@Inherited。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;10.6 源码级注解处理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;从Java SE6开始，可以将注解处理器添加到Java编译器中。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;10.7 字节码工程&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;在字节码级别上处理注解。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>分布式对象</title>
    <url>/2022/01/17/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%8811%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;11.1 客户与服务器的角色&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;所有分布式编程技术的基本思想都很简单：客户计算机产生一个请求，然后将这个请求通过网络发送到服务器。服务器处理这个请求，并发送回一个针对该客户端的响应，供客户端进行分析。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;代理之间通信：CORBA（通用对象请求代理架构）、SOAP（简单对象访问协议）、RMI（远程方法调用）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;CORBA与SOAP都是完全独立于语言的。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;11.2 远程方法调用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;分布式计算的关键是远程方法调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;当客户代码要在远程对象上调用一个远程方法是，实际上调用的是代理对象上的一个普通的方法，称此代理对象为存根（stub）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;存根位于客户端机器上，而非服务器上，它知道如何通过网络与服务器联系。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;存根会将远程方法所需的参数打包称一组字节。对参数编码的过程称作参数编组，目的是将参数转换成适合在虚拟机之间进行传递的格式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;在RMI协议中，对象是使用序列化机制进行编码的。在SOAP协议中，对象被编码成XML。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;客户端的存根方法构造了一个信息块，包括： 被使用的远程对象的标识符，被调用的方法的描述，编组后的参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;客户端存根对来自服务器端的返回值或异常进行反编组，其结果就成为调用存根的返回值。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;11.3 RMI编程模型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;远程对象的接口必须扩展java.rmi.Remote接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;接口中的方法还必须抛出RemoteException异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;JDK提供了自举注册服务。服务器程序应该使用自举注册服务来注册至少一个远程对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;要注册一个远程对象，需要一个RMI URL和一个对实现对象的引用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;当部署RMI应用时，通常需要动态地将类交付给运行程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;记录RMI活动的日志。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;11.4 远程方法中的参数与返回值&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;在开始进行远程方法调用时，调用参数需要从客户端的虚拟机中移动到服务器的虚拟机中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;在调用完成之后，返回值需要进行反方向传递。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;传递远程对象，远程远程对象的发送者和接收者都将持有一个对同一个实体的引用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;传递非远程对象，对象时可序列化的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;使用RMI的程序应该安装一个安全管理器，去控制动态加载类的行为。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;一个远程类可以实现多个接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;远程对象与equals、hashCode和clone方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;11.5 远程对象激活&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;激活机制允许延迟构造远程对象，仅当至少有一个客户端调用远程对象上的远程方法时，才真正去构造该远程对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;客户端代码完全无需改动，服务器程序需由一个激活程序来代替。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;Activatable类。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>本地方法</title>
    <url>/2022/01/17/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%8812%EF%BC%89%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;12.1 从Java程序中调用C函数&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Java编程语言使用关键字native表示本地方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;函数命名规则。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;运行javah程序，生成函数名。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;要在程序中添加一个对System.loadLibrary方法的调用。使用静态初始化代码块。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;12.2 数值参数与返回值&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Java数据类型与C数据类型的关系。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;12.3 字符串参数&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Java编程语言中的字符串时UTF-16编码点的序列，而C的字符串是以null结尾的字节序列。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Java本地接口由两组操作字符串的函数，一组把Java字符串转换成改良的UTF-8字节序列，一组将它们转换成UTF-16数值的数组。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;12.4 访问域&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;12.5 编码签名&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;将数据类型的名称和方法签名进行混编的规则。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;12.6 调用Java方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;本地方法常常需要从传递给它的对象那里得到某种服务。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;12.7 访问数组元素&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;Java编程语言的所有数组类型都由相对应的C语言类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;12.8 错误处理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;C语言没有异常，必须调用Throw或ThrowNew函数来创建一个新的异常对象。当本地方法退出时，Java虚拟机就会抛出该异常。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;12.8 使用调用API&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;C/C++调用Java代码。调用API（invocation API）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;12.8 完整的实例：访问Windows注册表&quot;}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>流与文件</title>
    <url>/2022/01/13/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%881%EF%BC%89%E6%B5%81%E4%B8%8E%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;1.1 流&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;在Java API中，可以从其中读入一个字节序列的对象称做输入流，而可以向其中写入一个字节序列的对象称做输出流。文件、网络、内存。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;抽象类InputSteam和OutputSteam构成了输入/输出（I/O）类层次结构的基础。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;从抽象类Reader和Writer中继承出来了一个专门用于处理Unicode字符的单独的类层次结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;read和write方法在执行时都将阻塞。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;当完成对流的读写时，应该通过调用close方法来关闭，这个调用会释放掉十分有限的操作系统资源。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;流家族。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;流家族有4个附加的接口：Closeable、Flushable、Readable和Appendable。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;java.io.Closeable接口扩展了java.lang.AutoCloseable接口。因此，对任何Closeable进行操作时，都可以使用try-with-resource语句。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;CharBuffer类拥有按顺序和随机地进行读写访问的方法，它表示一个内存中的缓冲区或者一个内存映像的文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;CharSequence接口描述了一个char值序列的基本属性，String、CharBuffer、StringBuilder和StringBuffer都实现了它。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;由于反斜杠字符在Java字符串中时转义字符，因此要确保在Windows风格的路径名中使用\\。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;在Windows中，还可以使用单斜杠字符（/），会解释成文件分隔符。不推荐。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;对于可移植的程序来说，应该使用程序所运行平台的分隔符。可以同常量字符串java.io.File.separator获得。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;FilterInputStream、FilterOutputSteam。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;可以通过嵌套过滤器来添加多重功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;当多个流链接在一起时，需要跟踪各个中介流。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;1.2 文本输入与输出&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;在存储文本字符串时，需要考虑字符编码方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;OutputStreamWriter类将使用选定的字符编码方式，把Unicode字符流转换为字节流。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;InputStreamReader类将包含字节（用某种字符编码方式表示的字符）的输入流转换为可以产生Unicode码元的读入器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;PrintWriter类拥有以文本格式打印字符串和数字的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;BufferedReader、Scanner。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;在过去，国际化字符集已经得到了处理，但是处理得很不系统，散布在Java类库的各处。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;在Java SE 1.4中引入的java.nio包用Charset类统一了对字符集的转换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;字符集建立了Unicode码元序列与使用本地字符编码方式的字节序列之间的映射。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;Charset类使用的是由IANA字符集注册中心标准化的字符集名字。为了兼容其他的命名惯例，每个字符集都可以拥有许多别名。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;字符集名字是大小写不敏感的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;Charset.forName()。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;1.3 读入和写出二进制数据&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;DataOutput接口对于给定类型的每个值，所需的控件都是相同的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;DataInput。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;随机访问文件。RandomAccessFile类可以在文件中的任何位置查找或写入数据。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;磁盘文件都是随机访问的，但是从网络而来的数据流却不是。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;可以打开一个随机访问文件，只用于读入或同时用于读写。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;RandomAccessFile类同时实现了DataInput和DataOutput接口。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;1.4 ZIP文档&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;ZIP文档以压缩格式存储了一个或多个文件，每个ZIP文档都有一个头，包含诸如每个文件名字和所使用的压缩方法等信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;ZipInputSteam、ZipOutputSteam。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;当Applet的类加载器读入JAR文件时，就是在读入和解压来自网络的数据。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;1.5 对象流与序列化&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;当需要存储相同类型的数据时，使用固定长度的记录格式是一个不错的选择。但是在面向对象程序中创建的对象很少全部都具有相同的类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;Java语言支持一种称为对象序列化的非常通用的机制，它可以将任何对象写出到流中，并在之后将其读回。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;ObjectOutputStream.writeObject、ObjectInputStream.readObject、Serializable接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;当一个对象被多个对象共享。每个对象都是用一个序列号保存的。这就是这种机制之所以称为对象序列化的原因。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;因为序列化用序列号代替了内存地址，所以它允许将对象集合从一台机器传送到另一台机器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;对象序列化是以特殊的文件格式存储对象数据的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;指纹是通过对类、超类、接口、域类型和方法签名按照规范方式排序，然后将安全散列算法（SHA）应用于这些数据而获得的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;SHA是一种可以为较大的信息块提供指纹的快速算法，不论最初的数据块尺寸由多大，这种指纹总是20个字节的数据包。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;transient。防止域被序列化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;序列化机制为单个的类提供了一种方式，去向默认的读写行为添加验证或任何其他想要的行为。 readObject、writeObject。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;readObject和writeObject方法只需保存和加载它们的数据域，而不需要关心超类数据和任何其他类的信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;除了让序列化机制来保存和恢复对象数据，类还可以定义它自己的机制。实现Externalizable接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;所有类型安全的枚举及所有支持单例的类中添加readResolve方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;readResolve方法必须返回一个对象，而该对象之后会称为readObject的返回值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;对象流将拒绝读入具有不同指纹的对象。但是，类可以表明它对早期版本保持兼容。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;JDK单机程序serialver获取。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;类的所有较新版本都必须把serialVersionUID常量定义为与最初版本的指纹相同。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;如果一个类具有名为serialVersionUID的静态数据成员，它就不需要再人工地计算指纹，而只需直接使用这个值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;如果这个类只有方法产生了变化，那么在读入新对象数据时是不会有问题的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;对象流会将这个类当前版本的数据域与流中版本的数据域进行比较（只考虑非瞬时和非静态的数据域）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;直接将对象序列化到输出流中，然后将其读回。这样产生的新对象是对现有对象的一个深拷贝。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;工具SerialCloneable类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;1.6 操作文件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;Path和Files类封装了在用户机器上处理文件系统所需的所有功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;Path和Files是在Java SE 7中新添加进来的类，它们用起来比自JDK 1.0以来就一直使用的File类要方便得多。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;Path表示的是一个目录名序列，其后还可以跟着一个文件名。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;路径中的第一个部件可以是根部件，而允许访问的根部件取决于文件系统。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;以根部件开始的路径是绝对路径；否则，就是相对路径。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;Path： get、resolve、resolveSibling、normalize、toAbsolutePath...&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;Path类有一个toFile方法，而File类也有一个toPath方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;Files类可以使得普通文件操作变得快捷。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;Files： readAllBytes、readAllLines、write、copy、move、delete、createDirectory、createDirectories、createFile...&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;DirectoryStream、FileVisitResult。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;Paths类会在默认文件系统中查找路径，即用户本地磁盘中的文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;也可以有别的文件系统。其中最有用的之一是ZIP文件系统。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;1.7 内存映射文件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;大多数操作系统都可以利用虚拟内存实现来将一个文件或者文件的一部分映射到内存中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;java.nio包使内存映射变得十分简单。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;从文件中获得一个通道，通道是用于磁盘文件的一种抽象，它使我们可以访问诸如内存映射、文件加锁机制以及文件间快速数据传递等操作系统特性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;缓冲区，ByteBuffer。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;缓存区支持顺序和随机数据访问。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;缓存区是由具有相同类型的数值构成的数组。Buffer使一个抽象类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;容量、读写位置、界限、可选的标记。flip、clear、rewind、mark、reset、remaining。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[105,106]},&quot;v&quot;:&quot;FileChannel： lock、tryLock。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;1.8 正则表达式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[108,109]},&quot;v&quot;:&quot;正则表达式用于指定字符串的模式，可以在任何需要定位匹配某种特定模式的字符串的情况下使用正则表达式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[109,110]},&quot;v&quot;:&quot;预定义字符类。java.util.regex.ASCII.*。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[110,111]},&quot;v&quot;:&quot;Pattern、Matcher。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>XML</title>
    <url>/2022/01/15/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%882%EF%BC%89XML/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;2.1 XML概述&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;在许多情况下，想要描述的信息的结构比较复杂，属性文件（Property）不能很方便地处理它。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;属性文件采用的使一种单一的平面层次结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;属性文件要求键使唯一的。如果要存放一个值序列，则需要另一个变通方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;XML能够表示层次结构，并且重复的元素不会被曲解。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;XML和HTML都是古老的标准通用标记语言（Standard Generalized Markup Language， SGML）的衍生语言。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;XML是大小写敏感的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;XML中结束标签不能省略。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;XML中属性值必须用引号括起来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;XML中属性必须都有属性值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;XML文档应当以一个文档头开始。文档头是可选的，但是强烈推荐使用文档头。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;文档头之后是文档类型定义（Document Type Definition，DTD）。文档类型定义的是确保文档正确的一个重要机制，但它不是必需的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;XML文档的正文包含根元素，根元素包含其他元素。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;元素可以有子元素、文本或两者皆有。在设计XML文档结构时，应该避免混合式内容（【可以简化解析过程】）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;何时用元素，何时用属性。一个常用的经验法则是：属性只应该用来修改值的解释，而不是用来指定值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;XML标记： 字符引用、实体引用、CDATA、处理指令、注释。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;2.2 解析XML文档&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;要处理XML文档，就要先解析它。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;解析器是这样一个程序：它读入一个文件，确认这个文件具有正确的格式，然后将其分解成各种元素，使得程序员能够访问这些元素。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;Java库提供了两种XML解析器：树型解析器、流机制解析器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;像文档对象模型（Document Object Model， DOM）解析器这样的树型解析器，它们将读入的XML文档转换成树结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;像XML简单API（Simple API for XML， SAX）解析器这样的流机制解析器，它们在读入XML文档时生成响应的事件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;DOM解析器的接口已经被W3C标准化了。org.w3c.dom包包含了这些接口类型的定义。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;不同的提供者（比如Apache、IBM）都编写了实现这些接口的DOM解析器。Java XML处理API（JAXP）库使得实际上可以以插件形式使用这些解析器中的任意一个。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;JDK中也包含了自己的DOM解析器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;Document、Element、Node。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;2.3 验证XML文档&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;XML解析器的一个很大的好处就是它能自动校验某个文档是否具有正确的结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;如果要指定文档结构，可以提供一个文档类型定义或一个XML Schema定义。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;DTD或schema包含了用于解释文档应如何构成的规则，这些规则指定了每个元素的合法子元素和属性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;与DTD相比，XML Schema可以表达更加复杂的验证条件。与DTD语法不同，Schema使用XML，这为处理Schema文件带来了方便。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;XML Schema语言时设计用来替代DTD的。然而XML Schema很复杂，而且还远没有得到普遍的采纳。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;提供DTD的方式有多种。1.纳入XML文档DOCTYPE声明中。2.存储在外面。SYSTEM声明。指定一个包含DTD的URL。3.来源于SGML的DTD机制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;如果要在文档中引用Schema文件，需要在根元素中添加属性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;Schema使用命名空间定义了每个元素的类型。类型可以是简单类型，即有格式限制的字符串，或者是复杂类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;2.4 使用XPath来定位信息&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;XPath语言使得访问树节点变得很容易。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;XPath可以描述XML文档中的一个节点集。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;Java SE 5.0增加了一个API来计算XPath表达式。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;2.5 使用命名空间&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;Java语言使用包来避免名字冲突。XML也有类似的命名空间机制，可以用于元素名和属性名。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;名字空间是由统一资源标识符（URI）来标识的。HTTP的URL格式是最常用的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;在命名空间的URL所表示的位置上不需要有任何文档，XML解析器不会尝试取该处查找任何东西。人们习惯于将解释该命名空间的文档放在URL位置上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;HTTP URL作为命名空间的标识符容易确保它们是独一无二的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;命名空间本质上是嵌套的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;可以用一个前缀来表示命名空间，即为特定文档选取的一个短的表示符。Java中没有类似的机制。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;2.6 流机制解析器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;如果文档很大，并且处理算法又非常简单，可以在运行时解析节点，而不必看到完整的树形结构。 -- 流机制解析器。SAX、StAX。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;SAX解析器在解析XML输入的组成部分时会报告事件，但不会以任何方式存储文档，而是由事件处理器建立相应的数据结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;实际上，DOM解析器是在SAX解析器的基础上建立起来的，它在接收到解析器事件使建立DOM树。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;在使用SAX解析器时，需要一个处理器来为不同的解析器事件定义事件动作。ContentHandler接口定义了若干个在解析文档时解析器会调用的回调方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;StAX解析器是一种”拉解析器“，与安装事件处理器不同，只需使用基本循环来迭代所有的事件。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;2.7 生成XML文档&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;不带命名空间的文档。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;带命名空间的文档。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;写出文档。XSLT。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;使用StAX写XML文档。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;2.8 XSL转换&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;XSL转换（XSLT）机制可以指定将XML文档转换为其他格式的规则。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;XSLT通常用来将某种机器可读的XML格式转译为另一种机器可读的XML格式，或者将XML转译为适合人类阅读的表示格式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;需要提供XSLT样式表，它描述了XML文档向某种其他格式转换的规则。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>网络</title>
    <url>/2022/01/16/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%883%EF%BC%89%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;3.1 连接到服务器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;telnet。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Java库隐藏了建立网络连接和通过连接发送数据的复杂过程。java.net包提供的编程接口与操作文件时使用的接口基本相同。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;从套接字读取信息时，在有数据可供访问之前，读操作将会被阻塞。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;如果主机不可达，那么应用将要等待很长的时间，并且因为受底层操作系统的限制而最终会导致超时。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;对于不同的应用，应该确定合理的超时值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;如果需要在主机名和因特网地址之间进行切换，那么就可以使用InetAddress类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;3.2 实现服务器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;ServerSocket类用来建立套接字。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;为多了个客户端服务： 循环操作、每一个连接启动一个新的线程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;半关闭提供了这样一种能力： 套接字连接的一端可以终止其输出，同时仍旧可以接收来自另一端的数据。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;可以通过关闭一个套接字的输出流来表示发送给服务器的请求数据已经结束，但是必须保持输入流处于打开状态。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;3.3 可中断套接字&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;当线程因套接字无法相应而发生阻塞时，则无法通过调用interrupt来解除阻塞。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;为了中断套接字操作，可以使用java.nio包提供的一个特性：SocketChannel类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;通道并没有与之相关联的流。实际上，它所拥有的read和write方法都是通过使用Buffer对象来实现的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;将通道转换成输出流。Channels.newOutputStream。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;3.4 获取Web数&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;URL和URLConnection类封装了大量复杂的实现细节，这些细节涉及如何从远程站点获取信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;java.net包对统一资源定位符（URL）和统一资源标识符（URI）做了非常有用的区分。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;在Java类库中，URI类不包含任何用于访问资源的方法，它的唯一作用就是解析。URL类可以打开一个到达资源的流。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;URL类只能作用于那些Java类库直到该如何处理的模式。例如http:、https:、ftp:、file:、jar:。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;URI句法： [scheme:]schemeSpecificPart[#fragment]。绝对URI、相对URI。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;所有绝对的透明URI和所有相对URI都是分层的。分层结构： [//authority][path][?query]。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;对于基于服务器的URI，authority形式： [user-info@]host[:port]。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;URI类的另一个作用是处理绝对标识符和相对标识符。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;如果想从某个Web资源获取更多信息，那么应该使用URLConnection类，通过它能够得到比基本的URL类更多的控制功能。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;3.5 发送E-mail&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;如果要使用JavaMail，需要设置一些和邮件服务器相关的属性。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>数据库编程</title>
    <url>/2022/01/16/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%884%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;4.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;JDBC的版本更新过数次。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;更具Oracle的声明，JDBC是一个已经注册了商标的属于，而并非Java Database Connectivity的首字母缩写。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;4.1 JDBC的设计&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;ODBC（微软，Open Database Connectivity）为C语言访问数据库提供了一套编程接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;JDBC和ODBC都基于同一个思想：根据API编写的程序都可以与驱动管理器进行通信，而驱动管理器则通过程序与实际的数据库进行通信。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;驱动程序： 1. 将JDBC翻译成ODBC； 2. 由部分Java程序和部分本地代码组成； 3. 纯Java客户端类库； 4. 纯Java类库。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;在传统的C/S模式中，通常是在服务器端部署数据库，而在客户端安装内容丰富的GUI界面。在此模型中，JDBC驱动程序应该部署在客户端。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;在三层应用模式中，客户端不直接调用数据库，而是调用服务器上的中间件层，最后由中间件层完成数据库查询操作。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;4.2 结构化查询语言&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;SQL是对所有现代关系型数据库都至关重要的命令行语言，JDBC则使得我们可以通过SQL与数据库进行通信。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;桌面数据库通过图形用户界面直接操作数据。基于服务器的数据库只能使用SQL进行访问。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;4.3 JDBC配置&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;数据库URL。 jdbc:sub-protocol:other stuff&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;驱动程序JAR文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;启动数据库。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;注册驱动器类。包含META-INF/services/java.sql.Driver文件的JAR文件可以自动注册驱动器类。否则Class.forName加载或命令行参数指定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;连接到数据库。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;4.4 执行SQL语句&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;Statement。executeUpdate、executeQuery、execute。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;ResultSet。迭代协议与Iterator接口不同。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;每个Connection对象都可以创建一个或多个Statement对象。同一个Statement对象可以用于多个不相关的命令和查询。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;一个Statement对象最多只能有一个打开的结果集。如果需要执行多个查询操作，且需要同时分析查询结果，那么必须创建多个Statement对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;至少有一种常用的数据库的JDBC驱动程序只允许同时存在一个活动的Statement对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;使用完ResultSet、Statement或Connection对象后，应立即调用close方法。这些对象都使用了规模较大的数据结构和数据库服务器上的有限资源。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;如果Statement对象上有一个打开的结果集，那么调用close方法将自动关闭该结果集。Java SE7 Statement.closeOnCompletion。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;每个SQLException都有一个由多个SQLException对象构成的链，这些对象可以通过getNextException方法获取。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;Java SE6 改进了SQLException类，让其实现了Iterable接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;数据库驱动程序可以将非致命问题作为警告报告，可以从连接、语句和结果集中获取这些警告。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;SQLWarning类是SQLException的子类。SQLWarning不会被当作异常抛出。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;4.5 执行查询操作&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;在预备查询语句中，每个宿主变量都用“?”来表示。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;在执行预备语句之前，必须使用set方法将变量绑定到实际的值上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;在SQL中，二进制大对象称为BLOB，字符型大对象称为CLOB。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;数据库使用的是与数据库相关的语法变体。转义语法转译为特定数据库的语法是JDBC驱动程序的任务之一。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;转义主要用于： 日期和时间字面常量、调用标量函数、调用存储过程、外连接、在LIKE子句中的转义字符。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;标量函数是指仅返回一个值的函数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;存储过程是在数据库中执行的用数据库相关的语言编写的过程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;在执行存储过程，或者在使用允许在单个查询中提交多个SELECT语句的数据库时，一个查询有可能会返回多个结果集。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;尽管JDBC没有提供独立于提供商的自动生成键的解决方法，但是它提供了获取自动生成键的有效途径。Statement.getGeneratedKeys。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;4.6 可滚动和可更新的结果集&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;默认情况下，结果集时不可滚动和不可更新的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;TYPE_FORWARD_ONLY、TYPE_SCROLL_INSENSITIVE、TYPE_SCROLL_SENSITIVE。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;CONCUR_READ_ONLY、CONCUR_UPDATABLE。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;4.7 行集&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;可滚动的结果集有一个重要的缺陷： 在于用户的整个交互过程中，必须始终与数据库保持连接。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;行集RowSet接口扩展子ResultSet接口，无需始终保持与数据库的连接。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;行集还适用于将查询结果移动到复杂应用的其他层，或其他设备中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;java.sql.rowset： CachedRowSet、WebRowSet、FilteredRowSet、JoinRowSet、JdbcRowSet。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;4.8 元数据&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;对于编写数据库工具的程序员来说，数据库的结构信息是极其有用的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;描述数据库或其组成部分的数据称为元数据。关于数据库的元数据、关于结果集的元数据、关于预备语句参数的元数据。DatabaseMetaData。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;4.9 事务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;可以将一组语句构建成一个事务。提交、回滚。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;将多个语句组合成事务的主要原因是为了确保数据库完整性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;默认情况下，数据库连接处于自动提交模式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;在使用某些驱动程序时，使用保存点可以更细粒度地控制回滚操作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;创建一个保存点意味着稍后只需返回到这个点，而非事务的开头。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;可以使用批量更新的方法来提高程序性能。在使用批量更新时，一个语句序列作为一批操作将同时被收集和提交。executeBatch。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;JDBC支持的数据类型及它们在Java语言中对应的数据类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;SQL Array指的是值的序列。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;从数据库中获得一个LOB或数组并不等于获取了它的实际内容，只有在访问具体的值时它们才会从数据库中被读取出来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;某些数据库支持描述行位置的ROWID值，可以非常快捷地获取某一行值。JDBC4 引入了java.sql.RowId接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;国家属性字符串（NCHAR及其变体）按照本地字符编码机制存储字符串，并使用本地排序惯例对这些字符串进行排序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;有些数据库可以存储用户自定义的结构化类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;有些数据库提供用于XML数据的本地存储。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;4.10 Web与企业应用中的连接管理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;在Web或企业环境中部署JDBC应用时，数据库连接管理与Java名字和目录接口（JNDI）是集成在一起的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;必须在某个地方配置数据源。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;数据库连接池。数据库连接在物理上并未被关闭，而是保留在一个队列中并被反复重用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;JDBC规范为实现者提供了用以实现连接池服务的手段。不过，JDK本身并未实现这项服务，数据库供应商提供的JDBC驱动程序中通常也不包含。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;Web容器和应用服务器的开发商通常会提供连接池服务的实现。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>国际化</title>
    <url>/2022/01/16/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%885%EF%BC%89%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;5.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Java编程语言是第一个设计称为全面支持国际化的语言。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;从一开始，它就具备了进行有效的国际化所必需的一个重要特性：使用Unicode来处理所有字符串。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;支持Unicode使得在Java编程语言中，编写程序来操作多种语言的字符串变得异常方便。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;国际化一个程序所要做的事情绝不仅仅是提供Unicode支持。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;5.1 Locales&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Locale类描述了：一种语言、一个位置、一段脚本（可选）、一个变体（可选）、指定诸如方言或拼写规则之类的杂项。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;为了以一种简练而标准的方式来表达语言和位置，Java语言使用的是由国际标准化组织（ISO）所定义的编码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;只要提供了语言代码，或语言与国家代码，就可以构建Locale对象了。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Java SE预定义了大量的Locale对象。还预定义了大量的语言Locale。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Locale类的静态getDefault方法可以获得作为本地操作系统的一部分而存放的默认Locale。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;对于所有依赖Locale的类，可以返回一个它们所支持的Locale数组。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;5.2 数字格式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;NumberFormat。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;数字和货币的格式是高度依赖于Locale的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;Java类库提供了一个格式器对象的集合，可以对java.text包中的数字值进行格式化和解析。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;如果要想读取一个按照某个Locale的惯用法而输入或存储的数字，那么就需要使用parse方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;格式化货币。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;5.3 日期和时间&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;DateFormat。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;parse。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;5.4 排序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;Java语言中的compareTo方法是用Unicode字符来决定顺序的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;Collator。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;可以设置排序器的强度以此来选择不同的排序行为。Collator.PRIMARY/SECONDARY/IDENTICAL。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;Unicode标准对字符串定义了四种范化形式： D、KD、C、KC。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;5.5 消息格式化&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;MessageFormat。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;静态的MessageFormat.format方法使用当前的locale对值进行格式化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;选择格式。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;5.6 文本文件和字符集&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;Java是完全基于Unicode的。但是操作系统一般有它们自己的字符编码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;当把数据保存到一个文本文件中时，应该照顾本地的字符编码。字符编码是在FileWriter的构造器中指定的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;目前，locale和字符编码之间没有任何联系。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;为了使源文件能够到处使用，必须使用普通的ASCII编码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;JDK工具：native2ascii，可以将本地字符编码转换成普通的ASCII。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;5.7 资源包&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;在本地化一个应用时，可能会在外部定义资源（消息字符串、按钮标签和其他的东西）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;在Java中，使用属性文件来设定字符串资源，并为其他类型的资源实现相应的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;当本地化一个应用时，会制造出很多资源包。每一个包都是一个属性文件或者是一个描述了与locale相关的项的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;需要对这些包使用一中统一的命名规则。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;对字符串进行国际化是很直接的，可以把所有字符串放到一个属性文件中。每行存放一个键值对的文本文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;存放属性的文件都是ASCII文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;为了提供字符串以外的资源，需要定义类，它必须扩展自ResourceBundle类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;应该使用标准的命名规则来命名自定义类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;加载。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;5.8 一个完整的例子&quot;}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>高级Swing</title>
    <url>/2022/01/16/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%886%EF%BC%89%E9%AB%98%E7%BA%A7Swing/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;6.1 列表&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;JList构件。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;6.2 表格&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;JTable构件。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;6.3 树&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;JTree类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;6.4 文本构件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;JEditorPane。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;JFormattedTextField。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;JSpinner构件。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;6.5 进度指示器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;JProgressBar构件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;ProgressMonitor。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;6.6 构件组织器和装饰器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;JSplitPane。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;JTabbedPane。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;JDesktopPane。多文档界面。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;JInternalFrame。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;JLayer。Java SE 7。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>高级AWT</title>
    <url>/2022/01/16/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%887%EF%BC%89%E9%AB%98%E7%BA%A7AWT/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;7.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Graphics类有多种方法可以用来创建简单的图形。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Java 2D API是一个更加成熟的类库，可以用它产生高质量的图形。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;7.1 绘图操作流程&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;7.2 形状&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;7.3 区域&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;7.4 笔划&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;7.5 着色&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;7.6 坐标变换&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;7.7 剪切&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;7.8 透明与组合&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;7.9 绘图提示&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;7.10 图像的读取器和写入器&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;7.11 图像处理&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;7.12  打印&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;7.13 剪贴板&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;7.14 拖放操作&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;7.15 平台集成&quot;}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>JavaBean构件</title>
    <url>/2022/01/16/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%888%EF%BC%89JavaBean%E6%9E%84%E4%BB%B6/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;8.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;根据Sun的JavaBean规范，一个bean就是一个可重用的软件构件，并且能够在开发工具中可视化地操作。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;8.1 为何使用Bean&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;JavaBean技术就是为了是Java技术在UI驱动领域也具备竞争力才被开发出来的。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;8.2 编写Bean的过程&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;最简单的Bean与一个Java类没任何区别，只不过其方法采用了某种严格的命名惯例罢了。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;属性与实例的域并不完全相同。属性在概念上比实例域更高一层，它们代表接口的特征，而实例域属于类的实现。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;8.3 使用Bean来构造一个应用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;为了使Bean能够在开发工具中使用，需要将Bean以及它使用到的所有类文件都打包进一个JAR文件。需要一个manifest清单文件。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;8.4 Bean属性与事件的命名模式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;采用标准的命名模式，使用反射机制。get（is）/set方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;提供一个bean的信息类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;8.5 Bean属性的类型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;简单属性。只具有一个单独的值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;索引属性。指定了一个数组。需要提供两对get/set方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;绑定属性。在属性值发生变化时，通知所有相关的监听器。需要提供监听器注册方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;约束属性。受到某种约束。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;8.6 BeanInfo类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;BeanInfo接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;SimpleBeanInfo类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;8.7 属性编辑器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;提供一个单独的构件，用户可以通过它来设定属性值。这样的构件就称为属性编辑器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;简单属性编辑器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;基于GUI的属性编辑器。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;8.8 定制器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;属性编辑器是为了让用户一次设置一个属性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;如果某个bean的特定属性与其他属性有关联时，需要提供一个定制器来取代多个属性编辑器，或者在多个属性编辑器的基础上增加一个定制器。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;8.9 JavaBean持久化&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;JavaBean持久化是指，用JavaBean的属性来将bean存储到流中，并在之后的某个时刻，或者在另一个虚拟机中再将它们读回来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;JavaBean持久化适合于长期存储。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;JavaBean持久化并不局限于Swing构件的存储，可以使用该机制存储任意对象的集合。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>安全</title>
    <url>/2022/01/17/Java/%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A1/%EF%BC%889%EF%BC%89%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;9.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Java技术与其他的语言和系统有所不同，在那些语言和系统中安全是在事后才想到要去实现的，或者仅仅是对破坏的一种应对措施。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;对Java技术来说，安全机制是一个不可分割的组成部分。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Java技术提供了三种确保安全的机制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;语言设计特性（对数组的边界进行检查，无不受检查的类型转换，无指针算法等）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;访问控制机制，用于控制代码能够执行的操作（比如文件访问，网络访问等）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;代码签名，利用该特性，代码的作者就能够用标准的加密算法来认证Java代码。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;9.1 类加载器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Java编译器会为虚拟机转换源指令。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;类加载器： 引导类加载器、扩展类加载器、系统类加载器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;引导类加载器负责加载系统类（rt.jar）。引导类加载器没有对应的ClassLoader对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;扩展类加载器用于从jre/lib/ext目录加载标准的扩展。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;系统类加载器用于加载应用类。在由CLASSPATH环境变量或者-classpath命令行选项设置的类路径中的目录或者是JAR/ZIP文件里查找这些类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;在Oracle的Java语言实现中，扩展类加载器和系统类加载器都是用Java来实现的。它们都是URLClassLoader类的实例。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;类加载器有一种父子关系。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;除了引导类加载器外，每个类加载器都有一个父类加载器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;类加载器倒置。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;每个线程都有一个类加载器的引用，称为上下文类加载器。主线程的上下文类加载器是系统类加载器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;当新线程创建时，它的上下文类加载器会被设置成为创建该线程的上下文类加载器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;在虚拟机中，类是由它的全名和类加载器来确定的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;可以编写自己的用于特殊目的的类加载器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;加密。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;9.2 字节码校验&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;当类加载器将新加载的Java平台类的字节码传递给虚拟机时，这些字节码首先要接受校验器的校验。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;校验器负责检查那些指令无法执行的明显由破坏性的操作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;除了系统类外，所有的类都要校验。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;变量要在使用之前进行初始化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;方法调用与对象引用类型之间要匹配。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;访问私有数据和方法的规则没有被违反。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;对本地变量的访问都落在运行时堆栈内。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;运行时堆栈没有溢出。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;实际上，用Java语言编译器生成的类文件总是可以通过校验的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;校验器总是在防范被故意篡改的类文件，而不仅仅只是检查编译器产生的类文件。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;9.3 安全管理器与访问权限&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;一旦某个类被加载到虚拟机中，并由检验器检查过之后，Java平台的第二种安全机制就会启动，这个机制就是安全管理器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;安全管理器是一个负责控制具体操作是否允许执行的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;创建一个新的类加载器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;退出虚拟机&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;使用反射访问另一个类的成员。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;访问本地文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;打开socket连接。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;启动打印作业。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;访问系统剪贴板。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;访问AWT事件队列。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;打开一个顶层窗口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;在运行Java应用程序时，默认的设置是不安装安全管理器的，这样所有的操作都是允许的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;Java平台的安全管理器，允许对各个安全访问权限实施细致的控制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;JDK 1.0具有一个非常简单的安全模型，即本地类拥有所有的权限，而远程类只能在沙盒里运行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;JDK 1.1，如果远程代码带有可信赖的实体的签名，将被赋予和本地类相同的访问权限。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;从Java SE 1.2开始，Java平台拥有了更灵活的安全机制，它的安全策略建立了代码来源和访问权限集之间的映射关系。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;代码来源是由一个代码位置和一个证书集指定的。代码位置指定了代码的来源。证书的目的是要由某一方来保障代码没有被篡改过。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;权限是指由安全管理器负责检查的任何属性。Java平台支持了许多访问权限类，每个类都封装了特定权限的详细信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;每个类都有一个保护域，它是一个用于封装类的代码来源和权限集合的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;当SecurityManager类需要检查某个权限时，它要查看当前位于调用堆栈上的所有方法的类，然后获得所有类的保护域，并且询问。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;策略管理器要读取相应的策略文件，这些文件包含了将代码来源映射为权限的指令。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;可以将策略文件安装在标准位置上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;默认位置：Java平台主目录java.policy文件； 用户主目录的.java.policy文件。可以在java.security配置文件中修改。或配置显示的策略文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;在安装安全管理器之前，看不到策略文件的作用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;实现自己的权限类，可以继承Permission类，并提供方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;9.4 用户认证&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;Java认证和授权服务（JAAS）包含两部分：认证部分主要负责确定程序使用者的身份，而授权将各个用户映射到相应的权限。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;JAAS是一个可插拔的API，可以将Java应用程序与实现认证的特定技术分离开来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;JAAS还支持UNIX登录、NT登录、Kerberos认证和基于证书的认证。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;一旦用户通过认证，就可以为其附加一组权限。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;9.5 数字签名&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;...&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;9.6 代码签名&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;...&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;9.7 加密&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;...&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>核心技术卷Ⅱ</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis 源码</title>
    <url>/2021/06/24/Java/%E6%BA%90%E7%A0%81/Mybatis%20%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h2 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h2><ul>
<li>SqlSession</li>
<li>Configuration</li>
<li>TypeHandler</li>
<li>Mapper</li>
<li>Interceptor</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>获取SqlSessionFactory。</li>
<li>解析xml配置文件。</li>
<li>通过SqlSessionFactory创建SqlSession。</li>
<li>通过SqlSession获取Mapper。</li>
<li>通过Mapper调用方法。</li>
<li>Mapper为动态代理类，调用InvocationHandler的invoke方法。</li>
<li>通过mapper调用的方法，及mapper的类名，获取MappedStatement，生成MapperMethod。</li>
<li>通过MapperMethod，调用sqlSession的方法进行操作。</li>
<li>sqlSession的操作通过Executor实现。通过CachingExecutor或BaseExecutor中的doXXX执行。</li>
<li>doXXX方法通过Configuration创建StatementHandler，关联ParameterHandler及ResultSetHandler。</li>
<li>插件处理，返回结果。</li>
</ol>
<h3 id="1-获取SqlSessionFactory"><a href="#1-获取SqlSessionFactory" class="headerlink" title="1.获取SqlSessionFactory"></a>1.获取SqlSessionFactory</h3><h3 id="9-SqlSession、Executor"><a href="#9-SqlSession、Executor" class="headerlink" title="9.SqlSession、Executor"></a>9.SqlSession、Executor</h3><p>通过SqlSession调用的方法又调用Executor执行，那SqlSession的作用？ 1. 对外暴露多个重载方法，而对应同一个Executor方法；2. 对Executor方法抛出的异常进行处理。</p>
<pre><code>动态代理 - 接口、类加载器
ognl表达式
mapper 实例化、单例 
Log
TypeDiscriminator
@Select &lt;script&gt; 与不加
</code></pre>
<ol>
<li>属性替换： 每次加载节点，转换为XNode数据时，在XNode构造方法中实现 ${} 属性替换。 即 XNode.evalNode(“”)时。</li>
<li>setting赋值顺寻：</li>
<li>TypeHandler中存储数据：保存在typeHandlerMap中。保存的是实例。如果javaType为null（实现TypeHandler接口 &amp;&amp; 不适用注解  或者手动注册null），则忽略。</li>
<li>TypeHandler配置优先级： xml配置 &gt; 注解 &gt; 泛型（继承BaseHandler），手动使用TypeReference也会检查注解。</li>
<li>cache、cache-ref 只能存在一个且只能配置一份。 ？？？</li>
<li>如果指定了databaseId，则每个sql、statement标签都需要指定databaseId。 ？？？</li>
<li>SelectKey</li>
<li>mapUnderscoreToCamelCase 默认false, 要真正存在一个与它对应的驼峰Bean才生效</li>
</ol>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><ul>
<li><p>org.apache.ibatis.session</p>
</li>
<li><p>typeHandlerRegistry</p>
</li>
<li><p>typeAliasRegistry</p>
</li>
<li><p>interceptorChain</p>
</li>
<li><p>mapperRegister</p>
</li>
<li><p>ScriptMap sqlFragments  解析sql标签的语句</p>
</li>
<li><p>loadedResources<br>  key：     通过mapper标签指定url： url</p>
<pre><code>      通过mapper标签指定resource： resource
      通过mapper解析namespace: `namespace:` + namespace
      通过java类解析：`interface ` + className
      通过java类解析相同名称及路径的xml：`namespace:` + className
</code></pre>
</li>
<li><p>addMapper() / addMappers() -&gt; mapperRegister.addMapper()/addMappers()</p>
</li>
</ul>
<h3 id="BaseBuilder"><a href="#BaseBuilder" class="headerlink" title="BaseBuilder"></a>BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder</li>
<li>Configuration</li>
<li>typeAliasRegistry</li>
<li>typeHandlerRegistry</li>
</ul>
<h3 id="XMLConfigBuilder-extends-BaseBuilder"><a href="#XMLConfigBuilder-extends-BaseBuilder" class="headerlink" title="XMLConfigBuilder extends BaseBuilder"></a>XMLConfigBuilder extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>XPathParser</li>
<li>environment</li>
<li>parse()</li>
</ul>
<h3 id="XPathParser"><a href="#XPathParser" class="headerlink" title="XPathParser"></a>XPathParser</h3><ul>
<li>org.apache.ibatis.parsing</li>
<li>Properties variables</li>
</ul>
<h3 id="ResolverUtil"><a href="#ResolverUtil" class="headerlink" title="ResolverUtil"></a>ResolverUtil<T></h3><ul>
<li><p>org.apache.ibatis.io</p>
</li>
<li><p>定义接口及实现类，进行条件匹配。</p>
</li>
<li><p>定义classloader、matches</p>
</li>
<li><p>根据接口查询、根据注解查询、根据条件查询</p>
</li>
<li><p>解析类有多步操作，用一个属性存储之前的结果，所有操作结束后调用方法返回所有结果。</p>
</li>
<li><p>接口参数后期才能确定，直接把接口作为参数。</p>
</li>
</ul>
<h3 id="TypeAliasRegistry"><a href="#TypeAliasRegistry" class="headerlink" title="TypeAliasRegistry"></a>TypeAliasRegistry</h3><ul>
<li>org.apache.ibatis.type</li>
<li>注册别名，不是匿名类、不是接口、不是成员类</li>
<li>获取注解指定别名</li>
<li>别名转小写</li>
<li>解析别名，不存在根据字符串解析，但不存储。</li>
<li>对基础类型及常用类型的保存。</li>
<li>直接根据类注册，跳过的类类型的判断。</li>
<li>根据别名、字符串注册与其它方式注册 加载类方式不一样，一种是直接通过classloader 加载，另一种通过resource加载。</li>
</ul>
<h3 id="TypeHandlerRegistry"><a href="#TypeHandlerRegistry" class="headerlink" title="TypeHandlerRegistry"></a>TypeHandlerRegistry</h3><ul>
<li>org.apache.ibatis.type</li>
<li>register  Map&lt;Type, Map&lt;JdbcType, TypeHandler<?>>> typeHandlerMap、 Map<Class<?>, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap：<br>  第一步：<pre><code>  1. 查找MappedTypes注解，注册其每一个value。
  2. 判断是否实现TypeReference，若是，注册。
  3. 注册javaType为null。
</code></pre>
  第二步： <pre><code>  1. 查找MappedJdbcTypes注册，注册其每一个value，并判断是否也需要注册jdbcType为null。
  2. 注册jdbcType为null。
</code></pre>
  第三步：<pre><code>  1. 若javaType不为null，则添加到typeHandlerMap。
  2. 以typeHandler.getClass()为key，添加到allTypeHandlersMap。
</code></pre>
  添加方法：<pre><code>  register(TypeHandler);
  register(Class, TypeHandler);
  private register(Type, TypeHandler);  相当于第一个通用处理方法。
  register(TypeReference, TypeHandler);
  register(Class, JdbcType, TypeHandler);
  private register(Type, JdbcType, TypeHandler); 第二个通用处理方法。
  另外支持TypeHandler 以Class为参数，通过getInstance转换， jdbcType不支持String。
  支持String代替Class，通过Resource转换。
  支持包名全部注册。
</code></pre>
</li>
<li>register Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;  jdbcTypeHandlerMap： register(JdbcType, TypeHandler)。</li>
<li>TypeHandler<Object> unknownTypeHandler</li>
<li>Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler</li>
<li>getTypeHandler:</li>
</ul>
<h3 id="MapperRegistry"><a href="#MapperRegistry" class="headerlink" title="MapperRegistry"></a>MapperRegistry</h3><ul>
<li>org.apache.ibatis.binding</li>
<li>Configuration</li>
<li>Map&lt;Class<?>, MapperProxyFactory<?>&gt; knownMappers</li>
<li>addMapper(Class) 最终执行方法</li>
<li>addMappers(String packageName)</li>
<li>addMappers(String packageName, Class superType)</li>
</ul>
<h3 id="MapperProxyFactory"><a href="#MapperProxyFactory" class="headerlink" title="MapperProxyFactory"></a>MapperProxyFactory</h3><ul>
<li>org.apache.ibatis.binding</li>
<li>Class mapperInterface</li>
<li>Map&lt;Method, MapperMethodInvoker&gt; methodCache</li>
</ul>
<h3 id="XMLMapperBuilder-extends-BaseBuilder"><a href="#XMLMapperBuilder-extends-BaseBuilder" class="headerlink" title="XMLMapperBuilder extends BaseBuilder"></a>XMLMapperBuilder extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>parser</li>
<li>MapperBuilderAssistant mapperBuilderAssistant</li>
<li>sqlFragments</li>
<li>parse()</li>
</ul>
<h3 id="MapperAnnotationBuilder"><a href="#MapperAnnotationBuilder" class="headerlink" title="MapperAnnotationBuilder"></a>MapperAnnotationBuilder</h3><ul>
<li>org.apache.ibatis.builder.annotation</li>
<li>configuration</li>
<li>mapperBuilderAssistant</li>
<li>type</li>
<li>解析：<br>  解析Cache: @CacheNamespace<br>  解析CacheRef: @CacheNamespaceRef<br>  解析ResultMap: </li>
</ul>
<h3 id="MapperBuilderAssistant-extends-BaseBuilder"><a href="#MapperBuilderAssistant-extends-BaseBuilder" class="headerlink" title="MapperBuilderAssistant extends BaseBuilder"></a>MapperBuilderAssistant extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>namespace</li>
<li>resource</li>
</ul>
<h3 id="XMLStatementBuilder-extends-BaseBuilder"><a href="#XMLStatementBuilder-extends-BaseBuilder" class="headerlink" title="XMLStatementBuilder extends BaseBuilder"></a>XMLStatementBuilder extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>mapperBuilderAssistant 为XMLMapperBuilder的成员变量</li>
</ul>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li>mapper通过url、resource、class加载，且xml会加载class，class会加载xml，怎么去重<br> 所有的资源都在configuration的loadedResources中保存，加载xml其key为resource路径/url路径，加载class其key为 class.toString(), 通过class加载xml与通过xml加载class 都是通过全限定类名/namespace查询加载，其key相同，为 <code>namespace:</code> + 全限定类名。</li>
<li>加载class -&gt; 先加载xml -&gt; xml加载完查询class加载 —&gt; … 会一直加载下去么<br> class的加载，都需经过mapperRegistry的addMapper()方法， 先行存储加载的class。<br> 通过xml加载后，会根据namespace加载class，并在此判断mapperRegistry中是否已加载该class。</li>
<li>会不会加载完xml找不到对应的class，从而getMapper拿不到实体<br> xml可以加载，mapper拿不到。</li>
<li>getMapper()返回的代理类是每次创建么，如果不是，怎么保存的<br> 不是，因为每次调用的sqlSession是不同的，创建出来的代理的sqlSession为当前sqlSession。</li>
<li>mybatis获取不到接口的参数名，而只能使用param1、param2之类的<br> java在编译的时候，默认不会保留方法名参数，因此无法在运行时获取参数名称。<br> 编译时可以使用-g参数来保留方法名参数。<br> maven在编译时会默认添加-g参数，所以通过maven可以拿到具体方法名参数。</li>
<li>resultMap标签中的type、ofType、javaType、resultType<br> type: resultMap标签的属性，为类的全限定名称，表示返回的结果。<br> ofType：collection标签的属性，表示哪一种类型的集合。<br> javaType：property标签的属性，表示这个属性的类型。<br> resultType：select标签的属性。</li>
<li>XmlMapperBuilder、MapperBuilderAssistant、MapperAnnotationBuilder<br> XMLMapperBuilder、MapperAnnotationBuilder 继承自BaseBuilder，为什么AnnotationMapperBuilder没有呢？<br> XMlMapperBuilder、MapperAnnotationBuilder都定义了MapperBuilderAssistant属性，是抽象公用？<br> 因为除了AnnotationMapperBuilder，其它都是解析xml，BaseBuilder提供了将字符串解析为对象的方法，而注解可以直接使用类型定义。<br> MapperBuilderAssistant相当于工具类，且需要使用BaseBuilder的基础方法。</li>
<li>为什么XML和DAO中的ResultMap不能通用呢？<br> 注解方式ResultMap是通过 类名、方法名、方法参数 拼起来的， 可以通过@Results的id属性指定。<br> XML方式是显示id和namespace拼接的，xml的id必须指定，通过dtd约束。<br> 使用解析后的resultMapId是可以通用的。</li>
<li>MapperProxy中的MapperMethodInvoker与使用函数式接口的区别。<ol>
<li>通过接口能体现出多态的特性。</li>
<li>接口需要在其它地方引用。</li>
</ol>
</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol>
<li>MapperRegistry中config属性只为创建XmlAnnotationBuilder，没有其它使用地方。将其作为全局变量来存储，而不是方法参数带过来。</li>
</ol>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><h4 id="构建方式"><a href="#构建方式" class="headerlink" title="构建方式"></a>构建方式</h4><ol>
<li>通过xml方式<br>将配置信息放在xml中，然后通过加载xml配置文件，使用SqlSessionFactoryBuilder来创建。</li>
<li>通过java代码<br>通过DataSource、 Environment、 TransactionFactory、 Configuration 等类来创建。</li>
<li>通过spring<br>// TODO<br>3.1 通过xml<br>3.2 通过yml</li>
</ol>
<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><pre><code>try (SqlSession session = sqlSessionFactory.openSession()) &#123;
    ...
&#125;
</code></pre>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><pre><code>绑定映射语句的接口。
</code></pre>
<h2 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h2><ul>
<li>properties</li>
<li>settings</li>
<li>typeAliases<ol>
<li>通过typeAlia标签配置</li>
<li>通过package标签及@Alias注解（没有注解时使用Java Bean首字母小写的非限定类名）配置</li>
</ol>
</li>
<li>typeHandlers<ol>
<li>通过typeHandler标签配置</li>
<li>通过package标签</li>
</ol>
</li>
<li>objectFactory 无自动义的情况下使用默认的DefaultObjectFactory.java</li>
<li>plugins<br>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)<br>ParameterHandler (getParameterObject, setParameters)<br>ResultSetHandler (handleResultSets, handleOutputParameters)<br>StatementHandler (prepare, parameterize, batch, update, query)</li>
<li>environments<br>每个environment 包含transactionManager 和 dataSource 配置‘<br>transactionManager 配置事务的提交和回滚规则，使用数据库提供的（type=JDBC），还是自己配置的（type=MANAGED）。</li>
<li>databaseIdProvider</li>
<li>mappers<ol>
<li>通过mapper标签，使用resource/URL/class属性。</li>
<li>通过package标签</li>
</ol>
</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>工厂方法： SqlSessionFactory。MapperProxyFactory。</li>
<li>代理： CachingExecutor（代理控制对象的访问，装饰器增加对象的行为）。RoutingStatementHandler（这里应该可以使用简单工厂）。</li>
<li>责任链： Interceptor。</li>
<li>模板方法： BaseExecutor。</li>
<li>组合： SqlNode。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码</category>
      </categories>
  </entry>
  <entry>
    <title>Spring 源码</title>
    <url>/2022/02/04/Java/%E6%BA%90%E7%A0%81/Spring%20%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件"></a>相关组件</h2><ul>
<li>BeanDefinition，保存表示Bean的配置元信息。</li>
<li>BeanDefinitionReader，从各个配置收集BeanDefinition，如XML、注解等。</li>
<li>BeanDefinitionRegistry，保存BeanDefinition的地方。</li>
<li>BeanFactoryPostProcessor，对BeanDefinition进行一定程序上的修改和替换（如占位符）。</li>
<li>BeanWrapper，</li>
<li>BeanFactory</li>
<li>ApplicationContext</li>
<li>Aware</li>
<li>BeanPostProcessor</li>
</ul>
<h2 id="Bean实例化过程"><a href="#Bean实例化过程" class="headerlink" title="Bean实例化过程"></a>Bean实例化过程</h2><h3 id="容器启动阶段"><a href="#容器启动阶段" class="headerlink" title="容器启动阶段"></a>容器启动阶段</h3><p>开始 -&gt; BeanDefinitionReader（读取配置元信息） -&gt; BeanDefinition -&gt; BeanDefinitionRegistry（BeanFactoryPostProcessor） -&gt; 结束</p>
<h3 id="Bean实例化阶段"><a href="#Bean实例化阶段" class="headerlink" title="Bean实例化阶段"></a>Bean实例化阶段</h3><p>开始 -&gt; 原生Bean实例 -&gt; BeanWrapper -&gt; 检查Aware相关接口 -&gt; BeanPostProcessor前置处理 -&gt; InitializingBean/init-method -&gt; BeanPostProcessor后置处理 -&gt; DisposeBean/destroy-method -&gt; 使用 -&gt; 调用回调销毁接口 -&gt; 结束</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat 源码</title>
    <url>/2022/01/27/Java/%E6%BA%90%E7%A0%81/Tomcat%20%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><ul>
<li>Tomcat具有接受并处理Http请求的能力，所以Tomcat是Http服务器。</li>
<li>Tomcat满足Servlet接口和协议，所以Tomcat是Servlet容器。</li>
<li>Web服务器对应Coyote框架，具体为Connector组件。</li>
<li>Servlet容器对应Catalina容器，具体为Container组件。</li>
<li>Tomcat主要运行JSP和Servlet，处理静态HTML的能力不如Apache服务器。</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>Catalina，Tomcat内部Servlet容器。</li>
<li>Coyote，Tomcat连接框架。</li>
<li>JMX，Java Management Extensions。</li>
</ul>
<h2 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h2><ul>
<li>Bootstrap，Catalina启动加载类。</li>
<li>Catalina，为Catalina容器处理shell命令。</li>
<li>Server(StandardServer)，代表整个Servlet容器，NamingResources最顶层，包含一个或多个Service。</li>
<li>Service(StandardService)，包含一个或多个Connector，共享一个Container，Container处理从Connector来的请求。</li>
<li>Connector，Coyote Connector的实现。</li>
<li>Container，处理请求并相应的对象。实现类按层级为Engine（Servlet引擎）、Host、Context、Wrapper。</li>
<li>Lifecycle，Catalina组件生命周期接口。</li>
<li>PipeLine、Valve，控制和/或修改请求和响应。</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>startup.bat -&gt; catalina.bat -&gt; Bootstrap。</li>
<li>bat中引用的变量，设置的参数，执行的命令等。</li>
<li>Bootstrap类静态加载使用System.getProperty获取数据，而这是启动类，所以应该是命令行参数传递过来的。</li>
<li>Bootstrap使用反射调用Catalina方法原因分析。</li>
<li>解压tomcat\bin\bootstrap.jar。</li>
<li>Bootstrap初始化类加载器，最后通过AccessController.doPrivileged。</li>
<li>初始化了三个类加载。都是URLClassLoader的实例，顺便看一下JVM源码里面的类加载器结构。这块还有Thread.contextClassLoader。</li>
<li>Bootstrap反射调用了Catalina的load、start方法，但是server为null，且无设置地方。分析load方法中的解析server.xml部分。</li>
<li>根据XML中的配置及一些默认配置，对组件进行处理。且每个组件负责其子组件的处理。处理主要包括initial、start。另外还有监听器。</li>
<li>Container组件监听器。</li>
<li>ContextConfig解析context.xml、web.xml。</li>
<li>Pipeline与Valve。</li>
</ol>
<h3 id="1-tomcat启动流程"><a href="#1-tomcat启动流程" class="headerlink" title="1.tomcat启动流程"></a>1.tomcat启动流程</h3><p>   tomcat/bin/startup.bat -&gt; tomcat/bin/catalina.bat -&gt; org.apache.catalina.startup.Bootstrap。<br>   在eclipse中，使用javaw指令。</p>
<h3 id="2-CATALINA-HOME、CATALINA-BASE、JAVA-HOME、jdb、jpda、juli"><a href="#2-CATALINA-HOME、CATALINA-BASE、JAVA-HOME、jdb、jpda、juli" class="headerlink" title="2.CATALINA_HOME、CATALINA_BASE、JAVA_HOME、jdb、jpda、juli"></a>2.CATALINA_HOME、CATALINA_BASE、JAVA_HOME、jdb、jpda、juli</h3><p>   CATALINA_HOME环境变量，应该设置tomcat根目录，而不是tomcat\bin目录。如果没有设置，tomcat只能在tomcat目录和bin目录下执行，其它目录下执行找不到对应的catalina.bat文件。<br>   catalina.bat中引用了JAVA_HOME的环境变量。</p>
<h3 id="3-java-Dproperty-value"><a href="#3-java-Dproperty-value" class="headerlink" title="3.java -Dproperty=value"></a>3.java -Dproperty=value</h3><p>   -D set a system property value。<br>   tomcat可以设置 catalina.home、catalina.base 两个参数。<br>   在Bootstrap中，使用了System.getProperty，set操作是在命令行进行的。<br>   在catalina.bat中，对catalina.home、catalina.base做了判断赋值。</p>
<h3 id="4-Bootstrap使用反射调用Catalina方法，包括new、load、start。"><a href="#4-Bootstrap使用反射调用Catalina方法，包括new、load、start。" class="headerlink" title="4.Bootstrap使用反射调用Catalina方法，包括new、load、start。"></a>4.Bootstrap使用反射调用Catalina方法，包括new、load、start。</h3><p>   通过反射进行解耦。<br>   启动时添加了classpath为tomcat\bin\bootstrap.jar，其中没有Catalina类。通过配置文件，使用ClassLoader加载tomcat\lib\下面的jar。（Bootstrap.initClassLoaders）<br>    1. commonClassLoader做为catalinaClassLoader和shareClassLoader的parent。<br>    2. CatalinaProperties使用静态初始化加载配置文件。<br>    3. 配置文件顺序： 1.命令行指定-Dcatalina.config； 2.tomcat目录tomcat\conf\catalina.properties文件； 3.bootstrap.jar中org.apache.catalina.startup.catalina.properties文件。</p>
<h3 id="5-bootstrap-jar中只使用了几个类"><a href="#5-bootstrap-jar中只使用了几个类" class="headerlink" title="5.bootstrap.jar中只使用了几个类"></a>5.bootstrap.jar中只使用了几个类</h3><p>   Bootstrap 主类<br>   CatalinaProperties 加载配置文件<br>   ClassLoaderFactory 创建类加载器，并指定相应的parent<br>   Constants 常量<br>   SafeForkJoinWorkerThreadFactory<br>   Tool</p>
<h3 id="6-AccessController-doPrivileged"><a href="#6-AccessController-doPrivileged" class="headerlink" title="6.AccessController.doPrivileged"></a>6.AccessController.doPrivileged</h3><p>   Java安全： 沙箱 -&gt; 代码签名 -&gt; 权限 -&gt; 域（系统域、应用域）<br>   使用-Djava.security.SecurityManage开启权限验证。指定policy文件。不指定使用JDK默认的。<br>   AccessController.checkPermission 验证权限，会验证操作栈中每一个栈帧的权限。<br>   AccessController.doPrivileged 验证权限，只在当前栈帧验证，中断栈上验证的操作。<br>   acc AccessControlContext。<br>   tomcat\conf\catalina.policy。</p>
<h3 id="7-URLClassLoader"><a href="#7-URLClassLoader" class="headerlink" title="7.URLClassLoader"></a>7.URLClassLoader</h3><p>   JDK11<br>   null(ClassLoaders.BootClassLoader) -&gt; platform(ClassLoaders.PlatformClassLoader) -&gt; app(ClassLoaders.AppClassLoader)<br>   JDK8<br>   null(BootstrapClassLoader) -&gt; Launch.ExtClassLoader -&gt; Launch.AppClassLoader<br>   CLassLoader: app -&gt; commonLoader -&gt; catalinaLoader、sharedLoader   catalina.parentClassLoader = shared。</p>
<h3 id="8-server-xml-解析"><a href="#8-server-xml-解析" class="headerlink" title="8.server.xml 解析"></a>8.server.xml 解析</h3><p>   org.apache.tomcat.util.digeter包。<br>   Digester[Rules, ArrayStack, SAXPaser、XMLReader]。<br>   digester.parse -&gt; getXMLReader(设置handler，DTDHandler、ContentHandler、EntityResolver、ErrorHandler) -&gt; xmlReader.parse -&gt; 解析xml，调用各种handler处理 -&gt; 根据标签信息，获取对应的rule -&gt; 调用rule创建对象、设置属性、调用方法等。</p>
<h3 id="9-Lifecycle"><a href="#9-Lifecycle" class="headerlink" title="9.Lifecycle"></a>9.Lifecycle</h3><p>状态：New、Initializing、Initialized、Starting_Prep、Starting、Started、Stop_Prep、Stopping、Stopped、Destroying、Destroyed、Failed。<br>事件：before_init、after_init、start、before_start、after_start、stop、before_stop、after_stop、before_destroy、after_destroy、periodic、configure_start、configure_stop。<br>StandardServer初始化：StandardService初始化。<br>StandardService初始化：Connector初始化，Container初始化。<br>…</p>
<h3 id="10-Container组件监听器"><a href="#10-Container组件监听器" class="headerlink" title="10.Container组件监听器"></a>10.Container组件监听器</h3><p>EngineConfig:<br>HostConfig:<br>ContextConfig:</p>
<h3 id="11-解析context-xml、web-xml"><a href="#11-解析context-xml、web-xml" class="headerlink" title="11.解析context.xml、web.xml"></a>11.解析context.xml、web.xml</h3><p>context.xml: config/context.xml +&gt; EngineName/HostName/context.xml.default +&gt; META-INF/context.xml。<br>web.xml: config/web.xml +&gt; EngineName/HostName/web.xml.default +&gt; WEB-INF/web.xml +&gt; WEB-INF/lib/!jar/META-INF/web-fragment.xml。</p>
<h3 id="12-Pipeline与Valve"><a href="#12-Pipeline与Valve" class="headerlink" title="12. Pipeline与Valve"></a>12. Pipeline与Valve</h3><p>对request处理 -&gt; 调用getNext().invoke() -&gt; 对response处理。<br>如果valve不通过，则不调用getNext().invoke()。<br>pipeline中只保存了第一个valve，而valve之间使用责任链的方式进行处理。<br>每个Container中都有一个basicValve，用来处理下级容器的valve，直到WrapperValve处理Servlet。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>模板方法：LifecycleBase。</li>
<li>简单工厂：ApplicationFilterChain。</li>
<li>责任链：Valve、FilterChain。</li>
<li>观察者：Lifecycle、LifecycleEvent、LifecycleListener。</li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>加载web.xml，loadOnStartUp。</li>
<li>封装Servlet，Request、Response。</li>
<li>tomcat配置，context标签。</li>
<li>生命周期接口。</li>
<li>Web容器、Servlet容器实现区分。</li>
<li>tomcat架构图/server.xml配置文件的理解。</li>
<li>NIO的使用。</li>
</ul>
<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><ul>
<li>org.apache.catalina  org.apache.tomcat</li>
<li>tomcat maven插件与tomcat-embeded版本有什么区别</li>
<li>tomcat maven插件配置完启动的tomcat是在哪里<ol>
<li>添加tomcat maven插件后在依赖里并没有相关的包。</li>
<li>将依赖下载的jar包解压，找到pom文件，里面依赖的是tomcat-embeded等。jar包比spring-boot-starter-tomcat中依赖的tomcat jar包要多。</li>
<li>解压包里面有一些配置文件，使用的还是tomcat本身的配置文件，而tomcat-embeded里面没有找到。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>源码</category>
      </categories>
  </entry>
  <entry>
    <title>盲区</title>
    <url>/2021/11/30/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%9B%B2%E5%8C%BA/</url>
    <content><![CDATA[<h2 id="1-1-抽象过程"><a href="#1-1-抽象过程" class="headerlink" title="1.1 抽象过程"></a>1.1 抽象过程</h2><ul>
<li>面向对象与面向过程的区别。 函数调用/对象。</li>
</ul>
<h2 id="1-2-抽象数据类型"><a href="#1-2-抽象数据类型" class="headerlink" title="1.2 抽象数据类型"></a>1.2 抽象数据类型</h2><ul>
<li>在面向对象程序设计中，使用class表示数据类型。即数据类型和类是等价的。</li>
<li>字段：数据成员；方法： 成员函数。 成员 = 字段+函数+内部类？</li>
</ul>
<h2 id="2-8-javadoc"><a href="#2-8-javadoc" class="headerlink" title="2.8 javadoc"></a>2.8 javadoc</h2><ul>
<li>自动生成文档，使用方面比源码更加方便。</li>
</ul>
<h2 id="3-操作符"><a href="#3-操作符" class="headerlink" title="3 操作符"></a>3 操作符</h2><ul>
<li>除了“=”可用于对象，“+=”、“=”可用于字符串。其它情况都是基本数据类型。</li>
<li>使用操作符会自动提升类型。</li>
<li>操作符优先级建议使用括号来明确表示。</li>
</ul>
<h2 id="5-4-this"><a href="#5-4-this" class="headerlink" title="5.4 this"></a>5.4 this</h2><ul>
<li>必须使用this情况： 1. 构造器初始化变量名区分； 2. return this;； 3. 构造器调用其它构造器； 4. this作为参数； 5. 泛型方法显式类型说明。</li>
</ul>
<h2 id="5-5-垃圾回收器"><a href="#5-5-垃圾回收器" class="headerlink" title="5.5 垃圾回收器"></a>5.5 垃圾回收器</h2><ul>
<li>自适应的、分代的、停止-复制、标记-清除 式垃圾回收器。</li>
<li>垃圾回收本身也有开销。</li>
</ul>
<h2 id="5-6-成员初始化"><a href="#5-6-成员初始化" class="headerlink" title="5.6 成员初始化"></a>5.6 成员初始化</h2><ul>
<li>自动初始化，在调用构造器之前进行。</li>
<li>每个对象都有相同的初值。</li>
</ul>
<h2 id="5-8-数组"><a href="#5-8-数组" class="headerlink" title="5.8 数组"></a>5.8 数组</h2><ul>
<li>Java不允许下标越界，通过每次在访问数组的时候检查边界实现。检查是需要开销的。</li>
</ul>
<h2 id="5-10-速度"><a href="#5-10-速度" class="headerlink" title="5.10 速度"></a>5.10 速度</h2><ul>
<li>Java 的速度问题是涉足某些特定编程领域的障碍。</li>
</ul>
<h2 id="6-1-CLASSPATH"><a href="#6-1-CLASSPATH" class="headerlink" title="6.1 CLASSPATH"></a>6.1 CLASSPATH</h2><ul>
<li>运行时通过参数指定CLASSPATH或者通过环境变量配置。</li>
</ul>
<h2 id="6-2-protected"><a href="#6-2-protected" class="headerlink" title="6.2 protected"></a>6.2 protected</h2><ul>
<li>protected处理的是继承的概念。也提供了包访问权限。</li>
</ul>
<h2 id="6-3-封装"><a href="#6-3-封装" class="headerlink" title="6.3 封装"></a>6.3 封装</h2><ul>
<li>访问权限的控制常被称为是具体实现的隐藏。把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作封装。其结果是一个同时带有特征和行为的数据类型。</li>
</ul>
<h2 id="7-8-final"><a href="#7-8-final" class="headerlink" title="7.8 final"></a>7.8 final</h2><ul>
<li>private方法被隐式声明为final。</li>
</ul>
<h2 id="7-9-初始化顺序"><a href="#7-9-初始化顺序" class="headerlink" title="7.9 初始化顺序"></a>7.9 初始化顺序</h2><ul>
<li>基类 static - 导出类 static - 初始化 - 基类构造器 - 导出类构造器 - 实例变量 - 其余部分。</li>
<li>构造器也是static方法。</li>
</ul>
<h2 id="8-2-动态绑定"><a href="#8-2-动态绑定" class="headerlink" title="8.2 动态绑定"></a>8.2 动态绑定</h2><ul>
<li>Java中除了static方法和final方法外，其他的所有方法都是后期绑定，且会自动发生。</li>
<li>想要实现动态绑定，就必须具有某种机制，在运行时判断对象的类型。</li>
</ul>
<h2 id="8-3-构造器和多态"><a href="#8-3-构造器和多态" class="headerlink" title="8.3 构造器和多态"></a>8.3 构造器和多态</h2><ul>
<li>准则：构造器只用来初始化，避免调用其它方法。</li>
</ul>
<h2 id="8-4-协变返回类型"><a href="#8-4-协变返回类型" class="headerlink" title="8.4 协变返回类型"></a>8.4 协变返回类型</h2><ul>
<li>在导出类的被覆盖方法可以返回基类的返回类型的某种导出类型。</li>
</ul>
<h2 id="9-2-包访问权限接口"><a href="#9-2-包访问权限接口" class="headerlink" title="9.2 包访问权限接口"></a>9.2 包访问权限接口</h2><ul>
<li>实现包访问权限的接口，其方法必须声明为public。</li>
</ul>
<h2 id="9-7-接口中的域"><a href="#9-7-接口中的域" class="headerlink" title="9.7 接口中的域"></a>9.7 接口中的域</h2><ul>
<li>如果是常量或常量表达式，则在类加载阶段赋值并放入常量池。如果是非常量表达式，则在类初始化阶段赋值。</li>
</ul>
<h2 id="9-8-嵌套接口"><a href="#9-8-嵌套接口" class="headerlink" title="9.8 嵌套接口"></a>9.8 嵌套接口</h2><ul>
<li>实现了一个private接口的内部类，同样可以被实现为public类，但是只能被其自身所使用。</li>
<li>实现一个private接口只是一种方式，强制该接口中的方法定义不要添加任何类型信息（不允许向上转型）。</li>
<li>返回对private接口的引用的public方法，只有以各种方式可用，就是将返回值交给有权使用它的对象。</li>
</ul>
<h2 id="11-13-Foreach与迭代器"><a href="#11-13-Foreach与迭代器" class="headerlink" title="11.13 Foreach与迭代器"></a>11.13 Foreach与迭代器</h2><ul>
<li>Iterable接口被foreach用来在序列中移动。</li>
</ul>
<h2 id="12-9-异常的限制"><a href="#12-9-异常的限制" class="headerlink" title="12.9 异常的限制"></a>12.9 异常的限制</h2><ul>
<li>当覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常。</li>
<li>异常限制对构造器不起作用。</li>
<li>派生类构造器的异常说明必须包含基类构造器的异常说明。</li>
<li>派生类构造器不能捕获基类构造器抛出的异常。</li>
<li>强制派生类遵守基类方法的异常说明。</li>
<li>派生类方法可以不抛出异常，即使它是基类所定义的异常。</li>
<li>异常说明本身并不属于方法类型的一部分，因此不能基于异常说明来重载方法。</li>
</ul>
<h2 id="14-3-instance-of-isInstance-isAssignableFrom"><a href="#14-3-instance-of-isInstance-isAssignableFrom" class="headerlink" title="14.3 instance of|isInstance|isAssignableFrom"></a>14.3 instance of|isInstance|isAssignableFrom</h2><ul>
<li>instance of 只能与命名类型比较，无法比较class对象。</li>
<li>isInstance动态测试对象是否是该类实例。</li>
<li>isAssignableFrom 针对子类class与父类class。</li>
</ul>
<h2 id="15-2-元组"><a href="#15-2-元组" class="headerlink" title="15.2 元组"></a>15.2 元组</h2><ul>
<li>元组（数据传送对象、信使）：将一组对象直接打包存储于其中的一个单一对象。这个对象容器允许读取其中元素，但是不允许向其中存放新的对象。</li>
</ul>
<h2 id="15-4-泛型方法"><a href="#15-4-泛型方法" class="headerlink" title="15.4 泛型方法"></a>15.4 泛型方法</h2><ul>
<li>泛型推断只对赋值操作有效。 JAVA SE7？</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2021/12/13/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8810%EF%BC%89%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;10.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;可以将一个类的定义放在另一个类的定义内部，这就是内部类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;10.1 创建内部类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;在外部类方法中使用内部类，与使用普通类没什么不同。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;外部类有一个方法，该方法返回一个指向内部类的引用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，必须具体地指明这个对象的类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;10.2 链接到外部类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;内部类拥有其外围类的所有成员的访问权。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;构建内部类对象时，需要一个指向其外围类对象的引用。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;10.3 使用.this与.new&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;必须使用外部类的对象来创建内部类的对象。在new表达式中提供对外部类对象的引用。这也解决了内部类名字作用域的问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;如果创建嵌套类（静态内部类），不需要对外部类对象的引用。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;10.4 内部类与向上转型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;当将内部类向上转型为其基类，尤其时转型为一个接口的时候，内部类就有了用武之地。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;内部类（某个接口的实现）能够完全不可见，并且不可用，所得到的只是指向基类或接口的引用，所以能够很方便的隐藏实现细节。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;10.5 在方法和作用域内的内部类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;理由： 1. 实现了某类型的接口，可以创建并返回对其的引用。 2. 解决复杂的问题，创建一个类来辅助解决方案，且不希望这个类是公共可用的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;在方法的作用域内创建一个完整的类，被称作局部内部类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;可以在任意的作用域（{}）内嵌入一个类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;10.6 匿名内部类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;将返回值的生成与表示这个返回值的类的定义结合在一起，且这个类是匿名的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;匿名内部类基类需要一个有参数的构造器，只需简单地传递合适的参数给基类的构造器即可。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;匿名内部类末尾的分号，并不是用来标记此内部类结束的，标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;在匿名内部类中定义字段是，还能够对其执行初始化操作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;匿名类中不可能有命名构造器，但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果。限制：不能重载实例初始化方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。如果是实现接口，也只能实现一个接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;匿名内部类实现工厂： 1. 产品构造器私有化； 2. 将工厂声明为产品的static域； 3. 使用匿名内部类实例化工厂。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;10.7 嵌套类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为嵌套类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;要创建嵌套类的对象，并不需要其外围类的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;不能从嵌套类的对象中访问非静态的外围类对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;普通的内部类不能有static成员，也不能包含嵌套类。但是嵌套类可以包含这些。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;在一个普通的内部类中，通过一个特殊的this引用可以链接到其外围类对象。嵌套类没有这个特殊的this引用，使得它类似于一个static方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;嵌套类可以作为接口的一部分。如果想创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;一个内部类能透明地访问所有它嵌入的外围类的成员。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;10.8 为什么需要内部类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;每个内部类都能独立的继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;内部类允许继承多个非接口类型（类或抽象类）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;内部类特性：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[53,54],&quot;index&quot;:1},&quot;v&quot;:&quot;1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[54,55],&quot;index&quot;:2},&quot;v&quot;:&quot;2. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[55,56],&quot;index&quot;:3},&quot;v&quot;:&quot;3. 创建内部类对象的时刻并不依赖于外围类对象的创建。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[56,57],&quot;index&quot;:4},&quot;v&quot;:&quot;4. 内部类并没有“is-a”关系，它就是一个独立的实体。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。 -- 内部类是面向对象的闭包。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;通过内部类提供的闭包功能实现回调，比指针更灵活、更安全。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;回调的价值在于灵活性，可以在运行时动态地决定需要调用什么方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;应用程序框架是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，已解决特定问题。 -- 模板方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统称为事件驱动系统。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;内部类允许： 1. 控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。 2. 内部类能够很容易地访问外围类的任意成员，所以可以避免这种实现变的笨拙。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;命令模式。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;10.9 内部类的继承&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类时，必须使用外围类对象调用super，才能提供必要的引用。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;10.10 内部类可以被覆盖吗&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;当继承了某个外围类时，内部类并没有发生变化，子类的内部类与基类的内部类是连个完全独立的实体，各自在自己的命名空间内。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;继承某个外围类的时候，可以明确地继承某个内部类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;10.11 局部内部类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;局部内部类不能有访问说明符，因为它不是外围类的一部分。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;局部内部类可以访问当前代码块内的常量，以及此外围类的所有成员。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;使用局部内部类而不使用匿名内部类的理由： 1. 需要一个已命名的构造器，或需要重载构造器； 2. 需要不止一个该内部类的对象。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;10.12 内部类标识符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;规则： 外围类名字 + “$” + 内部类的名字。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;编译器为匿名内部类产生一个数字作为其标识符。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;10.13 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;比起面向对象编程中其他概念来说，接口和内部类更深奥复杂。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>本章有几个概念，外部类、外围对象、外围类，感觉傻傻分不清。不知道是不是翻译的问题，为什么用的名词不统一。</li>
<li>内部类的具体使用场景需要慢慢感受。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>持有对象</title>
    <url>/2021/12/14/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8811%EF%BC%89%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;11.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;如果一个程序只包含固定数量且生命周期都是已知的对象，那么这是一个非常简单的程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;需要在任意时刻和任意位置创建任意数量的对象。所以，就不能依靠创建命名的引用来持有每一个对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Java实用类库提供了一套相当完整的容器类来保存对象，其中基本的类型是List、Set、Queue和Map。这些对象类型称为容器。容器提供了完善的方法来保存对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Java容器类都可以自动地调整自己的尺寸。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;即使在Java中没有关键字支持，容器类仍旧是可以显著增强编程能力的基本工具。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;11.1 泛型和类型安全的容器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;使用Java泛型来创建类会非常复杂。但是，应用预定义的泛型通常会很简单。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;通过使用泛型，可以在编译器放置将错误类型的对象放置到容器中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;当指定了某个类型作为泛型参数时，并不仅限于只能将该确切类型的对象放置到容器中。向上转型也可以像作用于其他类型一样作用于泛型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;11.2 基本概念&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;Java容器类类库的用途是“保存对象”，并将其划分为两个不同的概念：Collection 和 Map。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Collection，一个独立元素的序列，这些元素都服从一条或多条规则。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;Map，一组成对的“键值对”对象，使用键查找值。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;11.3 添加一组元素&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;java.util.Arrays、Collections类中有很多实用方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;Arrays.asList() 方法接受一个数组或是元素列表（可变参数），并将其转换为一个List对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;Collections.addAll() 方法接受一个Collection对象，以及一个数组或是元素列表，将元素添加到Collection中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;Collection的构造器可以接受另一个Collection，用它来将自身初始化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;Arrays.asList() 方法的限制是对所产生的List的类型做出了最理想的假设。可以添加显式类型参数说明。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;Map除了用另一个Map之外，Java标准库没有提供其他任何自动初始化的方式。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;11.4 容器的打印&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;默认的打印行为（使用容器提供的toString()方法）即可生成可读性很好的结果。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;Collection打印出来的内容用方括号括住，每个元素由逗号分隔。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;Map打印出来的内容用大括号括住，键与值由等号联系。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;11.5 List&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;List可以将元素维护在特定的序列中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;List接口在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;ArrayList，长于随机访问元素，但是在List的中间插入和移除元素时较慢。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;LinkedList，通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问。它的特性集较ArrayList更大。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;方法：contains、remove、equals、indexOf、subList、containsAll、retainAll、removeAll、set、replace、addAll、isEmpty、clear、toArray。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;11.6 迭代器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;任何容器类，都必须由某种方式可以插入元素并将它们再次取回。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端不必知道或关系该序列底层的结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;迭代器通常被称为轻量级对象：创建它的代价小。因此迭代器有些限制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;Java中的Iterator只能单向移动。使用iterator()要求容器返回一个Iterator。只有next、hasNext、remove功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;如果只是遍历，而不打算修改容器本身，foreach语法更加简洁。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;接受对象容器并传递它，从而在每个对象上都执行操作，这种思想十分强大。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;remove是“可选”方法，即不是所有的Iterator实现都必须实现该方法。但是，标准Java类库实现了remove()。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;迭代器统一了对容器的访问方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;ListIterator是一个更加强大的Iterator的子类型，只能用于各种List的访问。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;ListIterator可以双向移动。产生相对于迭代器在列表中指向当前位置的前一个和后一个元素的索引。可以使用set方法替换访问过的最后一个元素。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;通过调用listIterator方法产生ListIterator，还可以指定开始位置。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;方法： hasNext、next、hasPrevious、previous、listIterator。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;11.7 LinkedList&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;LinkedList和ArrayList一样实现了基本的List接口，执行插入和移除时比ArrayList更高效，随机访问操作方面效率低&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;LinkedList还添加了可以使其作为栈、队列或双端队列的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;这些方法中有些彼此之间只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;getFirst、element、peek、removeFirst、remove、removeLast、poll、addFirst、add、addLast。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;11.8 Stack&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;栈通常是指后进先出（LIFO）的容器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;LinkedList具有能够直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;方法： push、peek、pop。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;java.util.Stack 已过时。 只需要栈的行为，但是继承了Vector使得栈具有了其他方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;11.9 Set&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;Set不保存重复的元素。最常被使用的是测试归属性（HashSet）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;Set具有与Collection完全一样的接口，因此没有额外的功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;HashSet使用散列，TreeSet将元素存储在红黑树数据结构中，LinkedHashSet使用散列，并用链表维护元素顺序。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;11.10 Map&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;将对象映射到其他对象的能力是一种解决编程问题的杀手锏。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;Map与数组和其他的Collection一样，可以很容易扩展到多维。只需将其值设置为Map。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;很容易地将容器组合起来从而快速生成强大的数据结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;Map可以返回它的键的Set，值的Collection，或者它的键值对的Set。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;11.11 Queue&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;队列是一个典型的先进先出（FIFO）的容器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;队列在并发编程中特别重要。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;优先级队列声明下一个弹出元素是最需要的元素（具有最高的优先级）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;11.12 Collection与Iterator&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;Collection是描述所有序列容器的共性的跟接口，它可能会被认为是一个“附属接口”，即因为要表示其他若干个接口的共性而出现的接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;java.util.AbstractCollection类提供了Collection的默认实现。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;针对接口而非具体实现来编写代码，可以应用于更多的对象类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;在Java中，用迭代器而不是Collection来表示容器之间的共性。但是这两种方法绑定到了一起，因为实现Collection就意味着需要提供iterator()方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;Collection是Iterable类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;11.13 Foreach与迭代器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;foreach语法可用于数组，也可应用于任何Collection对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;Java SE5引入了新的Iterable接口，包含一个能够产生Iterator的iterator方法，并且Iterable接口被foreach用来在序列中移动。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;创建了任何实现Iterable的类，都可以将它用于foreach语句中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;不存在任何数组到Iterable的自动转换，必须手工执行转换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;适配器，提供多种使用foreach的方式。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;11.14 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;Java提供了大量持有对象的方式。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>通过异常处理错误</title>
    <url>/2021/12/15/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8812%EF%BC%89%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;12.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Java的基本理念是“结构不佳的代码不能运行”。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;发现错误的理想时机是在编译阶段。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。这就需要错误源能通过某种方式，把适当的信息传递给某个接收者，该接收者将知道如何正确处理这个问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;改进的错误恢复机制是提供代码健壮性的最强有力的方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;Java的主要目标之一是创建供他人使用的程序构件。Java使用异常来提供一致的错误报告模型，使得构件能够与客户端代码可靠地沟通问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Java中的异常处理的目的在于通过使用少于目前数量的代码来简化大型、可靠的程序的生成。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;异常处理是Java中唯一正式的错误报告机制，并且通过编译器强制执行。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;12.1 概念&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;C以及其他早期语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的基础之上，而并不属于语言的一部分。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;通常会返回某个特殊值或者设置某个标志，并且假定接收者将对这个返回值或标志进行检查，以判定是否发生了错误。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;用强制规定的形式来消除错误处理过程中随心所欲的因素。往往能够降低错误处理代码的复杂度。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;把“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;12.2 基本异常&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;异常情形是指阻止当前方法或作用域继续执行的问题。普通问题是指在当前环境下能得到足够的信息，总能够处理这个错误。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;当抛出异常后，首先，将使用new在堆上创建异常对象；然后，当前的执行路径被终止，从当前环境中弹出对异常对象的引用，异常处理机制接管程序，执行异常处理程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;异常处理程序的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;创建一个代表错误信息的对象，并且将它从当前环境中抛出，把错误信息传播到更大的环境中，这被称为抛出一个异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;异常允许强制程序停止运行，并报告出现了什么问题，或者强制程序处理问题，并返回到稳定状态。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;标准异常构造器： 默认构造器；接受字符串作为参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;使用new创建了异常对象之后，此对象的引用将传给throw。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;可以简单地把异常处理堪称一种不同的返回机制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;能够抛出任意类型的Throwable对象，它使异常类型的根类。通常，对于不同类型的错误，要抛出相应的异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;错误信息可以保存在异常对象或者用异常类的名称来暗示。通常，异常对象中仅有的信息就是异常类型，除此之外不包含任何有意义的内容。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;12.3 捕获异常&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;监控区域使一段可能产生异常的代码，并且后面跟着处理这些异常的代码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;如果在方法内部抛出了异常，且不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。这个块称为try块。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;对于不支持异常处理的程序语言，要想仔细检查错误，就得在每个方法调用的前后加上设置和错误检查的代码，甚至在每次调用同以方法时也得这么做。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;有了异常处理机制，可以把所有哦动作放在try块里，然后只需在一个地方就可以捕获所有异常。这意味着程序更容易编写和阅读。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;抛出的异常必须在某处得到处理，这个地点就是异常处理程序。而且针对每个要捕获的异常，得准备相应的处理程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;异常处理程序紧跟在try块之后，以关键字catch表示。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;在try块内部，许多不同的方法调用可能会产生类型相同的异常，只需要提供一个针对此类型的异常处理程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;异常处理理论上由两种基本模型： 终止模型、恢复模型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;Java支持终止模型。程序无法返回到异常发生的地方继续执行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;恢复模型意思是异常处理程序的工作时修正错误，然后重新尝试调用出问题的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;Java实现类似恢复的行为：遇见错误时不能抛出异常，而是调用方法来修正该错误；或把try块放在while循环里。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;恢复模型导致耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;12.4 创建自定义异常&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;Java可以自己定义异常类来表示程序中可能会遇到的特定问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;对异常来说，最重要的部分是类名。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;12.5 异常说明&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;Java提供了异常说明，能以礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型，然后进行相应的处理。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;异常说明属于方法声明的一部分，紧跟在形式参数列表之后。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;异常说明使用了附件的关键字throws，后面接一个所有潜在异常类型的列表。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;代码必须与异常说明一致。可以声明方法将抛出异常，实际上却不抛出。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;在编译时被强制检查的异常称为被检查的异常。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;12.6 捕获所有异常&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;可以只写一个异常处理程序来捕获所有类型的异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;Throwable方法： getMessage、getLocalizedMessage、toString、printStackTrace、fillInStackTrace。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;getStackTrace方法返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一帧。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;有时希望把刚捕获的异常重新抛出。调用fillInStackTrace更新异常信息。有关原来异常发生点的信息会丢失，类似于捕获之后抛出另一种异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;在捕获一个异常后抛出另一个异常，并且希望把原始异常信息保存下来，这被称为异常链。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;Java SE5之后，Throwable的子类可以在构造器中接受一个cause对象作为参数，用来表示原始异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;Throwable的子类中，只有三种基本的异常类提供了带cause参数的构造器： Error（用于Java虚拟机报告系统错误）、Exception、RuntimeException。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;如果要把其他类型的异常链接起来，应该使用initCause方法而不是构造器。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;12.7 Java标准异常&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;Throwable用来表示任何可以作为异常被抛出的类。分为两种类型：Error、Exception。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;Error用来表示编译时和系统错误。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;Exception是可以被抛出的基本类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;运行时异常都是从RuntimeException类继承未来，也被称为“不受检查异常”。这种异常属于错误，将被自动捕获。代表的是编程错误。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;不应把Java的异常处理机制当成是单一用途的工具。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;12.8 使用finally进行清理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;finally子句总能被执行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;对于没有垃圾回收和析构函数自动调用机制的语言来说，finally非常重要。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;Java中当要把除内存之外的资源恢复到它们的初始状态时，就要用到finally子句。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;如果把finally子句和带标签的break及continue配合使用，在Java里就没有必要使用goto语句了。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;因为finally子句总是会执行，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;用某些特殊的方式使用finally子句，会导致异常丢失。 1. 在finally中抛异常； 2. 在finally中return。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;12.9 异常的限制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;当覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;异常限制对构造器不起作用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;派生类构造器的异常说明必须包含基类构造器的异常说明。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;派生类构造器不能捕获基类构造器抛出的异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;强制派生类遵守基类方法的异常说明。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;派生类方法可以不抛出异常，即使它是基类所定义的异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;异常说明本身并不属于方法类型的一部分，因此不能基于异常说明来重载方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;在继承和覆盖的过程中，某个特定方法的“异常说明的接口”不是变大了而是变小了。这恰好和类接口在继承时的情形相反。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;12.10 构造器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;如果构造器在其执行过程中半途而废，也许该对象的某些部分还没有被成功创建，而这些部分在finally子句中却是要被清理的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;对于在构造阶段可能会抛异常，并且要求清理的类，最安全的使用方式是使用嵌套的try子句（try嵌套try）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;12.11 异常匹配&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;抛出异常的时候，异常处理系统会按照代码的书写顺序找出最近的处理程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;12.12 其他可选方式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;异常处理的一个重要原则是“只有在知道如何处理的情况下才捕获异常”。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;异常处理的一个重要目标是把错误处理的代码同错误发生的地点相分离。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;被检查的异常强制在可能还没准备好处理错误的适合被迫加上catch子句，导致了“吞食则有害”的问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;异常处理历史、Java发明了“被检查的异常”，及作者观点。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;反射和泛型用来补偿静态类型检查所带来的过多限制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;处理被检查的异常：1. 传递给控制台； 2. 转换为不检查的异常。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;12.13 异常使用指南&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;再恰当的级别处理问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[108,109]},&quot;v&quot;:&quot;解决问题并且重新调用产生异常的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[109,110]},&quot;v&quot;:&quot;进行少许修补，然后绕过异常发生的地方继续执行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[110,111]},&quot;v&quot;:&quot;用别的数据进行计算，以代替方法预计会返回的值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[111,112]},&quot;v&quot;:&quot;把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[113,114]},&quot;v&quot;:&quot;终止程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[114,115]},&quot;v&quot;:&quot;进行简化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[115,116]},&quot;v&quot;:&quot;让类库和程序更安全。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[117,118]},&quot;v&quot;:&quot;12.14 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[118,119]},&quot;v&quot;:&quot;异常是Java程序设计不可分隔的一部分，如果不了解如何使用，只能完成很有限的工作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[119,120]},&quot;v&quot;:&quot;Java坚定地强调将所有的错误都已异常形式报告。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>12.6 Throwable的子类在构造器都可以接受一个cause对象作为参数。在Throwable子类中，只有三种基本的异常类提供了带cause参数的构造器。这里冲突了？？？</li>
<li>使用initCause方法而不是构造器？？？</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2021/12/16/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8813%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;13.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;可以证明，字符串操作是计算机程序设计中最常见的行为。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;13.1 不可变String&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;String对象是不可变的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修稿后的字符串内容。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;13.2 重载“+”与StringBuilder&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;不可变性会带来一定的效率问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;重载：一个操作符在应用于特定的类时，被赋予了特殊的意义。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;进行重载时，编译器自动引入了StringBuilder类，因为它更高效。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;显式创建StringBuilder允许预先指定大熊啊，避免多次重新分配缓存。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;如果在字符串拼接中使用循环，最好创建一个StringBuilder，用它来构造最终的结果。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;StringBuilder方法：append、insert、replace、substring、reverse、toString。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;13.3 无意识的递归&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;toString中使用this，导致递归调用。发生了自动转换，编译器将this转换为String，调用this上的toString。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;13.4 String上的操作&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;13.5 格式化输出&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;Java SE5 推出了C语言中printf风格的格式化输出功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;占位符，称作格式修饰符。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;Java SE5 引入的format方法可用于PrintStream或PrintWriter对象，其中也包括System.out对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;在Java中，所有新的格式化功能都有java.util.Formatter类处理。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;格式修饰符语法： %[argument_index$][flags][width][.precision]coversion。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;类型转换字符：d（十进制整数）、c（Unicode字符）、b（Boolean值）、s（String）、f（十进制浮点数）、e（科学技术浮点数）、x（十六进制整数）、h（十六进制散列码）、%。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;Java SE5参考了C中的sprintf方法，以生成格式化的String对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;String.format是一个static方法，接受与Formatter.format方法一样的参数，返回一个String对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;在String。format内部，也是创建一个Formatter对象，然后将传入的参数转给该Formatter。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;使用String.format，制作以十六进制格式查看内容的工具。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;13.6 正则表达式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;在Java中，字符串操作主要集中在String、StringBuffer和StringTokenizer类，与正则表达式相比，只能提供相当简单的功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;正则表达式是一种强大而灵活的文本处理工具。使用正则表达式，能够以编程的方式，构造复杂的文本模式，并对输入的字符串进行搜索。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;正则表达式提供一种完全通用的方式，能够解决各种字符串处理相关的问题：匹配、选择、编译及验证。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;一般来说，正则表达式就是以某种方式来描述字符串。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;Java对反斜线的不同处理。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;应用正则表达式最简单的途径，就是利用String类内建的功能。matches、split、replace、replaceAll、replaceFirst。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;如果正则表达式不是只使用一次的话，非String对象的正则表达式明显具备更佳的性能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;参考java.util.regex.Pattern。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;量词描述了一个模式吸收输入文本的方式： 贪婪型、勉强型、占有型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;接口CharSequence从CharBuffer、String、StringBuffer、StringBuilder类之中抽象出了字符序列的一般化定义： charAt、length、subSequence、toString。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;多数正则表达式都接受CharSequence类型的参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;使用Pattern.compile方法编译正则表达式构造功能强大的正则表达式对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;Pattern.matcher方法生成要给Matcher对象。参考java.util.regex.Matcher。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;组是用括号划分的正则表达式，可以根据组的编号来引用某个组。组号为0表示整个表达式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;Pattern标记。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;13.7 扫描输入&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;Java SE5新增了Scanner类，可以大大减轻扫描输入的工作负担。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;Scanner的构造器可以接受任何类型的输入对象，包括File、InputStream、String、Readable。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;默认情况下，Scanner根据空白字符对输入进行分词，但可用正则表达式指定所需的定界符。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;使用正则表达式指定定界符时，仅仅针对下一个输入分词进行匹配，如果正则表达式中含有定界符，那永远不可能匹配成功。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;13.8 StringTokenizer&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;在Java引入正则表达式（J2SE 1.4）和Scanner（Java SE5）类之前，分隔字符串的唯一方法是使用StringTokenizer来分词。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;StringTokenizer已经可以废弃不用了。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;13.9 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;过去，Java对字符串操作的支持相当不完善。到目前为止，已经很完善了。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>类型信息</title>
    <url>/2021/12/20/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8814%EF%BC%89%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;14.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;运行时类型信息（Runtime Type Information, RTTI）使得可以在程序运行时发现和使用类型信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;从只能在编译期执行面向类型的操作的禁锢中解脱了出来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Java在运行时识别对象和类的信息： 1. “传统的”RTTI，假定在编译时已经知道了所有的类型； 2. 反射，在运行时发现和使用类的信息。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;14.1 为什么需要RTTI&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;在Java中，所有的类型转换都是在运行时进行正确性检查的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;RTTI名字的含义：在运行时，识别一个对象的类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;RTTI类型转换，在编译时，由容器和Java泛型系统来强制确保；在运行时，由类型转换操作来确保。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;多态机制决定引用所指向的具体对象实际执行的代码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;特殊的编程问题，需要知道某个泛化引用的确切类型，使用最简单的问题解决。 -- 使用RTTI。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;14.2 Class对象&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的。 -- Class对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Class对象包含了与类有关的信息。Class对象就是用来创建类的所有“常规”对象的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;Java使用Class对象来执行其RTTI。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;类是程序的一部分，每个类都有一个Class对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;JVM使用类加载来生成这个类的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。 -- 构造器也是类的静态方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;Class对象仅在需要的时候才被加载，static初始化是在类加载时进行的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;Class.forName 时取得Class对象的引用的一种方法。副作用：没有类还没有加载就加载它。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;只要想在运行时使用类型信息，就必须首先获得对恰当的Class对象的引用。 1. Class.forName；2. getClass； 3. 类字面常量 .class。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;Class方法：getName、getSimpleName、getCanonicalName、getInterfaces、getSuperclass、newInstance。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;类字面常量更简单、跟安全。因为在编译时就会受到检查。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;类字面常量可用于普通的类、接口、数组以及基本数据类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;类字面常量对于基本数据类型的包装器，有一个标准字段TYPE，是一个引用，指向对应的基本数据类型的Class对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;为了使用类而做的准备工作的步骤： 1. 加载； 2. 链接； 3. 初始化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;类字面常量不会自动地初始化该Class对象，被延迟到对静态方法或者非常数静态域进行首次引用时才执行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;Class引用表示的是所指向的对象的确切类型，而该对象是Class类的一个对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;Java SE5 通过对Class引用所指向的Class对象的类型进行限定，使得类型变得更具体了一些。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;通过使用泛型语法，可以让编译器强制执行额外的类型检查。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;使用通配符“?”在使用泛化的Class引用时放松限制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;在Java SE5中，Class&amp;lt;?&amp;gt;由于平凡的Class，即便它们时等价的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;使用通配符与extends关键字结合，创建一个范围。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;向Class引用添加泛型语法的原因仅仅时为了提供编译期类型检查。否则直到运行时才发现错误，显得很不方便。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;Java SE5添加了用于Class引用的转型语法cast。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;新的转型语法对于无法使用普通转型的情况显得非常有用。存储了Class引用，并希望以后通过这个引用来执行转型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;Java SE5中另一个没有任何用处的新特性是asSubclass。将一个类对象转型为更加具体的类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;14.3 类型转换前先做检查&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;RTTI形式： 1. 传统的类型转换，由RTTI确保类型转换的正确性； 2. 代表对象的类型Class对象，获取运行时所需的信息； 3. instanceof。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;对instanceof有比较严格的限制：只可将其与命名类型进行比较，而不能与Class对象作比较。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;使用类字面常量代替Class.forName。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;Class.isInstance方法提供了一种动态地测试对象的途径。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;Class.isAssignableFrom。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;14.4 注册工厂&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;使用工厂方法设计模式，将对象的创建工作交给类自己完成。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;14.5 instanceof与Class的等价性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;instanceof和isInstance保持了类型的概念。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;用==比较实际的Class对象，没有考虑继承。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;14.6 反射：运行时的类信息&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;在编译时，编译器必须知道所有要通过RTTI来处理的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;RTTI限制：获取一个指向某个并不在程序空间中的对象的引用，在编译时程序无法获知这个对象所属的类。 1. 基于构件的编程； 2. GUI事件的构件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;反射提供了一种机制，用来检查可用的方法，并返回方法名。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;运行时获取类的信息的另一个动机：希望提供在跨网络的远程平台上创建和运行对象的能力。 --RMI。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;远程方法调用（RMI）允许一个Java程序员将对象分布到多态机器上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;Class类与java.lang.reflect类库（包含Field、Method以及Constructor，都实现了Member接口）一起对反射的概念进行了支持。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;RTTI和反射之间的真正区别只在于，对RTTI来说，编译器在编译时打开和检查.class文件，而对于反射来说，是在运行时打开和检查.class文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;反射在Java中是用来支持其他特性的，例如对象序列化和JavaBean。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;反射机制提供了一种方法，能够编写可以自动展示完整接口的简单工具。 -- 类方法提取器。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;14.7 动态代理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;代理是为了提供额外的或不同的操作，而插入的用来代替实际对象的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;Java的动态代理比代理的思想更向前迈进了一步，因为它可以动态地创建代理并动态地代理对所代理方法的调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的对策。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;通过调用静态方法Proxy.newProxyInstance()可以创建动态代理。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;14.8 空对象&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;当使用内置的null表示缺少对象时，在每次使用引用时都必须测试其是否为null，这显得枯燥，而且势必产生相当乏味的代码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;null除了在试图用它执行任何操作来产生NPE之外，没有其它任何行为。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;空对象可以接受传递给它的所代表对象的消息，但是将返回表示为实际上并不存在任何“真实”对象的值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;空对象是看作是策略模式的特例。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;到处使用空对象没有任何意义。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;空对象最有用之处在于它更靠近数据，因为对象表示的是问题空间内的实体。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;即使空对象可以相应实际对象可以相应的所有消息，仍需要某种方式去测试其是否为空。 -- 创建标记接口，使用内置工具instanceof。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;空对象都是单例。使用静态内部类实现，添加static final域。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;在某些地方仍必须测试空对象，与检查是否为null没有差异，但在其它地方不必执行额外测试，而可以直接假设所有的对象都是有效的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;多种不同类型的空对象。 -- 动态代理。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;空对象的逻辑变体是模拟对象和桩。只是假扮可以传递实际信息的存活对象。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;14.9 接口与类型信息&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;interface关键字的一种重要目标是允许程序员隔离构件，进而降低耦合性。但是通过类型信息，这种耦合性还是会传播出去。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;解决方案：1. 直接声明，自己负责； 2. 对实现使用包访问权限（反射可访问，没有任何方式可以阻止。final域不能修改）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;所有违反访问权限的操作并非世上最糟之事。通常反射带来的好处是不可否认的。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;14.10 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;使用RTTI在代码开发和维护过程中损失了多态机制的重要价值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;面向编程语言的目的是凡是可以使用的地方都使用多态机制，只在必需的时候使用RTTI。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;RTTI与多态的冲突。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;反射允许更加动态的编程风格，开创了编程的新世界。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;一致的错误报告模型的存在使得能够通过使用反射编写动态代码。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2021/12/20/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8815%EF%BC%89%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;15.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;在面向对象编程语言中，多态算是一种泛化机制。这种灵活性大多数时候也会有一些性能损耗。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;有时候，拘泥于单继承体系，会使程序受限太多。有的时候，即便使用了接口，对程序的约束也还是太强。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;泛型实现了参数化类型的概念，使代码可以应用于多种类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;泛型在编程语言中出现时，最初的目的是希望类或方法能够具备最广泛的表达能力。通过解耦类或方法与所使用的类型之间的约束。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Java中的泛型并没有这么高的追求。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;15.1 与C++的比较&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;设计Java的灵感主要来自C++。尽管如此，学习Java时，基本上可以不用参考C++。除非与C++的比较可以加深理解。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Java中的泛型需要与C++进行一番比较。理解C++模板的某些方面，有助于理解泛型的基础。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;15.2 简单泛型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;有许多原因促成了泛型的出现，而最引人注目的一个原因，就是为了创造容器类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;泛型的主要目的之一是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;有了泛型，能够仅一次方法调用就能返回多个对象。同时，在编译期就能确保类型安全。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;元组（数据传送对象、信使）：将一组对象直接打包存储于其中的一个单一对象。这个对象容器允许读取其中元素，但是不允许向其中存放新的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;可以读取，随心所欲的使用，但是无法赋值。使用 public final修饰。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;利用继承机制实现长度更长的元组。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;为了使用元组，只需定义一个长度适合的元组，将其作为方法的返回值，然后在return语句中创建该元组，并返回即可。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;使用泛型实现内部链式存储机制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;使用末端哨兵来判断何时为空。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;使用泛型构建一个可以应用于各种类型的对象的工具。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;15.3 泛型接口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;生成器，一种专门负责创建对象的类。是工厂方法的一种应用（生成器不需要参数，而工厂方法一般需要参数）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;基本类型无法作为类型参数。 -- 自动装箱、自动拆箱。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;适配器。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;15.4 泛型方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;可以在类中包含参数化方法。是否拥有泛型方法，与其所在的类是否是泛型类没有关系。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;泛型方法使得该方法能够独立于类而产生变化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法。对于一个static方法而言，无法访问泛型类的类型参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;使用泛型类时，必须在创建对象的时候指定类型参数的值。而使用泛型方法的时候，通常不必指明参数类型，编译器会进行类型参数推断。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;使用泛型类无法进行泛型推断。 -- 创建工具类，定义泛型方法，简化部分工作。 -- 额外复杂度。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;类型推断只对赋值操作有效，其他时候并不起作用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;在泛型方法中，可以显式地指明类型。必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;显式指明类型时，如果时定义在该方法的类的内部，必须在点操作符之前使用this关键字。如果是static方法，必须在点操作符之前加上类名。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;只有在编写非赋值语句时，才需要显式指明类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;泛型方法与可变参数列表能够很好的共存。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;有了类型参数推断，再加上static方法，可以重新编写之前的元组工具，使其成为更通用的工具类库。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;用Set来表达数学中的关系式。并集、交集、差集、补集。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;15.5 匿名内部类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;泛型可以应用于内部类以及匿名内部类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;15.6 构建复杂类型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;泛型的一个重要好处是能够简单而安全地创建复杂的模型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;15.7 擦除的神秘之处&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;在泛型代码内部，无法获得任何有关泛型参数类型的信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;Java泛型是使用擦除来实现的。使用泛型时，任何具体的类型信息都被擦除了。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;C++中，当模板被实例化时，模板代码知道其模板参数的类型。Java必须给定泛型类的边界，重用extends关键字。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;泛型类型参数将擦除到它的第一个边界。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;希望代码能够跨多个类工作时，使用泛型才有所帮助。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;擦除不是一个语言特性，是Java的泛型实现的一种折中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;擦除减少了泛型的泛化性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;在基于擦除的实现中，泛型类被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;泛型类型只有在静态类型检查期间才出现，在此之后，程序中所有的泛型类型都将被擦除，替换为它们的非泛型上界。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“迁移兼容性”。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作之中。例如转型、instanceof操作和new表达式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;擦除和迁移兼容性意味着，使用泛型并不是强制的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;当希望将类型参数不要仅仅当作Object处理时，需要付出额外努力来管理边界。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;Java SE5提供了@SuppressWarnings注解关闭警告。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;泛型最令人困惑的方面源自：可以表示没有任何意义的事物。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;对于在泛型中创建数组，使用Array.newInstance是推荐的方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;即便擦除在方法或类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;在泛型中的所有动作都发生在边界处。对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;15.8 擦除的补偿&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;擦除丢失了在泛型代码中执行某些操作的能力。任何在运行时需要知道确切类型信息的操作都将无法工作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;有时必须通过引入类型标签来对擦除进行补偿。这意味着需要显式传递类型的Class对象，以便在类型表达式中使用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;编译器将确保类型标签可以匹配泛型参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;无法创建一个new T()。在C++中，这种操作很自然、很直观，并且很安全。在编译期受到检查。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;Java中的解决方案是传递一个工厂对象，并使用它来创建新的实例。最便利的工厂对象就是Class对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;Sun建议使用显式的工厂，并将限制其类型，使得只能接受实现了这个工厂的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;另一种方式是模板方法设计模式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;不能创建泛型数组。一般的解决方案是使用ArrayList。这将获得数组的行为，以及由泛型提供的编译期的类型安全。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;可以定义一个泛型数组引用，但是永远都不能创建这个确切类型的数组（包括类型参数）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;创建一个Object数组，并将其转型为泛型数组类型。这可以编译，但是不能运行，将产生ClassCaseException。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;所有数组无论它们持有的类型如何，都具有相同的结构（每个数组槽位的尺寸和数组的布局）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;最好是在集合内部使用Object[]，使用数组元素时，添加一个对T的转型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;Java SE5标准类库的源代码，从Object数组到参数化类型的转型遍及各处&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;即使在Java类库源代码中出现了某些惯用法，也不能表示这就是正确的解决之道。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;15.9 边界&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;边界使得可以在用于泛型的参数类型上设置限制条件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[105,106]},&quot;v&quot;:&quot;尽管可以强制规定泛型可以应用的类型，但是其潜在的一个更重要的效果是可以按照自己的边界类型来调用方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;extends关键字在泛型边界上下文环境中和在普通情况下所具有的意义是完全不同的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;在继承的每个层次上添加边界限制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[108,109]},&quot;v&quot;:&quot;通配符被限制为单一边界。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[110,111]},&quot;v&quot;:&quot;15.10 通配符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[111,112]},&quot;v&quot;:&quot;可以向导出类型的数组赋予基类型的数组引用。 -- 向上转型不合适用在这里。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;数组的行为是它可以持有其它对象。数据对象可以保留有关它们包含的对象类型的规则。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[113,114]},&quot;v&quot;:&quot;对数组的赋值，在运行时可以发现插入了不正确的类型，但是泛型的主要目标之一是将这种错误检测移入到编译期。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[114,115]},&quot;v&quot;:&quot;试图使用泛型容器来代替数组。 -- 编译错误。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[115,116]},&quot;v&quot;:&quot;与数组不通过，泛型没有内建的协变类型。数组在语言中是完全定义的，因此可以内建了编译期和运行时的检查。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[116,117]},&quot;v&quot;:&quot;在两个类型之间建立某种类型的向上转型关系，这是通配符所允许的。 -- 丢失向其中床底任何对象的能力。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[118,119]},&quot;v&quot;:&quot;ArrayList，add接受一个具有泛型参数类型的参数，但是contains和indexOf接受Object类型的参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[119,120]},&quot;v&quot;:&quot;编译器将直接拒绝对参数列表中设计通配符的方法的调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[121,122]},&quot;v&quot;:&quot;超类型通配符，可以声明通配符是由某个特定类的任何基类来界定的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[122,123]},&quot;v&quot;:&quot;不能对泛型类型给出一个超类型边界（&amp;lt;T super MyClass&amp;gt;）。使得可以安全地传递一个类型对象到泛型类型中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[123,124]},&quot;v&quot;:&quot;超类型边界放松了在可以向方法传递的参数上所作的限制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[125,126]},&quot;v&quot;:&quot;使用无界通配符好像等价于使用原生类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[126,127]},&quot;v&quot;:&quot;在处理多个泛型参数时，有时允许一个参数可以是任何类型（使用无界通配符），同时为其它参数确定某种特定类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[127,128]},&quot;v&quot;:&quot;原生类型将持有任何类型的组合，而通配符将持有具有某种具体类型的同构集合。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;编译器何时关注原生类型和设计无界通配符的类型之间的差异？ -- 示例。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[129,130]},&quot;v&quot;:&quot;使用确切类型代替通配符类型的好处是，可以用泛型参数来做更多的事。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[130,131]},&quot;v&quot;:&quot;使用通配符必须接受范围更宽的参数化类型作为参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[132,133]},&quot;v&quot;:&quot;有一种情况特别需要使用&amp;lt;?&amp;gt;而不是原生类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[133,134]},&quot;v&quot;:&quot;如果向一个使用&amp;lt;?&amp;gt;的方法传递原生类型，编译器可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。这被称为捕获转换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[134,135]},&quot;v&quot;:&quot;捕获转换只有在方法内部，且需要使用确切的类型的情况下可以工作。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[136,137]},&quot;v&quot;:&quot;15.11 问题&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[137,138]},&quot;v&quot;:&quot;基本类型不能作为类型参数。 -- 包装器类及自动装箱。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[138,139]},&quot;v&quot;:&quot;自动包装机制不能应用于数组。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[140,141]},&quot;v&quot;:&quot;一个类不能实现同一个泛型接口的两种变体。由于擦除的原因，这两个变体会成为相同的接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[142,143]},&quot;v&quot;:&quot;使用带有泛型类型参数的转型或instanceof不会由任何效果。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[143,144]},&quot;v&quot;:&quot;有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[145,146]},&quot;v&quot;:&quot;由于擦除的原因，重载方法就产生相同的类型签名。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[146,147]},&quot;v&quot;:&quot;当被擦除的参数不能产生唯一的参数列表时，必须提供明显有区别的方法名。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[148,149]},&quot;v&quot;:&quot;基类劫持了接口。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[150,151]},&quot;v&quot;:&quot;15.12 自限定的类型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[151,152]},&quot;v&quot;:&quot;古怪的循环泛型（CRG）的本质：基类用导出类替代其参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[152,153]},&quot;v&quot;:&quot;CRG意味着泛型基类变成了一种其所有导出类的公共功能的模板。在所产生的类中将使用确切类型而不是基类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[154,155]},&quot;v&quot;:&quot;自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[155,156]},&quot;v&quot;:&quot;自限定的参数意义：可以保证类型参数必须与正在被定义的类相同。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[156,157]},&quot;v&quot;:&quot;自限定限制只能强制作用于继承关系。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[157,158]},&quot;v&quot;:&quot;如果使用自限定，就应该了解这个类所使用的类型参数将于使用这个参数的类具有相同的基类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[159,160]},&quot;v&quot;:&quot;自限定的价值在于它们可以产生协变参数类型（方法参数类型会随子类而变化）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[160,161]},&quot;v&quot;:&quot;如果不适用自限定，将重载参数类型。如果使用了自限定，只能获得某个方法的一个版本，它将接受确切的参数类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[162,163]},&quot;v&quot;:&quot;15.13 动态类型安全&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[163,164]},&quot;v&quot;:&quot;Java SE5的Collections中有一组工具，可以解决向之前的代码传递泛型容器，从而可能会破坏容器的类型检查问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[164,165]},&quot;v&quot;:&quot;工具：checkedCollection、checkedList、checkedMap、checkedSet、checkedSortedMap、checkedSortedSet。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[166,167]},&quot;v&quot;:&quot;15.14 异常&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[167,168]},&quot;v&quot;:&quot;由于擦除的原因，将泛型应用于异常是非常受限的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[168,169]},&quot;v&quot;:&quot;catch语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[169,170]},&quot;v&quot;:&quot;泛型类也不能直接或间接继承自Throwable。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[170,171]},&quot;v&quot;:&quot;类型参数可能会在一个方法的throws子句中用到，这使得可以编写随检查型异常的类型而发生变化大的泛型代码。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[172,173]},&quot;v&quot;:&quot;15.15 混型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[173,174]},&quot;v&quot;:&quot;混型基本概念是：混合多个类的能力，以产生一个可以表示混型中所有类型的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[174,175]},&quot;v&quot;:&quot;混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[175,176]},&quot;v&quot;:&quot;如果在混型中修改某些东西，这些修改会应用于混型所应用的所有类型之上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[177,178]},&quot;v&quot;:&quot;在C++中，使用多重继承的最大理由，就是为了使用混型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[178,179]},&quot;v&quot;:&quot;对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[179,180]},&quot;v&quot;:&quot;在C++中，可以很容易的创建混型，因为C++能够记住其模板参数的类型。 -- Java泛型不允许这样，擦除会忘记基类类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[181,182]},&quot;v&quot;:&quot;一种更常见的推荐解决方案是使用接口来产生混型效果。 -- 使用代理。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[183,184]},&quot;v&quot;:&quot;可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器的继承结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[184,185]},&quot;v&quot;:&quot;装饰器只是对由混型提出的问题的一种局限的解决方案。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[186,187]},&quot;v&quot;:&quot;可以使用动态代理来创建一种比装饰器更贴近混型模型的机制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[187,188]},&quot;v&quot;:&quot;通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[188,189]},&quot;v&quot;:&quot;仍旧不如C++的方式好，因为在调用方法之前，必须先向下转型。但是，它更接近于真正的混型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[190,191]},&quot;v&quot;:&quot;15.16 潜在类型机制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[191,192]},&quot;v&quot;:&quot;潜在类型机制是一种代码组织和复用机制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[192,193]},&quot;v&quot;:&quot;两种支持潜在类型机制的语言实例是Python（动态类型语言）和C++（静态类型语言）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[193,194]},&quot;v&quot;:&quot;Java没有对这种特性的支持。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[195,196]},&quot;v&quot;:&quot;15.17 对缺乏潜在类型机制的补偿&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[196,197]},&quot;v&quot;:&quot;通过反射使用潜在类型机制。但是将所有的类型检查都转移到了运行时。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[197,198]},&quot;v&quot;:&quot;反射和可变参数，内建的Iterable接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[198,199]},&quot;v&quot;:&quot;用适配器仿真潜在类型机制。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[200,201]},&quot;v&quot;:&quot;15.18 将函数对象用作策略&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[201,202]},&quot;v&quot;:&quot;函数对象就是在某种程度上行为像函数的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[202,203]},&quot;v&quot;:&quot;函数对象的价值在于，与普通方法不同，它们可以传递出去，并且还可以拥有在多个调用之间持久化的状态。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[203,204]},&quot;v&quot;:&quot;在C++中，潜在类型机制将在调用函数是负责协调各个操作，但是在Java中，需要编写函数对象来将泛型方法适配为特定的需求。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[204,205]},&quot;v&quot;:&quot;适配器模式和策略模式的结合。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[206,207]},&quot;v&quot;:&quot;15.19 总结&quot;}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/12/21/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8816%EF%BC%89%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;16.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;对数组的基本看法是，可以创建并组装它们，通过使用整形索引值访问它们的元素，并且它们的尺寸不能改变。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;如何更加深入地思考数组。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;16.1 数组为什么特殊&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;数组与其它种类的容器之间的区别有三方面：效率、类型和保存基本类型的能力。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;为速度所付出的代价是数组对象的大小被固定，并且在其生命周期中不可改变。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;16.2 数组是第一级对象&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;数组标识符只是一个引用，指向在堆中创建的一个真实对象，这个对象用以保存指向其他对象的引用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;可以作为数组初始化语法的一部分隐式地创建此对象，或者用new表达式显式地创建。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;聚集初始化操作必须在定义数组的位置使用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;动态聚集初始化可以在任意位置创建和初始数组对象。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;16.3 返回一个数组&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;C/C++不能返回一个数组，而只能返回指向数组的指针。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;16.4 多维数组&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;对于多维数组，可以通过花括号将每个向量分割开。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;Java SE5 Arrays.deepToString 可以将多维数组转换为多个String。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;数组中构成矩阵的每个向量都可以具有任意的长度（粗糙数组）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;16.5 数组与泛型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;通常，数组与泛型不能很好的结合。不能实例化具有参数化类型的数组。可以参数化数组本身的类型（T[]）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;使用参数化方法而不使用参数化类的方便之处在于：不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且可以将其定义为静态的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;可以创建对泛型数组的引用，但是不能实例化。可以创建非泛型的数组，然后将其转型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;数组是协变类型的。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;16.6 创建测试数据&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;Arrays.fill：只能用一个值填充各个位置，对对象而言，就是复制同一个引用进行填充。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;16.7 Arrays使用功能&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;Arrays基本方法：equals、fill、sort、binarySearch、toString、hashCode。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;System.arraycopy，复制数组比用for循环复制要快很多。针对所有类型做了重载。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;Arrays.equals 用来比较整个数组，对所有类型做了重载。数组相等的条件是元素个数相等，且对应位置的元素也相等。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;Java有两种方式用来提供比较功能，1. Comparable接口； 2. Comparator接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;使用内置的排序方法，就可以对任意的基本类型数组排序；也可以对任意的对象数组排序，只要该对象实现了Comparable接口或具有相关联的Comparator。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;基本类型数组无法是哦那个Comparator进行排序。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;16.8 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;在使用最近的Java版本编程时，应该优选容器而不是数组。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>容器深入研究</title>
    <url>/2021/12/21/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8817%EF%BC%89%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;17.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;更深入地探索这个重要的类库。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;17.1 完整的容器分类法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Java SE5 新添加了Queue、PriorityQueue、BlockingQueue、ConcurrentMap、ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteSet、EnumSet、EnumMap、Collections中的多个便利方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;17.2 填充容器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Collections.fill，只复制同一个对象引用来填充整个容器，只对List对象有用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Collections.nCopies填充。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;享元。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;17.3 Collection的功能方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;add、addAll、contains、containsAll、isEmpty、iterator、remove、removeAll、retainAll、size、toArray。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;不包括随机访问所选择元素的get方法。如果想检查Collection中的元素，那就必须使用迭代器。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;17.4 可选操作&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;执行各种不同的添加和移除的方法在Collection接口中都是可选操作。这意味着实现类并不需要为这些方法提供功能定义。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;可选操作声明调用某些方法将不会执行有意义的行为，相反，它们会抛出异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;如果一个操作是可选的，编译器仍旧会严格要求只能调用该接口中的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;将Collection当作参数接受的大部分方法只会从该Collection中读取，而Collection的读取方法都不是可选的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;将方法定义为可选的，可以防止在设计中出现接口爆炸的情况。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;未获支持的操作只有在运行时才能探测到，因此它们表示动态类型检查。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;最常见的未获支持的操作，都来源于背后由固定尺寸的数据结构支持的容器。Arrays.asList、Collections类中unmodifiable的方法等。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;对于将容器作为参数接受的方法，其文档应该指定哪些可选方法必须实现。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;17.5 List的功能方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;大多数时候只是调用add添加对象，使用get一次取出一个元素，以及调用iterator获取用于该序列的Iterator。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;17.6 Set和存储顺序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;Set与Collection有完全一样的接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;HashSet，为快速查找而设计的Set。元素必须定义hashCode。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;TreeSet，保持次序的Set，底层为树结构。元素必须实现Comparable接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;LinkedHashSet，具有HashSet的查询速度，且内部使用链表维护元素插入的顺序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;应该在覆盖equals时，覆盖hashCode方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;SortedSet方法：first、last、subSet、headSet、tailSet。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;17.7 队列&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;除了并发应用，Queue在Java SE5中仅有的两个实现是LinkedList和PriorityQueue。它们的差异在于排序行为而不是性能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;优先队列的排序顺序也是通过实现Comparable而进行控制的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;双向队列，可以在任何一端添加或移除元素。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;在LinkedList中包含支持双向队列的方法，但是Java标准类库中没有任何显式的用于双向队列的接口。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;17.8 理解Map&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;映射表的基本思想是它维护的是键-值关联，可以使用键来查找值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;标准的Java类库中包含了Map的几种基本实现，包括：HashMap、TreeMap、LinkedHashMap、WeakHashMap、ConcurrentHashMap、IdentityHashMap。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;它们的行为特性各不相同，表现在效率、键值对的保存及呈现次序、对象的保存周期、映射表如何在多线程中工作和判断键等价的策略等方面。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;hashCode是根类Object中的方法，因此所有Java对象都能产生散列码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;IdentityHashMap使用==代替equals，用来解决某种特定问题。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;17.9 散列与散列码&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;Object的hashCode方法，默认使用对象的地址计算散列码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;正确的equals方法必须满足5个条件： 1. 自反性； 2. 对称性； 3. 传递性； 4. 一致性； 5. 对任何不是null的x，x.equals(null)一定返回false。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;默认的Object.equals只是比较对象的地址。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;如果要使用自己的类作为HashMap的键，必须同时重载hashCode和equals。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;数组并不保存键本身。而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;通常，冲突由外部链接处理，数组并不直接保存值，而是保存值的list。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;设计hashCode时最重要的因素是： 1. 对同一个对象调用hashCode都应该生成同样的值； 2. 不应该依赖于具有唯一性的对象信息，尤其是this的值。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;17.10 选择接口的不同实现&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;实际上只有四种容器：Map、List、Set和Queue。但是每种接口都有不止一个实现版本。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;性能表现。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;HashMap的性能因子：容量、初始容量、尺寸、负载因子。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;17.11 实用方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;java.util.Collections类内部的静态方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;unmodifiable、synchronized。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;Java容器有一种保护机制，能够防止多个线程同时修改同一个容器的内容。-- 快速报错机制。ConcurrentModificationException。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;17.12 持有引用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;java.lang.ref类库包含了一组类，这些类为垃圾回收提供了更大的灵活性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;有三个继承自抽象类Reference的类: SoftReference、WeakReference、PhantomReference。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;容器类中有一种特殊的Map，即WeakHashMap，被用来保存WeakReference。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;17.13 Java1.0/1.1的容器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;Vector、Enumeration、Hashtable、Stack、BitSet。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;17.14 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;容器类库对于面向对象语言来说是最重要的类库。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;Java容器类库具有成熟的类库应该具有的完备的功能。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>

]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>Java I/O系统</title>
    <url>/2021/12/27/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8818%EF%BC%89Java%20IO%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;18.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;对程序语言设计者来说，创建一个好的输入/输出（I/O）系统是一项艰难的任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;不仅存在各种I/O源端和想要与之通信的接收端，而且还需要以多种不同的方式与它们进行通信。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Java类库的设计者通过创建大量的类来解决这个难题。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;18.1 File类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;File类既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;FilenameFilter接口。策略模式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;程序设计中一项常见的任务就是在文件集上执行操作。这些文件要么在本地目录中，要么遍布整个目录树中。 -- 工具。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;也可以用File对象来创建新的目录或尚不存在的整个目录路径。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;File类其它方法： canRead、canWrite、getName、getParent、getPath、renameTo、mkdirs。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;18.2 输入和输出&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;编程语言的I/O类库中常使用流整个抽象概念，代表任何有能力产出数据的数据源对象或者是有能力接收数据的接收端对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;流屏蔽了实际的I/O设备中处理数据的细节。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;Java类库中的I/O中分成输入和输出两部分。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;任何自InputStream或Reader派生而来的类都含有read方法，用于读取单个字节或字节数组。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;任何自OutputStream或Writer派生而来的类都含有write方法，用于写单个字节或字节数组。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;很少使用单一的类来创建流对象，而是通过叠合多个对象来提供所期望的功能。 -- 装饰器设计模式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;Java中流类库让人迷惑的主要原因就在于：创建但一个的结果流，却需要创建多个对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;Java 1.0中，限定与输入有关的类都应该从InputStream继承，与输出有关的类都应该从OutputStream继承。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;InputStream的作用是用来表示那些从不同数据源产生输入的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;数据源包括 1. 字节数组（ByteArrayInputSteam）； 2. String对象（StringBufferInputSteam）； 3. 文件（FileInputSteam）； 4. 管道（PipedInputSteam）； 5. 流序列（SequenceInputStream）； 6. 其它数据源。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;FilterInputStream也属于一种InputStream，为装饰器类提供基类。把属性或有用的接口与输入流连接在一起。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;OutputStream类别的类巨顶了输出所要去往的目标。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;目标包括 1. 字节数组（ByteArrayOutputSteam）； 2. 文件（FileOutputSteam）； 3. 管道（PipedOutputStream）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;FilterOutputStream为装饰器类提供了一个基类，把属性或者有用的接口与输出流链接了起来。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;18.3 添加属性和有用的接口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;Java I/O类库需要多种不同功能的组合。增加了代码的复杂性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;FilterInputStream类能够完成两件完全不同的事情。DataInputStream允许读取不同的基本类型数据即String对象，其它类在内部修改InputSteam的行为方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;FilterInputStream类型：DataInputStream、BufferedInputStream、LineNumberInputStream、PushbackInputStream。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;FilterOutputStream类型：DataOutputStream、PrintStream、BufferedOutputStream。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;18.4 Reader和Writer&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;Java 1.1对基本的I/O流类库进行了重大的修改。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;Reader和Writer提供兼容Unicode与面向字符的I/O功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;Java 1.1 向InputStream和OutputStream继承层次结构中添加了一些新类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;适配器类：InputStreamReader可以把InputStream转换为Reader，OutputStreamWriter可以把OutStream转换为Writer。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;设计Reader和Writer继承层次结构主要是为了国际化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;Java 1.1类：Reader、Writer、FileReader、FileWriter、StringReader、StringWriter、CharArrayReader、CharArrayWriter、PipedReader、PipedWriter。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;StringBufferInputStream已弃用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;Java 1.1类：FilterReader、FilterWriter、BufferedReader、BufferWriter、PrintWriter、LineNumberReader、StreamTokenizer、PushbackReader。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;LineNumberInputStream已弃用。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;18.5 自我独立的类：RandomAccessFile&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;RandomAccessFile适用于由大小已知的记录组成的文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;RandomAccessFile不是InputStream或者OutputStream继承层次结构中的一部分。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;RandomAccessFile与拥有和别的I/O类型本质不同的行为，可以在一个文件内向前或向后移动。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;只有RandomAccessFile支持搜寻方法，并且只适用于文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;在JDK 1.4中，RandomAccessFile的大多数功能由nio存储映射文件所取代。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;18.6 I/O流的典型使用方式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;缓冲输入文件： new BufferedReader(new FileReader(filename));。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;从内存输入： new StringReader(BufferedInputFile.read(string));。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;格式化的内存输入： new DataInputStream(new ByteArrayInputStream(BufferedInputFile.read(string).getBytes()));。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;基本的文件输出： new PrintWriter(new BufferedWriter(new FileWriter(filename)));。PrintWriter。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;存储和恢复数据： DataInputStream、DataOutStream。要么为文件中的数据采用固定的格式，要么将额外的信息保存到文件中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;读写随机访问文件： RandomAccessFile。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;管道流： 用于任务之间的通信。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;18.7 文件读写的实用工具&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;一个很常见的程序化任务就是读取文件到内存，修改，然后再写出。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;18.8 标准I/O&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;标准I/O这个术语参考的Unix中“程序所使用的单一信息流”这个概念。标准输入、标准输出、标准错误。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;标准I/O的意义在于：可以很容易把程序串联起来，一个程序的标准输出可以成为另一程序的标准输入。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;按照标准I/O模型，Java提供了System.in、System.out、System.err。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;System.out、System.err已经事先被包装成了PrintWriter对象。System.in是一个未经包装的InputStream，读取之前必须包装。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;Java的System类提供了一些简单的静态方法调用，以允许对标准输入、输出和错误I/O流进行重定向。setIn、setOut、setErr。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;I/O重定向操纵的是字节流，而不是字符流。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;18.9 进程控制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;Java类库提供了在Java内部执行其他操作系统的程序，并且控制这些程序的输入和输出的类。ProcessBuilder、Process。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;18.10 新I/O&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;JDK 1.4的java.nio.*包中引入了新的Java I/O类库，其目的在于提高速度。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;实际上，旧的I/O包已经使用nio重新实现过，以便充分利用这种速度提高。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;速度的提高来自于所使用的结构更接近于操作系统执行的I/O的方式：通道和缓冲器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;并没有直接和通道交互，只是和缓冲器交互，并把缓冲器派送到通道。通道要么从缓冲器获得数据，要么向缓冲器发送数据。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;唯一直接与通道交互的缓冲器是ByteBuffer。可以存储未加工字节的缓冲器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;使用wrap方法将已存在的字节数组包装到ByteBuffer中。 -- 数组支持的ByteBuffer。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;对于只读访问，必须显式使用allocate方法来分配ByteBuffer。allocateDirect产生一个与操作系统有更高耦合的直接缓冲器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;一旦调用read存储字节，就必须调用缓冲器上的flip，做好读取字节的准备。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;如果打算使用缓冲器执行进一步的read操作，必须得调用clear来为read做好准备。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;transferTo、transferFrom允许一个通道和另一个通道直接相连。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;ByteBuffer可以看作是具有asCharBuffer方法的CharBuffer。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;缓冲器容纳的是普通字节，为了转换成字符，要么在输入时进行编码，要么在输出时进行解码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;java.nio.charset.Charset类提供了把数据编码成多种不同类型的字符集的工具。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;ByteBuffer只能保存字节类型的数据，但是具有从其所容纳的字节中产生出各种不同基本类型值的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;视图缓冲器通过某个特定的基本数据类型的视窗查看其底层的ByteBuffer。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;ByteBuffer依然是实际存储数据的地方，对视图的修改都会映射成对ByteBuffer中数据的修改。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;ByteBuffer是以高位优先的形式存储数据的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;ByteBuffer是将数据移进移出通道的唯一方式，并且只能创建一个独立的基本类型缓冲器，或者使用as方法从ByteBuffer中获得。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[108,109]},&quot;v&quot;:&quot;Buffer由数据和可以高效地访问即操作这些数据的四个索引组成。索引是：mark、position、limit、capacity。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[110,111]},&quot;v&quot;:&quot;内存映射文件允许创建和修改因为太大而不能放入内存的文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[111,112]},&quot;v&quot;:&quot;MappedByteBuffer是一种特殊类型的直接缓冲器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;MappedByteBuffer由ByteBuffer继承而来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[114,115]},&quot;v&quot;:&quot;JDK 1.4 引入了文件枷锁机制，允许同步访问某个作为共享资源的文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[115,116]},&quot;v&quot;:&quot;文件锁对其他的操作系统进程是可见的，因为Java的文件加锁直接映射到了本地操作系统的加锁工具。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[116,117]},&quot;v&quot;:&quot;如果由Java虚拟机，它会自动释放锁，或者关闭加锁的通道。也可以显式释放锁。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[118,119]},&quot;v&quot;:&quot;18.11 压缩&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[119,120]},&quot;v&quot;:&quot;Java I/O类库中的类支持读写压缩格式的数据流。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[120,121]},&quot;v&quot;:&quot;压缩类库是按字节方式而不是字符方式处理的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[121,122]},&quot;v&quot;:&quot;压缩类：CheckedInputStream、CheckedOutputStream、DeflaterOutputStream、ZipOutputStream、GZIPOutputSteam、InflaterInputStream、ZipInputStream、GZIPInputStream。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[122,123]},&quot;v&quot;:&quot;支持Zip格式的Java库更加全面。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[123,124]},&quot;v&quot;:&quot;Zip格式也被应用于JAR文件格式中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[124,125]},&quot;v&quot;:&quot;一个JAR文件由一组压缩文件构成，同时还有一张描述了所有这些文件的文件清单。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[125,126]},&quot;v&quot;:&quot;Sun的JDK自带的jar程序可根据选择自动压缩文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[126,127]},&quot;v&quot;:&quot;jar工具的功能没有zip工具那么强大。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;18.12 对象序列化&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[129,130]},&quot;v&quot;:&quot;Java的对象序列化将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[130,131]},&quot;v&quot;:&quot;利用序列化可以实现轻量级持久化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[131,132]},&quot;v&quot;:&quot;对象序列化的概念加入到语言是为了支持两种主要特性。 1. 远程方法调用RMI； 2. 对JavaBeans来说，对象的序列化是必需的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[133,134]},&quot;v&quot;:&quot;反序列化，必须保证Java虚拟机能找到相关的.class文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[135,136]},&quot;v&quot;:&quot;通过实现Externalizable接口，代替实现Serializable接口，来对序列化过程进行控制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[136,137]},&quot;v&quot;:&quot;Externalizable接口继承了Serializable接口，同时增添了两个方法：writeExternal、readExternal。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[137,138]},&quot;v&quot;:&quot;用transient关键字关闭序列化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[138,139]},&quot;v&quot;:&quot;可以实现Serializable接口，并添加（而非覆盖或实现）writeObject和readObject的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[139,140]},&quot;v&quot;:&quot;Java的版本控制机制过于简单，因而不能在任何场合都可靠运转，尤其是对JavaBeans更是如此。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[141,142]},&quot;v&quot;:&quot;18.13 XML&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[142,143]},&quot;v&quot;:&quot;对象序列化的一个重要限制是它只是Java的解决方案：只有Java程序才能反序列化这种对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[143,144]},&quot;v&quot;:&quot;一种更具互操作性的解决方案是将数据转换为XML格式，这可以是其被各种各样的平台和语言使用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[144,145]},&quot;v&quot;:&quot;用XML编程时的各种选择不胜枚举，包括随JDK发布的javax.xml.*类库。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[146,147]},&quot;v&quot;:&quot;18.14 Preferences&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[147,148]},&quot;v&quot;:&quot;Preferences API与对象序列化相比，前者与对象持久化更密切，因为它可以自动存储和读取信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[148,149]},&quot;v&quot;:&quot;Preferences API用于存储和读取用户的偏好以及程序配置项的设置。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[149,150]},&quot;v&quot;:&quot;Preferences是一个键值集合，存储在一个节点层级结构中。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[151,152]},&quot;v&quot;:&quot;18.15 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[152,153]},&quot;v&quot;:&quot;一旦理解了装饰器模式，并开始在某些情况下使用该类库以利用其提供的灵活性，那就开始从这个设计中受益了。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>枚举类型</title>
    <url>/2021/12/27/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8819%EF%BC%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;19.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;19.1 基本enum特性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;values方法返回enum实例的数组，而且该数组中的元素严格保持其在enum中声明时的顺序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;创建enum时，编译器会生成一个相关的类，这个类继承自java.lang.Enum。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;ordinal返回一个int值，是每个enum实例在声明时的次序，从0开始。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;编译器自动提供equals和hashCode方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Enum类实现了Comparable接口，所以具有compareTo方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;Enum类实现了Serializable接口。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;19.2 向enum中添加新方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;除了不能继承自一个enum之外，可以将enum看作一个常规的类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;19.3 switch语句中的enum&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;在switch中使用enum，是enum提供的一项非常便利的功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;枚举实例天生就具备整数值的次序，并且可以通过ordinal方法取得其次序。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;19.4 values的神秘之处&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;Enum类并没有values方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;values是由编译器添加的static方法。还添加了valueOf方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;可以通过Class对象获取所有enum实例。getEnumConstants。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;19.5 实现，而非继承&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;enum继承自Enum列，不能再继承其他类。可以同时实现一个或多个接口。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;19.6 随机选取&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;虽然Enum只是一个相当短小的类，但是它能消除很多重复的代码。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;19.7 实用接口组织枚举&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类组织的目的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;对于enum而言，实现接口是使其子类化的唯一办法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;当需要与一大堆类型打交道时，接口就不如enum好用了。 -- 枚举的枚举。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;一种更简洁的管理枚举的办法：将一个enum嵌套在另一个enum内。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;19.8 使用EnumSet替代标志&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;Java SE5引入EnumSet，为了通过enum创建一种替代品，以替代传统的基于int的位标志。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;EnumSet的优点是，在说明一个二进制位是否存在时，具有更好的表达能力，并且无需担心性能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;EnumSet中的元素必须来自一个enum。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;EnumSet的基础时long，一个long值有64位，而一个enum实例只需一位bit表示其是否存在。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;19.9 使用EnumMap&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;EnumMap是一种特殊的Map，它要求其中的键必须来自一个enum。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;EnumMap内部可由数组实现。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;命令模式。首先需要一个只有单一方法的接口，然后从该接口实现具有各自不同的行为的多个子类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;与EnumSet一样，enum实例定义时的次序决定了其在EnumMap中的顺序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;EnumMap允许改变值对象。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;19.10 常量相关的方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;Java的enum允许为enum实例编写方法，从而为每个enum实例赋予各自不同的行为。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;常量相关的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;表驱动的代码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;每个enum元素都是一个其类型的static final实例。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;由于它们时static实例，无法访问外部类的非static元素或方法，所以对于内部的enum的实例而言，其行为与一般的内部类并不相同。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;通过常量相关的方法，可以很容易实现一个简单的责任链。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;枚举类型非常适合用来创建状态机。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;19.11 多路分发&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;Java只支持单路分发。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;如果要执行的操作包含了不止一个类型未知的对象时，那么Java的动态绑定机制只能处理其中一个的类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;所以必须自己来判定其他的类型，从而实现自己的动态绑定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;要利用多路分发，必须为每一个类型提供一个实际的方法调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;使用enum分发。一种方式是使用构造器来初始化每个enum实例，并以一组结果作为参数。形成类似查询表的结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;使用常量相关的方法。将enum用在switch语句中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;使用EnumMap分发。使用EnumMap能够实现两路分发。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;使用二维数组。进一步简化实现两路分发的解决方案。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;19.12 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;可以将enum与Java语言其他功能结合使用，例如多态、泛型和反射。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>对象导论</title>
    <url>/2021/11/30/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%881%EF%BC%89%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;前言&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Sun对Java的设计目标：“我们关系的是，减少开发健壮代码所需的事件以及困难。” -- 为程序员减少复杂性。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;1.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;计算机革命起源于机器，因此，编程语言的产生也始于对机器的模仿。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;计算机并非只是机器那么简单，计算机是头脑延伸的工具，同时还是一种不同类型的表达媒体。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;1.1 抽象过程&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;所有编程语言都提供抽象机制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;建立机器模型（位于“解空间”）和实际待解决问题的模型（位于“问题空间”）之间的关联。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;面向对象思想实质：程序可以通过添加新类型的对象使本身适用于某个特定问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;OOP与计算机的联系：每个对象看起来都有点像一台微型计算机，具有状态和操作，用户可以要求对象执行这些操作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;对象具有状态、行为和标识。每一个对象在内存中都有一个唯一的地址。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;1.2 每个对象都有一个接口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;创建抽象数据类型（类）使面向对象程序设计的基本概念之一。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;在面向对象程序设计中，实际进行的是创建新的数据类型，但事实上所有的面向对象程序设计语言都使用class关键词来表示数据类型。即类型和类是等价的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;1.3 每个对象都提供服务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;将对象看作“服务提供者”。程序本身向用户提供服务，它将通过调用其它对象提供的服务来实现这一目的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;有助于提供对象的内聚性。高内聚是软件设计的基本质量要求之一，意味着一个软件构件的各个方面组合得很好。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;构件是可复用的软件组成成分，可以是类、对象、方法等等。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;1.4 被隐藏的具体实现&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;访问权限控制。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;1.5 复用具体实现&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;组合（has-a）、继承（is-a）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;组合与继承的使用选择：首先考虑组合，因为更加灵活。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;1.6 继承&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;两个类型可以有相同的特性和行为，但是其中一个类型可能必另一个含有更多的特性，并且可以处理更多的消息（或以不同的方式来处理消息）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;基类与导出类产生差异方法：在导出类中添加新方法（is-like-a），改变现有基类方法的行为（is-a）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;导出类与基类具有相同的类型，但表示完全相同的类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;1.7 伴随多态的可转换对象&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;处理类型的层次结构使，经常把一个对象不当作它所属的特定类型来对待，而是将其当作基类的对象来堆到。从而可以编写出不依赖于特定类型的代码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;编译器不可能产生传统意义上的函数调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;前期绑定：编译器将产生对一个具体函数名字的调用，而运行时将这个调用解析到将要被执行代码的绝对地址。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;后期绑定/动态绑定：当向对象发送消息时，被调用的代码直到运行时才能确定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;Java中为了执行后期绑定，使用一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;C++中使用virtual关键字来实现后期绑定。而在Java中，动态绑定是默认行为。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;1.8 单根继承结构&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;终极基类：Object。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;在OOP中，C++使用多根继承。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;单根继承保证所有对象都具备某些功能。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;1.9 容器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;创建一种新的对象类型，持有对其它对象的引用。可以用数组来实现相同的功能。这个类型通常被称为容器/集合。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;Java类库以不同的含义使用“集合”这个术语。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;参数化类型是一个编译器可以自动定制作用于特定类型上的类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;1.10 对象的创建和生命周期&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;对象创建位置：堆栈、堆。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;堆栈：容易控制、牺牲了灵活性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;堆： 直到运行时才知道需要多少对象，及他们的生命周期，具体类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;Java完全采用了动态内存分配方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;C++必须通过编程方式来确定合适销毁对象。Java提供了“垃圾回收器”机制。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;1.11 异常处理：处理错误&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;Java内置了一场处理，并且强制要求必须使用。是唯一可接受的错误报告方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;异常处理并不是面向对象的特征，尽管在面向对象语言中异常常被表示成一个对象。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;1.12 并发编程&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;同一时刻处理多个任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;Java的并发是内置于语言的。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;1.13 Java与Internet&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;Java促使计算机编程语言向前迈进了革命性的一步。 -- 解决了在万维网（World Wide Web）上的程序设计问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;C/S结构：过去所作的，都是针对某个问题发明一个单独的解决方案，所以每一次都要发明一个新的方案。这些方案难以开发且难以使用，而且用户对每一个方案都要学习新的接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;客户端编程：在客户端浏览器中运行程序的能力。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;Web最初的B/S设计是为了能够提供交互性的内容，但是其交互性完全由服务器提供。通过Web服务器提供的通用网关接口（Common Gateway Interface, CGI）实现。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;客户端编程方式：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[77,78],&quot;index&quot;:1},&quot;v&quot;:&quot;1. 插件&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[78,79],&quot;index&quot;:2},&quot;v&quot;:&quot;2. 脚本语言 JavaScript不需要插件。可以解决80%问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[79,80],&quot;index&quot;:3},&quot;v&quot;:&quot;3. Java Applet 需要插件，JRE环境。用来解决剩下的20%问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[80,81],&quot;index&quot;:4},&quot;v&quot;:&quot;4. FLash 几乎所有浏览器都支持。备选方案。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[81,82],&quot;index&quot;:5},&quot;v&quot;:&quot;5. C#.NET&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[82,83],&quot;index&quot;:6},&quot;v&quot;:&quot;6. Intranet 企业内部网。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;服务端编程：过去，Python、C++使用CGI，Java使用servlet。将重点放在数据存储及业务逻辑上。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;1.14 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;过程型语言： 数据定义和函数调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;OOP和Java也许并不适合所有的人。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>本章介绍了面向对象的一些基本特征，并将Java中的实现方式与其它OOP语言（主要是C++）做了对比，体现出Java语言的优势。</li>
<li>理解本章内容需要过程编程及面向对象背景有一定的了解，从而更能感受到面向对象的优势。如果一上来就使用面向对象，甚至Java，则感觉不知所云。</li>
<li>之前也阅读过第一章内容，但是感觉云里雾里。刚好前段时间又重新学习了一下C，在回过头来看，有些概念就很容易理解了。</li>
<li>另一方面，需要对web的发展，以及Java诞生时的历史背景有所了解，这样才更能理解Java对于其它OOP语言来说，它的绝对优势是什么。我想这也是第14节用了比其它小节更多篇幅来描述Java与Internet关系的原因吧。</li>
<li>每一种语言，都有它流行的原因，也有它不得已而为之的地方。例如C++，它之所以流行是因为它完全向前兼容了C，而这也是它里面有些语法令人诟病的地方。Java同样也是。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2021/12/28/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8820%EF%BC%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;20.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;注解为在代码中添加信息提供了一种形式化的方法，使得可以在稍后某个时刻非常方便地使用这些数据。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;注解在一定程度上是在把元数据与源代码文件结合在一起，而不是保存在外部文档中这一大的趋势之下所催生的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;注解是众多引入到Java SE5中的重要的语言变化之一。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;注解可以提供用来完整地描述程序所需的信息，而这些信息是无法用Java来表达的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;注解的语法比较简单，除了@符号的使用之外，基本与Java固有的语法一致。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Java SE5内置了三种，定义在java.lang中的注解：@Override、@Deprecated、@SuppressWarnings。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Java另外提供了四种注解，专门负责新注解的创建。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;注解的出现，可以替代某些现存的系统。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;注解是真正的语言级的概念，一旦构造出来，就享有编译期的类型检查保护。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;注解是在实际的源代码级别保存所有的信息，而不是某种注释性的文字，这使得代码更整洁，且便于维护。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;通过使用扩展的annotation API，或外部的字节码工具类库，拥有对源代码以及字节码强大的检查与操作能力。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;20.1 基本语法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;被注解的方法与其它的方法没有区别。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;从语法的角度来看，注解的使用方式几乎与修饰符的使用一摸一样。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;注解的定义看起来很像接口的定义。事实上，与其他任何Java接口一样，注解也将会编译成class文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;在注解中，一般都会包含一些元素以表示某些值。没有元素的注解称为标记注解。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;元注解负责注解其他的注解：@Target、@Retention、@Documented、@Inherited。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;20.2 编写注解处理器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;使用注解的过程中，很重要的一个部分就是创建与使用注解处理器（用来读取注解的工具）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;Java SE5扩展了反射机制的API，以帮助构造注解处理器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;同时，还提供了一个外部工具apt帮助解析带有注解的Java源代码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;注解元素可用的类型：基本类型、String、Class、enum、Annotation、以上类型的数组。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;注解元素不能由不确定的值。对于非基本类型的元素，不能以null作为其值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;使用注解将信息保存在JavaBean源文件中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;快捷方式。名为value的元素。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;可以使用多种不同的方式来定义自己的注解。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;编译器允许对一个目标同时使用多个注解。同一个注解不能重复使用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;不能使用关键字extends来继承某个@interface。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;20.3 使用apt处理注解&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;注解处理工具apt是Sun为了帮助注解的处理过程而提供的工具。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;apt被设计为操作Java源文件，而不是编译后的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;自定义的每一个注解都需要自己的处理器，而apt工具能够很容易地将多个注解处理器结合在一起。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;通过使用AnnotationProcessorFactory，apt能够为每一个它发现的注解生成一个正确的注解处理器。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;20.4 将观察者模式用于apt&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;一个访问者会遍历某个数据结构或一个对象的集合，对其中的每一个对象执行一个操作。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;20.5 基于注解的单元测试&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;单元测试是对类中的每个方法提供一个或多个测试的一种实践，其目的是为了有规律地测试一个类的各个部分是都具备正确的行为。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;在Java中，最著名的单元测试工具是JUnit。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;有了注解，可以直接在要验证的类里面编写测试，这将大大减少单元测试所需的时间和麻烦之处。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;单元测试的方法没有参数，且返回值是boolean或void。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;编写单元测试时，唯一需要做的就是决定测试是成功还是失败。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;要生成一个非嵌入式的测试，最简单的办法就是继承。还可以使用组合的方式创建非嵌入式的测试。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;Java的断言机制一般要求在命令行中加上-ea标志。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;如果创建对象的类没有默认构造器， 或者新对象需要复杂的构造过程，可以创建一个static方法专门负责构造对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;用注解标记的域表示只在单元测试中使用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;也可以标记只在测试中使用的方法，而本身并不是测试方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;测试必须针对某个特定类型的参数或参数集才能进行。 -- 让测试类继承自泛型类的一个特定版本即可。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;用套件来组织测试。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;开源的Java assist工具类库将字节码工程带入了一个可行的领域。 -- 可以根据注解删除所有的单元测试。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;20.6 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;注解是Java引入的一项非常受欢迎的补充。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>图形化用户界面</title>
    <url>/2021/12/31/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8822%EF%BC%89%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;22.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Java 1.0版本中的图形用户界面（GUI）库，其最初的设计目标时帮助程序员编写在所有平台上都能良好表现的GUI程序。这个目标没有达到。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Java 1.0提供的AWT（Abstract Window Toolkit，抽象窗口工具包）编程模型非常笨拙，并且不是面向对象的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Java 1.1的AWT中引入了事件模型（更清晰的、面向对象的方法），及JavaBeans（最初是为了使可视化编程环境的创建变得更容易而引入的构件编程模型）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Java 2最终完成了从旧式的AWT到新标准的转换。其中有关GUI的部分被称为Swing。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;Swing使一组易于使用、易于理解的JavaBeans，它能通过拖放操作（也可以通过手工编写）来创建合理的GUI程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Java中仍然存在某些AWT构件，有时必须使用它们。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Swing与其他语言或开发环境相比，使已经改进了很多的编程模型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Swing中有一个非常令人称道的原则，称为正交使用。一旦你理解了库中某个通用概念，就可以把这个概念应用到其他地方。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;为了可移植性，Swing完全用Java编写。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Swing还支持可插式外观，用户界面的外观可以动态改变，以适应不同平台和操作系统下用户的习惯。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;22.1 applet&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;applet是一种可以在Internet上传递，并在Web浏览器中运行的程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Java applet作为客户端应用传递系统，从来都没有实现大规模应用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;如果可以保证用户安装了JRE，那么applet就有可能称为分发客户程序和自动更新所有机器的最佳方式，而这种方式不需要分发和安装新软件通常所需的那些开销和投入。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;22.2 Swing基础&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;大多数Swing应用都被构建在基础的JFrame内部，JFrame在使用任何操作系统中都可以创建视窗应用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;JLabel。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;其他线程应该通过Swing事件分发线程提交要执行的任务。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;22.3 创建按钮&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;创建按钮只要在希望出现在按钮上的标签调用JButton的构造器即可。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;一般来说，要在类中为按钮创建一个字段，以便以后可以引用这个按钮。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;FlowLayout，布局管理器，是面板用来隐式地决定控件在窗体上的位置的工具。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;22.4 捕获事件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;事件驱动编程的基础，就是把事件同处理事件的代码连接起来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;在Swing中，这种关联的方式就是通过清楚地分离接口（图形组件）和实现（当和组件相关的事件发生时要执行的代码）而做到的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;每个Swing组件都能够报告其上所有可能发生的事件，并且它能单独报告每种事件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;JTextField组件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;通常，把ActionListener实现成匿名内部类会更方便，尤其是对每个监听器类只使用一个实例的时候更是如此。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;22.5 文本区域&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;除了可以有多行文本以及更多的功能不同之外，JTextArea与JTextField在其他方面都很相似。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;JScrollPane。滚动控制。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;22.6 控制布局&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;在Java中，组件放置在窗体上的方式完全基于代码，没有用来控制组件布局的资源。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;组件放置在窗体上的方式不是通过绝对坐标控制，而是由布局管理器根据组件加入的顺序决定其位置。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;使用不同的布局管理器，组件的大小、形状和位置将大不相同。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;布局管理器还可以适应applet或应用程序窗口的大小。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;JApplet、JFrame、JDialog、JPanel等都可以包含和显式组件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;BorderLayout。默认布局模式。具有四个边框区域和一个中央区域的概念。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;FlowLayout。从左到右流动到窗体上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;GridLayout。构建一个放置组件的表格。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;GridBagLayout。最复杂的布局管理器。目的主要是辅助GUI构造工具自动生成代码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;TableLayout。GridBagLayout可替换选择。不属于Swing类库，需要单独下载。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;绝对定位。null。传递以像素坐标为单位的边界矩形的参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;BoxLayout。具有GridBagLayout的许多好处，却不像GridBagLayout那么复杂。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;只要理解了布局的方式以及如何处理事件，那么如何手工放置组件的细节就显得不那么重要了；应该让合适的工具去做这些事情。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;22.7 Swing事件模型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;在Swing的事件模型中，组件可以发起（触发）一个事件。每种事件的类型由不同的类表示。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;当事件被触发时，它将被一个或多个监听器接受，监听器负责处理事件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;事件发生的地方与事件处理的地方分离开。这是一个分离接口与实现的极佳例子。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;所谓事件监听器，就是一个实现特定类型的监听器接口的类对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;程序员要做的就是，先创建一个监听器对象，然后把它注册到触发事件的组件。这个注册动作是通过调用出发事件的组件的addXXXListener方法来完成的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;要编写一个监听器类，唯一的要求就是必须实现相应的接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;可以创建一个全局的监听器类，不过有时写成内部类会更有用。 1. 分组； 2. 持有对外部类的引用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;所有Swing组件都具有addXXXListener和removeXXXListener方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;事件模型是可扩展的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;每种组件所支持的事件类型都是固定的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;某些含有多个方法的监听器接口提供了相应的适配器。适配器为接口里的每个方法都提供了默认的空实现。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;适配器的出发点就是为了使监听器类变得更容易。也有某种形式的缺陷。-- @Override。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;22.8 Swing组件一览&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;按钮，AbstractButton。按钮组，ButtonGroup。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;图标，Icon。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;工具提示，setToolTipText。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;文本域，JTextField。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;边框，setBorder。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;编辑器，JTextPanel。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;复选框，JCheckBox。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;单选按钮，JRadioButton。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;组合框，JComboBox。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;列表框，JList。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;页签面板，JTabbedPane。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;消息框，JOptionPane。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;菜单，JMenuBar，JMenu，setJMenuBar。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;弹出式菜单，JPopupMenu。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;绘图，JComponent，JPanel，paintComponent。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;对话框，JDialog。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;文件对话框，JFileChoose。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;HTML，html标记。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;滑块与进度条，ProgressMonitor，JProgressBar。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;选择外观，UIManager。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;树、表格、剪贴板。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;22.9 JNLP与Java Web Start&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;JNLP，Java Network Launch Protocol，Java网络发布协议。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;JNLP是一个协议，而不是实现，Java Web Start是由Sun免费提供的官方参考实现，并且作为Java SE5的一部分而发布的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;能把applet的所有优点和应用程序的优点结合起来。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;22.10 Swing与并发&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;当你用Swing编程时，就是在使用线程。不用显式地创建Thread对象。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;22.11 可视化编程与JavaBean&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;类是最可重用的代码单元，因为它把性质（字段）和行为（方法）聚合成一个单元，所以它既可以被直接重用，也可以通过组合或继承得到重用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;可视化编程。Visual BASIC（VB）、Delphi。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;实际上可视化表示通常就是组件在运行的程序中可被观察到的方式。所以可视化编程的部分过程就包括了从选用区选择组件，然后把它拖放到窗体上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;在拖放的过程中，应用程序构建集成开发环境（IDE）会帮着生成相应的代码，这些代码将在程序实际运行的时候创建相应的组件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[105,106]},&quot;v&quot;:&quot;简单地把组件拖放到窗体上一般还不足以完成程序。通常，还必须改变组件的特征。可以在设计时被修改的特征被称为属性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;IDE构建工具能够使用反射机制来动态地向组件查询，以找出组件具有的属性和支持的事件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;可视化编程工具成功的原因就在于，极大地加速了程序的构建过程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[109,110]},&quot;v&quot;:&quot;通过引入JavaBean，Java把可视化组件的创建带到了最高的层次，因为Bean就是一个类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[110,111]},&quot;v&quot;:&quot;要编写一个Bean，不必添加任何代码或者使用任何特殊的语言功能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[111,112]},&quot;v&quot;:&quot;唯一要做的就是，对方法的名称做少许修改。通过方法得到名称就能告诉应用程序构建工具，这是一个工具，一个事件，还是只是一个普通方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;JavaBean命名规则。对于属性，需要get/set方法。通常，所有的字段都是私有的，只能通过方法和属性进行访问。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[114,115]},&quot;v&quot;:&quot;Java的反射机制能发现未知类的所有方法。Java语言里加入反射机制的主要原因之一就是为了支持JavaBean（对象序列化、RMI）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[115,116]},&quot;v&quot;:&quot;Introspector（内省器）类，标准工具，使用Bean用起来简单，而且对于创建更复杂的Bean也能提供一个标准方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[116,117]},&quot;v&quot;:&quot;静态getBeanInfo方法。传递一个Class对象引用，能够完全侦测这个类，然后返回一个BeanInfo对象，可以通过这个对象得到Bean的属性、方法和事件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[118,119]},&quot;v&quot;:&quot;当创建Bean的时候，必须要假设它可能会在多线程环境下运行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[119,120]},&quot;v&quot;:&quot;尽可能地让Bean中的所有公共方法都是synchronized的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[120,121]},&quot;v&quot;:&quot;当一个多路事件触发了一组对该事件感兴趣的监听器时，必须假定在遍历列表进行通知的同时，监听器可能会被添加或删除。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[122,123]},&quot;v&quot;:&quot;在把JavaBean加入到某个支持Bean的IDE之前，必须把它置于一个Bean容器中，也就是一个JAR文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[123,124]},&quot;v&quot;:&quot;一旦把Bean正确地打包成JAR文件，就可以把它导入支持Bean的IDE中了。导入方式根据不同的工具有所不同。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[125,126]},&quot;v&quot;:&quot;JavaBean架构提供的门槛很低，但也可以扩展到更复杂的情况。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[126,127]},&quot;v&quot;:&quot;可以针对属性提供高级功能。如索引属性：使用数组来表示多重属性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[127,128]},&quot;v&quot;:&quot;属性可以被绑定。PropertyChangeEvent。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;属性可以被约束。PropertyChangeEvent。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[129,130]},&quot;v&quot;:&quot;还可以改变Bean在设计阶段的表示方式。...&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[131,132]},&quot;v&quot;:&quot;22.12 Swing的可替代选择&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[132,133]},&quot;v&quot;:&quot;尽管Swing类库是Sun支持的GUI，但它决不是创建图形化用户界面的唯一方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[133,134]},&quot;v&quot;:&quot;有两种重要的可替代选择。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[134,135]},&quot;v&quot;:&quot;用于Web之上的客户端GUI的使用MacroMedia的Flex编程系统的MacroMedia Flash。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[135,136]},&quot;v&quot;:&quot;以及用于桌面应用的开源的Eclipse标准工具包（Standard Widget Toolkit，SWT）类库。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[137,138]},&quot;v&quot;:&quot;22.13 用Flex构建Flash Web客户端&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[138,139]},&quot;v&quot;:&quot;Flex由基于XML和脚本的编程模型以及非常健壮的组件库构成的，其中的编程模型与HTML和JavaScript的编程模型类似。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[139,140]},&quot;v&quot;:&quot;需要使用MXML语法来声明布局管理和工具控件，并且需要使用动态脚本机制来添加事件处理和服务调用代码。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[141,142]},&quot;v&quot;:&quot;22.14 创建SWT应用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[142,143]},&quot;v&quot;:&quot;swt.jar。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[144,145]},&quot;v&quot;:&quot;22.15 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[145,146]},&quot;v&quot;:&quot;IDE是真正革命性的进步。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>字段：Java类中的域。</li>
<li>属性：Java Bean中的概念，拥有get/set方法的字段。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>一切都是对象</title>
    <url>/2021/12/01/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%882%EF%BC%89%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;2.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Java是杂合型语言。 --允许多种编程风格。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;2.1 用引用操纵对象&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;每种编程语言都有自己的操纵内存中元素的方式。Java中一切都被视为对象，因此可采用单一固定的语法。操纵的标识符实际上是对象的一个“引用”。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;引用不一定需要一个对象与之关联。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;2.2 必须由你创建所有对象&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,14]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;通常使用new操作符来将一个新的对象和创建的引用相关联。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;对象存储位置：寄存器（处理器内部）、堆栈、堆、常量存储（ROM）、非RAM存储（流对象、持久化对象）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;基本类型需要特殊对待，置于堆栈中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;基本类型所占存储空间大小是不变的。&quot;}]},{&quot;t&quot;:&quot;table&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,25]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;thead&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;th&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;基本类型&quot;},{&quot;t&quot;:&quot;th&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;大小&quot;},{&quot;t&quot;:&quot;th&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;最小值&quot;},{&quot;t&quot;:&quot;th&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;最大值&quot;},{&quot;t&quot;:&quot;th&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;包装器类型&quot;}]},{&quot;t&quot;:&quot;tbody&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,25]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;tr&quot;,&quot;d&quot;:4,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;boolean&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;1bit&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;-&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;-&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;Boolean&quot;}]},{&quot;t&quot;:&quot;tr&quot;,&quot;d&quot;:4,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;char&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;16bit&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;Unicode 0&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;Unicode 2^16-1&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;Character&quot;}]},{&quot;t&quot;:&quot;tr&quot;,&quot;d&quot;:4,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;byte&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;8bit&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;-128&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;+127&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;Byte&quot;}]},{&quot;t&quot;:&quot;tr&quot;,&quot;d&quot;:4,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;short&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;16bit&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;-2^15&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;+2^15-1&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;Short&quot;}]},{&quot;t&quot;:&quot;tr&quot;,&quot;d&quot;:4,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;int&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;32bit&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;-2^31&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;+2^31-1&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;Int&quot;}]},{&quot;t&quot;:&quot;tr&quot;,&quot;d&quot;:4,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;long&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;64bit&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;-2^63&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;+2^63-1&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;Long&quot;}]},{&quot;t&quot;:&quot;tr&quot;,&quot;d&quot;:4,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;float&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;32bit&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;Float&quot;}]},{&quot;t&quot;:&quot;tr&quot;,&quot;d&quot;:4,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;double&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;64bit&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;Double&quot;}]},{&quot;t&quot;:&quot;tr&quot;,&quot;d&quot;:4,&quot;p&quot;:{},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;void&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;-&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;-&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;-&quot;},{&quot;t&quot;:&quot;td&quot;,&quot;d&quot;:5,&quot;p&quot;:{},&quot;v&quot;:&quot;Void&quot;}]}]}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[26,31]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;高精度数字：BigInteger、BigDecimal。支持任意精度。使用方法调用取代运算符，运算速度慢。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;数组：几乎所有的程序设计语言都支持数组。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;安全性史Java的主要目标之一，确保数组会被初始化，使用时进行范围检查。以内存开销及运行时的下标检查为代价。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;创建数组对象时，实际创建了一个引用数组。数组中的每个对象都为null。&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;2.3 永远不需要销毁对象&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;在大多数程序设计语言中，变量生命周期的概念，占据了程序设计工作中非常重要的部分。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;作用域定义了在其内定义的变量名的可见性和生命周期。作用域由花括号的位置决定。在作用域里定义的变量只可用于作用域结束之前。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;Java垃圾回收器，用来监视new创建的所有对象，并辨别那些不会在被引用的对象。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;2.4 创建新的数据类型：类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;从历史发展角度来看，大多数面向对象的程序设计语言习惯用关键字class来表示创建新的数据类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;class关键字之后紧跟着的是新类型的名称。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;可以在类中设置两种类型的元素：字段（数据成员）和方法（成员函数）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;在Java中所作的全部工作就是定义类，产生那些类的对象，以及发送消息给这些对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;每个对象都有用来存储其字段的空间，普通字段不能在对象间共享。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;点号操作符：引用对象的成员。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;基本类型变量，即使没有初始化，Java确保获得一个默认值（只有成员变量）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;2.5 方法、参数和返回值&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;方法的基本组成包括：名称、参数、返回值和方法体。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;方法签名（方法名+参数列表）唯一地标识出某个方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;Java中的方法只能作为类的一部分创建，只有通过对象/类才能调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;点号操作符：调用方法。对象名.方法名(参数列表)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;调用方法的行为通常被称为发送消息给对象。即向对象发送消息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;方法参数传递的实际是引用（除基本类型），且引用的类型必须正确。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;return： 1. 离开此方法；2. 此方法产生了一个值。若返回类型是void，return关键字的作用只是用来退出方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;2.6 构建一个Java程序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;名字管理对任何程序设计语言来说，都是一个重要问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;C++类将函数包于其类，从而避免于其他类中的函数名相冲突。C++允许全局数据和全局函数的存在，使用名字空间来解决。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;Java采用域名反转的方式，保证类库生成不会于其它名字混淆的名字。Java语言本身解决了同一个文件内的每个类都有唯一的标识符。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;Java消除了“向前引用”问题：可以在类中使用在该类的后面定义的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;使用import准确引入位于其它文件中的类，消除混淆情况。可以使用通配符“*”。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;当创建类是，就是在描述那个类的对象的外观与行为。执行new创建对象时，数据存储空间才会被分配，其方法才供外界调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;static： 1. 为特定域分配的那一存储空间；2. 方法不于包含它的那个类的任何对象关联（没有创建对象，也能调用方法）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;类数据、类方法，代表那些数据和方法只能是作为整个类，而不是类的某个特定对象而存在的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;引用static变量：1. 对象.变量名； 2. 类.变量名（推荐）。 调用static方法：1. 对象.方法名(...)； 2. 类.方法名(...)（推荐）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;当static作用于某个字段是，会改变数据创建的方式。static作用于方法，区别不大。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;2.7 第一个Java程序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;在每个程序文件的开头，声明import语句，引入在文件代码中需要用到的额外类（java.lang会自动被导入到每一个Java文件中）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;创建一个独立运行的程序，文件中必须存在某个类于该文件同名，且那个类包含一个main方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;main方法参数args用来存储命令行参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;编译（javac命令）、运行（java命令）Java程序必须要有Java开发环境JDK。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;2.8 注释和嵌入式文档&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;块注释：以“/*”开头，以“*/”结束，中间可以跨多行。源于C/C++。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;单行注释：“//”。源于C++。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;Java为实现代码同文档连接起来，使用一种特殊的注释语法来标记文档，还需要一个工具（javadoc，JDK安装的一部分）来提取注释，并将其转换成有用的形式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;javadoc输出的是一个HTML文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;注释文档：以“/**”开头，以“*/”结束。可以使用嵌入式文档HTML和文档标签。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;文档标签有独立文档标签（以”@“字符开头的命令，至于注释行”*“之后最前面）和行内文档标签（以”@“开头，括在花括号内）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;三种类型的注释文档，分别对应于注释位置后面的三种元素：类、域和方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;2.9 编码风格&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;类的首字母要大写。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;使用“驼峰风格”。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>本章讲述Java程序的基本组成部分，以及编写一个程序时所需要注意的地方，另外还有与其它语言的对比。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>操作符</title>
    <url>/2021/12/02/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%883%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;3.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;在最底层，Java中的数据是通过使用操作符来操作的。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;3.1 更简单的打印语句&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;静态导入static import。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;3.2 使用Java操作符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;操作符作用于操作数，接受一个或多个参数，并生成一个新值。参数形式与普通方法调用不同。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;副作用：操作符改变操作数自身的值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;能改变其操作数的操作符，最普遍的用途是用来产生副作用。使用有副作用的操作符和没有副作用的操作符，生成的值没有什么区别。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;几乎所有的操作符都只能操作基本类型。例外的操作符是“=”、“==”、“！=”，这些能操作所有的对象。String类支持“+”、“+=”操作符。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;3.3 优先级&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;当一个表达式中存在多个操作符时，操作符的优先级决定了各部分的计算顺序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;最简单的规则是先乘除后加减。程序员经常会忘记其他优先级规则，所以应该用括号明确规定计算顺序。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;3.4 赋值&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;取右边的值，把它复制给左边。右值可以是任何常数、变量或者表达式。但左值必须是一个明确的，已命名的变量。即必须有一个物理空间可以存储等号右边的值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;基本类型存储了实际的数值，为其赋值时，是直接将一个地方的内容复制到了另一个地方。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;别名现象：多个变量引用指向同一个对象。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;3.5 算术操作符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;包括&amp;quot;+&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;%&amp;quot;。整数除法会直接去掉结果的小数位。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;操作符简化：&amp;quot;+=&amp;quot;, &amp;quot;-=&amp;quot;, &amp;quot;*=&amp;quot;, &amp;quot;/=&amp;quot;, &amp;quot;%=&amp;quot;。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;一元加减号：编译器自动识别，规范加括号。（eg：x = a*(-b)）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;一元减号用于改变数据的符号. 一元加号只是为了与一元减号对应，但可以将较小类型的操作数提升为int。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;3.6 自动递增和递减&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;递增、递减是两种快捷运算。Java提供了大量的快捷运算，使编码更方便。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;包括&amp;quot;i++&amp;quot;,&amp;quot;++i&amp;quot;,&amp;quot;i--&amp;quot;,&amp;quot;--i&amp;quot;。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;前缀会先执行运算，在生成值。后缀会先生成值，在执行运算。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;除涉及赋值的操作符以外，唯一具有&amp;quot;副作用&amp;quot;的操作符（会改变操作数）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;3.7 关系操作符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;包括&amp;quot;&amp;gt;&amp;quot;, &amp;quot;&amp;lt;&amp;quot;, &amp;quot;&amp;gt;=&amp;quot;, &amp;quot;&amp;lt;=&amp;quot;, &amp;quot;==&amp;quot;, &amp;quot;!=&amp;quot;。生成的是一个boolean结果（true/false）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;&amp;quot;==&amp;quot;,&amp;quot;!=&amp;quot;适用于所有基本类型，其它不适用于boolean类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;==：比较引用。equals默认比较引用，重写比较内容，不适合用于基本类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;3.8 逻辑操作符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;包括&amp;quot;&amp;amp;&amp;amp;&amp;quot;, &amp;quot;||&amp;quot;, &amp;quot;!&amp;quot;。能根据参数的逻辑关系，生成一个boolean值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;只可应用于boolean值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;短路：一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下的部分了。潜在的性能提升。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;3.9 直接常量&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;编译器可以明确地知道要生成什么样的类型。用与直接常量相关的某些字符来额外增加一些信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;直接常量后面的后缀字符标志了它的类型。直接常量的前缀标识不同进制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;前缀：&amp;quot;0x&amp;quot;十六进制，&amp;quot;0&amp;quot;十进制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;后缀：&amp;quot;l/L&amp;quot;浮点型，&amp;quot;d/D&amp;quot;双精度型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;指数记数：e 代表 &amp;quot;10的幂次&amp;quot;。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;3.10 按位操作符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;包括&amp;quot;&amp;amp;&amp;quot;, &amp;quot;|&amp;quot;, &amp;quot;~&amp;quot;, &amp;quot;^&amp;quot;。用来操作整个基本数据类型的单个bit，即二进制位。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;来源于C语言面向底层的操作。Java的设计初衷是嵌入电视机顶盒内，所以这种操作被保留了下来。但是不会过多的使用到。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;除“~”（一元操作符）外，可与&amp;quot;=&amp;quot;联合使用.&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;3.11 移位操作符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;包括&amp;quot;&amp;lt;&amp;lt;&amp;quot;(左移，低位补0), &amp;quot;&amp;gt;&amp;gt;&amp;quot;(有符号右移，高位正插0，负插1), &amp;quot;&amp;gt;&amp;gt;&amp;gt;&amp;quot;(无符号右移，高位插0)。操作对象是二进制的bit。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;只可用来处理整数类型（基本数据的一种）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;可与&amp;quot;=&amp;quot;联合使用。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;3.12 三元操作符 if-else&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;三元操作符也称条件操作符。有三个操作数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;表达式：boolean-exp ? value0 : value1;。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;3.13 字符串操作符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;包括&amp;quot;+&amp;quot;， &amp;quot;+=&amp;quot;。用来连接不同的字符串。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;C++可以为几乎所有操作符增加功能。而Java不能实现自己的重载操作符。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;如果表达式以一个字符串起头，那么后续所有操作数都必须是字符串类型（编译器会把双引号内的字符序列自动转成字符串）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;3.14 使用操作符时常犯的错误&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;即使对表达式如何计算优点不确定，也不愿意使用括号。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;“=”“==”、“&amp;amp;”“&amp;amp;&amp;amp;”、“|”“||” 可能会输入错误。Java编译器可防止这种错误发生，因为不允许把一种类型当作另一种类型来用。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;3.15 类型转换操作符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;类型转换(cast)。显式的进行类型的转换，或者在不能自动进行转换时强制进行类型转换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;将float、double转为整型，会截尾，即向下取整。可以使用Math.round()，四舍五入。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;对基本数据类型进行执行算术运算或按位运算，只要类型比int小，在运算之前，会自动转换成int，最终结果就是int型，如果要把结果赋值给较小的类型，就必须使用类型转换。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;3.16 Java没有sizeof&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;C/C++中，sizeof()操作符返回数据分配的字节数。使用sizeof最大的原因是为了“移植”。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;Java不需要sizeof，因为所有类型在所有机器中的大小是相同的。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;3.17 操作符小结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;对boolean的运算有限，只能赋予true和false。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;对char、byte、short进行任何算术运算时，数据类型会提示为int。必须显示转换为原来的类型（可能会丢失信息）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;对int执行乘法运算，结果可能会溢出。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>C中明确比较了操作符的优先级，而Java则建议使用括号来明确优先级。</li>
<li>除了字符串支持（+=、+）及赋值（=）操作符，其它操作符的操作数都是基本类型。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>控制执行流程</title>
    <url>/2021/12/02/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%884%EF%BC%89%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;4.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Java使用了C的所有流程控制语句。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;4.1 true和false&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;所有条件语句都利用表达式的真或假来决定执行路径。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;4.2 if-else&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;控制程序流程最基本的形式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;else是可选的。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;4.3 迭代&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;while、do-while、for。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;do-while至少会执行一次。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;Java中唯一用到逗号操作符的地方就是for循环的控制表达式。用逗号操作符隔开的语句，均会独立执行。（逗号分隔符用来分隔函数不同参数。）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;4.4 Foreach语法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;更加简洁的for语法用于数组和容器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;不必创建int变量去访问项构成的序列进行计数，foreach将自动产生每一项。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;4.5 return&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;指定一个方法的返回值。退出当前方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;4.6 break 和 continue&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;break用于强行退出循环，不执行循环中剩余的语句。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;continue用于停止执行当前的迭代，然后退回循环起始处，开始下一次迭代。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;4.7 臭名昭著的goto&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;goto起源于汇编语言的程序控制。Java编译器生成自己的“汇编代码”，运行在JVM上，而不是CPU硬件上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;goto是Java的保留字，但Java中没有goto。Java中使用相同机制的 标签（label: (后面紧跟冒号的标识符)），作为中断迭代语句的一种方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;Java中使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;4.8 switch&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;根据表达式的值，从一系列代码中选出一段去执行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;选择因子：int(byte，char，short 会自动转型为int)，enum（Java SE 5.0），String (Java SE 7)。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>大多数编程语言都具有的基本特性：运算、操作符优先级、类型转换、选择、循环等。</li>
<li>在大多数情况下，for、while可以相互转换，但是有break、continue时不能转换。</li>
<li>流程控制看似简单，但是日常开发中最常用的。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>初始化与清理</title>
    <url>/2021/12/03/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%885%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;5.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;初始化和清理正是设计安全的两个问题。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;5.1 用构造器确保初始化&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;创建对象时，如果其内具有构造器，Java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;构造器命名：与类名相同，所以“每个方法首字母小写”的编程风格不适用于构造器。1. 不会与其它方法冲突；2. 编译器直到该调用哪个方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;构造器有助于减少错误，并使代码更易于阅读。从概念上讲，初始化与创建使彼此独立的，在Java中，捆绑在一起，两者不能分离。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;构造器没有返回值，与void不同。new表达式返回了对新建对象的引用，但构造器本身并没有返回任何值。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;5.2 方法重载&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;方法重载：对相同的概念使用相同的名字。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;在Java和C++中，构造器是强制重载方法的一个原因。构造器的名字已经由类名确定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;方法重载是构造器所必需的，但亦可用于其他方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;每个重载的方法都必须有一个独一无二的参数类型列表（参数类型、参数顺序（会使代码难以维护））。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;基本类型当作参数会先提升类型，然后传参。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;根据返回值无法区分方法重载。为了副作用而调用就会忽略其返回值。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;5.3 默认构造器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;如果类中没有构造器，编译器会自动创建一个默认构造器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;如果已有构造器，则不会创建。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;5.4 this关键字&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;为了能用简便、面向对象的语法来编写代码，编译器做了一些幕后工作，把“所操作对象的引用”作为第一个参数传给方法(方法在内存中只有一份)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;只能在方法内部使用，表示对“调用方法的那个对象”的引用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;使用高级语言的原因之一就是它会帮我们做一些事情。如传递对当前对象的引用（this），所以除非必要，则不用使用this。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;必须使用this的情况：1. 需要返回当前对象的引用时，return this;。2. 将当前对象作为参数传递给其他对象。3. 在构造器中调用构造器(只能调用一个，且必须将构造器的调用至于最起始处)。4. 参数名和数据成员名称相同时，使用this来代表数据成员。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;static方法：没有this的方法（不用将当前对象引用作为第一个参数传给方法）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;static主要用途：没有创建任何对象的前提下，使用类本身调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;static不是面向对象的？&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;5.5 清理：终结处理和垃圾回收&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;程序员都了解初始化的重要性，但常常会忘记同样也重要的清理工作。Java有垃圾回收器负责回收无用对象占据的内存资源。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;在C++中，对象一定会被销毁（析构函数）。而在Java中，对象并非总是被垃圾回收。1. 对象可能不被垃圾回收；2. 垃圾回收不等于析构；3. 垃圾回收只与内存有关。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;垃圾回收本身也有开销。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;不论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;本地方法（在Java中调用非Java代码的方式）通过某种创建对象方式以外的方式为对象分配了存储空间，需要在finalize()方法来释放。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;本地方法目前只支持C/C++，但它们可以调用其它任何语言的代码，相当于可以调用任何代码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;Java不允许创建局部对象。C++局部对象销毁动作发生在}为边界。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;在堆上分配对象的代价十分高昂，涉及到对象销毁后重新利用内存。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;Java垃圾回收器对于对象创建速度有明显的提高。Java从堆分配空间的速度，可以和其它语言从堆栈上分配空间的速度相媲美。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;引用计数：常用来说明垃圾收集的工作方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;更快的模式：从堆栈和静态存储区考试，遍历所有引用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;Java虚拟机采用自适应的垃圾回收技术，如何处理找到的存活对象，却决于不同的虚拟机实现。有一种做法是“停止-复制”。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;停止-复制问题：1. 得有两个堆，空间大（按需分配几款较大的内存）； 2. 可能只有少量垃圾，甚至没有垃圾（转到标记-清扫）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;标记-清扫：从堆栈和静态存储区考试，遍历所有引用，标记存活对象，全部标记工作完成之后，清理动作才会开始，清理过程中，没有标记的对象将被释放，不会发生任何复制动作。 -- 希望得到连续空间就得重新整理。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;垃圾回收动作发生的同时，程序将会被暂停（停止-复制、标记-清扫）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;在Java虚拟机中，内存分配以较大的“块”为单位。如果对象较大，会占用单独的块。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;每个块都有相应的代数来记录它是否存活。清理时，大型对象不会被复制，只是增加代数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;自适应：Java虚拟机监视结果，自动切换“停止-复制”与“标记-清扫”。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;自适应的、分代的、停止-复制、标记-清扫 式垃圾回收器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;Java虚拟机中有许多附加技术用以提升速度。如HotSpot中的JIT（Just-In-Time）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;5.6 成员初始化&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;Java尽力保证：所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;类的数据成员(全局变量)，基本类型会默认有一个初始值，对象引用会获得特殊值null。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;可以在定义类成员变量的地方为其赋值。可以调用方法。方法可以带参，但是参数必须时已初始化的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;每个对象都有相同的初值。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;5.7 构造器初始化&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;通过构造器来进行初始化(无法阻止自动初始化的进行，它将在构造器调用之前发生)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;变量定义的先后顺序决定了初始化的顺序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;静态数据只占用一份存储区域。static关键字不能应用于局部变量，只能作用于域。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;静态数据在第一次访问静态数据（构造器也是static方法）时被初始化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;显式的静态数据初始化：静态代码块。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;非静态实例初始化：普通代码块(匿名内部类的初始化)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;构造器没有显式地使用static，但也是静态方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;5.8 数组初始化&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;数组是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。通过方括号下标操作符来定义和使用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;声明数组时编译器不允许指定数组的大小（只是创建了一个数组的引用并未该引用分配了空间，并没有给数组本身分配空间）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;初始化表达式：由一对花括号括起来的值组成。在这种情况下，存储空间的分配(等价于使用new)由编译器负责。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;所有数组都有一个固有成员length，用来获知数组内包含了多少个元素。只能访问不能修改。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;Java不允许下标越界，一旦越界，就会出现运行时错误。通过每次在访问数组的时候检查边界实现，检查是需要开销的，且无法禁用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;可以用new在数组里创建元素（只能用在数组被定义之处），也可以用花括号括起来的列表来初始化对象数组（可以在任何地方使用）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;使用可变参数，指定参数时，编译器会自动填充为数组，获取的仍旧是个数组。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;int数组的class： [I。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;应该只在重载方法的一个版本上使用可变参数列表，或者压根不使用。（可变参数列表使得重载过程变得复杂了，每一种情况，编译器都会使用自动包装机制来匹配重载的方法，然后调用最明确匹配的方法。）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;5.9 枚举类型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;枚举类型的实例是常量，按照命名惯例使用大写字母表示(多个单词用下划线隔开)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;为了使用enum，需要创建一个该类型的引用，并将其赋值给某个实例。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;创建enum时，编译器自动添加toString()，ordinal()(声明顺序)，values()(按声明顺序，产生由常量构成的数组)方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;与switch配合使用。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;5.10 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;Java的速度问题是涉足某些特定编程领域的障碍。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>Java中付出了一定的开销，来保证代码的安全性，使使用更简单。这种权衡使得Java更加面向上层应用开发，而更加使底层开发者望而却步。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>访问权限控制</title>
    <url>/2021/12/04/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%886%EF%BC%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;6.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;重构即重写代码，以使得它更可读、更易理解，并因此而更具有可维护性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;面向对象中需要考虑的一个基本问题：如何把变动的事物与保持不变的事物区分开来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Java提供了访问权限修饰词，以供类库开发人员向客户端程序员指明哪些式可用的，哪些式不可用的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;访问权限控制的等级，从最大权限到最小权限依次为：public、protected、包访问权限、private。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;Java中用关键字package将构建捆绑到一个内聚的类库单元中。而访问权限修饰词会因类是存在于一个相同的包，还是存在于一个单独的包而受到影响。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;6.1 包：库单元&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;包内包含有一组类，它们在单一的名字空间之下被组织在了一起。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;import关键字是程序变得简单。不使用import得用类全名来指定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;没有指定package，则在未命名包/默认包中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;每个编译单元都只能有一个public类，该类的名称必须与文件名称相同（包括大小写，不包括后缀名）。其它额外的类在包之外无法看到，因为它们主要用来为主public类提供支持。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;当编译.java文件时，文件中的每个类都会有一个输出文件。因此，在编译少量.java文件之后，会得到大量的.class文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR，Java Archive）的.class文件。Java解释器负责这些文件的查找、装载和解释。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;类库实际上是一组类文件，如果希望这些构件从属于同一个群组，就可以使用关键字package。如果使用package语句，它必须是文件中除注释以外的第一句程序代码。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;package和import关键字是将单一的全局名字空间分隔开，使得不会出现名称冲突问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;一个包从未真正将被打包的东西包装成单一的文件，并且要给包可以由许多.class文件构成。 -- 操作系统层次化文件结构、jar工具？。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;将所有的文件收入子目录还可以解决另外两个问题：怎样创建独一无二的名称以及怎样查找有可能隐藏于目录结构中某处的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;package的第一部分是类的创建者的反顺序的域名，第二部分是把package分解为机器上的一个目录。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;Java解释器运行过程：找出CLASSPATH（包含一个或多个目录，及JAR文件路径），从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，产生一个路径名称，查找相关的.class文件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;Java没有C的条件编译功能，该功能绝大多数情况下是用来解决跨平台的问题的，对Java而言没有必要。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;务必记住，无论合适创建包，都已经在给定包的名称的时候隐含地指定了目录结构。这个包必须位于其名称所指定的目录之中，而该目录必须是在以CLASSPATH开始的目录中可以查询到的。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;6.2 Java访问权限修饰词&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;访问修饰词public、protected、private置于类中每个成员（域、方法）的定义之前。每个访问权限修饰词仅控制它所修饰的特定定义的访问权。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;如果不提供任何访问权限修饰词，则意味着它是“包访问权限”。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;默认访问权限没有任何关键字，通常指包访问权限。意味着当前的包中的其他所有类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员却是private。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;一个编译单元只能隶属于一个包，所以经由包访问权限，处于一个编译单元中的所有类彼此之间都是自动可访问的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;包访问权限为把类群聚在一个包中的做法提供了意义和理由。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;关键字public意味着之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;Java将没有设定任何包名称的文件自动看作是隶属于该目录的默认包之中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;// TODO -- 与设定了包名称的？？？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;private除了包含该成员的类之外，其他任何类都无法访问这个成员。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;protected处理的是继承的概念。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;protected也提供了包访问权限。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;6.3 接口和实现&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;访问权限的控制常被称为是具体实现的隐藏。把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作封装。其结果是一个同时带有特征和行为的数据类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;访问权限控制将权限的边界划在了数据类型的内部。1. 要设定客户端程序员可以使用和不可以使用的界限；2. 将接口和具体实现进行分离。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;javadoc所提供的注释文档功能降低了程序代码的可读性对客户端程序员的重要性。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;6.4 类的访问权限&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;访问权限修饰词也可以用于确定库中的哪些类对于该库的使用者是可用的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;每个编译单元都只能包含有一个public类，且public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;编译单元可以不带public类。在这种情况下，可以随意对文件命名，该类只可以用于该包之中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;类不可以是private的，也不可以是protected的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;如果不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private。 -- static例外。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;单例模式。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>可以不使用操作系统的层次化文件结构，而直接使用package来指定，但这样会存在冲突。</li>
<li>package是java建立的用于解决命名冲突的。而这在实际开发中确实很有用，省去了很多麻烦。</li>
<li>访问权限控制虽然只有几个关键字，但要用好却不是一件简单的事。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>复用类</title>
    <url>/2021/12/04/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%887%EF%BC%89%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;7.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;使用类而不破坏现有程序代码。 1. 组合； 2. 继承。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;继承是面向对象程序设计的基石之一。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;7.1 组合语法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;将对象引用置于新类中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;组合对象初始化：1. 在定义对象的地方；2. 在类的构造器中；3. 使用对象之前； 4. 使用实例初始化（代码块）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;7.2 继承语法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;继承是所有OOP语言和Java语言不可缺少的组成部分。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;当创建一个类时，总是在继承。除非已明确指出要从其他类中继承，否则就是在隐式地从Java的标准跟类Object进行继承。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;继承声明式通过在类主体的左边花括号之前，书写后面紧随基类名称的关键字extends而实现的。会自动得到基类中所有域和方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;Java中用super关键字表示超类的意思，当前类就是从超类继承的来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;在继承的过程中，并不一定非得使用基类的方法，也可以在导出类中添加新方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;在构造器中调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需要的所有知识和能力。Java会自动在导出类的构造器中插入对基类构造器的调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;如果没有默认的基类构造器，或想调用一个带参数的基类构造器，就必须用super显式地编写调用基类构造器的语句，并且配以适当的参数列表。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;7.3 代理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;Java没有提供对代理的直接支持。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;这是继承域组合之间的中庸之道，将一个成员对象置于所要构造的类中（就像组合），与此同时在新类中暴露了该成员对象的所有方法（就像继承）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;7.4 结合使用组合和继承&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;虽然编译器强制要求初始化基类，并且要求在构造器起始处就要这么做，但是并不监督必须将成员对象也初始化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;try-finally。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;手动清理时注意清理顺序。一般来说与生成顺序相反。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;如果Java的基类拥有多个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本（与C++不同）。无论是在该层或者它的基类中对方法进行定义，重载机制都可以正常工作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;Java SE5.0 新增加了@Override注解表示覆写每个方法。可以防止在不想重载时而意外地进行了重载。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;7.5 在组合与继承之间选择&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;组合和继承都允许在新的类中放置子对象，组合是显式做，继承是隐式地做。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;组合技术通常用于想在新类中使用现有类地功能而非它地接口这种情形。即在新类中嵌入某个对象，让其实现所需要的功能，但类中的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;在继承地时候，使用某个现有类，并开发一个它的特殊版本。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;7.6 protected关键字&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;就类用户而言，这是private的，但对于任何继承于此类的导出类或其他任何位于同一个包内的类来说，它却是可以访问的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;尽管可以创建protected域，但最好的方式还是将域保持为private，应当一直保留“更改底层实现”的权利，然后通过protected方法来控制类的继承者的访问权限。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;7.7 向上转型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;“为新的类提供方法”并不是继承技术最重要的方面，其最重要的方面是用来表现新类和基类之间的关系。这种关系可以用“新类是现有类的一种类型”这句话加以概括。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;这个描述并非只是一种解释继承的华丽的方式，这直接是由语言所支撑的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;传统类的继承图的绘制方法：将根置于页面的顶端，然后逐渐向下。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;由导出类转型成基类，在继承图上是向上移动的，因此一般成为向上转型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;在向上转型的过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;慎用。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;7.8 final关键字&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;根据上下文环境，Java的关键字final的含义存在着细微的区别，但通常指的是“这是无法改变的”。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;final可用于 数据、方法和类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;编译时常量（带有恒定初始值）： final 基本类型/基本类型计算式。必须在定义的时候对其进行赋值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;一个既是static又是final的域只占据一段不能改变的存储空间。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;对于基本类型，final使数值恒定不变；而用于对象引用，final使引用恒定不变。对象自身是可以被修改的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;static final 基本类型：用大写表示，用下划线分隔单词。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;看起来，使引用成为final没有使基本类型成为final的用处大。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;空白final，指被声明为final但未给定处置的域。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;编译器确保空白final在使用前必须被初始化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;空白final在关键字final的使用上提供了更大的灵活性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;Java允许在参数列表中以声明的方式将参数指明为final。意味着无法在方法中更改参数引用所指向的对象。或无法修改基本类型的参数。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;这一特性主要用来向匿名内部类传递数据。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;final方法：1. 锁定方法，以防继承。确保在继承中使方法行为保持不变，并且不会被覆盖；2. 效率（早期版本）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;类中所有的private方法都隐式地指定为是final的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;覆盖只有在某方法是基类的接口的一部分是才会出现。如果某方法是private，只不过是具有相同的名称而已。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;当将某个类的整体定义为final时，表明了你不打算继承该类，而且也不允许别人这样做。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;final类的域可以根据需要选择为是或不是final。不论类是否被定义为final，相同的规则都适用于定义为final的域。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;final类中的方法都隐式指定为是final的。可以添加final修饰词，但没有任何意义。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;要预见类是如何被复用的一般是很困难的。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;7.9 初始化及类的加载&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;在许多传统语言中，程序是作为启动过程的一部分立刻被加载的。然后是初始化，紧接着程序开始运行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;Java采用了一种不同的加载方式。每个类的编译代码都存在于它自己的独立的文件中，该文件只在需要使用程序代码时才会被加载。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;构造器也是static方法。类是在任何static成员被访问时加载的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;加载顺序：基类static - 导出类static - 初始化 - 基类构造器 - 导出类构造器 - 实例变量 - 其余部分。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;7.10 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;继承和组合都能从现有类型生成新类型。组合一般是将现有类型作为新类型底层实现的一部分来加以复用，而继承复用的是接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;程序开发是一个增量过程。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>继承是面向对象的基础，但是每个语言的实现却并不相同。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>多态</title>
    <url>/2021/12/04/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%888%EF%BC%89%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;8.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;多态的作用是消除类型之间的耦合关系。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;8.1 再论向上转型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;忘记对象类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;8.2 转机&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;将一个方法调用同一个方法主体关联起来被称为绑定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;在程序执行前进行绑定（如果有的话，由编译器和连接程序实现）叫做前期绑定。 --面向过程语言中不需要选择就默认的绑定方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;在运行时根据对象的类型进行绑定叫做后期绑定（也叫动态绑定或运行时绑定）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;Java中除了static方法和final方法之外，其他的所有方法都是后期绑定，且会自动发生。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;在编译时，编译器不需要获得任何特殊信息就能进行正确的调用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;只与基类通信，这样的程序时可扩展的，因为可以从通用的基类继承出新的数据类型，从而新添一些功能。那些操作基类的接口的方法不需要任何改动就可以应用于新类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;只有非private才可以被覆盖。在导出类中，对于基类中的private方法，最好采用不同的名字。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;只有普通方法的方法调用可以是多态的。任何域访问操作都由编译器解析。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;8.3 构造器和多态&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;只有基类的构造器才具有恰当的知识和权限来对自己的元素进行初始化。因此，必须令所有构造器都得到调用，否咋就不可能正确构造完整对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行处理。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;构造器内部的多态方法的行为。 --可能会造成一些难于发现的隐藏错误。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;初始化过程：1. 分配对象存储空间初始化； 2. 调用基类构造器； 3. 按照声明顺序调用成员的初始化方法； 4. 调用导出类的构造器主体。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;构造器准则：用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其他方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;8.4 协变返回类型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;Java SE5 中添加了协变返回类型，它表示在导出类的被覆盖方法可以返回基类的返回类型的某种导出类型。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;8.5 用继承进行设计&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;用继承表达行为间的差异，并用字段表达状态上的变化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;状态模式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;is-a：采用纯粹的方式来创建继承层次结构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;is-like-a：有着相同的基本接口，但是它还具有由额外方法实现的其他特性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;必须由某种方法来确保向下转型的正确性。早某些程序设计语言中，必须执行一个特殊的操作符来获得安全的向下转型。在Java中，所有转型都会得到检查。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;在运行期间对类型进行检查的行为称作“运行时类型识别（RTTI）”。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>Java比其它一些程序设计语言在底层做了更多的事，让程序员能够更加不关心底层实现，这样做在使用上会比其他程序设计语言更加简单。</li>
<li>虽然有些操作编译器运行我们进行，但结果可能并不是期望的。所以在实际使用时还得遵循一些准则。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2021/12/12/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%889%EF%BC%89%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;9.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;接口和内部类提供了一种将接口与实现分离的更加结构化的概念。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;这种机制在编程语言中并不通用。在Java中存在语言关键字提供了直接支持。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;9.1 抽象类和抽象方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;创建抽象类是希望通过这个通用接口操纵一系列类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;相较于没有抽象类的情况，抽象类可以在编译器捕获问题。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;抽象类是不完整的，为抽象类创建对象是不安全的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;没有任何抽象方法的抽象类。 -- 阻止产生这个类的任何对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;抽象类和抽象方法可以使类的抽象性明确起来。是很有用的重构工具。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;用abstract关键字来限定抽象类和抽象方法。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;9.2 接口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;interface关键字使抽象的概念更向前迈进了一步。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;interface关键字产生一个完全抽象的类，没有提供任何具体实现。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;接口被用来建立类与类之间的协议。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;interface允许通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继承的特性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;接口可以包含域，隐式声明为 static final。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;接口中的方法隐式声明为 public。实现一个接口时，实现的方法必须被定义为是public的。（Java编译器不允许继承过程中访问权限被降低。） 包访问权限的public意义？？？&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;9.3 完全解耦&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;能够根据所传递的参数对象的不同而具有不同行为的方法，被称为策略模式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;复用不在同一继承结构中的某个类。1. 遵循接口编写实现类。2. 适配器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现，因此代码更具可复用性。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;9.4 Java中的多重继承&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;接口没有具体实现，也就是说，没有任何与接口相关的存储。因此，无法阻止与接口的组合。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;在C++中，组合多个类的接口的行为被称为多重继承（C++对接口只有间接的支持）。在Java中可以执行相同的行为，但是只有一个类可以有具体实现。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;从一个非接口的类继承，只能从一个类去继承，其它的基元素必须是接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;可以继承任意多个接口，并可以向上转型为每个接口，因为每一个接口都是一个独立类型。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;使用接口的原因：1. 为了能够向上转型为多个基类型； 2. 防止创建该类的对象。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;9.5 通过继承来扩展接口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;通过继承，可以在接口中添加新的方法声明，还可以在新街口中组合接口。这两种情况都可以获得新的接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;在打算组合的不同接口中使用相同的方法名通常会造成代码可读性的混乱。应尽量避免这种情况。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;9.6 适配接口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;允许同一个接口具有不同的具体实现。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;interface提供伪多重继承机制。适配器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;让方法接受接口类型，是一种让任何类都可以对该方法进行适配的方式。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;9.7 接口中的域&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;接口中的域自动是 public static final，所以接口成为了一种很便捷的创建常量组的工具。在Java SE5 之前，产生与enum具有相同效果的类型的唯一途径。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;Java中表示具有常量初始值的static final时，使用大写字母的风格（下划线分隔多个单词）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;接口中定义的域不能是“空final”，但可以是被非常量表达式初始化。在类第一次被加载时初始化。值被存储在该接口的静态存储区域内。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;9.8 嵌套接口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;接口可以嵌套在类或其它接口中。嵌套接口可以被实现为private。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;实现了一个private接口的内部类，同样可以被实现为public类，但是只能被其自身所使用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;实现一个private接口只是一种方式，强制该接口中的方法定义不要添加任何类型信息（不允许向上转型）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;返回对private接口的引用的public方法，只有以各种方式可用，就是将返回值交给有权使用它的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;嵌套在另一个接口中的接口自动就是public的，而不能声明为private的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;当实现某个接口时，并不需要实现嵌套在其内部的任何接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;private接口不能在定义它的类之外被实现。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;9.9 接口与工厂&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;生成遵循某个接口的对象的典型方式就是工厂方法设计模式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;更加优雅的工厂实现方式： 匿名内部类。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;9.10 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;对于创建类，几乎在任何时刻，都可以替代为创建一个接口和一个工厂。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;任何抽象性都应该是应真正的需求而产生的。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>


<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>接口和抽象类在某些方面确实做得很好。但是，添加了新的类型，意味着需要了解更多，才能更好的掌握它。如接口中域被非常量表达式初始化，需要了解类加载过程；接口中嵌套的修饰，需要了解其意义所在。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>并发</title>
    <url>/2021/12/28/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8821%EF%BC%89%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:undefined">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;21.0 序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;顺序编程，即程序中的素有事物在任意时刻都只能执行一个步骤。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;并发具有可论证的确定性，但是实际上具有不可确定性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;尽管Java SE5在并发方面做出了显著的改进，但是仍旧没有像编译期验证或检查型异常这样的安全网。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;无法选择何时Java程序中出现线程。Servlet具有天生的多线程性。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;21.1 并发的多面性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;并发编程令人困惑的一个主要原因是：使用并发时需要解决的问题由多个，而实现并发的方式也有多种，并且这两者之间没有明显的映射关系。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;用并发解决的问题大体上可以分为“速度”和“设计可管理性”两种。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;并发是用于多处理器编程的基本工具。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;并发通常是提高运行在单处理器上程序的性能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;从性能的角度看，如果没有任务会阻塞，那么在单处理器机器上使用并发就没有任何意义。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;在单处理器系统中的性能提高的常见示例是事件驱动的编程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;实现并发最注解的方式是在操作系统级别使用进程。进程是运行在它自己的地址空间内的自包容的程序。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;某些编程语言被设计为可以将并发任务彼此隔离，这些语言通常被称为函数型语言。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;Java采取了更加传统的方式，在顺序型语言的基础上提供对线程的支持。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;线程机制是在由执行程序表示的单一进程中创建任务。这种方式产生的一个好处是操作系统的透明性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;对于不支持多任务的OS，除非在Java中添加多线程机制，否则就会打破“编写一次，到处运行”的要求。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;在单CPU机器上使用多任务的程序在任意时刻仍旧只在执行一项工作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;并发提供了一个重要的组织结构上的好处：程序设计可以极大地简化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;Java中的线程机制是抢占式的，这表示调度机制会周期性地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;在协作式系统中，每个任务都会自动地放弃控制，这要求程序员要有意识地在每个任务中插入某种类型的让步语句。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;协作式系统的优势是双重的：上下文切换的开销通常比抢占式系统要低廉许多，并且对可以同时执行的线程数量在理论上没有任何限制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;并发需要付出代价，包含复杂性代价，但是这些代价在与程序设计、资源负载均衡以及用户方便使用方面的改进相比，就显得微不足道了。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;通常，线程使你能够创建更加松散耦合的设计。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;21.2 基本的线程机制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务（子任务）中的每一个都将由执行线程来驱动。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;一个线程就是在进程中的一个单一的顺序控制流。因此，单个进程可以拥有多个并发执行的任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;多任务和多线程往往使使用多处理器系统的最合理方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;线程可以驱动任务，因此需要一种描述任务的方式，这可以由Runnable接口来提供。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;静态方法Thread.yield是对线程调度器（Java线程机制的一部分，可以将CPU从一个线程转移给另一个线程）的一种建议。这完全是选择性的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;如果机器上由多个处理器，线程调度器将会在这些处理器之间默默地分发线程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;线程调度机制是非确定性的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;每个Thread都“注册”了它自己，因此确实有一个对它的引用，而且在它的任务退出其run并死亡之前，垃圾回收器无法清除它。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;Java SE5的java.util.concurrent包中的执行器（Executor）将为你管理Thread对象，从而简化了并发编程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;Executor在客户端和任务执行之间提供了一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;Executor允许管理异步任务的执行，而无须显式地管理线程的声明周期。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;非常常见的情况是，单个的Executor被用来创建和管理系统中所有的任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;在任何线程池中，现有线程在可能的情况下，都会被自动复用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;CachedThreadPool、FixedThreadPool、SingleThreadExecutor。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;Runnable是执行工作的独立任务，但是它不返回任何值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;在Java SE5中引入的Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call中返回的值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;必须使用ExecutorService.submit调用Callable。会产生参数化Future对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;影响任务行为的一种简单方法是调用sleep，这将是任务中止执行给定的时间。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;Java SE5引入了更加显式的sleep版本，TimeUnit。还可以被用来执行转换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;线程的优先级将该线程的重要性传递给了调度器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;CPU处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先级最高的线程先执行。优先级不会导致死锁。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;在绝大多数时间里，所有线程都应该以默认的优先级运行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;使用getPriority来读取现有线程的优先级，通过setPriority来修改。 -- 设置位置。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;唯一可移植的方法是当调整优先级的时候，只是用MAX_PRIORITY、NORM_PRIORITY、MIN_PRIORITY。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;yield只是一个暗示，没有任何机制保证它将会被采纳。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;当调用yield是，也是在建议具有相同优先级的其他线程可以运行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;后台（daemon）线程是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;必须在线程启动之前调用setDaemon方法，才能把它设置为后台线程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;一个后台线程创建的任何线程都将被自动设置为后台线程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;后台线程finally子句可能不会执行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;任务直接从Thread类继承。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;另一种惯用法是自管理的Runnable。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;有时通过使用内部类来将线程代码隐藏在类中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;执行的任务与驱动它的线程之间有一个差异，对Thread类实际没有任何控制权。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;创建任务。并通过某种方式将一个线程附着到任务上，以使得这个线程可以驱动任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;在Java中，Thread类自身不执行任何操作，它只是驱动赋予它的任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;将任务从线程中分离出来是很有意义的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;一个线程可以在其他线程之上调用join方法，其效果是等待一段时间直到第二个线程结束才继续执行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;对join方法的调用可以被中断，做法是在调用线程上调用interrupt方法，这时需要用到try-catch子句。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;使用线程的动机之一就是建立有响应的用户界面。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;&lt;del&gt;线程组持有一个线程集合。&lt;/del&gt;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;由于线程的本质特性，不能捕获从线程中逃逸的异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;一旦异常逃出任务的run方法，它就会向外传播到控制台，除非采取特殊的步骤捕获这种错误的异常。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;Thread.UncaughtExceptionHandler是Java SE5中的新接口，允许在每个Thread对象上都附着一个异常处理器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;Thread.UncaughtExceptionHandler.uncaughtException会在线程因未捕获的异常而临近死亡时被调用。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;21.3 共享受限资源&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;共享公共资源的任务观察该资源的终止信号。这可以消除所谓竞争条件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;在Java中，递增不是原子性操作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。意味着在给定时刻只允许一个任务访问共享资源。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;通常通过在代码前面加上一条锁语句来实现的。因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量（mutex）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;线程调度机制并不是确定性的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;Java以提供关键字synchronized的形式，为防止资源冲突提供了内置支持。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;共享资源一般是以对象形式存在的内存片段，但也可以是文件、输出/输出端口，或者是打印机。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;所有对象都自动含有单一的锁。针对每个类，也有一个锁（作为类的Class对象的一部分）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;每个访问邻接共享资源的方法都必须被同步，否则它们就不会正确地工作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;Java SE5的java.util.concurrent类库还包含有定义在locks中的显式的互斥机制。Lock对象必须被显式地创建、锁定和释放。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;使用Lock对象时的惯用法：对lock的调用，必须放置在finally子句中带有unlock的try-finally语句中。return语句必须在try子句中出现，以确保unlock不会过早发生。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;显式的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁来说，还赋予了更细粒度的控制力。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;原子操作是不能被线程调度机制中断的操作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;volatile关键字确保了应用中的可视性。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[108,109]},&quot;v&quot;:&quot;同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[109,110]},&quot;v&quot;:&quot;对域中的值赋值和返回操作通常都是原子性的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[111,112]},&quot;v&quot;:&quot;Java SE5引入了诸如AtomicInteger、AtomicLong、AtomicReference等特殊的原子性变量类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;有时，只是希望防止多个线程同时访问方法内部的部分代码而不是整个方法。通过这种方式分离出来的代码段被称为临界区。同步控制块。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[113,114]},&quot;v&quot;:&quot;还可以使用显式的Lock对象来创建临界区。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[115,116]},&quot;v&quot;:&quot;synchronized块必须给定一个在其上进行同步的对象。并且最合理的方式是，使用其方法正在被调用的当前对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[117,118]},&quot;v&quot;:&quot;线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[118,119]},&quot;v&quot;:&quot;创建和管理线程办呢滴存储可以由java.lang.ThreadLocal类来实现。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[119,120]},&quot;v&quot;:&quot;ThreadLocal对象通常当作静态域存储。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[121,122]},&quot;v&quot;:&quot;21.4 终结任务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[122,123]},&quot;v&quot;:&quot;在某些情况下，任务必须更加突然地终止。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[124,125]},&quot;v&quot;:&quot;线程状态：新建（new）、就绪（Running）、阻塞（Blocked）、死亡（Dead）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[125,126]},&quot;v&quot;:&quot;进入阻塞状态： 1. 调用sleep； 2. 调用wait； 3. 任务在等待某个输入/输出完成； 4. 等待锁释放。 调用join？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[126,127]},&quot;v&quot;:&quot;&lt;del&gt;使用suspend和resume来阻塞和唤醒线程，可能导致死锁。stop方法不释放线程获得的锁。&lt;/del&gt;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;Thread类包含interrupt方法，这个方法将设置线程的终端状态。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[129,130]},&quot;v&quot;:&quot;如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出InterruptedException。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[130,131]},&quot;v&quot;:&quot;当抛出InterruptedException异常或者该任务调用Thread.interrupted时，中断状态将被复位。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[131,132]},&quot;v&quot;:&quot;Thread.interrupted提供了离开run循环而不抛出异常的第二种方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[132,133]},&quot;v&quot;:&quot;在Executor上调用shutdownNow，将发送一个interrupt调用给它启动的所有线程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[133,134]},&quot;v&quot;:&quot;submit将返回一个通配符泛型Future，可以在其上调用cancel，并因此可以使用它来中断某个特定任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[134,135]},&quot;v&quot;:&quot;不能中断正在试图获取synchronized锁或者试图执行I/O操作的线程。 -- 关闭任务在其上发生阻塞的底层资源。 -- 被阻塞的nio通道会自动地响应中断。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[135,136]},&quot;v&quot;:&quot;同一个互斥可以被同一个任务多次获得。 -- 可重入锁。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[136,137]},&quot;v&quot;:&quot;只要任务以不可中断的方式被阻塞，那么都有潜在的会锁住程序的可能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[137,138]},&quot;v&quot;:&quot;Java SE5并发类库中添加了一个特性，即在ReentrantLock上阻塞的任务具备可以被中断的能力。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[139,140]},&quot;v&quot;:&quot;在线程上调用interrupt时，中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部时。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[140,141]},&quot;v&quot;:&quot;如果只能通过在阻塞上调用抛出异常来退出，无法总是可以离开run循环。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[141,142]},&quot;v&quot;:&quot;如果调用interrupt以停止某个任务，那么在run循环碰巧没有产生任何阻塞调用的情况下，需要第二种方式来退出。 -- 中断状态。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[142,143]},&quot;v&quot;:&quot;可以通过调用interrupted来检查中断状态，还可以清除中断状态。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[144,145]},&quot;v&quot;:&quot;21.5 线程之间的协作&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[145,146]},&quot;v&quot;:&quot;当任务协作时，关键问题时这些任务之间的握手。为了实现这种握手，使用了相同的基础特性：互斥。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[146,147]},&quot;v&quot;:&quot;互斥能够确保只有一个任务可以相应某个信号，这样就可以根除任何可能的竞争条件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[148,149]},&quot;v&quot;:&quot;wait使你可以等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力。通常，这种条件由另一个任务来改变。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[149,150]},&quot;v&quot;:&quot;wait会在等待外部世界产生变化的时候将任务挂起，并且只有在notify或notifyAll发生时，这个任务才会被唤醒并去检查所产生的变化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[150,151]},&quot;v&quot;:&quot;wait提供了一种在任务之间对活动同步的方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[151,152]},&quot;v&quot;:&quot;调用sleep时锁没有被释放，调用yield也是。调用wait时，线程的执行被挂起，对象上的锁被释放。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[152,153]},&quot;v&quot;:&quot;由两种形式的wait。 1. 指定时间； 2. 无限等待，直到线程接受到notify或notifyAll消息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[153,154]},&quot;v&quot;:&quot;wait、notify、notifyAll时基类Object的一部分，而不是Thread的一部分。因为这些方法操作的锁也是所有对象的一部分。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[154,155]},&quot;v&quot;:&quot;只能在同步控制方法或同步控制块里调用wait、notify、notifyAll。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[155,156]},&quot;v&quot;:&quot;可以让另一个对象执行某种操作以维护其自己的锁。要这么做的话，必须首先得到对象的锁。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[156,157]},&quot;v&quot;:&quot;必须用一个检查感兴趣的条件的while循环包围wait。这很重要。本质就是要检查所感兴趣的特定条件，并在条件不满足的情况下返回到wait中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[157,158]},&quot;v&quot;:&quot;当两个线程使用notify/wait或notifyAll/wait进行协作时，有可能会错过某个信号。 -- 防止在变量上产生竞争条件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[159,160]},&quot;v&quot;:&quot;使用notify时，在众多等待同一个锁的任务中只有一个会被唤醒。必须保证被唤醒的是恰当的任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[160,161]},&quot;v&quot;:&quot;当notifyAll因某个特定锁而被调用时，只有等待这个锁的任务才会被唤醒。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[161,162]},&quot;v&quot;:&quot;在典型的生产者-消费者实现中，应使用先进先出队列来存储被生产和消费的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[162,163]},&quot;v&quot;:&quot;使用互斥并允许任务挂起的基本类是Condition。await、signal、signalAll。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[163,164]},&quot;v&quot;:&quot;与使用notifyAll相比，signalAll是更安全的方式。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[164,165]},&quot;v&quot;:&quot;Lock产生Condition对象，这个对象被用来管理任务间的通信。但是不包含任何有关处理状态的信息，因此需要管理额外的表示处理状态的信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[166,167]},&quot;v&quot;:&quot;wait和notify方法以一种非常低级的方式解决了任务互操作问题，即每次交互时都握手。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[167,168]},&quot;v&quot;:&quot;使用同步队列来解决协作问题，同步队列在任何时刻都只允许一个任务插入或移除元素。 -- java.util.concurrent.BlockingQueue接口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[168,169]},&quot;v&quot;:&quot;LinkedBlockingQueue，无界队列。 ArrayBlockingQueue，具有固定的尺寸。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[169,170]},&quot;v&quot;:&quot;如果消费者任务试图从队列中获取对象，而该队列此时为空，那么这些队列可以挂起消费者任务，当有更多元素可用时恢复消费者任务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[170,171]},&quot;v&quot;:&quot;阻塞队列可以解决非常大量的问题，而其方式与wait与notifyALl相比，则简单并可靠得多。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[171,172]},&quot;v&quot;:&quot;同步由队列（其内部是同步的）和系统的设计隐式地管理了。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[172,173]},&quot;v&quot;:&quot;使用显式的wait和notifyAll时存在的类和类之间的耦合被消除了，因为每个类都只和它的BlockingQueue通信。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[174,175]},&quot;v&quot;:&quot;通过输入/输出在线程间进行通信通常很有用。提供线程功能的类库以管道的形式对线程间的输入/输出提供了支持。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[175,176]},&quot;v&quot;:&quot;在Java中输入/输出类库中对应物就是PipedWriter类和PipedReader类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[176,177]},&quot;v&quot;:&quot;管道基本上就是一个阻塞队列，存在于多个引入BlockingQueue之前的Java版本中。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[178,179]},&quot;v&quot;:&quot;21.6 死锁&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[179,180]},&quot;v&quot;:&quot;哲学家就餐问题时一个经典的死锁例证。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[180,181]},&quot;v&quot;:&quot;当四个条件同时满足时，就会发生死锁。 1. 互斥； 2. 请求和保持； 3. 不可抢占； 4. 循环等待。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[181,182]},&quot;v&quot;:&quot;要防止死锁，只需破坏其中一个即可。在程序中，最容易的方法是破坏第4个条件。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[183,184]},&quot;v&quot;:&quot;21.7 新类库中的构件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[184,185]},&quot;v&quot;:&quot;Java SE5的java.util.concurrent引入了大量设计用来解决并发问题的新类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[185,186]},&quot;v&quot;:&quot;CountDownLatch。 被用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[186,187]},&quot;v&quot;:&quot;CyclicBarrier。 CountDownLatch是只出发一次的事件，而CyclicBarrier可以多次重用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[187,188]},&quot;v&quot;:&quot;DelayQueue。 这是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[188,189]},&quot;v&quot;:&quot;PriorityBlockingQueue。 优先级队列，具有可阻塞的读取操作。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[189,190]},&quot;v&quot;:&quot;ScheduledExecutor。 可以将Runnable对象设置为在将来的某个时刻执行或每隔规则的时间重复执行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[190,191]},&quot;v&quot;:&quot;Semaphore。 允许n个任务同时访问一个资源。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[191,192]},&quot;v&quot;:&quot;Exchanger。 是两个任务之间交换对象的栅栏。当这些任务进入栅栏时，它们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[193,194]},&quot;v&quot;:&quot;21.8 仿真&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[194,195]},&quot;v&quot;:&quot;并发最有趣也最令人兴奋的用法就是创建仿真。通过使用并发，仿真的每个构件都可以成为其自身的任务，这使得仿真更容易编程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[195,196]},&quot;v&quot;:&quot;银行出纳员仿真。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[196,197]},&quot;v&quot;:&quot;饭店仿真。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[197,198]},&quot;v&quot;:&quot;分发工作。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[199,200]},&quot;v&quot;:&quot;21.9 性能调优&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[200,201]},&quot;v&quot;:&quot;在Java SE5的java.util.concurrent类库中存在着数量庞大的用于性能提高的类。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[202,203]},&quot;v&quot;:&quot;比较各类互斥技术。synchronized、Lock、Atomic。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[203,204]},&quot;v&quot;:&quot;微基准测试：通常指在隔离的、脱离上下文环境的情况下对某个特性进行性能测试。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[204,205]},&quot;v&quot;:&quot;只有在互斥存在竞争的情况下，才能看到真正的性能差异，因此必须有多个任务尝试访问互斥代码区。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[205,206]},&quot;v&quot;:&quot;编译器看到synchronized关键字时，有可能会执行特殊的优化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[206,207]},&quot;v&quot;:&quot;模板方法。将所有共用代码都放置到基类中，并将所有不同的代码隔离在导出类的实现中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[207,208]},&quot;v&quot;:&quot;FixedThreadPool，在测试过程中防止产生任何额外的开销。丢弃第一次结果，因为它包含了初始线程的创建。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[208,209]},&quot;v&quot;:&quot;CyclicBarrier，确保所有的任务在声明每个测试完成之前都已经完成。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[209,210]},&quot;v&quot;:&quot;使用Lock通常会比使用synchronized要高效许多，而且synchronized的开销看起来变化范围太大，而Lock相对比较一致。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[210,211]},&quot;v&quot;:&quot;代码被阅读的次数远多于被编写的次数。 -- 代码的可读性至关重要。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[211,212]},&quot;v&quot;:&quot;以synchronized关键字入手，只有在性能调优时才替换为Lock对象这种做法，是具有实际意义的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[212,213]},&quot;v&quot;:&quot;Atomic对象只有在非常简单的情况下才有用，这些情况通常包括只有一个要被修改的Atomic对象，并且这个对象独立于其他所有的对象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[213,214]},&quot;v&quot;:&quot;以更加传统的互斥方式入手，只有在性能方面的需求能够明确指示时，再替换为Atomic。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[215,216]},&quot;v&quot;:&quot;容器是所有编程中的基础工具，这其中包括并发编程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[216,217]},&quot;v&quot;:&quot;Java 1.2中，新的容器类库是不同步的，并且Collections类提供了各种static的同步的装饰方法，从而来同步不同类型的容器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[217,218]},&quot;v&quot;:&quot;Java SE5特别添加了新的容器，通过使用更灵巧的技术来消除加锁，从而提高线程安全的性能。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[218,219]},&quot;v&quot;:&quot;免锁容器背后的通用策略是：对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[219,220]},&quot;v&quot;:&quot;修改是再容器数据结构的某个部分的一个单独的副本（有时是整个数据结构的副本）上执行的，并且这个副本再修改过程中是不可见的。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[220,221]},&quot;v&quot;:&quot;CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap、ConcurrentLinkedQueue。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[221,222]},&quot;v&quot;:&quot;只要是从免锁容器中读取，它就会比其synchronized对应物快许多，因为获取和释放锁的开销被省掉了。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[222,223]},&quot;v&quot;:&quot;ConcurrentHashMap使用了一种不同的技术，可以明显地最小化写入所造成的影响。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[224,225]},&quot;v&quot;:&quot;尽管Atomic对象将执行原子性操作，但是某些Atomic类还允许执行所谓的乐观加锁。 -- compareAndSet方法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[225,226]},&quot;v&quot;:&quot;通过使用Atomic来替代synchronized或Lock，可以获得性能上的好处。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[226,227]},&quot;v&quot;:&quot;如果compareAndSet操作失败会发生什么？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[228,229]},&quot;v&quot;:&quot;ReadWriteLock可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[229,230]},&quot;v&quot;:&quot;应该使用更直观的同步，并且只有在必需时再引入ReadWriteLock。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[231,232]},&quot;v&quot;:&quot;21.10 活动对象&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[232,233]},&quot;v&quot;:&quot;Java中的线程机制看起来非常复杂并难以正确使用。有一种可替换的方式被称为活动对象或行动者。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[233,234]},&quot;v&quot;:&quot;每个对象都维护者它自己的工作器线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻都只能运行其中的一个。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[234,235]},&quot;v&quot;:&quot;有了活动对象，就可以串行化消息而不是方法，这意味着不再需要要给防备一个任务在其循环的中间被中断这种问题了。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[235,236]},&quot;v&quot;:&quot;当向一个活动对象发送消息时，这条消息会转变为一个任务，该任务会被插入到这个对象的队列中，等待再以后的某个时刻运行。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[236,237]},&quot;v&quot;:&quot;Java SE5的Future在实现这种模式时将排上用场。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[237,238]},&quot;v&quot;:&quot;没有直接的编译器支持。 -- 基于代理。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[238,239]},&quot;v&quot;:&quot;代理编程，把对象和相对容易的并发解决方案结合了起来。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[240,241]},&quot;v&quot;:&quot;21.11 总结&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[241,242]},&quot;v&quot;:&quot;线程的一个额外好处时它们提供了轻量级的执行上下文切换，而不是重量级的进程上下文切换。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[242,243]},&quot;v&quot;:&quot;因为一个给定进程内的所有线程共享相同的内存空间，轻量级的上下文切换只是改变了程序的执行序列和局部变量。进程切换必须改变所有内存空间。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[243,244]},&quot;v&quot;:&quot;活锁：多个运行各自任务的线程使得整体无法完成。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[244,245]},&quot;v&quot;:&quot;需要明智地使用可用的加锁机制。&quot;}]}],&quot;p&quot;:{}}"></svg>
</div>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
</search>
