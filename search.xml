<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js prototye</title>
    <url>/2021/07/29/JS/js-prototye/</url>
    <content><![CDATA[<ol>
<li><strong>proto</strong> 和 contructor 是对象属性，prototype是函数属性（函数也是对象）。</li>
<li><strong>proto</strong> 由一个对象指向它的原型对象。</li>
<li>prototype 从一个函数指向所创建实例的原型对象。</li>
<li>contructor 从一个对象指向给对象的构造函数。</li>
</ol>
<h2 id="prototype-的目的"><a href="#prototype-的目的" class="headerlink" title="prototype 的目的"></a>prototype 的目的</h2><p>共享方法、共享属性、面向对象</p>
<ol>
<li>函数内部定义的变量及函数，只能在内部调用，是私有的，外部无法访问。</li>
<li>函数添加静态变量及函数，通过函数对象本身可以访问，但是通过实例访问不到。</li>
<li>函数内部通过this添加变量及函数，创建实例时详单与做了拷贝，无法共享。（函数本身拷贝没有意义，且浪费资源）</li>
</ol>
<p>故，只要创建一个函数，就为该函数创建一个prototype属性，prototype本身是个对象，其contructor属性指向该函数本身，其__proto__属性指向Function.prototype。</p>
<h2 id="对象创建方式及区别"><a href="#对象创建方式及区别" class="headerlink" title="对象创建方式及区别"></a>对象创建方式及区别</h2><ol>
<li>字面量创建<br> <strong>proto</strong> 指向Object.prototype。</li>
<li>函数对象<br> <strong>proto</strong> 指向Function.prototype。<br> prototype 指向 该对象的prototype。</li>
<li>new创建<ol>
<li>生成一个新对象</li>
<li>设置对象__proto__指向函数的prototype属性。</li>
<li>绑定this</li>
<li>返回</li>
</ol>
</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code>内部使用this变量，使用new调用创建。
构造函数生成的实例对象都有__proto__属性，指向构造函数的prototype。
利用构造函数继承属性，利用原型对象继承方法。（组合继承）
</code></pre>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><pre><code>构造函数的另一种写法。
语法糖。
</code></pre>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><pre><code>1. 原型链继承
2. 构造函数继承
3. 组合继承
其它。。。
</code></pre>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>vue</title>
    <url>/2021/07/29/JS/vue/</url>
    <content><![CDATA[<ul>
<li>ES6在语言的层面上实现了模块化。浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li>
</ul>
<p>VUE项目打包后通过nginx代理找不到js/css文件</p>
<ul>
<li><p>nginx代理后路径为 root 路径 + location 路径</p>
</li>
<li><p>需要修改VUE static 打包路径为 location 路径 + static (相对路径)</p>
</li>
<li><p>需要修改VUE index.html 打包路径为 location 路径下的index.html  或者 修改 nginx 配置 try_files 为 location 路径/index.html</p>
<p>  __dirname ： js文件当前绝对路径（仅在js文件中有效）<br>  path： node 内置模块<br>  index: 打包后 index.html 文件路径 （绝对路径）<br>  assetRoot: 指向包含应用程序的所有静态资源的根目录<br>  assetsSubDirectory: 静态资源要存放的路径， 相对于 assetRoot 的路径<br>  assetsPublicPath: 代表打包后，index.html里面引用资源的的地址 （相对路径/绝对路径）</p>
</li>
</ul>
<p>eslint 文件/设置中 区别，关系<br>-文件：运行项目后，通过控制台才发现语法错误。<br>-设置：在开发过程中，就根据ESlint规则修改代码。（不必支持项目）<br>IDEA中配置：Setting -&gt;Preferences -&gt; Languages &amp; Frameworks -&gt; JavaScript -&gt; Code Quality Tools -&gt; Eslint ，然后勾选Enable单选框。</p>
<pre><code>    IDEA webpack配置
- 当在“设置/首选项”|语言和框架|JavaScript|Webpack中打开项目或编辑指定的webpack.config.js时，IntelliJ IDEA在后台分析配置，并根据收到的信息，正确理解项目解析根和解析别名。由于对项目配置的理解，IntelliJ IDEA为JavaScript文件中的导入和导出符号提供了更精确的代码完成。
</code></pre>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/2020/02/05/Java/AOP/</url>
    <content><![CDATA[<h2 id="一-什么是AOP"><a href="#一-什么是AOP" class="headerlink" title="一. 什么是AOP"></a>一. 什么是AOP</h2><pre><code>AOP（Aspect Oriented Programing），面向切面编程，是对OOP的补充，通过预编译方式或运行期动态代理实现程序功能的统一维护的一种技术。
</code></pre>
<h2 id="二-意图"><a href="#二-意图" class="headerlink" title="二. 意图"></a>二. 意图</h2><pre><code>将与业务无关的代码，如日志记录，性能监控，事务处理等从业务逻辑代码中划分出来，将它们独立到非业务逻辑方法中，使得与业务方法解耦，并且在改变相关逻辑的时候不影响业务逻辑的代码。
</code></pre>
<h2 id="三-AOP-概念"><a href="#三-AOP-概念" class="headerlink" title="三. AOP 概念"></a>三. AOP 概念</h2><h4 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面 Aspect"></a>切面 Aspect</h4><pre><code>切面是一个横切关注点。
</code></pre>
<h4 id="连接点-JointPoint"><a href="#连接点-JointPoint" class="headerlink" title="连接点 JointPoint"></a>连接点 JointPoint</h4><pre><code>连接点是具体执行增强的点，比如方法执行，构造器调用，成员赋值。
</code></pre>
<h4 id="切点-PointCut"><a href="#切点-PointCut" class="headerlink" title="切点 PointCut"></a>切点 PointCut</h4><pre><code>匹配连接点的正则表达式，是连接点的集合。
</code></pre>
<h4 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知 Advice"></a>通知 Advice</h4><pre><code>对连接点的进行的操作。
</code></pre>
<h4 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入 Weaving"></a>织入 Weaving</h4><pre><code>把切面应用到目标对象，并创建代理对象的过程。切面在指定的连接点被织入到目标对象。
</code></pre>
<h2 id="四-AOP流行框架比较"><a href="#四-AOP流行框架比较" class="headerlink" title="四. AOP流行框架比较"></a>四. AOP流行框架比较</h2><pre><code>当下最流行的AOP框架为Spring AOP 及 AspectJ。
</code></pre>
<ol>
<li>能力和目标</li>
</ol>
<ul>
<li>Spring AOP<br>  旨在通过Spring IOC 提供一个简单的AOP实现。<br>  不是一个完整的AOP解决方案，只能用于被Spring容器管理的bean。</li>
<li>AspectJ<br>  完整的AOP解决方案，比Spirng AOP复杂。<br>  可以在应用于所有领域对象。</li>
</ul>
<ol start="2">
<li>织入时机</li>
</ol>
<ul>
<li>Spring AOP<br>  只能在运行时织入。</li>
<li>AspectJ<br>  可以在编译期，加载期，编译后（jar包和字节码文件）。</li>
</ul>
<ol start="3">
<li>依赖</li>
</ol>
<ul>
<li>Spring AOP<br>  使用JDK动态代理或者VGLIB代理。</li>
<li>AspectJ<br>  不依赖任何运行时环境，只需要AspectJ compiler(ajc)在运行前完成织入。</li>
</ul>
<ol start="4">
<li>连接点</li>
</ol>
<ul>
<li>Spring AOP<br>  由于要使用代理模式，所以不能作用域final类，static方法，final方法。<br>  只支持方法执行连接点。</li>
<li>AspectJ<br>  没有限制。<br>  方法调用，方法执行，构造器调用，构造器执行，静态初始化执行，对象初始化，成员引用，成员赋值，处理器执行，通知执行。</li>
</ul>
<ol start="5">
<li>复杂度</li>
</ol>
<ul>
<li>Spring AOP<br>  不需要额外的编译器，只能和Spirng管理的bean一起工作。</li>
<li>AspectJ<br>  需要引入ajc并重新打包。</li>
</ul>
<ol start="6">
<li>总结</li>
</ol>
<table>
<thead>
<tr>
<th>Spring AOP</th>
<th>AspectJ</th>
</tr>
</thead>
<tbody><tr>
<td>Implemented in pure Java</td>
<td>Implemented using extensions of Java programming language</td>
</tr>
<tr>
<td>No need for separate compilation process</td>
<td>Needs AspectJ compiler (ajc) unless LTW is set up</td>
</tr>
<tr>
<td>Only runtime weaving is available</td>
<td>Runtime weaving is not available. Supports compile-time, post-compile, and load-time Weaving</td>
</tr>
<tr>
<td>Less Powerful – only supports method level weaving</td>
<td>More Powerful – can weave fields, methods, constructors, static initializers, final class/methods, etc…</td>
</tr>
<tr>
<td>Can only be implemented on beans managed by Spring container</td>
<td>Can be implemented on all domain objects</td>
</tr>
<tr>
<td>Supports only method execution pointcuts</td>
<td>Support all pointcuts</td>
</tr>
<tr>
<td>Proxies are created of targeted objects, and aspects are applied on these proxies</td>
<td>Aspects are weaved directly into code before application is executed (before runtime)</td>
</tr>
<tr>
<td>Much slower than AspectJ</td>
<td>Better Performance</td>
</tr>
<tr>
<td>Easy to learn and apply</td>
<td>Comparatively more complicated than Spring AOP</td>
</tr>
</tbody></table>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><pre><code>https://www.baeldung.com/spring-aop-vs-aspectj
</code></pre>
<p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象。</p>
<p>织入时期：编译器（aspectj），装载器（cglib），运行期</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>BeanValidation</title>
    <url>/2020/02/05/Java/BeanValidation/</url>
    <content><![CDATA[<h2 id="Bean-Validation"><a href="#Bean-Validation" class="headerlink" title="Bean Validation"></a>Bean Validation</h2><pre><code>Bean Validation是一个运行时的数据验证框架，为JavaBean验证定义了相应的元数据模型和Api。
</code></pre>
<table>
<thead>
<tr>
<th>JSR版本</th>
<th>Bean Validation版本</th>
<th>发布时间</th>
<th>hibernate实现版本</th>
<th>apache BLal实现版本</th>
</tr>
</thead>
<tbody><tr>
<td>303</td>
<td>1.0</td>
<td>2009年javaee 6</td>
<td>4.3.1.Final</td>
<td>0.5</td>
</tr>
<tr>
<td>349</td>
<td>1.1</td>
<td>2013年javaee 7</td>
<td>5.1.1.Final</td>
<td>1.1.1</td>
</tr>
<tr>
<td>380</td>
<td>2.0</td>
<td>2017年javaee 8</td>
<td>6.0.1.Final</td>
<td>2.0.3</td>
</tr>
</tbody></table>
<h2 id="Hibernate-Validation"><a href="#Hibernate-Validation" class="headerlink" title="Hibernate Validation"></a>Hibernate Validation</h2><pre><code>hibernate validation是对这个规范的实践，他提供了相应的实现，并增加了一些其他校验注解(后期规范更新，hibernate将重复的标记了@Departure)，他们位于org.hibernate.validator.constraints包下。
</code></pre>
<h2 id="Spring-Validataion"><a href="#Spring-Validataion" class="headerlink" title="Spring Validataion"></a>Spring Validataion</h2><pre><code>spring validation对hibernate validation进行了二次封装，在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类（BindingResult）中。
</code></pre>
<h2 id="Validated-和-Valid-的区别"><a href="#Validated-和-Valid-的区别" class="headerlink" title="@Validated 和 @Valid 的区别"></a>@Validated 和 @Valid 的区别</h2><ul>
<li>@Validted 支持分组校验，@Valid不支持。</li>
<li>@Valid支持嵌套验证，@Validated不支持。</li>
<li>@Validated可以将校验结果绑定到BindingResult中，而不抛出异常。<br>  必须一个校验对象一个BindingResult，一一对应且紧随其后。</li>
<li>在没有分组校验及嵌套校验的情况下， 效果一致。</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><pre><code>https://beanvalidation.org
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java版本与特性</title>
    <url>/2020/07/21/Java/Java%E7%89%88%E6%9C%AC%E4%B8%8E%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>Java是由Sun Microsystems公司（简称Sun公司）于1995年5月推出的Java程序设计语言和Java平台的总称。“Write Once, Run Anywhere”。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>JDK: Java Development Kit，Java开发工具包，包括JVM、Java类库、Java工具。</li>
<li>Java 平台: 用Java语言编写的软件运行的平台，包括SE、ME、EE。</li>
</ul>
<h2 id="Java-发展史"><a href="#Java-发展史" class="headerlink" title="Java 发展史"></a>Java 发展史</h2><ul>
<li>1995-5-23，Oak语言更名为Java，并发布JDK 1.0α2和HotJava 浏览器（1999年停止发展）。10月，发布JDK 1.0β。</li>
<li>1996-1-23，JDK 1.0发布，Java语言第一个正式版本的运行环境。</li>
<li>1997-2-19，JDK 1.1发布。</li>
<li>1998-12-4，Java2平台拆为3个方向，J2SE 1.2（JDK 1.2）发布。</li>
<li>1999-4-27，HotSpot虚拟机发布。</li>
<li>1999-12-12, J2EE 1.2发布。</li>
<li>2000-5-8，J2SE 1.3（JDK 1.3）发布。</li>
<li>2001-9-24，J2EE 1.3发布。</li>
<li>2002-2-13，J2SE 1.4（JDK 1.4）发布。</li>
<li>2003-11-11，J2EE 1.4发布。</li>
<li>2004-9-30，J2SE 5.0（JDK 1.5）发布，修改版本号命名方式，1.x保留为内部命名方式。</li>
<li>2006-11-13，Sun在GPL许可证下开源Java。</li>
<li>2006-12-11，Java SE 6发布，使用Java SE替换J2SE，版本号去掉“.0”。</li>
<li>2006-5-11，Java EE 5发布。</li>
<li>2009-4-20，Oracle以74亿美元收购Sun。</li>
<li>2011-7-28，Java SE 7发布，LTS（2022-7）。</li>
<li>2013-5-28，Java EE 7发布。</li>
<li>2014-3-18，Java SE 8发布，LTS（2030-12）。</li>
<li>2017-8-31，Java EE 8发布。</li>
<li>2018-9-25，Java SE 11发布，LTS（2026-9）。</li>
<li>2019-9-10，Jakarta EE8发布，Java EE更名为Jakarta EE。</li>
<li>2020-11-22，Jakarta EE9发布。</li>
<li>2021-9-17，Java SE 17发布，从此免费提供，LTS（2029-9）。</li>
</ul>
<h2 id="Java-JDK-新特性"><a href="#Java-JDK-新特性" class="headerlink" title="Java/JDK 新特性"></a>Java/JDK 新特性</h2><h3 id="Java-SE-11"><a href="#Java-SE-11" class="headerlink" title="Java SE 11"></a>Java SE 11</h3><ul>
<li>String API isBlank、strip、stripTrailing、stripLeading、repeat、lines.count</li>
<li>Optinal API isEmpty…</li>
<li>局部变量类型推断加强 var上可以加注解</li>
<li>HttpClient</li>
<li>垃圾回收ZGC</li>
</ul>
<h3 id="Java-SE-10"><a href="#Java-SE-10" class="headerlink" title="Java SE 10"></a>Java SE 10</h3><ul>
<li>局部变量类型推断</li>
<li>不可变集合的改进</li>
<li>并行全垃圾回收器 G1</li>
<li>线程本地握手</li>
<li>Optional新增orElseThrow()方法</li>
<li>类数据共享</li>
<li>Unicode 语言标签扩展</li>
<li>根证书</li>
</ul>
<h3 id="Java-SE-9"><a href="#Java-SE-9" class="headerlink" title="Java SE 9"></a>Java SE 9</h3><ul>
<li>模块化</li>
<li>jShell</li>
<li>接口可定义private方法 （只能在接口内部调用）</li>
<li>try with resource 优化</li>
<li>String, StringBuilder, StringBuffer 中的value由char[]改为byte[]</li>
<li>List、Set、Map 添加of方法创建只读集合</li>
<li>InputStream流加强</li>
<li>StreamAPI takeWhile、dropWhile、ofNullable、iterate</li>
<li>Optional增加stream()</li>
<li>垃圾回收机制</li>
</ul>
<h3 id="Java-SE-8"><a href="#Java-SE-8" class="headerlink" title="Java SE 8"></a>Java SE 8</h3><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><ul>
<li>lambda 表达式和函数式接口</li>
<li>接口的默认方法和静态方法</li>
<li>方法引用</li>
<li>重复注释</li>
<li>更好的类型推断</li>
<li>注解的扩展 （扩展了注解可以使用的范围，包括：局部变量，泛型，超类，接口实现，方法的exception声明等）</li>
</ul>
<h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><ul>
<li>参数名字</li>
</ul>
<h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><ul>
<li>Optional</li>
<li>Stream</li>
<li>时间日期API</li>
<li>Nashorn javascript引擎</li>
<li>Base64</li>
<li>并行数组 （增加了支持并行的数组处理）</li>
<li>并发 （新增StampedLock、DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder等）</li>
</ul>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul>
<li>Nashorn引擎 jjs</li>
<li>类依赖分析工具 jdeps</li>
</ul>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul>
<li>JVM内存永久区被metaspace替换，JVM参数 -XX:PermSize 和 -XX:MaxPermSize 被 -XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 代替。</li>
</ul>
<h3 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h3><ul>
<li>switch 支持String字符串类型</li>
<li>try-with-resources，资源自动关闭</li>
<li>整数类型能够用二进制来表示</li>
<li>数字常量支持下划线</li>
<li>泛型实例化类型自动推断,即”&lt;&gt;”</li>
<li>catch捕获多个异常类型，用（|）分隔开</li>
<li>全新的NIO2.0 API</li>
<li>Fork/join 并行执行任务的框架</li>
</ul>
<h3 id="JDK-1-6"><a href="#JDK-1-6" class="headerlink" title="JDK 1.6"></a>JDK 1.6</h3><ul>
<li>java.awt新增Desktop类和SystemTray类</li>
<li>使用JAXB2来实现对象与XML之间的映射</li>
<li>轻量级 Http Server API</li>
<li>插入式注解处理API(lombok使用该特性来实现的)</li>
<li>STAX，处理XML文档的API</li>
<li>Compiler API</li>
<li>对脚本语言的支持（ruby, groovy, javascript）</li>
</ul>
<h3 id="JDK-1-5"><a href="#JDK-1-5" class="headerlink" title="JDK 1.5"></a>JDK 1.5</h3><ul>
<li>自动装箱拆箱</li>
<li>泛型</li>
<li>元数据</li>
<li>Introspector 内省</li>
<li>枚举</li>
<li>静态引入</li>
<li>可变长参数</li>
<li>foreach</li>
<li>JMM</li>
<li>concurrent</li>
</ul>
<h3 id="JDK-1-4"><a href="#JDK-1-4" class="headerlink" title="JDK 1.4"></a>JDK 1.4</h3><ul>
<li>XML解析器</li>
<li>Java打印服务</li>
<li>Logging API（日志功能）</li>
<li>Java Web Start</li>
<li>JDBC 3.0 API（jdbc高级)</li>
<li>断言</li>
<li>Preferences API</li>
<li>链式异常处理</li>
<li>支持IPV6</li>
<li>支持正则表达式</li>
<li>引入Imgae I/O API （图片流);</li>
<li>NIO（高级流）</li>
<li>XSLT转换器</li>
</ul>
<h3 id="JDK-1-3"><a href="#JDK-1-3" class="headerlink" title="JDK 1.3"></a>JDK 1.3</h3><ul>
<li>数学运算</li>
<li>Timer API</li>
<li>Java Sound API</li>
<li>CORBA IIOP实现RMI的通信协议</li>
<li>Java 2D</li>
<li>JAR文件索引</li>
</ul>
<h3 id="JDK-1-2"><a href="#JDK-1-2" class="headerlink" title="JDK 1.2"></a>JDK 1.2</h3><ul>
<li>J2SE/J2EE/J2ME</li>
<li>EJB</li>
<li>Java IDL（平台对象请求代理体系结构）</li>
<li>集合框架</li>
<li>JIT(Just In Time)编译器</li>
<li>数字签名</li>
<li>JFC(Java Foundation Classes), 包括Swing1.0, 拖放和Java2D类库</li>
<li>Java Plug-In（运行插件)</li>
<li>JDBC中引入可滚动结果集,BLOB,CLOB,批量更新和用户自定义类型</li>
<li>Applet中添加声音支持</li>
<li>字符串常量做内存映射</li>
<li>控制授权/访问系统资源的策略工具</li>
</ul>
<h3 id="JDK-1-1"><a href="#JDK-1-1" class="headerlink" title="JDK 1.1"></a>JDK 1.1</h3><ul>
<li>JAR</li>
<li>JDBC</li>
<li>JavaBeans</li>
<li>RMI</li>
<li>Inner Class</li>
<li>Reflection</li>
</ul>
<h3 id="JDK-1-0"><a href="#JDK-1-0" class="headerlink" title="JDK 1.0"></a>JDK 1.0</h3><ul>
<li>Classic VM（虚拟机）</li>
<li>Applet（java小应用程序）</li>
<li>AWT（java图形设计）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Lombok 填坑</title>
    <url>/2021/06/24/Java/Lombok-%E5%A1%AB%E5%9D%91/</url>
    <content><![CDATA[<h2 id="lombok-getset生成"><a href="#lombok-getset生成" class="headerlink" title="lombok getset生成"></a>lombok getset生成</h2><p>属性名第一个字母小写，第二个字母大写<br>lombok生成的为 getXX<br>java官方默认的为 getxX</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>SnowFlakeId</title>
    <url>/2021/01/02/Java/SnowFlakeId/</url>
    <content><![CDATA[<h2 id="SnowFlakeId"><a href="#SnowFlakeId" class="headerlink" title="SnowFlakeId"></a>SnowFlakeId</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.hibernate.engine.spi.SharedSessionContractImplementor;</span><br><span class="line">import org.hibernate.id.IdentityGenerator;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class SnowFlakeIdGenerator extends IdentityGenerator &#123;</span><br><span class="line"></span><br><span class="line">    // ==============================Fields===========================================</span><br><span class="line">    /** 开始时间截 (2015-01-01) */</span><br><span class="line">    private final long twepoch = 1420041600000L;</span><br><span class="line"></span><br><span class="line">    /** 机器id所占的位数 */</span><br><span class="line">    private final long workerIdBits = 5L;</span><br><span class="line"></span><br><span class="line">    /** 数据标识id所占的位数 */</span><br><span class="line">    private final long datacenterIdBits = 5L;</span><br><span class="line"></span><br><span class="line">    /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span><br><span class="line">    private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    /** 支持的最大数据标识id，结果是31 */</span><br><span class="line">    private final long maxDataCenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    /** 序列在id中占的位数 */</span><br><span class="line">    private final long sequenceBits = 12L;</span><br><span class="line"></span><br><span class="line">    /** 机器ID向左移12位 */</span><br><span class="line">    private final long workerIdShift = sequenceBits;</span><br><span class="line"></span><br><span class="line">    /** 数据标识id向左移17位(12+5) */</span><br><span class="line">    private final long datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    /** 时间截向左移22位(5+5+12) */</span><br><span class="line">    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span><br><span class="line">    private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    /** 工作机器ID(0~31) */</span><br><span class="line">    private long workerId;</span><br><span class="line"></span><br><span class="line">    /** 数据中心ID(0~31) */</span><br><span class="line">    private long datacenterId;</span><br><span class="line"></span><br><span class="line">    /** 毫秒内序列(0~4095) */</span><br><span class="line">    private long sequence = 0L;</span><br><span class="line"></span><br><span class="line">    /** 上次生成ID的时间截 */</span><br><span class="line">    private long lastTimestamp = -1L;</span><br><span class="line"></span><br><span class="line">    //==============================Constructors=====================================</span><br><span class="line">    public SnowFlakeIdGenerator() &#123;</span><br><span class="line">        this.workerId = 0;</span><br><span class="line">        this.datacenterId = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造函数</span><br><span class="line">     * @param workerId 工作ID (0~31)</span><br><span class="line">     * @param datacenterId 数据中心ID (0~31)</span><br><span class="line">     */</span><br><span class="line">    public SnowFlakeIdGenerator(long workerId, long datacenterId) &#123;</span><br><span class="line">        if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        if (datacenterId &gt; maxDataCenterId || datacenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;, maxDataCenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        this.workerId = workerId;</span><br><span class="line">        this.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ==============================Methods==========================================</span><br><span class="line">    /**</span><br><span class="line">     * 获得下一个ID (该方法是线程安全的)</span><br><span class="line">     * @return SnowflakeId</span><br><span class="line">     */</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span><br><span class="line">        if (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果是同一时间生成的，则进行毫秒内序列</span><br><span class="line">        if (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + 1) &amp; sequenceMask;</span><br><span class="line">            //毫秒内序列溢出</span><br><span class="line">            if (sequence == 0) &#123;</span><br><span class="line">                //阻塞到下一个毫秒,获得新的时间戳</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //时间戳改变，毫秒内序列重置</span><br><span class="line">        else &#123;</span><br><span class="line">            sequence = 0L;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //上次生成ID的时间截</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        //移位并通过或运算拼到一起组成64位的ID</span><br><span class="line">        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) //</span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) //</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) //</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 阻塞到下一个毫秒，直到获得新的时间戳</span><br><span class="line">     * @param lastTimestamp 上次生成ID的时间截</span><br><span class="line">     * @return 当前时间戳</span><br><span class="line">     */</span><br><span class="line">    private long tilNextMillis(long lastTimestamp) &#123;</span><br><span class="line">        long timestamp = timeGen();</span><br><span class="line">        while (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        return timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回以毫秒为单位的当前时间</span><br><span class="line">     * @return 当前时间(毫秒)</span><br><span class="line">     */</span><br><span class="line">    private long timeGen() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Serializable generate(SharedSessionContractImplementor s, Object obj) &#123;</span><br><span class="line">        return nextId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p style="text-align: center"><strong>END</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Stream原理</title>
    <url>/2020/09/09/Java/Stream%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><p>Java 8 中定义了四种流，分别是Stream、IntStream、LongStream、DoubleStream。每种流的操作、参数等都有区别。</p>
<h3 id="BaseStream"><a href="#BaseStream" class="headerlink" title="BaseStream"></a>BaseStream</h3><p>所有流接口的父级接口。</p>
<h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><p>工具类。</p>
<h3 id="StreamSupport"><a href="#StreamSupport" class="headerlink" title="StreamSupport"></a>StreamSupport</h3><p>创建流的工具，多用于类库</p>
<h2 id="PipelineHelper"><a href="#PipelineHelper" class="headerlink" title="PipelineHelper"></a>PipelineHelper</h2><p>流水线，通过其将流串起来。</p>
<h3 id="AbastractPipeline"><a href="#AbastractPipeline" class="headerlink" title="AbastractPipeline"></a>AbastractPipeline</h3><p>抽象类，定义了流水线串联起来的属性，及一些方法。</p>
<h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>与流类型，也分为四类。ReferencePipeline、IntPipeline、LongPipeline、DoublePipeline。</p>
<h4 id="ReferencePipeline"><a href="#ReferencePipeline" class="headerlink" title="ReferencePipeline"></a>ReferencePipeline</h4><p>引用类型的流水线，抽象类，其实现类主要有，Head、StatelessOp、StatefulOp，分别表示第一个、无状态的和有状态。</p>
<h2 id="OP"><a href="#OP" class="headerlink" title="OP"></a>OP</h2><p>操作</p>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><h4 id="有状态的操作"><a href="#有状态的操作" class="headerlink" title="有状态的操作"></a>有状态的操作</h4><ul>
<li>distinct</li>
<li>sorted</li>
<li>limit</li>
<li>skip<h4 id="无状态的操作"><a href="#无状态的操作" class="headerlink" title="无状态的操作"></a>无状态的操作</h4></li>
<li>map</li>
<li>filter</li>
<li>peek<h3 id="结束操作"><a href="#结束操作" class="headerlink" title="结束操作"></a>结束操作</h3>TerminalOP。<h4 id="短路操作"><a href="#短路操作" class="headerlink" title="短路操作"></a>短路操作</h4></li>
<li>match</li>
<li>find<h4 id="非短路操作"><a href="#非短路操作" class="headerlink" title="非短路操作"></a>非短路操作</h4></li>
<li>foreach</li>
<li>reduce</li>
</ul>
<h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><p>真正的执行者。</p>
<h3 id="TerminalSink"><a href="#TerminalSink" class="headerlink" title="TerminalSink"></a>TerminalSink</h3><p>标识是结束操作。</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>返回值。</p>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>通过ForkJoinTask来实现并行流的处理。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="编码流程"><a href="#编码流程" class="headerlink" title="编码流程"></a>编码流程</h3><ol>
<li>创建一个stream</li>
<li>添加中间操作，包括有状态、无状态操作</li>
<li>添加结束操作</li>
<li>如果有返回值，接收返回值</li>
</ol>
<h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><ol>
<li>创建steam，其类型为Head</li>
<li>每一步中间操作，创建一个新的stream，其类型为StatelessOp或StatefulOp，并在新的steam中保存上一个stream的引用</li>
<li>对于结束操作，创建一个新的TerminalSink</li>
<li>通过stream中的引用，逆序对每一个中间操作创建一个Sink，因为Sink继承自Consumer，在accpet中调用下流sink</li>
<li>接收返回值</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>String</title>
    <url>/2021/11/15/Java/String/</url>
    <content><![CDATA[<p>在C/C++中，字符串作为字符的数组被实现。而在Java中，字符串是作为对象实现，字符串实际上是对象类型。</p>
<p>Java字面量：<br>    基本数据类型<br>    字符串<br>    数组 - 实际也是对象？</p>
<p>字符串常量池： 在类加载时，在堆（方法区？）中创建一个对象，然后将它的引用存放在池中（还是方法区？）的一个常量表中。并且不会被垃圾回收。</p>
<p>使用new创建字符串，是在运行期创建的。</p>
<p>String s1 = “abc”;<br>String s2 = new String(“abc”);<br>s1.equals(s2) &amp;&amp; s1 != s2 &amp;&amp; s1.value == s2.value<br>字符串的值使用数组实现，在java中也是对象，s1，s2 的值都指向常量池中的数组对象。</p>
<p>String intern(): 把自身替换为常量池中的引用</p>
<p>字符串拼接：<br>    字面量拼接： 优化为一个字面量<br>    字面量和变量拼接： 使用StringBuilder优化<br>    int + char -&gt; char<br>    int + string -&gt; string<br>    string + 任意 -&gt; string</p>
<p>String 实现方式<br>    Jdk 6 char[]、offset、count、hash<br>    Jdk 7、8  char[]、hash<br>    Jdk 9  byte[]、coder、hash  </p>
<p>数组：<br>    数据是对象，但不是从某个类实例化来的，而是由JVM直接创建的，其父类是Object。<br>    每个数据都对应一个Class对象，通过RTTI，可以检查数据的运行时类型，签名，基类等。</p>
<pre><code>数组        RTTI
char[]        [C
int[]        [I
long[]        [J
float[]        [F
String[]    [Ljava.lang.String;
</code></pre>
<p>字面量初始化<br>int          直接定义, int i = 1;<br>short         2个字节以内的int，short s = (short)1;<br>long        l/L 结尾<br>byte        1个字节以内的byte，byte b = (byte)1;<br>float        f/F 结尾<br>double        整数+d/D结尾或小数<br>char        单引号<br>boolean     true/false<br>string        双引号<br>[]            大括号{} （简化了new）</p>
<p>null        null</p>
<p>null：<br>    null是一种数据类型，但可以忽略。<br>    null是关键字，是所有对象类型的默认值。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>classloader</title>
    <url>/2021/09/03/Java/classloader/</url>
    <content><![CDATA[<ol>
<li><p>classloader<br> 将class文件加载到jvm虚拟机中，使得程序可以运行。<br> jvm启动时，并不会一次性加载所有class文件，而是根据需要动态加载。 ？？？</p>
</li>
<li><p>系统类加载器</p>
<ol>
<li>Bootstrap ClassLoader  加载环境变量[sun.boot.class.path]目录下jar和class。</li>
<li>Extention ClassLoader  加载环境变量[java.ext.dirs]目录下jar和class。</li>
<li>AppClass Loader 加载环境变量[java.class.path]目录下jar和class（项目当前路径）。</li>
<li>如需加载其它路径，或重写加载规则，需自定义classLoader。</li>
<li>每个classLoader都有一个parent，在创建时指定。AppClassLoader的parent为ExtClassLoader，自定义parent默认为AppClassLoader。</li>
<li>Context ClassLoader - Thread ClassLoader，线程默认加载器为AppClassLoader，可自行设置更改，子线程会继承父线程的ClassLoader。</li>
</ol>
</li>
<li><p>双亲委派机制<br> 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时，子加载器才会尝试自己去加载。</p>
<p> 优点：</p>
<pre><code> 安全、性能（避免重复加载，避免核心类被篡改）。
</code></pre>
<p> 缺陷：</p>
<pre><code> 基础类无法调用用户类。
 （不知道具体实现类，无法创建对象）
 （如果类A中调用了类B，那么加载B的时候，需要使用A的类加载器去加载B。
 如果A是基础类，B是用户类，那么A对应的最上层类加载器，是没办法处理下层的用户类的。）
 
</code></pre>
<p> 解决：</p>
<pre><code> SPI + Thread ClassLoader。
 1. SPI只是一种机制/规范，具体加载部分还是使用Thread ClassLoader加载。
 2. 使用Thread ClassLoader 破坏了双亲委派机制。
</code></pre>
</li>
<li><p>加载</p>
<ol>
<li>虚拟机启动时，加载执行的主类。</li>
<li>new、getstatic、putstatic、invokestatic字节码指定。<ol>
<li>使用new实例化对象。</li>
<li>读取/设置静态字段。</li>
<li>调用静态方法。</li>
</ol>
</li>
<li>使用反射调用。</li>
<li>加载子类时，父类未被加载，优先加载父类。</li>
</ol>
<p> 不会加载</p>
<pre><code> 1. 常量在编译阶段会存入调用类的常量池中，使用常量不会加载。
 2. 创建数组不会加载。
 3. 通过子类引用父类静态属性/方法，只会加载父类。
</code></pre>
</li>
<li><p>Launcher<br> Launcher是jvm的启动类。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>io</title>
    <url>/2020/09/17/Java/io/</url>
    <content><![CDATA[<h2 id="按流向"><a href="#按流向" class="headerlink" title="按流向"></a>按流向</h2><h4 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h4><p>以自己为参照，从外面读取为输入。</p>
<h4 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h4><p>以自己为参照，向外面写为输出。</p>
<h2 id="按最小数据单元"><a href="#按最小数据单元" class="headerlink" title="按最小数据单元"></a>按最小数据单元</h2><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>以8位（8bit即1byte）作为一个数据单元。</p>
<h5 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h5><p>以16位（16bit即2byte）作为一个数据单元。<br>Java中的字符是Unicode编码，一个字符占用两个字节。</p>
<h2 id="按功能"><a href="#按功能" class="headerlink" title="按功能"></a>按功能</h2><h4 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h4><p>可以</p>
<ul>
<li>文件流</li>
<li>数组流</li>
<li>字符串流</li>
<li>管道流<h4 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h4>对一个已存在的流的连接和封装，通过对数据的处理为程序提供更为强大的读写功能。</li>
<li>缓冲流</li>
<li>转换流： 字节转字符，流中数据上全是字节。</li>
<li>数据流</li>
</ul>
<ul>
<li>getResourceAsStream<ol>
<li>Class.getResourceAsStream(String)<ul>
<li>相对路径：当前类路径下</li>
<li>绝对路径：classpath路径下</li>
</ul>
</li>
<li>Class.getClassLoader.getResourceAsStream(String)<br>相对路径，不能是绝对路径</li>
<li>ServletContext.getResourceAsStream(String)<br>resource目录下，相对/绝对都一样</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>lamada</title>
    <url>/2020/02/05/Java/lamada/</url>
    <content><![CDATA[<p>lamada 本质上可以理解为匿名内部类，在编译时传入的是实现了方法接口的匿名内部类。</p>
<p>lamada VS 匿名内部类</p>
<ol>
<li>匿名内部类编译后会出现 类名$1.class 的字节码，lamada没有。</li>
<li>通过反编译（javap），lamada在类中创建了一个 lamada$所在方法名$1 的static方法。</li>
<li>匿名内部类通过构造函数传入了一个原类的final实例。</li>
</ol>
<p>==？？？lamada是怎么访问方法局部变量的？？？==</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h4 id="java8-内置核心函数式接口"><a href="#java8-内置核心函数式接口" class="headerlink" title="java8 内置核心函数式接口"></a>java8 内置核心函数式接口</h4><ol>
<li>Consumer<T> 消费型<br> void accept(T t);</li>
<li>Supplier<T> 提供型<br> T get();</li>
<li>Function&lt;T, R&gt; 函数型<br> R apply(T t);</li>
<li>Predicate<T> 断定型<br> boolean test(T t);<h4 id="java8-其它函数式接口"><a href="#java8-其它函数式接口" class="headerlink" title="java8 其它函数式接口"></a>java8 其它函数式接口</h4></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>validate</title>
    <url>/2020/07/14/Java/validate/</url>
    <content><![CDATA[<h2 id="JSR303-JSR-349"><a href="#JSR303-JSR-349" class="headerlink" title="JSR303, JSR-349"></a>JSR303, JSR-349</h2><p>JSR303是一项标准,JSR-349是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，他们位于javax.validation.constraints包下，只提供规范不提供实现。</p>
<p>@Null 被注释的元素必须为null<br>@NotNull 被注释的元素必须不为null<br>@AssertTrue 被注释的元素必须为true<br>@AssertFalse 被注释的元素必须为false<br>@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>@Size(max, min) 被注释的元素的大小必须在指定的范围内<br>@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内<br>@Past 被注释的元素必须是一个过去的日期<br>@Future 被注释的元素必须是一个将来的日期<br>@Pattern(value) 被注释的元素必须符合指定的正则表达式</p>
<h2 id="hibernate-validation"><a href="#hibernate-validation" class="headerlink" title="hibernate validation"></a>hibernate validation</h2><p>hibernate validation是对这个规范的实践（不要将hibernate和数据库orm框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，他们位于org.hibernate.validator.constraints包下。<br>@Email 被注释的元素必须是电子邮箱地址<br>@Length 被注释的字符串的大小必须在指定的范围内<br>@NotEmpty 被注释的字符串的必须非空<br>@Range 被注释的元素必须在合适的范围内</p>
<h2 id="spring-validation"><a href="#spring-validation" class="headerlink" title="spring validation"></a>spring validation</h2><p>spring validation对hibernate validation进行了二次封装，在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中</p>
<ul>
<li>注意，必须相邻，如果有多个参数需要校验，形式可以如下。valid(@Validated Person person, BindingResult fooBindingResult ，@Validated Bar bar, BindingResult barBindingResult);即一个校验类对应一个校验结果。</li>
<li>校验结果会被自动填充</li>
<li>不加BindingResult ，会抛出BindException</li>
</ul>
<ol>
<li><p>@Validate 和 @Valid 的区别<br>而<br>而万能的spring为了给开发者提供便捷，对hibernate validation进行了二次封装，显示校验validated bean时，你可以使用spring validation或者hibernate validation，而spring validation另一个特性，便是其在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中。这无疑便捷了我们的web开发。<br>@Validate 支持分组验证，@Valid 支持嵌套验证</p>
</li>
<li><p>@Validate 用在方法入参和类上面的区别（能否用在方法上）</p>
</li>
<li><p>spring controller 验证</p>
</li>
<li><p>方法参数验证</p>
</li>
<li><p>自定义校验注解</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2021/09/03/Java/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><pre><code>参数化类型，将类型由原来的具体类型参数化，然后在使用/调用的时候传入具体的类型。
参数化： 在不创建新的类型的情况下， 通过泛型指定的不同类型来控制形参具体限制的类型。
</code></pre>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre><code>    泛型类型用于类的定义中，被成为泛型类。
    在实例化类的时候指明泛型的具体类型，或子类实现/继承时指定类型。
</code></pre>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><pre><code>    在调用方法的时候指明泛型的具体类型。
    静态方法无法访问类定义上的泛型。
</code></pre>
<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><pre><code>    ？
</code></pre>
<h3 id="泛型边界"><a href="#泛型边界" class="headerlink" title="泛型边界"></a>泛型边界</h3><pre><code>    上界 extends
    下界 super
</code></pre>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><pre><code>避免过多的创建类而造成的运行时的过度消耗。
泛型的约束在编译期生效，在运行期无效，可以在运行期忽略泛型。
</code></pre>
<h2 id="获取具体类型"><a href="#获取具体类型" class="headerlink" title="获取具体类型"></a>获取具体类型</h2><h3 id="获取父类具体类型"><a href="#获取父类具体类型" class="headerlink" title="获取父类具体类型"></a>获取父类具体类型</h3><pre><code>    eg: public class TestA extends ParentA&lt;String&gt; &#123;&#125;

    ParameterizedType type = (ParameterizedType)子类对象.getClass().getGenericSuperClass();
    type.getActualTypArguments();
</code></pre>
<h3 id="获取接口具体类型"><a href="#获取接口具体类型" class="headerlink" title="获取接口具体类型"></a>获取接口具体类型</h3><pre><code>    eg：public class TestB&lt;T&gt; implements InterfaceA&lt;T&gt; &#123;&#125;

    ParameterizedType[] types = (ParameterizedType)子类对象.getClass().getGenericInterfaces();
    ...
</code></pre>
<h3 id="获取泛型方法返回值类型"><a href="#获取泛型方法返回值类型" class="headerlink" title="获取泛型方法返回值类型"></a>获取泛型方法返回值类型</h3><pre><code>    ParameterizedType type = getMethod(&quot;...&quot;).getGenericReturnType();
    type.getActualTypArguments();
</code></pre>
<h3 id="获取泛型方法参数具体理性"><a href="#获取泛型方法参数具体理性" class="headerlink" title="获取泛型方法参数具体理性"></a>获取泛型方法参数具体理性</h3><pre><code>    Type[] genericParameterTypes=method.getGenericParameterTypes();
    ...
</code></pre>
<h3 id="通过泛型成员获取具体类型"><a href="#通过泛型成员获取具体类型" class="headerlink" title="通过泛型成员获取具体类型"></a>通过泛型成员获取具体类型</h3><pre><code>    eg: List&lt;String&gt; list;
    
    ParameterizedType type = (ParameterizedType) field.getGenericType();
    type.getActualTypArguments();
</code></pre>
<h3 id="类定义时没有指定泛型类型，而在使用时指定泛型类型，这种情况无法获取具体类型信息，这时getClass-获取的是类模板上的信息。"><a href="#类定义时没有指定泛型类型，而在使用时指定泛型类型，这种情况无法获取具体类型信息，这时getClass-获取的是类模板上的信息。" class="headerlink" title="类定义时没有指定泛型类型，而在使用时指定泛型类型，这种情况无法获取具体类型信息，这时getClass()获取的是类模板上的信息。"></a>类定义时没有指定泛型类型，而在使用时指定泛型类型，这种情况无法获取具体类型信息，这时getClass()获取的是类模板上的信息。</h3><pre><code>比如 List&lt;String&gt; list = new ArrayList&lt;&gt;(); 无法获取list的具体类型信息。
</code></pre>
<h2 id="Type-接口"><a href="#Type-接口" class="headerlink" title="Type 接口"></a>Type 接口</h2><pre><code>GenericArrayType, ParameterizedType, WildcardTYpe, TypeVariable， Class
</code></pre>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><pre><code>只有使用泛型通配符，在使用过程中，或定义泛型方法参数时才能使用super关键字。
</code></pre>
<h3 id="泛型推导"><a href="#泛型推导" class="headerlink" title="泛型推导"></a>泛型推导</h3><pre><code>https://www.cnblogs.com/heimianshusheng/p/5766573.html
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS8</title>
    <url>/2020/02/05/Linux/CentOS8/</url>
    <content><![CDATA[<blockquote>
<p>最近centos 8发布，而且之前系统安装软件、文件路径都不太符合现在所理解的一些规范，所以准备重新安装系统。</p>
</blockquote>
<h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><h3 id="机器配置"><a href="#机器配置" class="headerlink" title="机器配置"></a>机器配置</h3><ul>
<li>型号： HP200 Pro G1 MT（(J1800)）</li>
<li>处理器： Intel Celeron J1800(2.41GHz/L3 1M)，双核双线程</li>
<li>内存： 4G DDR3 1600</li>
<li>硬盘： 500G机械硬盘</li>
</ul>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol>
<li>阿里云下载centos8 iso镜像，制作U盘启动。</li>
<li>开机时不插键盘，出现键盘找不到时，插入usb键盘，按esc，设置引导。</li>
<li>选择最小安装，设置磁盘分区，开启网络配置，开始安装。</li>
</ol>
<h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><table>
<thead>
<tr>
<th>路径</th>
<th>格式</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>/boot</td>
<td>-</td>
<td>512MB</td>
</tr>
<tr>
<td>/boot/efi</td>
<td>-</td>
<td>256MB</td>
</tr>
<tr>
<td>swap</td>
<td>-</td>
<td>8GB</td>
</tr>
<tr>
<td>/home</td>
<td>-</td>
<td>150GB</td>
</tr>
<tr>
<td>/var</td>
<td>-</td>
<td>50GB</td>
</tr>
<tr>
<td>/</td>
<td>-</td>
<td>260GB左右(剩余全部)</td>
</tr>
</tbody></table>
<h3 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>主板键盘为ps/2接口，只能通过ps/2接口进入BIOS设置（ps/2转usb转换头也不行）。<blockquote>
<p>开机时不插键盘，出现键盘找不到时，插入usb键盘，按esc。</p>
</blockquote>
</li>
<li>镜像开机时选择install选项后不出现安装界面。<blockquote>
<p>选择install选项，按e键进入编辑页面，将label设置为/dev/sdb4，按ctrl+X执行安装。<br>PS1: 可以先修改为linux dd查看设备，确定之后在修改。<br>PS2：在引导系统中，按Ctrl + Shift + Delete 组合键重启。</p>
</blockquote>
</li>
<li>使用DVD镜像安装时，提示 Pane is DEAD，而使用虚拟机安装是没有问题的。<blockquote>
<p>使用网络版镜像安装，在设置安装源时，先联网，然后选择从网络安装，设置镜像仓库地址。<br>PS：网络版镜像应该不是官网的，而是阿里云提供的。</p>
</blockquote>
</li>
</ul>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>/usr/lcoal 安装系统软件<br>/opt 安装临时软件，存储安装包（压缩包安装方式）<br>/var 放日志文件</p>
<h3 id="开放端口及服务"><a href="#开放端口及服务" class="headerlink" title="开放端口及服务"></a>开放端口及服务</h3><ul>
<li>查看指定区域(public)所有开启的端口号/服务<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports / --list-service</span><br></pre></td></tr></table></figure></li>
<li>开放端口/服务（防火墙重启生效）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp / --add-service=http --permanent</span><br></pre></td></tr></table></figure></li>
<li>查看所有服务<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><ul>
<li>查看自带的，yum search docker 发现自带的不是我们想要的。</li>
<li>下载docker-ce repo<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li>安装containerd.io依赖<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm</span><br></pre></td></tr></table></figure></li>
<li>安装docker<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure></li>
<li>设置开机启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><ul>
<li>安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure></li>
<li>设置开机启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure></li>
<li>nginx配置文件路径：/etc/nginx/nginx.conf</li>
<li>nginx日志文件路径：/var/nginx</li>
</ul>
<p>  ngigx路径/结尾</p>
<ul>
<li>在某些情况下，Nginx内部重定向规则会被启动，例如，当 URL 指向一个目录并且在最后没有包含“/”时，Nginx 内部会自动的做一个 301 重定向</li>
<li>location<ul>
<li>以/结尾：url与location路径完全匹配</li>
<li>不以/结尾：模糊匹配，以location路径开头。</li>
</ul>
</li>
<li>proxy_pass<ul>
<li>以/结尾：访问服务proxy + (uri - location)路径</li>
<li>ip/域名结尾：访问服务proxy + url路径</li>
<li>其它：访问服务proxy + (uri - location)路径 (字符串拼接，没有/)</li>
</ul>
</li>
<li>root<ul>
<li>一致</li>
</ul>
</li>
</ul>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><blockquote>
<p>通过docker安装mysql服务，简单，省事。<br>但是docker容器具有临时性，而mysql的数据要持久化，所以通过docker启动MySQL，然后通过挂载卷的方式保存数据，是否是个好的选择呢？</p>
</blockquote>
<ul>
<li>拉取镜像<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:8</span><br></pre></td></tr></table></figure></li>
<li>启动容器<br>  将容器设置为自动重启，这样服务器开机或docker服务重启时会自动启动容器。<br>  使用 -e 选项为mysql设置root账号密码。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root --restart=always --name mysql mysql:8</span><br></pre></td></tr></table></figure>
<ul>
<li>进入容器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h3><blockquote>
<p>使用docker安装jenkins，方便，省事。</p>
</blockquote>
<ul>
<li>拉取镜像<br>  使用latest版本<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jenkinsci/blueocean</span><br></pre></td></tr></table></figure></li>
<li>启动容器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -u root -d -p 8080:8080 -v /var/jenkins_data:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock --restart=always --name jenkins jenkinsci/blueocean</span><br></pre></td></tr></table></figure></li>
<li>获取admin默认密码</li>
<li>自定义安装插件</li>
<li>创建管理员用户密码</li>
</ul>
<h4 id="填坑-1"><a href="#填坑-1" class="headerlink" title="填坑"></a>填坑</h4><ol>
<li>启动jenkins容器，配置nginx代理，静态资源访问不到</li>
<li>开启防火墙，启动jenkins容器，开放8080端口，内网访问不到</li>
<li>在2的前提下，关闭防火墙，内网可以访问，但是jenkins提示离线</li>
<li>开机启动docker，firewalld，然后关闭防火墙，启动容器，启动不起来，提示： docker: Error response from daemon: driver failed programming external connectivity on endpoint jenkins (0a8069842c234eaae6d36192f62b5d9503926c0167cae15711300168103c5b1e):  (iptables failed: iptables –wait -t nat -A DOCKER -p tcp -d 0/0 –dport 8080 -j DNAT –to-destination 172.17.0.2:8080 ! -i docker0: iptables: No chain/target/match by that name.</li>
<li>最终解决办法：开机启动docker，firewallld, 然后关闭防火墙，docker服务重启，然后启动容器，ok！（问题，怎么能不关闭防火墙）<br>PS: 每次防火墙重启时都需要重启docker服务。</li>
</ol>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><blockquote>
<p>github国内访问有点慢，有时候提交需要等好一会儿，而且自己的那点代码，感觉放在开源网站有点low，所以决定在自己服务器安装一个git服务器，等项目做的有点水平了，在放到github上去。</p>
</blockquote>
<h4 id="ssh版本"><a href="#ssh版本" class="headerlink" title="ssh版本"></a>ssh版本</h4><blockquote>
<p>Protocol 2</p>
</blockquote>
<h4 id="git协议选择"><a href="#git协议选择" class="headerlink" title="git协议选择"></a>git协议选择</h4><blockquote>
<p>通过查看git官网文档，git有四种可选择的协议来传输资料，分别是local，git，ssh，http。<br>其中local是本地协议，不能通过网络访问，git协议缺乏授权机制。<br>http协议安装比较复杂，等后期对相关知识更加了解在做。<br>暂时选择git协议，使用密钥的方式进行授权，添加访问用户时需要添加公钥到服务器。</p>
</blockquote>
<h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><ol>
<li>安装git软件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure></li>
<li>创建git用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adduser git (不用设置密码)</span><br></pre></td></tr></table></figure></li>
<li>在git根目录下创建.ssh文件夹</li>
<li>在git/.ssh目录下创建 authorized_keys 文件，用来存放用户公钥。</li>
<li>设置git目录所属用户为git，.ssh目录权限为700，authorized_keys 文件权限为600。</li>
<li>限制git账号使用ssh连接。<br>git-shell: 登录成功后自动退出的shell<br>查看git-shell命令路径： where is git-shell<br>修改/etc/passwd中 git账号登录后的shell为git-shell全路径</li>
<li>打开RSA认证。<br>修改配置文件/etc/ssh/sshd_config 中 设置<br>RSAAuthentication yes(centos 7.4 已弃用，忽略不设置)<br>PubkeyAuthentication yes<br>AuthorizedKeysFile .ssh/authorized_keys<h4 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h4><blockquote>
<p>在git目录下新建.git结尾文件夹，进入文件夹，创建一个裸仓库。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init --bare</span><br></pre></td></tr></table></figure>
<h4 id="填坑-2"><a href="#填坑-2" class="headerlink" title="填坑"></a>填坑</h4></li>
</ol>
<ul>
<li>git用户密码<blockquote>
<p>git用户不必设置密码，没有必要。</p>
</blockquote>
</li>
<li>权限问题<blockquote>
<p>git用户根目录下的所有文件及目录都应该属于git用户，每次创建完git仓库时也要修改目录所属用户，否则会提示 无权限访问。</p>
</blockquote>
</li>
<li>公钥<blockquote>
<p>使用 &gt;&gt; 操作可以将公钥追加到文件里面。<br>使用 &gt; 操作会清空文件的内容，并把新内容添加到文件里面。</p>
</blockquote>
</li>
<li>git clone<blockquote>
<p>在使用 TortoistGit 进行git clone 的时候，需要勾选 Load Putty Key 选项，并选择私钥。<br>在使用 git bash clone的时候需要保证当前用户目录.ssh文件夹下面存在私钥。</p>
</blockquote>
</li>
<li>RSA<blockquote>
<p>RSAAuthentication 是对ssh 1版本的支持，在本环境中，使用ssh 2，所以没有这个配置，忽略即可。<br>如果自己手动加上了这个配置，在查看日志文件时会有警告。</p>
</blockquote>
</li>
<li>bare<blockquote>
<p>裸仓库即不包含工作目录的仓库。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2021/11/28/Linux/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>/bin 系统普通用户命令</li>
<li>/sbin root命令</li>
<li>/usr/bin 系统普通用户命令</li>
<li>/usr/sbin root命令</li>
<li>/etc 系统默认配置目录</li>
<li>/root </li>
<li>/home </li>
<li>/lib 函数库</li>
<li>/media 光盘</li>
<li>/mnt U盘、硬盘</li>
<li>/misc 磁带</li>
<li>/proc 内存的过载点</li>
<li>/sys 内存的过载点</li>
<li>/temp 临时目录</li>
<li>/usr 系统资源</li>
<li>/var 系统可变文档</li>
<li>/boot 启动目录</li>
</ul>
<h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><ul>
<li>0 关机</li>
<li>1 单用户模式</li>
<li>2 不完全的命令行</li>
<li>3 完全的命令行</li>
<li>4 系统保留</li>
<li>5 图形界面</li>
<li>6 重启</li>
</ul>
<p>查看： run level<br>修改： init x<br>修改开始时级别： /etc/inittab</p>
<h2 id="用户、用户组"><a href="#用户、用户组" class="headerlink" title="用户、用户组"></a>用户、用户组</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>/etc/group 存储当前系统中所有用户组信息 （组名称:组密码占位符:组编号:组中用户名列表）</li>
<li>/etc/gshadow 存储当前系统中用户组的密码信息 （组名称:组密码:组管理者:组中用户列表）</li>
<li>/etc/passwd 存储用户组中用户信息 （用户名:密码占位符:用户编号:用户组编号:用户注释信息:用户主目录:shell类型）</li>
<li>/etc/shadow 存储用户密码信息 （用户:密码:……）</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>添加用户组： groupadd 组名</li>
<li>修改用户组名称： groupmod -n 新组名 旧组名</li>
<li>修改用户组编号： groupmod -g 编号 组名</li>
<li>删除用户组：groupdel 组名</li>
<li>添加用户： useradd 用户名</li>
<li>修改用户： usermod -l 旧名 新名</li>
<li>删除用户： userdel 用户名</li>
<li>锁定： passwd 用户名 -l</li>
<li>解锁： passwd 用户名 -u</li>
<li>清除命令： passwd 用户名 -d</li>
</ul>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [选项] 模式 文件名</span><br><span class="line">chown [组名:]用户名 文件名</span><br><span class="line">chgrp 组名 文件名</span><br></pre></td></tr></table></figure>
<p>-R 递归</p>
<h2 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩/解压缩"></a>压缩/解压缩</h2><p>压缩文件格式： .zip、.gz、.bz2、.tar.gz、.tar.gz2</p>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><ul>
<li>-c 打包、-x 解压、 -t 查看</li>
<li>-v 显示过程</li>
<li>-f 指定打包后的文件名</li>
<li>-z .tar.gz格式 -j .tar.bz2格式</li>
</ul>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><ul>
<li>压缩文件 zip *.zip *</li>
<li>压缩目录 zip -r *.zip 目录</li>
<li>解压缩 unzip 压缩文件</li>
</ul>
<h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><ul>
<li>压缩文件 gzip 源文件 （源文件消失）</li>
<li>压缩目录 gzip  -r 目录</li>
<li>解压 gunzip 压缩文件</li>
<li>解压 gzip -d 压缩文件</li>
</ul>
<h3 id="bzip"><a href="#bzip" class="headerlink" title="bzip"></a>bzip</h3><ul>
<li>压缩文件 bzip2 源文件</li>
<li>不能压缩目录</li>
<li>解压 bzip2 -d 压缩文件</li>
<li>解压 bunzip2 压缩文件</li>
</ul>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul>
<li>查看级别 map -f 命令  -&gt;  whatis 命令</li>
<li>查找  map -k 命令  -&gt;  apropos 命令</li>
</ul>
<h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><h2 id="ssh操作"><a href="#ssh操作" class="headerlink" title="ssh操作"></a>ssh操作</h2><ul>
<li>ctrl + L  清屏</li>
<li>ctrl + c  强制退出</li>
<li>ctrl + u  删除至行首</li>
<li>ctrl + a  Home</li>
<li>ctrl + e  End</li>
<li>ctrl + r  在历史命令搜索</li>
<li>ctrl + z  放入后台</li>
</ul>
<h2 id="VI操作模式"><a href="#VI操作模式" class="headerlink" title="VI操作模式"></a>VI操作模式</h2><p>virsual interface<br>命令模式、输入模式、底行模式</p>
<ul>
<li>:w 保存</li>
<li>:q 退出</li>
<li>:! 强制执行</li>
<li>:ls 列出当前打开文件</li>
<li>:n 切换到下一个打开的文件</li>
<li>:N 切换到上一个打开的文件</li>
<li>:15 定位到15行</li>
<li>/xxx 向后搜索</li>
<li>?xxx 向前搜索</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>命令格式： 命令 [选项] [参数]</p>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>print working directory</p>
<ul>
<li>~ 当前用户家目录</li>
<li><h1 id="管理员用户"><a href="#管理员用户" class="headerlink" title="管理员用户"></a>管理员用户</h1></li>
<li>$ 普通用户</li>
</ul>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ul>
<li>-a all</li>
<li>-l long 文件类型（-、d、l、…）</li>
<li>-d 目录属性</li>
<li>-h human 人性化显示</li>
<li>-i inode i结点</li>
</ul>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [原文件/目录] [目标文件/目录]</span><br></pre></td></tr></table></figure>

<h3 id="创建目录-mkdir"><a href="#创建目录-mkdir" class="headerlink" title="创建目录 mkdir"></a>创建目录 mkdir</h3><ul>
<li>-p 递归创建</li>
</ul>
<h3 id="删除-rm"><a href="#删除-rm" class="headerlink" title="删除 rm"></a>删除 rm</h3><ul>
<li>-f force 强制</li>
<li>-r 删除目录</li>
</ul>
<h3 id="复制-cp"><a href="#复制-cp" class="headerlink" title="复制 cp"></a>复制 cp</h3><ul>
<li>-r 目录</li>
<li>-p 连带文件属性复制</li>
<li>-d 若源文件是链接文件，则复制链接属性</li>
</ul>
<h3 id="链接-ln"><a href="#链接-ln" class="headerlink" title="链接 ln"></a>链接 ln</h3><p>ln [原文件] [目标文件]<br>-s 软链接</p>
<h3 id="文件搜索-locate"><a href="#文件搜索-locate" class="headerlink" title="文件搜索 locate"></a>文件搜索 locate</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate 文件名</span><br></pre></td></tr></table></figure>

<h3 id="命令搜索"><a href="#命令搜索" class="headerlink" title="命令搜索"></a>命令搜索</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">where is 命令</span><br><span class="line">which 命令</span><br></pre></td></tr></table></figure>
<p>where 查看命令所在位置-b 和帮助文档-m<br>which 查看命令所在位置和别名</p>
<h3 id="字符串搜索-grep"><a href="#字符串搜索-grep" class="headerlink" title="字符串搜索 grep"></a>字符串搜索 grep</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [选项] 字符串 文件名</span><br></pre></td></tr></table></figure>
<ul>
<li>-i 忽略大小写</li>
<li>-v 取反</li>
</ul>
<h3 id="文件搜索-find"><a href="#文件搜索-find" class="headerlink" title="文件搜索 find"></a>文件搜索 find</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [搜索目录] [搜索条件（通配符）]</span><br></pre></td></tr></table></figure>
<ul>
<li>atime 文件访问时间</li>
<li>ctime 改变文件属性时间</li>
<li>mtime 改变内容时间</li>
<li>-10 10天内修改</li>
<li>+10 10天前修改</li>
<li>10 10天前当天修改</li>
<li>-size 25k/+25k/-25k</li>
<li>-inum</li>
<li>-a and</li>
<li>-o or</li>
</ul>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><ul>
<li>-l 本地磁盘</li>
<li>-a 所有文件系统</li>
<li>-h 1024 进制换算</li>
<li>-H 1000 进制换算</li>
<li>-T 分区类型</li>
<li>-t 显示指定类型</li>
<li>-x 不显示指定类型</li>
</ul>
<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount ntfs-3g 目录 目录</span><br><span class="line">umount 目录</span><br></pre></td></tr></table></figure>

<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li>du 统计磁盘上的文件大小<ul>
<li>-b -k -m</li>
<li>-h -H </li>
<li>-s 指定统计目标</li>
</ul>
</li>
<li>fdish 添加MBR分区</li>
<li>parted 添加GPT/MBR分区</li>
<li>mkfs 格式化</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux软件安装</title>
    <url>/2021/11/28/Linux/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="源码包安装"><a href="#源码包安装" class="headerlink" title="源码包安装"></a>源码包安装</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>C语言编译器gcc</li>
<li>源码包 *.tar.gz</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>解压缩</li>
<li>进入解压缩目录</li>
<li>./config 软件配置与检查</li>
<li>make / make clean 编译</li>
<li>make install 编译安装</li>
<li>启动</li>
</ol>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>直接删除安装目录即可。</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><ul>
<li>源码保存位置 /usr/local/src/</li>
<li>安装位置 /usr/local</li>
</ul>
<h2 id="RPM安装"><a href="#RPM安装" class="headerlink" title="RPM安装"></a>RPM安装</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>软件包名-版本-发布次数.适合平台.适合硬件平台.rpm</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>树依赖、环形依赖、库文件依赖/模块依赖</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>rpm -ivh 包全名<br>-i install 安装<br>-e erase 卸载<br>-v verbose 显示详细信息<br>-h hase 显示进度</p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>rpm -uvh 包全名<br>-u upgrade 升级</p>
<h3 id="卸载-1"><a href="#卸载-1" class="headerlink" title="卸载"></a>卸载</h3><p>rpm -e 包名<br>-e erase 卸载</p>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>rpm -v 包名<br>-v validate 校验</p>
<h3 id="查询命令"><a href="#查询命令" class="headerlink" title="查询命令"></a>查询命令</h3><ul>
<li>-q query</li>
<li>-a all</li>
<li>-i information</li>
<li>-p package</li>
<li>-l list</li>
<li>-f file</li>
</ul>
<h3 id="默认安装路径"><a href="#默认安装路径" class="headerlink" title="默认安装路径"></a>默认安装路径</h3><p>rpm包安装位置由rpm包确定，可以指定perfix，但不建议。<br>/etc/ 配置文件<br>/usr/share/doc/ 软件使用手册<br>/usr/bin/ 可执行命令<br>/usr/shar/man/ 帮助文件<br>/usr/lib/ 程序所使用函数库</p>
<h3 id="文件提取"><a href="#文件提取" class="headerlink" title="文件提取"></a>文件提取</h3><p>rpm2cpio 包全名 | epio -idu 文件绝对路径</p>
<h2 id="yum在线安装"><a href="#yum在线安装" class="headerlink" title="yum在线安装"></a>yum在线安装</h2><p>服务器使用最小化安装，用什么装什么，尽量不卸载。</p>
<h3 id="yum源文件"><a href="#yum源文件" class="headerlink" title="yum源文件"></a>yum源文件</h3><p>/etc/yum.repos.d/Centos-Base.repo</p>
<ul>
<li>[base]: 容器名称</li>
<li>name: 容器说明</li>
<li>mrrorlist: 镜像站点</li>
<li>baseurl: yum源服务器地址</li>
<li>enable: 是否生效，默认1，1生效，0无效</li>
<li>gpgcheck: RPM数字证书，1生效，0无效</li>
<li>gpgkey: 数字证书公钥文件保存位置</li>
</ul>
<h3 id="配置光盘yum源"><a href="#配置光盘yum源" class="headerlink" title="配置光盘yum源"></a>配置光盘yum源</h3><ol>
<li>挂载光盘</li>
<li>使默认失效，修改名字</li>
<li>修改光盘配置yum源</li>
</ol>
<h3 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h3><ul>
<li>yum list</li>
<li>yum search 关键字</li>
<li>yum -y install 包名</li>
<li>yum -y update 包名</li>
<li>yum -y remove 包名</li>
<li>yum grouplist</li>
<li>yum groupinstall 软件组名</li>
<li>yum groupremove 软件组名</li>
</ul>
<h2 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h2><p>eg nginx</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h3><ul>
<li>优点 开源，安装功能可配置，卸载方便，干净。</li>
<li>缺点 编译时间长，编译出错重复安装，安装步骤多。<h3 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h3></li>
<li>优点 安装、升级、查询、卸载简单，速度快。</li>
<li>缺点 不开源，不灵活，依赖性强。<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3></li>
<li>优点 简单、迅速、方便。</li>
<li>缺点 软件版本、功能不能自定义。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>WSL2</title>
    <url>/2021/06/03/Linux/WSL2/</url>
    <content><![CDATA[<h1 id="WSL2"><a href="#WSL2" class="headerlink" title="WSL2"></a>WSL2</h1><blockquote>
<p>How/Why</p>
</blockquote>
<h2 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h2><p>一、 更新windows<br>    wsl2需要： ×64架构 需要1903及更高<br>    下载windows易升，从1909版本升级到20H2。</p>
<p>二、 启用windows功能<br>    适用于Linux的Windows子系统<br>    虚拟机平台  wsl2需要</p>
<p>三、 登录microsoft账号，加入windows预览体验计划    只是简化安装需要<br>    下载ubuntu，windows terminal</p>
<p>四、 wsl2<br>    下载linux内核更新包并运行<br>    设置默认版本为2</p>
<h2 id="安装centos"><a href="#安装centos" class="headerlink" title="安装centos"></a>安装centos</h2><ol>
<li>下载镜像 <a href="https://github.com/CentOS/sig-cloud-instance-images/tree/CentOS-8-x86_64">https://github.com/CentOS/sig-cloud-instance-images/tree/CentOS-8-x86_64</a></li>
<li>windows安装Chocolatey</li>
<li>通过Chocolatey安装LxRunOffline</li>
<li>通过LxRunOffline安装centos<br> LxRunOffline.exe  install -n centos -d E:\WSL\CentOS -f  E:\WSL\centos-8-x86_64.tar.xz<pre><code> -n 名称
 -d 安装路径
 -f 文件路径
</code></pre>
 启动： LxRunOffline run -n centos</li>
<li>安装VcXsrc<br> 需要VcXsrc来显示</li>
<li>安装图形界面<br> yum install -y epel-release<br> yum groupinstall -y “Xfce”<br> 重启<br> export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk ‘{print $2; exit;}’):0.0<br> startxfce4 export DISPLAY=172.20.128.1:0.0</li>
</ol>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>LxRunOffline.exe  install -n c8 -d D:\WSL2\WSL_C8 -f  E:\down\centos-8-x86_64.tar.xz</li>
<li>yum install net-tools -y</li>
<li>yum -y install xorg-x11-xauth</li>
<li>yum -y install firefox ( libXcomposite libXcursor libXft libXi libXinerama libXrandr libXrender libXtst libXpm )</li>
<li>yum -y install mesa-libGL</li>
</ol>
<p>yum -y install which</p>
<p>bat启动文件<br>.\config.xlaunch<br>start /min wsl -d c8 idea</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>安装jdk： yum install -y java-1.8.0-openjdk</li>
<li>安装mysql: yum install -y mysql-server</li>
<li>安装maven：下载、解压、设置环境变量</li>
<li>安装node：yum install -y nodejs</li>
<li>安装git：yum install -y git</li>
<li>安装svn：</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>selinux，firewalld，iptable</title>
    <url>/2020/02/05/Linux/selinux%EF%BC%8Cfirewalld%EF%BC%8Ciptable/</url>
    <content><![CDATA[<p>selinux  ( /etc/selinux/config)<br>    安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。<br>    SELinux 主要由美国国家安全局开发。2.6 及以上版本的 Linux 内核都已经集成了 SELinux 模块。<br>    SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）。</p>
<p>firewalld<br>    firewall能够允许哪些服务可用，那些端口可用…. 属于更高一层的防火墙。<br>    firewall的底层是使用iptables进行数据过滤，建立在iptables之上。<br>    firewall是动态防火墙，使用了D-BUS方式，修改配置不会破坏已有的数据链接。</p>
<p>iptables<br>    iptables用于过滤数据包，属于网络层防火墙.<br>    在设置iptables后需要重启iptables，会重新加载防火墙模块，而模块的装载将会破坏状态防火墙和确立的连接。会破坏已经对外提供数据链接的程序。可能需要重启程序。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>ssh</title>
    <url>/2020/02/05/Linux/ssh/</url>
    <content><![CDATA[<p>SSH （ Secure Shell ），建立在应用层基础上的安全协议</p>
<p>SCP（Secure Copy）、SFTP（SSH File Transfer Protocol）是基于ssh的协议，使用了ssh的加密功能</p>
<p>使用ssh-copy-id命令将公钥复制到远程主机。ssh-copy-id会将公钥写到远程主机的 ~/ .ssh/authorized_key 文件中</p>
<p>SSH之所以能够保证安全，原因在于它采用了非对称加密技术(RSA)加密了所有传输的数据。<br>从客户端来看，SSH提供两种级别的安全验证。<br>第一种级别（基于口令的安全验证）<br>第二种级别（基于密匙的安全验证）</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>命令</title>
    <url>/2020/02/05/Linux/%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>x86泛指一系列基于Intel 8086且向后兼容的中央处理器指令集架构<br>x86_64 = x64</p>
<p>Nginx 13: Permission denied</p>
<ol>
<li>nginx user 设置为root</li>
<li>访问的目录/文件不存在</li>
<li>selinux 关闭</li>
</ol>
<p>查看时区 timedatectl<br>查看可设置时区 timedatectl list<br>设置时区 timedatectl set-timezone Asia/Shanghai (设置完之后硬件时间跟着变了，why？)</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2020/07/14/Maven/maven/</url>
    <content><![CDATA[<h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><ul>
<li>relativePath / pom<br>  relativePath 默认情况下，从当前pom.xml的父级目录查找， 为空值时从仓库查找<br>  pom 聚合工程，install时不会jar包，其它文件都会生成</li>
</ul>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>pom.xml</title>
    <url>/2021/06/24/Maven/pom-xml/</url>
    <content><![CDATA[<h2 id="dependencyManagemet与dependency"><a href="#dependencyManagemet与dependency" class="headerlink" title="dependencyManagemet与dependency"></a>dependencyManagemet与dependency</h2><p>dependencyManagemet 只是管理版本，并不下载依赖<br>dependency 添加依赖</p>
<h2 id="pachaging-默认jar，可选jar、pom、war"><a href="#pachaging-默认jar，可选jar、pom、war" class="headerlink" title="pachaging 默认jar，可选jar、pom、war"></a>pachaging 默认jar，可选jar、pom、war</h2><ul>
<li>jar 调用或者作为服务</li>
<li>pom 一般为父子继承使用</li>
<li>war web项目</li>
</ul>
<h2 id="spring-boot-parent-与-spring-boot-dependency"><a href="#spring-boot-parent-与-spring-boot-dependency" class="headerlink" title="spring-boot-parent 与 spring-boot-dependency"></a>spring-boot-parent 与 spring-boot-dependency</h2><ul>
<li>风格不同，功能一样</li>
<li>如果有自己的parent，则无法使用spring-boot-parent，只能使用spring-boot-dependency方式</li>
<li>使用spring-boot-parent需要配置 <relativePath/></li>
<li>使用spirng-boot-dependency 需要配置 scope=import、type=pom</li>
</ul>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis 源码</title>
    <url>/2021/06/24/Mybatis/Mybatis-%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>动态代理 Mapper、Inteceptor<br>装饰器 Executor<br>建造者 Environment.Builder</p>
<pre><code>动态代理 - 接口、类加载器
ognl表达式
mapper 实例化、单例 
Log
TypeDiscriminator
@Select &lt;script&gt; 与不加
</code></pre>
<ol>
<li>属性替换： 每次加载节点，转换为XNode数据时，在XNode构造方法中实现 ${} 属性替换。 即 XNode.evalNode(“”)时。</li>
<li>setting赋值顺寻：</li>
<li>TypeHandler中存储数据：保存在typeHandlerMap中。保存的是实例。如果javaType为null（实现TypeHandler接口 &amp;&amp; 不适用注解  或者手动注册null），则忽略。</li>
<li>TypeHandler配置优先级： xml配置 &gt; 注解 &gt; 泛型（继承BaseHandler），手动使用TypeReference也会检查注解。</li>
<li>cache、cache-ref 只能存在一个且只能配置一份。 ？？？</li>
<li>如果指定了databaseId，则每个sql、statement标签都需要指定databaseId。 ？？？</li>
<li>SelectKey</li>
<li>mapUnderscoreToCamelCase 默认false, 要真正存在一个与它对应的驼峰Bean才生效</li>
</ol>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><ul>
<li><p>org.apache.ibatis.session</p>
</li>
<li><p>typeHandlerRegistry</p>
</li>
<li><p>typeAliasRegistry</p>
</li>
<li><p>interceptorChain</p>
</li>
<li><p>mapperRegister</p>
</li>
<li><p>ScriptMap sqlFragments  解析sql标签的语句</p>
</li>
<li><p>loadedResources<br>  key：     通过mapper标签指定url： url</p>
<pre><code>      通过mapper标签指定resource： resource
      通过mapper解析namespace: `namespace:` + namespace
      通过java类解析：`interface ` + className
      通过java类解析相同名称及路径的xml：`namespace:` + className
</code></pre>
</li>
<li><p>addMapper() / addMappers() -&gt; mapperRegister.addMapper()/addMappers()</p>
</li>
</ul>
<h3 id="BaseBuilder"><a href="#BaseBuilder" class="headerlink" title="BaseBuilder"></a>BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder</li>
<li>Configuration</li>
<li>typeAliasRegistry</li>
<li>typeHandlerRegistry</li>
</ul>
<h3 id="XMLConfigBuilder-extends-BaseBuilder"><a href="#XMLConfigBuilder-extends-BaseBuilder" class="headerlink" title="XMLConfigBuilder extends BaseBuilder"></a>XMLConfigBuilder extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>XPathPaser</li>
<li>environment</li>
<li>parse()</li>
</ul>
<h3 id="XPathPaser"><a href="#XPathPaser" class="headerlink" title="XPathPaser"></a>XPathPaser</h3><ul>
<li>org.apache.ibatis.parsing</li>
<li>Properties variables</li>
</ul>
<h3 id="ResolverUtil"><a href="#ResolverUtil" class="headerlink" title="ResolverUtil"></a>ResolverUtil<T></h3><ul>
<li><p>org.apache.ibatis.io</p>
</li>
<li><p>定义接口及实现类，进行条件匹配。</p>
</li>
<li><p>定义classloader、matches</p>
</li>
<li><p>根据接口查询、根据注解查询、根据条件查询</p>
</li>
<li><p>解析类有多步操作，用一个属性存储之前的结果，所有操作结束后调用方法返回所有结果。</p>
</li>
<li><p>接口参数后期才能确定，直接把接口作为参数。</p>
</li>
</ul>
<h3 id="TypeAliasRegistry"><a href="#TypeAliasRegistry" class="headerlink" title="TypeAliasRegistry"></a>TypeAliasRegistry</h3><ul>
<li>org.apache.ibatis.type</li>
<li>注册别名，不是匿名类、不是接口、不是成员类</li>
<li>获取注解指定别名</li>
<li>别名转小写</li>
<li>解析别名，不存在根据字符串解析，但不存储。</li>
<li>对基础类型及常用类型的保存。</li>
<li>直接根据类注册，跳过的类类型的判断。</li>
<li>根据别名、字符串注册与其它方式注册 加载类方式不一样，一种是直接通过classloader 加载，另一种通过resource加载。</li>
</ul>
<h3 id="TypeHandlerRegistry"><a href="#TypeHandlerRegistry" class="headerlink" title="TypeHandlerRegistry"></a>TypeHandlerRegistry</h3><ul>
<li>org.apache.ibatis.type</li>
<li>register  Map&lt;Type, Map&lt;JdbcType, TypeHandler<?>>> typeHandlerMap、 Map<Class<?>, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap：<br>  第一步：<pre><code>  1. 查找MappedTypes注解，注册其每一个value。
  2. 判断是否实现TypeReference，若是，注册。
  3. 注册javaType为null。
</code></pre>
  第二步： <pre><code>  1. 查找MappedJdbcTypes注册，注册其每一个value，并判断是否也需要注册jdbcType为null。
  2. 注册jdbcType为null。
</code></pre>
  第三步：<pre><code>  1. 若javaType不为null，则添加到typeHandlerMap。
  2. 以typeHandler.getClass()为key，添加到allTypeHandlersMap。
</code></pre>
  添加方法：<pre><code>  register(TypeHandler);
  register(Class, TypeHandler);
  private register(Type, TypeHandler);  相当于第一个通用处理方法。
  register(TypeReference, TypeHandler);
  register(Class, JdbcType, TypeHandler);
  private register(Type, JdbcType, TypeHandler); 第二个通用处理方法。
  另外支持TypeHandler 以Class为参数，通过getInstence转换， jdbcType不支持String。
  支持String代替Class，通过Resource转换。
  支持包名全部注册。
</code></pre>
</li>
<li>register Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;  jdbcTypeHandlerMap： register(JdbcType, TypeHandler)。</li>
<li>TypeHandler<Object> unknownTypeHandler</li>
<li>Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler</li>
<li>getTypeHandler:</li>
</ul>
<h3 id="MapperRegistry"><a href="#MapperRegistry" class="headerlink" title="MapperRegistry"></a>MapperRegistry</h3><ul>
<li>org.apache.ibatis.binding</li>
<li>Configuration</li>
<li>Map&lt;Class<?>, MapperProxyFactory<?>&gt; knownMappers</li>
<li>addMapper(Class) 最终执行方法</li>
<li>addMappers(String packageName)</li>
<li>addMappers(String packageName, Class superType)</li>
</ul>
<h3 id="MapperProxyFactory"><a href="#MapperProxyFactory" class="headerlink" title="MapperProxyFactory"></a>MapperProxyFactory</h3><ul>
<li>org.apache.ibatis.binding</li>
<li>Class mapperInterface</li>
<li>Map&lt;Method, MapperMethodInvoker&gt; methodCache</li>
</ul>
<h3 id="XMLMapperBuilder-extends-BaseBuilder"><a href="#XMLMapperBuilder-extends-BaseBuilder" class="headerlink" title="XMLMapperBuilder extends BaseBuilder"></a>XMLMapperBuilder extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>parser</li>
<li>MapperBuilderAssistant mapperBuilderAssistant</li>
<li>sqlFragments</li>
<li>parse()</li>
</ul>
<h3 id="MapperAnnotationBuilder"><a href="#MapperAnnotationBuilder" class="headerlink" title="MapperAnnotationBuilder"></a>MapperAnnotationBuilder</h3><ul>
<li>org.apache.ibatis.builder.annotation</li>
<li>configuration</li>
<li>mapperBuilderAssistant</li>
<li>type</li>
<li>解析：<br>  解析Cache: @CacheNamespace<br>  解析CacheRef: @CacheNamespaceRef<br>  解析ResultMap: </li>
</ul>
<h3 id="MapperBuilderAssistant-extends-BaseBuilder"><a href="#MapperBuilderAssistant-extends-BaseBuilder" class="headerlink" title="MapperBuilderAssistant extends BaseBuilder"></a>MapperBuilderAssistant extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>namespace</li>
<li>resource</li>
</ul>
<h3 id="XMLStatementBuilder-extends-BaseBuilder"><a href="#XMLStatementBuilder-extends-BaseBuilder" class="headerlink" title="XMLStatementBuilder extends BaseBuilder"></a>XMLStatementBuilder extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>mapperBuilderAssistant 为XMLMapperBuilder的成员变量</li>
</ul>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li>mapper通过url、resource、class加载，且xml会加载class，class会加载xml，怎么去重<br> 所有的资源都在configuration的loadedResources中保存，加载xml其key为resource路径/url路径，加载class其key为 class.toString(), 通过class加载xml与通过xml加载class 都是通过全限定类名/namespace查询加载，其key相同，为 <code>namespace:</code> + 全限定类名。</li>
<li>加载class -&gt; 先加载xml -&gt; xml加载完查询class加载 —&gt; … 会一直加载下去么<br> class的加载，都需经过mapperRegistry的addMapper()方法， 先行存储加载的class。<br> 通过xml加载后，会根据namespace加载class，并在此判断mapperRegistry中是否已加载该class。</li>
<li>会不会加载完xml找不到对应的class，从而getMapper拿不到实体<br> xml可以加载，mapper拿不到。</li>
<li>getMapper()返回的代理类是每次创建么，如果不是，怎么保存的<br> 不是，因为每次调用的sqlSession是不同的，创建出来的代理的sqlSession为当前sqlSession。</li>
<li>mybatis获取不到接口的参数名，而只能使用param1、param2之类的<br> java在编译的时候，默认不会保留方法名参数，因此无法在运行时获取参数名称。<br> 编译时可以使用-g参数来保留方法名参数。<br> maven在编译时会默认添加-g参数，所以通过maven可以拿到具体方法名参数。</li>
<li>resultMap标签中的type、ofType、javaType、resultType<br> type: resultMap标签的属性，为类的全限定名称，表示返回的结果。<br> ofType：collection标签的属性，表示哪一种类型的集合。<br> javaType：property标签的属性，表示这个属性的类型。<br> resultType：select标签的属性。</li>
<li>XmlMapperBuilder、MapperBuilderAssistant、MapperAnnotationBuilder<br> XMLMapperBuilder、MapperAnnotationBuilder 继承自BaseBuilder，为什么AnnotationMapperBuilder没有呢？<br> XMlMapperBuilder、MapperAnnotationBuilder都定义了MapperBuilderAssistant属性，是抽象公用？<br> 因为除了AnnotationMapperBuilder，其它都是解析xml，BaseBuilder提供了将字符串解析为对象的方法，而注解可以直接使用类型定义。<br> MapperBuilderAssistant相当于工具类，且需要使用BaseBuilder的基础方法。</li>
<li>为什么XML和DAO中的ResultMap不能通用呢？<br> 注解方式ResultMap是通过 类名、方法名、方法参数 拼起来的， 可以通过@Results的id属性指定。<br> XML方式是显示id和namespace拼接的，xml的id必须指定，通过dtd约束。<br> 使用解析后的resultMapId是可以通用的。</li>
<li>MapperProxy中的MapperMethodInvoker与使用函数式接口的区别。<ol>
<li>通过接口能体现出多态的特性。</li>
<li>接口需要在其它地方引用。</li>
</ol>
</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol>
<li>MapperRegistry中config属性只为创建XmlAnnotationBuilder，没有其它使用地方。将其作为全局变量来存储，而不是方法参数带过来。</li>
</ol>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><h4 id="构建方式"><a href="#构建方式" class="headerlink" title="构建方式"></a>构建方式</h4><ol>
<li>通过xml方式<br>将配置信息放在xml中，然后通过加载xml配置文件，使用SqlSessionFactoryBuilder来创建。</li>
<li>通过java代码<br>通过DataSource、 Enverionment、 TransactionFactory、 Configuration 等类来创建。</li>
<li>通过spring<br>// TODO<br>3.1 通过xml<br>3.2 通过yml</li>
</ol>
<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><pre><code>try (SqlSession session = sqlSessionFactory.openSession()) &#123;
    ...
&#125;
</code></pre>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><pre><code>绑定映射语句的接口。
</code></pre>
<h2 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h2><ul>
<li>properties</li>
<li>settings</li>
<li>typeAliases<ol>
<li>通过typeAlia标签配置</li>
<li>通过package标签及@Alias注解（没有注解时使用Java Bean首字母小写的非限定类名）配置</li>
</ol>
</li>
<li>typeHandlers<ol>
<li>通过typeHandler标签配置</li>
<li>通过package标签</li>
</ol>
</li>
<li>objectFactory 无自动义的情况下使用默认的DefaultObjectFactory.java</li>
<li>plugins<br>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)<br>ParameterHandler (getParameterObject, setParameters)<br>ResultSetHandler (handleResultSets, handleOutputParameters)<br>StatementHandler (prepare, parameterize, batch, update, query)</li>
<li>environments<br>每个environment 包含transactionMangager 和 dataSource 配置‘<br>transactionManager 配置事务的提交和回滚规则，使用数据库提供的（type=JDBC），还是自己配置的（type=MANAGED）。</li>
<li>databaseIdProvider</li>
<li>mappers<ol>
<li>通过mapper标签，使用resource/URL/class属性。</li>
<li>通过package标签</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/2020/07/14/Mybatis/mybatis/</url>
    <content><![CDATA[<ul>
<li>mybatis 基于注解的sql可以不用写script？<br>  script 标签中可以使用xml中的标签来实现复杂语句的查询</li>
<li>mybatis 多个参数时使用@Param 注解指定？<br>  不使用@Param注解：<pre><code>  参数为基本类型，可以有多个
  参数为javabean对象，且只能有一个，使用时直接用对象的属性（注解无法获取多个属性，只能获取嵌套属性）
</code></pre>
  参数为String时，必须指定@Param注解，但是当有多个参数时，可以不用注解，猜想可能是把多个参数自动封装成一个对象了</li>
<li>mybatis 基于注解使用@ResultMap(“?”) 来使用xml中定义的reslutmap<br>  只能引用通过@Result注解定义的，并指定名称的resultmap</li>
<li>当方法传入多个参数且包含复杂对象时，使用 对象.属性 来引用，可以使用@Param起别名。如果其中有基本参数类型，直接引用即可。</li>
</ul>
<ul>
<li>读mybatis二级缓存有感<br>mybatis二级缓存使用装饰器模式实现，涉及的类有: Executor, CachingExecutor<br>装饰器模式并没有要求被装饰类和装饰器抽象出一个接口，被装饰类本身就有一个接口，装饰器类只是实现了被装饰类的接口（即如果没有装饰器类，接口的存在也没有不合适）<br>PS1： 如果被装饰类本身没有接口，这种情况（装饰器模式的意义在于动态的扩展一个对象的功能，即对功能做增强操作。一个对象的功能即行为，接口抽象的就是行为，抽象类抽象的是属性，那这时候去定义一个接口也是合适的）<br>PS2:  装饰器抽象类，这个角色是否有存在的意义。</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql 填坑</title>
    <url>/2021/06/24/Mysql/Mysql-%E5%A1%AB%E5%9D%91/</url>
    <content><![CDATA[<h2 id="mysql-left-on-where"><a href="#mysql-left-on-where" class="headerlink" title="mysql left on where"></a>mysql left on where</h2><p>过程： from + left 生成中间表 -&gt; 对中间表进行where过滤<br>on 是在生成中间表的时候的条件， 不管on后的条件是否满足，都会返回主表的所有数据<br>where 是对中间表过滤的条件</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title>spring cloud</title>
    <url>/2020/07/14/Spring/spring%20cloud/</url>
    <content><![CDATA[<ol>
<li>eureka server<br>依赖<br> spring-cloud-starter-eureka-server<br>注解<br> @EnableEurekaServer</li>
</ol>
<p>配置<br>    spirng.application.name server需要么<br>    eureka.clinet.service-url.default-zone ？？？<br>    eureka.clinet.registry-with-eureka 如果有集群，是否注册到其他eureka服务<br>    eureka.client.fetch-registry</p>
<p>自我保护模式<br>数据中心<br>环境</p>
<ol start="2">
<li>eureka clent<br>依赖<br> spring-cloud-starter-eureka<br>注解<br> @EnableEurekaClinet  只能被eureka服务中心发现<br> @EnalbeDisconveryClient  可以被其他服务注册中心发现</li>
</ol>
<p>配置<br>    spring.application.name 指定服务名称<br>    eureka.client.service-url.default-zone<br>    eureka.clent.instance.perfer-ip-address<br>    eureka.client.instance-id  指定服务实例id,默认为 主机名:服务名:端口</p>
<ol start="3">
<li>ribbon 编程式服务间调用、负载均衡<br>依赖<br> spring-cloud-starter-ribbon</li>
</ol>
<p>注解<br>    @LoadBalanced<br>    @RibbonClient</p>
<ol start="4">
<li>feign 声明式服务间调用<br>注解<br> @EnableFeignClients<br> @FeignClient</li>
</ol>
<p>配置<br>    spring.</p>
<p>feign对hystrix的支持<br>feign中callback及callbackfactory的属性设置</p>
<ol start="5">
<li><p>hystrix 熔断处理<br>@HystrixCommand</p>
</li>
<li><p>网关<br>注解<br> @EnableEuulProxy  组合注解</p>
</li>
</ol>
<p>配置<br>    zuul.routes.<em><strong>.path<br>    zuul.routes.</strong></em>.service-id/url</p>
<ol start="7">
<li>config</li>
</ol>
<ol start="8">
<li><p>sleuth 全链路追踪</p>
</li>
<li><p>log<br>ESK  ES、LogStash、Kibana</p>
</li>
</ol>
<p>turbine</p>
<p>通过在不同环境中配置 port，来启动多个spingboot实例  @Import<br>spring mvc Resolver<br>启动异步 @EnableAsync 方法使用@Async(调用方与执行方在两个service里)<br>@Transaction rollbackfor 默认为受检异常<br>starter核心 auto-configuration<br>session、Token、JWT<br>@Mappper<br>springboot parent、dependencies</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>spring-configuration</title>
    <url>/2021/09/03/Spring/spring-configuration/</url>
    <content><![CDATA[<p>spring-configuration-metadata.json<br>    提供spring configuration元数据</p>
<p>spring-boot-configuation-processor<br>    自动生成spring-configuation-processor.json文件</p>
<p>dependency optional true<br>    不传递依赖，需要使用才添加依赖</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2020/07/14/Spring/spring/</url>
    <content><![CDATA[<ul>
<li>MATE-INF<br>  spring.factories</li>
<li>profile / @  spring-boot-starter-parent<br>  手动重新引入maven依赖<br>  父级pom对所有子级生效，子级覆盖父级，子级优先级更高</li>
<li>spring-boot-devtools</li>
</ul>
<p>service实现多个接口，则用任一接口都可注入该对象</p>
<ol>
<li><p>spring IOC<br>加载</p>
<ol>
<li>加载配置文件、读取配置</li>
<li>扫描包</li>
<li>实例化、放入容器</li>
<li>自动注入<br>初始化</li>
<li>请求映射</li>
</ol>
</li>
<li><p>Spring MVC</p>
<ol>
<li><p>加载配置文件、读取配置</p>
</li>
<li><p>扫描包</p>
</li>
<li><p>实例化、放入容器</p>
</li>
<li><p>自动注入</p>
</li>
<li><p>请求映射</p>
</li>
<li><p>请求分发、参数封装、校验等</p>
</li>
</ol>
</li>
</ol>
<p>入口<br>ClassPathXmlApplicationContext<br>AnnotationConfigApplicationContext</p>
<p>注入方式</p>
<ol>
<li>@Controller @Service @Repository @Commonent</li>
<li>@Bean</li>
<li>@Import</li>
<li>FactoryBean</li>
</ol>
<p>注解驱动<br>IOC</p>
<ol>
<li><p>@Configuration<br>配置类相当于配置文件<br>@Bean相当于bean标签，返回值相当于bean标签class，方法名作为默认key，也可自定义<br>@Configuration被@Component注解，本身相当于一个bean</p>
</li>
<li><p>@ComponentScan<br>相当于&lt;context:component-scan /&gt;标签<br>includeFilters、excludeFilters 相当于标签属性  includeFilters 需要将userDefaultFilters置为false<br>@ComponentScans 配置多个<br>自定义TypeFilter<br>3.@Scope<br>Prototype(多实例)、Singleton（单例）、Request、Session<br>Singleton 容器启动会创建对象放入容器<br>Prototype 每次获取时创建新的对象、不会管理</p>
</li>
<li><p>@Lazy<br>针对单例bean，在第一次调用的时候创建并放入容器</p>
</li>
<li><p>@Conditional spring4.x新增<br>按照一定的条件进行判断，满足条件创建bean并放入容器<br>实现Condition接口</p>
</li>
<li><p>@Import<br>value为class，容器中注入该类对象，key为class全限类名<br>实现ImportSelector接口, 返回全限类名数组<br>实现ImportBeanDefinitionRegistrar接口，实现自定义注册BeanDefinition</p>
</li>
<li><p>FactoryBean 接口<br>默认获取到的是getObject返回的bean，加&amp;前缀获取本身</p>
</li>
<li><p>生命周期 自定义<br>xml配置 bean标签属性：init-method destroy-method， @Bean属性 initMethod destroyMethod<br>Bean 实现 InitalizBean、DisposingBean 接口<br>使用@PostConstruct @PreDestroy 注解<br>Bean实现BeanPostProcessor接口 spring 底层对BeanPostProcessor的使用</p>
</li>
<li><p>@Value<br>字面量<br>SPEL、 #{}<br>${} 取配置文件的值  @PropertySource/@PropertySources 指定读取的配置文件， 相当于xml中的&lt;context:property-placeholder /&gt;</p>
</li>
<li><p>自动装配<br>@Autowired 先按类型匹配，如果找到多个，按属性名为key匹配 required 属性指定是否必须<br>@Primary 按类型匹配多个时，注入@Primary注解的bean，而不使用属性名，可使用@Qualifier注入其他bean<br>@Qualifier 按类型匹配多个时，指定按照key去匹配<br>@Resource JSR250 java规范 默认按属性名称注入，可自定义key，无法和@Pramiry、@Qualifier 组合使用，没有required属性<br>@Inject JSR330 java规范 需要添加依赖 javax.inject, 和 @Autowired 规则一样，没有required属性</p>
<p>@Autowired<br>标注在方法上，spring创建容器时会调用标注了该注解的方法  可以 @Bean + 方法参数，注解可省略<br>标注在构造器上 一样  如果只有一个有参构造器，该注解可以省略<br>标注在参数 一样<br>Aware<br>创建对象的时候，调用相应的方法，实现注入<br>使用PostProcessor实现<br>@Profile spring 提供的根据当前环境，动态激活和切换一系列组件的功能<br>激活 默认为”default”<br>虚拟机 -Dspring.profiles.active=<br>代码 applicationContext.getEnvironmet.setProfile() 需要容器创建前设置</p>
</li>
</ol>
<p>AOP<br>切面、切点、通知<br><a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a> @EnableAspectJAutoProxy</p>
<ol>
<li>@Befor @After @AfterReturning @AfterThrowing @Around @PointCut @Aspect @EnableAspectJAutoProxy JointPoint必须是第一个参数</li>
<li>@EnableAspectJAutoProxy -&gt; @Import -&gt; ImportBeanDefinitionRegistrar</li>
</ol>
<p>事务<br>@Transactional <a href="tx:annotation-driver">tx:annotation-driver</a> @EnableTranscationManagement<br>配置事务管理器 PlatformTransactionManage DataSourceTransactionManager</p>
<p>事件<br>@EventListener EventListenerMethodPostPossector, 可在方法上使用<br>@Commonent  +  ApplicationListener</p>
<p>Web Sevlet3.0+以上支持注解<br>Web三大组件 Servlet Filter Listener<br>@WebSevlet<br>@WebFilter<br>@WebListener<br>@WebInitParam<br>ServletContainerInitializer<br>异步请求    支持、开启、配置</p>
<p>MVC<br>@EnableWebMvc  &lt;mvc:annotation-driver /&gt;<br>WebMvcConfigurer接口的方法相当于xml里面的mvc配置</p>
<p>过滤器、拦截器</p>
<p>refresh</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA 配置</title>
    <url>/2021/11/16/default/IDEA-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>since InteilJ IDEA 2021.2.3.</p>
</blockquote>
<h3 id="换行显示"><a href="#换行显示" class="headerlink" title="换行显示"></a>换行显示</h3><blockquote>
<p>Settings -&gt; Editor -&gt; General =&gt; Soft Wraps</p>
</blockquote>
<p>可以设置要换行显示的文件格式</p>
<h3 id="文件末尾不加空行"><a href="#文件末尾不加空行" class="headerlink" title="文件末尾不加空行"></a>文件末尾不加空行</h3><blockquote>
<p>Settings -&gt; Editor -&gt; General =&gt; On Save</p>
</blockquote>
<p>ensure every saved file ends with a line break</p>
<h3 id="side-by-side"><a href="#side-by-side" class="headerlink" title="side-by-side"></a>side-by-side</h3><blockquote>
<p>Settings -&gt; Appearance &amp; Behavior -&gt; Appearance =&gt; Tool Windows</p>
</blockquote>
<p>Side-by-side layout on the left/right<br>左上、左下/右上、右下 显示为一行两列还是两行一列</p>
<h3 id="左侧隐藏文件-文件夹"><a href="#左侧隐藏文件-文件夹" class="headerlink" title="左侧隐藏文件/文件夹"></a>左侧隐藏文件/文件夹</h3><blockquote>
<p>Settings -&gt; Editor -&gt; File Types =&gt; Ignored Files and Folders</p>
</blockquote>
<h3 id="编辑页标签"><a href="#编辑页标签" class="headerlink" title="编辑页标签"></a>编辑页标签</h3><blockquote>
<p>Settings -&gt; Editor -&gt; General -&gt; Editor Tabls</p>
</blockquote>
<p>靠右显示、按字典序、修改标记、不显示关闭标签（Shift + 左键 = 关闭）、上限50</p>
<h3 id="打开项目不打开ReadMe"><a href="#打开项目不打开ReadMe" class="headerlink" title="打开项目不打开ReadMe"></a>打开项目不打开ReadMe</h3><blockquote>
<p>Settings -&gt; Advanced Setting =&gt; Startup</p>
</blockquote>
<p>Open README.md file if there are no open files on project startup</p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>OAS</title>
    <url>/2020/07/14/default/OAS/</url>
    <content><![CDATA[<h2 id="OAS"><a href="#OAS" class="headerlink" title="OAS"></a>OAS</h2><p>OpenAPI Specification, 开放API声明，是一个API规范，用于描述一整套API接口。</p>
<h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2><p>一个流行的API框架，以OAS为基础，对整个API的开发周期都提供了相应的解决方案，几乎支持所有语言。</p>
<h2 id="springfox-swagger"><a href="#springfox-swagger" class="headerlink" title="springfox-swagger"></a>springfox-swagger</h2><p>用于将swagger集成到spring中来，前身是swagger-springmvc。生成多个json文件。</p>
<h2 id="springfox-swagger2"><a href="#springfox-swagger2" class="headerlink" title="springfox-swagger2"></a>springfox-swagger2</h2><p>生成一个json文件。</p>
<h2 id="springfox-swagger-ui"><a href="#springfox-swagger-ui" class="headerlink" title="springfox-swagger-ui"></a>springfox-swagger-ui</h2><p>页面</p>
<h2 id="springdoc-openapi"><a href="#springdoc-openapi" class="headerlink" title="springdoc-openapi"></a>springdoc-openapi</h2>]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>apache common</title>
    <url>/2020/04/05/default/apache%20common/</url>
    <content><![CDATA[<p>一、Commons BeanUtils<br>说明：针对Bean的一个工具集。由于Bean往往是有一堆get和set组成，所以BeanUtils也是在此基础上进行一些包装。 </p>
<p>二、Commons CLI<br>说明：这是一个处理命令的工具。比如main方法输入的string[]需要解析。你可以预先定义好参数的规则，然后就可以调用CLI来解析。 </p>
<p>三、Commons Codec<br>说明：这个工具是用来编码和解码的，包括Base64，URL，Soundx等等。用这个工具的人应该很清楚这些，我就不多介绍了。 </p>
<p>四、Commons Collections<br>说明：你可以把这个工具看成是java.util的扩展。 </p>
<p>五、Commons Configuration<br>说明：这个工具是用来帮助处理配置文件的，支持很多种存储方式 </p>
<p>六、Commons DBCP<br>说明：Database Connection pool, Tomcat就是用的这个，不用我多说了吧，要用的自己去网站上看说明。 </p>
<p>七、Commons DbUtils<br>说明：我以前在写数据库程序的时候，往往把数据库操作单独做一个包。DbUtils就是这样一个工具，以后开发不用再重复这样的工作了。值得一体的是，这个工具并不是现在流行的OR-Mapping工具（比如Hibernate），只是简化数据库操作，比如 </p>
<p>八、Commons HttpClient<br>说明：这个工具可以方便通过编程的方式去访问网站。 </p>
<p>九、Commons IO<br>说明：可以看成是java.io的扩展，我觉得用起来非常方便。 </p>
<p>十、Commons JXPath<br>说明：Xpath你知道吧，那么JXpath就是基于Java对象的Xpath，也就是用Xpath对Java对象进行查询。这个东西还是很有想像力的。 </p>
<p>十一、Commons Lang<br>说明：这个工具包可以看成是对java.lang的扩展。提供了诸如StringUtils, StringEscapeUtils, RandomStringUtils, Tokenizer, WordUtils等工具类。 </p>
<p>十二、Commons Logging<br>说明：你知道Log4j吗？ </p>
<p>十三、Commons Math<br>说明：看名字你就应该知道这个包是用来干嘛的了吧。这个包提供的功能有些和Commons Lang重复了，但是这个包更专注于做数学工具，功能更强大。 </p>
<p>十四、Commons Net<br>说明：这个包还是很实用的，封装了很多网络协议。 </p>
<ol>
<li>FTP </li>
<li>NNTP </li>
<li>SMTP </li>
<li>POP3 </li>
<li>Telnet </li>
<li>TFTP </li>
<li>Finger </li>
<li>Whois </li>
<li>rexec/rcmd/rlogin </li>
<li>Time (rdate) and Daytime </li>
<li>Echo </li>
<li>Discard </li>
<li>NTP/SNTP </li>
</ol>
<p>十五、Commons Validator<br>说明：用来帮助进行验证的工具。比如验证Email字符串，日期字符串等是否合法。 </p>
<p>十六、Commons Virtual File System<br>说明：提供对各种资源的访问接口。支持的资源类型包括 </p>
<ol>
<li>CIFS </li>
<li>FTP </li>
<li>Local Files </li>
<li>HTTP and HTTPS </li>
<li>SFTP </li>
<li>Temporary Files </li>
<li>WebDAV </li>
<li>Zip, Jar and Tar (uncompressed, tgz or tbz2) </li>
<li>gzip and bzip2 </li>
<li>res </li>
<li>ram<br>这个包的功能很强大，极大的简化了程序对资源的访问。 </li>
</ol>
<p>十七、Commons Transaction<br>说明：提供持久层事务支持 </p>
<p>十六、Commons Proxy<br>说明： 动态代理，拦截器一类的东西 </p>
<p>十八、Commons pool<br>说明： 创建新的对象并初始化的操作，可能会消耗很多的时间。<br>在需要频繁创建并使用这些对象的场景中，为了提供系统性能，通常的做法是，创建一个对象池，将一定数量的对象缓存到这个对象池中。<br>需要使用时直接从对象池中取出对象，使用完后将对象扔回到对象池中即可。<br>Apache的commons pool组件是我们实现对象池化技术的良好助手。 </p>
<p>十九、Commons Launcher<br>说明：创建跨平台可执行程序 </p>
<p>二十、Commons Bean Scripting Framework（BSF）<br>说明：是一个支持在Java应用程序内调用脚本语言 (Script)，并且支持脚本语言直接访问Java对象和方法的一个开源项目。有了它 , 你就能在java application中使用javascript, Python, XSLT, Perl, tcl, ……等一大堆scripting language<br>. 反过来也可以，就是在这些scripting language中调用任何已经注册过了的JavaBean,java object。它提供了完整的API实现通过Java访问脚本语言的引擎。 </p>
<p>二十一、Commons chain<br>说明： 可以在你需要定义和执行一些顺序操作的时候采用Commons Chain。 </p>
<p>二十二、Commons Compress<br>说明： 是一个压缩、解压缩文件的类库。可以操作ar, cpio, Unix dump, tar, zip, gzip, XZ, Pack200 and bzip2格式的文件，功能比较强大 </p>
<p>二十三、Commons Discovery<br>说明： 组件被用以查找可插拔接口的实现实例，它提供了一种通用的实例化这些实现的方式，而且可以管理单例（工厂）的生命周期。 </p>
<p>二十四、 commons exec<br>说明： Apache Commons Exec 是 Apache 上的一个 Java 项目，提供一些常用的方法用来执行外部进程，如下面代码所示： </p>
<p>String line = &quot;AcroRd32.exe /p /h &quot; + file.getAbsolutePath();<br>CommandLine commandLine = CommandLine.parse(line);<br>DefaultExecutor executor = new DefaultExecutor();<br>executor.setExitValue(1);<br>ExecuteWatchdog watchdog = new ExecuteWatchdog(60000);<br>executor.setWatchdog(watchdog);<br>int exitValue = executor.execute(commandLine); </p>
<p>二十五、commons jelly<br>说明：Jelly能够把XML转换成可执行代码,所以Jelly是一个基于XML与Java的脚本和处 理引擎。 Jelly借鉴了JSP定指标签，Velocity, Cocoon和Xdoclet中的脚本引擎的许多优点。Jelly可以用在命令行，Ant或者Servlet之中 </p>
<p>二十六、Commons FileUpload<br>上传下载组件 </p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2020/04/05/default/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li><p>添加远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add &lt;远程仓库名称 一般默认为origin&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>删除远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote remove &lt;远程仓库名称&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>更新/设置远程仓库地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote set-url &lt;远程仓库名称&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>添加远程仓库地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote set-url --add &lt;远程仓库名称&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>设置用户名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>设置邮箱</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>全局设置用户名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>全局设置邮箱</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>其他命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init ...</span><br><span class="line">git add ...</span><br><span class="line">git commit -m &quot;...&quot;</span><br><span class="line">git status</span><br><span class="line">git diff 文件名</span><br><span class="line">git log </span><br><span class="line">git reset --hard HEAD^ / 版本号</span><br><span class="line">git reflog </span><br><span class="line">git checkout -- 文件名</span><br><span class="line">git checkout 分支名</span><br><span class="line">git remote add origin 远程仓库路径</span><br><span class="line">git push -u origin master</span><br><span class="line">git push origin master</span><br><span class="line">git clone</span><br><span class="line">git checkout -b 分支名 = git branch 分支名 + git checkout 分支名 （创建并切换分支）</span><br><span class="line">git merge 分支名</span><br><span class="line">git branch -d</span><br><span class="line">git merge -no-ff -m</span><br><span class="line">git stash</span><br><span class="line">git stash list</span><br><span class="line">git stash apply</span><br><span class="line">git stash drop</span><br><span class="line">git stash pop</span><br><span class="line">git remote</span><br><span class="line">git remote -v</span><br><span class="line">git checkout -b 分支名 origin/分支名</span><br><span class="line">git pull</span><br><span class="line">git branch --set-upstream 分支名 origin/分支名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git init &lt;repo&gt;</span><br><span class="line">git add &lt;file&gt; [ &lt;file&gt; ... ]</span><br><span class="line">git commit -m &lt;message&gt;</span><br><span class="line">git status</span><br><span class="line">git diff &lt;file&gt;</span><br><span class="line">git log [--pretty=oneline] （提交历史）</span><br><span class="line">git reset --hard HEAD^ / HEAD~&lt;num&gt; / &lt;commit id&gt;</span><br><span class="line">git reflog （命令历史）</span><br><span class="line">git diff -- HEAD &lt;file&gt;</span><br><span class="line">git checkout -- &lt;file&gt;</span><br><span class="line">git rm &lt;file&gt;</span><br><span class="line">git remote add origin &lt;URL&gt;</span><br><span class="line">git push -u orgin &lt;branch&gt;</span><br><span class="line">git clone &lt;URL&gt;</span><br><span class="line">git checkout -b &lt;branch&gt; = git branch &lt;branch&gt; + git checkout &lt;branch&gt; = git switch - c &lt;branch&gt;</span><br><span class="line">git branch</span><br><span class="line">git checkout &lt;branch&gt;</span><br><span class="line">git merge &lt;branch&gt;</span><br><span class="line">git branch -d &lt;branch&gt;</span><br><span class="line">git switch &lt;branch&gt;</span><br><span class="line">git log --graph</span><br><span class="line">git merge --no-ff [-m &lt;message&gt;] &lt;branch&gt;</span><br><span class="line">git stash</span><br><span class="line">git stash list</span><br><span class="line">git stash apply</span><br><span class="line">git stash drop</span><br><span class="line">git stash pop</span><br><span class="line">git stash apply stash@&#123;&lt;num&gt;&#125;</span><br><span class="line">git cherry-pick &lt;commit id&gt;</span><br><span class="line">git branch -D &lt;branch&gt;</span><br><span class="line">git remote</span><br><span class="line">git remote -v</span><br><span class="line">git checkout -b &lt;branch&gt; origin/&lt;branch&gt;</span><br><span class="line">git pull</span><br><span class="line">git branch --set-upstream &lt;branch&gt; origin/&lt;branch&gt;</span><br><span class="line">git rebase</span><br><span class="line">git tag &lt;tag&gt;</span><br><span class="line">git tag</span><br><span class="line">git tag &lt;tag&gt; &lt;commit id&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>websocket</title>
    <url>/2020/04/05/default/websocket/</url>
    <content><![CDATA[<ul>
<li>socket 与 websocket<br>socket 网络层的抽象接口，用来实现计算机之间的通信。不同的操作系统做了不同的实现。<br>java中的socket与serverSocket应该是对操作系统的实现做了封装。<br>WebSocket是应用层协议，基于http，全双工通信模式，用来实现浏览器和服务器的长连接。</li>
</ul>
<p>背景<br>    后端： spring boot + websocket<br>    前端： vue + websocket + stomp</p>
<p>心跳配置<br>    后端： [n1, n2]<br>        n1表示 后端给前端发送ping的间隔<br>        n2表示 前端应该给后端发送ping的间隔<br>    前端： [m1, m2]<br>        m1表示 前端发送给后端ping的间隔<br>        m2表示 前端检查后端消息发送的间隔</p>
<p>心跳frame<br>    心跳帧的数据为 0x0A(\n)</p>
<p>解释<br>    心跳要客户端和服务端都要接收和发送数据，否则心跳不能维持，必须保证四个数字都不能为0。<br>    前端发送ping，间隔取 n2,m1 最大值，打印为ping<br>    后端定时器间隔取 n1,n2 最小值，读间隔取 m1,n2 最大值 乘3, 写间隔取 m2, n1 最大值，定时器执行，lastWriteTime为上次发送消息的时间（只有发送Message才会更新），lastReadTime为接收消息的时间<br>    前端检验间隔取 n1,m2 最大值<br>    前端接收后端发送心跳，打印为pong</p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>xml</title>
    <url>/2020/07/14/default/xml/</url>
    <content><![CDATA[<h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><pre><code>xmlns:
    定义标签，定义默认命名空间。
    命名空间可防止在任何元素的开始标签上。
xmlsns:xsi
    xml schema instance
    使用dtd实现，用来描述xsd。
    业界默认使用&quot;http://www.w3.org/2001/XMLSchema-instance&quot;。
xsi:schemaLocation
    指定xsd文件的位置。
    形式为“key value”，中间用空格分开，key为命名空间的值，value为xsd文件的位置。
</code></pre>
<h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h2><pre><code>document type definition
验证xml文件的规范性。
可内部定义，也可外部引入，也可内外结合。外部引入分为私有（SYSTEM）和公共（PUBLIC）。
</code></pre>
<h2 id="XSD"><a href="#XSD" class="headerlink" title="XSD"></a>XSD</h2><pre><code>xml schema definition
基于XML的DTD代替者。
</code></pre>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/2021/11/11/default/%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>减轻数据库的压力。</p>
<h3 id="选择考虑"><a href="#选择考虑" class="headerlink" title="选择考虑"></a>选择考虑</h3><p>本地缓存/分布式缓存。<br>轻量级<br>线程安全<br>高并发<br>过期</p>
<h2 id="成员变量、静态变量"><a href="#成员变量、静态变量" class="headerlink" title="成员变量、静态变量"></a>成员变量、静态变量</h2><p>本地缓存，性能一般，线程不安全，可以配合线程池实现过期。</p>
<h2 id="guavaCache"><a href="#guavaCache" class="headerlink" title="guavaCache"></a>guavaCache</h2><p>本地缓存，性能高，轻量级，线程安全，支持高并发，一个实例过期时间只能配置一个。</p>
<h2 id="EhCache"><a href="#EhCache" class="headerlink" title="EhCache"></a>EhCache</h2><p>hibernate 默认的缓存。</p>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>分布式缓存</p>
<h2 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h2><p>分布式缓存</p>
<h2 id="springCache"><a href="#springCache" class="headerlink" title="springCache"></a>springCache</h2><p>对缓存使用的抽象。</p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>项目分层</title>
    <url>/2020/09/04/default/%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B1%82/</url>
    <content><![CDATA[<h2 id="项目分层"><a href="#项目分层" class="headerlink" title="项目分层"></a>项目分层</h2><ul>
<li>阿里规约</li>
</ul>
<p><img src="/images/pasted-5.png" alt="upload successful"></p>
<ul>
<li>终端显示层<br>前端、JSP</li>
<li>开放接口<br>RPC接口、http接口</li>
<li>web层<br>负责请求转发、基本参数校验</li>
<li>service层<br>负责具体的业务逻辑处理、复用性低</li>
<li>manager层  <br>通用业务处理。可以是 1.第三方接口的封装。2.service层的通用业务。3.dao层的组合服用。</li>
<li>dao层  <br>数据访问</li>
</ul>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>Session、Cookie、Token、JWT</title>
    <url>/2020/09/11/web/Session%E3%80%81Cookie%E3%80%81Token%E3%80%81JWT/</url>
    <content><![CDATA[<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>会话，在服务端保存用户信息。</p>
<h3 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>服务器保存用户信息，导致session占据过多的内存。</li>
<li>网站采用集群部署，需要考虑session共享的问题。</li>
<li>多个应用共享session时，需要考虑蛞蝓问题。</li>
<li>如果交由cookie处理，需要考虑浏览器禁止cookie或不支持cookie的问题。</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>浏览器实现的一种数据存储功能。在客户端保存信息。</p>
<h3 id="填坑-1"><a href="#填坑-1" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>移动端对cookie支持不是很好。</li>
<li>容易被篡改，需要验证。</li>
<li>存储大小限制。</li>
<li>存储个数限制。</li>
<li>无法跨域。</li>
</ul>
<h2 id="Cookie-VS-Session"><a href="#Cookie-VS-Session" class="headerlink" title="Cookie VS Session"></a>Cookie VS Session</h2><ul>
<li>安全性</li>
<li>存取值的类型</li>
<li>有效期</li>
<li>存储大小</li>
</ul>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>令牌。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>用户通过用户名密码</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>无状态 （负载均衡器可以将请求转发到任意服务器）</li>
<li>可扩展 （可以扩展为第三方应用程序）</li>
<li>安全性 （可以蛞蝓）</li>
</ul>
<h3 id="填坑-2"><a href="#填坑-2" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>需要加密。</li>
<li>token传输方式。（header、payload、url）</li>
</ul>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>Json Web Token 是一个轻量级的认证规范，这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。其本质是一个token，是一种紧凑的URL安全方法，用于在网络通信的双方之间传递。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Header.Payload.Signature</p>
<h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><p>JSON对象，描述JWT的元数据。</p>
<h5 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h5><p>实际需要传递的数据。JWT官方规定了7个字段，供选用。</p>
<table>
<thead>
<tr>
<th>name</th>
<th></th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>iss</td>
<td>issuer</td>
<td>签发人</td>
</tr>
<tr>
<td>exp</td>
<td>expiration time</td>
<td>过期时间</td>
</tr>
<tr>
<td>sub</td>
<td>subject</td>
<td>主题</td>
</tr>
<tr>
<td>aud</td>
<td>audience</td>
<td>受众</td>
</tr>
<tr>
<td>nbf</td>
<td>not before</td>
<td>生效时间</td>
</tr>
<tr>
<td>iat</td>
<td>issued at</td>
<td>签发时间</td>
</tr>
<tr>
<td>jti</td>
<td>jwt id</td>
<td>编号</td>
</tr>
</tbody></table>
<h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>对前两部分的签名，防止数据篡改。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>对于SSO来说，每个系统都需要去CAS系统认证，如果使用jwt的话，可以通过算法来验签，而不需要通过数据库或者http接口验证。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>web发展</title>
    <url>/2020/09/11/web/web%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ol>
<li>web项目<ol>
<li>创建空项目，创建对应的文件夹，如果选择ide创建，则会默认创建文件夹，及选择的web版本。</li>
<li>配置文件编译输出位置，及编译输出目录，归档方式<br>exploded 文件夹<br>archive war包形式</li>
<li>配置运行环境，即tomcat，配置发布方式，发布路径。<br>端口配置和访问路径是怎么生效的呢？？？</li>
<li>静态文件是热加载，改动java文件需要重启服务。</li>
<li>添加需要的jar包。</li>
<li>servlet2.x 规范： web.xml WEB-INF classes lib</li>
<li>必要时需要tomcat配置（如端口）。IDE怎么实现界面配置改的端口。</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>model1模式<br>jsp + javabean</p>
</li>
<li><p>model2模式 （MVC）<br>jsp + servlet + javabean</p>
</li>
<li><p>maven，项目管理工具<br>通过maven，可以优化项目创建目录，打包方式，jar包管理。</p>
</li>
<li><p>servlet3.0规范<br>基于注解， 省略web.xml</p>
</li>
<li><p>maven tomcat 插件</p>
</li>
</ol>
<p>web.xml  serlvet 规范？？？</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>Heox文章规范</title>
    <url>/2020/07/15/%E5%85%83/Heox%E6%96%87%E7%AB%A0%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<blockquote>
<p>在此列举出一些规则，之后编写文章时都应遵循这些规则。该规则逐渐丰富。</p>
</blockquote>
<ul>
<li>文章最高使用二级标题，逐级递减，不适用一级标题。</li>
<li>文章添加分类，根据Hexo的描述，使用二级分类。</li>
</ul>
<p><img src="/images/pasted-0.png" alt="upload successful"></p>
<ul>
<li>缩进，还没有找到好的缩进方式。</li>
</ul>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 缺点</title>
    <url>/2021/06/24/%E5%85%83/Hexo-%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h2 id="分类-标签"><a href="#分类-标签" class="headerlink" title="分类/标签"></a>分类/标签</h2><p>每篇文章的分类、标签都是输入的，而不是选择的，导致后面会忘记前期添加过哪些数据。</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>用markdown的表格做数据很别扭，没有直接用表单，来生成表格来的舒服。</p>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/2020/03/28/%E5%85%83/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h1><blockquote>
<p>GitHub Pages 允许开发者自定义项目的首页，代替直接展示代码的方式。</p>
</blockquote>
<h2 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h2><blockquote>
<p>GitHub Pages 默认的静态网站生成工具，通过项目中的相应的配置文件，可以自动打包部署。</p>
</blockquote>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><blockquote>
<p>静态网站生成工具，可以通过配置使GitHub支持。</p>
</blockquote>
<h2 id="Jekyll-VS-Hexo"><a href="#Jekyll-VS-Hexo" class="headerlink" title="Jekyll VS Hexo"></a>Jekyll VS Hexo</h2><ul>
<li>本地开发预览<blockquote>
<p>Jekyll 需要搭建完整的Ruby环境。<br>Hexo 需要搭建NodeJS环境。</p>
</blockquote>
</li>
<li>迁移<blockquote>
<p>GitHub Pages中对Jekyll的支持，使得我们太多去关心Jekyll的配置以及插件，这会在迁移过程中造成一定的影响。因为不知道配置是什么，及使用了哪些插件。<br>Hexo的配置是自定义的。  </p>
</blockquote>
<h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><blockquote>
<p>由于GitHub访问速度问题，也可使用Gitee Pages功能，其概念和GitHub概念相似。  </p>
</blockquote>
<h3 id="GitHub-Pages-VS-Gitee-Pages"><a href="#GitHub-Pages-VS-Gitee-Pages" class="headerlink" title="GitHub Pages VS Gitee Pages"></a>GitHub Pages VS Gitee Pages</h3><blockquote>
<p>Gitee 支持Jekyll、Hexo、Hugo，GitHub只支持Jekyll。<br>GitHub 支持自动打包部署，检测到代码提交时执行。Gitee个人免费版不知道自动打包部署，需要手动进行。<br>GitHub 支持自定义域名。Gitee个人免费版不支持。<br>GitHub 只支持master、gh-pages分支，当使用根路径访问时只支持master分支。Gitee支持任意分支。</p>
</blockquote>
<h2 id="自动打包部署"><a href="#自动打包部署" class="headerlink" title="自动打包部署"></a>自动打包部署</h2><blockquote>
<p>对于支持自动打包部署的情况，只需要提交源码到对应的分支就行，会自动打包并部署。<br>而不支持自动打包部署的情况，需要在本地通过命令生成部署到对应的分支。而将源码提交到另一个分支。</p>
</blockquote>
</li>
</ul>
<h1 id="Hexo-搭建过程"><a href="#Hexo-搭建过程" class="headerlink" title="Hexo 搭建过程"></a>Hexo 搭建过程</h1><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><blockquote>
<p>hexo init命令需要空文件夹，git clone会生成一个不为空的文件夹，所以创建过程中需要按以下步骤进行。</p>
</blockquote>
<ol>
<li>初始化hexo项目<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hexo init &lt;dir name&gt;</span><br></pre></td></tr></table></figure>
PS: 如不指定目录名称，则在当前文件夹下初始化，要求该文件夹为空。</li>
<li>初始化git仓库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li>关联远程仓库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><blockquote>
<p>项目目录下的_config.yml为站点配置文件，themes/?/_config.yml为主题配置文件。将主题文件复制到source/_data/next.yml进行修改。</p>
</blockquote>
<ol>
<li>网站配置<br>其中 language为主题要求的值。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">&lt;title&gt;</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&lt;subtitle&gt;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&lt;description&gt;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&lt;keywords&gt;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">&lt;author&gt;</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/shanghai</span></span><br></pre></td></tr></table></figure></li>
<li>URL 配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">&lt;url&gt;</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year:month/:category/:post_title/</span></span><br></pre></td></tr></table></figure></li>
<li>发布配置<br>可配置多个<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;url&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li>
<li>主题配置<br>使用最新NexT主题<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure></li>
<li>CNAME配置<br>如需自定义域名，且手动打包部署，则CNAME配置应跳过渲染。相对路径为source。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">CNAME</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><ol>
<li>菜单配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure></li>
<li>样式配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure></li>
<li>pjax配置<br>页面局部刷新功能<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
添加依赖<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pjax themes/next/source/lib/pjax</span><br></pre></td></tr></table></figure></li>
<li>其他配置<br>每个配置的地方都有注释说明。</li>
</ol>
<ul>
<li>图标 favicon</li>
<li>头像 avatar</li>
<li>代码高亮样式 highlight_theme</li>
<li>局部页面刷新 pjax</li>
<li>中英文之间空格 pangu</li>
<li>阅读进度条 reading_progress</li>
<li>github_banner</li>
<li>书签 bookmark</li>
<li>评论 gitalk</li>
<li>公式 math</li>
<li>搜索 search</li>
<li>RSS</li>
<li>捐赠 reward</li>
</ul>
<h1 id="文章与页面"><a href="#文章与页面" class="headerlink" title="文章与页面"></a>文章与页面</h1><ol>
<li>新建文章<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
layout为scaffolds中定义的模板，默认为post</li>
<li>新建页面<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page archives/categories/tags/about</span><br></pre></td></tr></table></figure>
在各自index.md中修改其type为主题菜单配置中名称，除about外，其它都不需要编辑。</li>
<li>搜索页面<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-gengerator-searchdb</span><br></pre></td></tr></table></figure>
站点配置中新增<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">    <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
主题配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>404页面</li>
</ol>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo admin后台管理</title>
    <url>/2020/07/15/%E5%85%83/hexo-admin%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>使用hexo搭建博客之后，通过在编辑器里面来记录文章总归不是一个好的方式，而hexo admin提供了后台管理的页面来通过页面管理文章。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-admin</span><br></pre></td></tr></table></figure>
<p>安装好之后会在根目录下生成一个配置文件，该配置文件可以保存页面settings中的配置。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>管理页面中deploy功能需要添加配置。</p>
<ol>
<li>在_config.yml 中添加amdin发布命令的脚本路径。</li>
<li>创建脚本文件。</li>
</ol>
<p>PS: 该功能没有实现 </p>
<h2 id="线上"><a href="#线上" class="headerlink" title="线上"></a>线上</h2><p>github Pages是静态网站，不支持。支持其它动态的服务器。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>hexo admin 可以在编辑器内复制图片，图片将保存在images文件夹下，可自定义。<br>windows复制的图片需要去掉...\。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol>
<li>Posts页面没有分类，所有文章放在一起，看起来比较乱。</li>
<li>新建文章能否按照分类按文件夹存放。</li>
<li>添加分类和标签时只能输入，不能选择。</li>
<li>不能编辑文章的描述，该描述影响列表页面的内容。</li>
</ol>
<p>PS：<br>（1）. 可以在文章编辑界面上方修改文章路径。<br>（2）. 可以在_config.yml中添加 metadata - description 支持。</p>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>语法</title>
    <url>/2021/11/11/%E5%85%83/%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li>标题、列表 下一行前面不要空格<blockquote>
<p>示例</p>
<blockquote>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p> 有空格</p>
</blockquote>
</blockquote>
</li>
</ol>
<blockquote>
<blockquote>
<h4 id="标题-1"><a href="#标题-1" class="headerlink" title="标题"></a>标题</h4><p>没有空格</p>
</blockquote>
</blockquote>
<ol start="2">
<li>列表完了之后要空一行</li>
</ol>
<blockquote>
<p>示例</p>
<blockquote>
<ul>
<li>aaa<br>123123</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>aaa</li>
</ul>
</blockquote>
</blockquote>
<p>123123</p>
<blockquote>
<blockquote>
<ul>
<li>ccc</li>
</ul>
</blockquote>
</blockquote>
<ol start="3">
<li>列表嵌套<br>子列表前面加四个空格</li>
</ol>
<blockquote>
<p>示例</p>
<blockquote>
<ul>
<li>1 - 1<ul>
<li>1 - 2 - 1</li>
<li>1 - 2 - 2</li>
</ul>
</li>
<li>1 - 2</li>
</ul>
</blockquote>
</blockquote>
<ol start="4">
<li>段落 使用空行<blockquote>
<p>示例<br>1 - 1<br>1 - 2</p>
<p>2 - 1</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>计算机求解任何问题都离不开程序设计，而程序设计的实质是数据表示和数据处理，数据表示的核心是数据结构，数据处理的核心是算法。所以 程序 = 数据结构 + 算法。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>数据<br>信息的载体，在计算机科学中指所有能输入到计算机中并能被计算机程序识别和处理的符号集合。</li>
<li>数据元素<br>数据的基本单位，通常作为一个整体进行考虑和处理。</li>
<li>数据项<br>数据元素中不可分割的最小单位。</li>
<li>数据结构<br>相互之间存在一种或多种特定关系的数据元素的集合。<ul>
<li>逻辑结构<br>指数据元素之间逻辑关系的整体。面向要解决的问题。</li>
<li>物理结构<br>又称为存储结构，是数据的逻辑结构在计算机中的表示。面向计算机。</li>
</ul>
</li>
<li>结构<br>数据元素相互之间的关系称为结构。</li>
<li>元素/结点<br>数据元素在计算机中的映像。</li>
<li>数据类型<br>一组值的集合以及定义于这个值集上的一组操作的总称。</li>
<li>抽象数据类型（ADT）<br>是一个数据结构以及定义在该结构上的一组操作的总称。<ul>
<li>原子类型<br>变量的值是不可分解的。</li>
<li>固定聚合类型<br>值由确定数目的成分按某种结构组成。</li>
<li>可变聚合类型<br>值由不确定数目的成分按某种结构组成。</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构。<br>数据结构通常指数据的逻辑结构。</p>
<p>逻辑结构根据数据元素之间关系的不同特性分类：</p>
<ul>
<li>集合： 数据元素之间属于同一个集合。</li>
<li>线性结构： 数据元素之间存在一对一的线性关系。</li>
<li>树形结构： 数据元素之间存在一对多的层次关系。</li>
<li>图状结构： 数据元素之间存在多对多的任意关系。</li>
</ul>
<p>集合是数据元素之间关系极为松散的一种结构，因此也可以用其它结构来表示它。</p>
<p>根据数据元素之间关系的不同表示方法，顺序映象和非顺序映象，得到两种不同的存储结构：顺序存储结构和链式存储结构。<br>顺序存储结构： 把逻辑上相邻的结点存储在物理位置相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现。 通常借助数组来实现。<br>链式存储结构： 结点间的关系由附加的指针字段来表示。 通常借助指针来实现。</p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>抽象数据类型和数据类型实质上是一个概念。抽象的意义在于数据类型的数学抽象特性，且抽象数据类型的范畴更长，不局限于处理器已定义并实现的数据类型。<br>抽象数据类型通常包含定义、表示和实现3个部分。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>解决问题的方法或过程。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>输入</li>
<li>输出</li>
<li>有限行</li>
<li>确定性</li>
<li>可行性</li>
</ul>
<h3 id="算法与程序"><a href="#算法与程序" class="headerlink" title="算法与程序"></a>算法与程序</h3><p>程序是对一个算法使用某种程序设计语言的具体实现。算法可用任何一种程序设计语言实现。并不是所有的程序都是算法（有限性）。</p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ul>
<li>分治法</li>
<li>动态规划</li>
<li>贪心算法</li>
<li>回溯法</li>
<li>分支限界法</li>
</ul>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>计算机中最重要的资源是时间资源和空间资源，其概念类同，计量方法相似，且空间复杂性分析相对简单，所以更注重时间算法复杂性的分析。<br>通常有三种情况：最好情况、最坏情况、平均情况。使用O表示。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-二叉排序树</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8810%EF%BC%89-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<p>二叉排序树（Binary Sort Tree）, 又称二叉搜索/查找树（Binary Search Tree）。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ol>
<li>左子树上所有结点的值小于[等于]它根节点的值。</li>
<li>右子树上所有结点的值大于[等于]它根节点的值。</li>
<li>左右子树也均是二叉排序树。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>查找<br>平均查找长度： 每个结点的深度的总和/总结点数。</li>
<li>插入<br>新插入的结点一定是一个新添加的叶子结点，并且时查找不成功时查找路径上访问的最后一个结点的子结点。</li>
<li>删除<ol>
<li>删除结点为叶子结点，直接删除</li>
<li>删除结点只有一个孩子结点，则继承给删除结点的父节点。</li>
<li>删除结点有两个孩子结点。<br>1.</li>
</ol>
</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="平衡二叉搜索树（AVL）"><a href="#平衡二叉搜索树（AVL）" class="headerlink" title="平衡二叉搜索树（AVL）"></a>平衡二叉搜索树（AVL）</h3><p>每个结点的左右子树的高度差绝对值最多为1。</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li>LL 右旋</li>
<li>RR 左旋</li>
<li>LR 左旋 -&gt; LL 右旋</li>
<li>RL 右旋 -&gt; RR 左旋</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入为叶子结点，向上旋转。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>向下旋转为叶子结点, 删除。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>结点是红色或者黑色。</li>
<li>根节点是黑色。</li>
<li>所有叶子结点都是黑色（叶子结点是Null结点）。</li>
<li>每个红色结点的两个叶子结点都是黑色（路径中不能有两个连续的红色结点）。</li>
<li>从任一结点到其每个叶子结点的路径都包含相同数目的黑色结点。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-哈希表</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8811%EF%BC%89-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表，将关键码映射为散列表中适当存储位置的函数称为散列函数，所得的存储位置称为散列地址。</p>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>H(key) = a * key + b (a、b为常熟)<br>特点： 单调、均匀、不会产生冲突。<br>适用于事先知道关键码的分布，且关键码集合不是很大且连续性较好的情况。</p>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>H(key) = key % p (p为某个适当的正整数)<br>最简单、最常用的构造散列函数的方法，且不要求事先知道关键码的分布。</p>
<h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p>根据关键码在各个位上的分布情况，选取分布比较均匀的若干位组成散列地址。<br>适用于事先知道关键码的分布且关键码中有若干位分布较均匀的情况。</p>
<h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>对关键码平方后，按散列表大小，取中间的若干位作为散列地址。<br>通常用在事先不知道关键码的分布且关键码的位数不是很大的情况。</p>
<h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>将关键码从左到右分割称位数相等的几部分，然后叠加求和，取后几位作为散列地址。<br>叠加方法：<br>    移位叠加： 将各部分的最后一位对齐相加。<br>    间界叠加： 从一端向另一端沿各部分分界来回折叠后，最后一位对齐相加。<br>适用于关键码的位数很多，且关键码的每一位分布都不均匀的情况。事先不需要知道关键码的分布。</p>
<h2 id="处理冲突方法"><a href="#处理冲突方法" class="headerlink" title="处理冲突方法"></a>处理冲突方法</h2><h3 id="开放定址法-（闭散列表）"><a href="#开放定址法-（闭散列表）" class="headerlink" title="开放定址法 （闭散列表）"></a>开放定址法 （闭散列表）</h3><p>关键码得到的散列地址一旦产生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>
<ul>
<li>线性探测法<br>  从冲突位置的下一个位置起，依次寻找空的散列地址。 Hi = (H(key) + di) % m</li>
<li>二次探测法</li>
<li>随机探测法</li>
</ul>
<h3 id="拉链法-（开散列表）"><a href="#拉链法-（开散列表）" class="headerlink" title="拉链法 （开散列表）"></a>拉链法 （开散列表）</h3><p>将所有散列地址相同的记录存储在一个单链表中，称为同义词子表，在散列表中存储的是所有同义词子表的头指针。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="拉链哈希表"><a href="#拉链哈希表" class="headerlink" title="拉链哈希表"></a>拉链哈希表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class HashTable&lt;E&gt; &#123;</span><br><span class="line">    Node[] tables;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-堆</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8812%EF%BC%89-%E5%A0%86/</url>
    <content><![CDATA[<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li>完全二叉树。</li>
<li>每个结点的值都小于或等于其左右孩子结点的值（小根堆）。</li>
<li>每个结点的值都大于或等于其左右孩子结点的值（大根堆）。</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>优先队列<br>在优先队列中，元素被赋予优先级。<br>当访问元素时，具有最高优先级的元素最先出队。<br>通常采用堆数据结构来实现。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-B-树</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8813%EF%BC%89-B-%E6%A0%91/</url>
    <content><![CDATA[<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ol>
<li>所有的叶子结点都出现在同一层，并且不带信息。叶子结点的双亲称为终端结点。</li>
<li>树中每个系结点至多有m棵子树。</li>
<li>若根节点不是终端结点，则至少有两棵子树。</li>
<li>除根结点之外的所有非终端结点至少有 m/2 棵子树。</li>
<li>所有的非终端结点都包含数据。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>查找</li>
<li>插入</li>
<li>删除</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>3阶的B-树。</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>一个结点包含一个或者两个关键码。</li>
<li>每个内部结点有2个孩子（包含一个关键码）或3个孩子（包含两个关键码）。</li>
<li>所有叶子结点都在树的同一层。</li>
</ol>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>查找从根节点开始，如果根节点不包含被查找的关键码k，那么查找就在可能包含关键码k的子树中继续进行。存储在根节点中的关键码确定哪一个子树是正确的子树。</p>
<h3 id="2-3-4"><a href="#2-3-4" class="headerlink" title="2-3-4"></a>2-3-4</h3><p>2-3-4 树是4阶的B-树。</p>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ol>
<li>2结点包含一个元素和两个儿子。</li>
<li>3结点包含两个元素和三个儿子。</li>
<li>4结点包含三个元素和四个儿子。</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h4><p>1，具有m棵子树的结点含有m个关键码，即每一个关键码对应一颗子树。<br>2. 关键码Ki是它所对应的子树的根节点中最大/最小的关键码。<br>3. 所有的终端结点包含了全部的关键码信息，以及指向关键码记录的指针。<br>4. 各终端结点按关键码的大小次序链在一起，形成单链表，并设置头指针。</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><p>B*树是B+树的变体，在B+树的非根结点和非叶子结点在添加指向兄弟的指针。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-线性表</title>
    <url>/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%881%EF%BC%89-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>线性表是线性结构的典型代表。是一种最基本、最简单的数据结构，数据元素直接仅具有单一的前驱和后继关系。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>是n（n&gt;=0）个具有相同类型的数据元素的有限序列。<br>相邻两个元素之间存在序偶关系。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>返回长度</li>
<li>获取指定位置元素</li>
<li>返回第一个匹配的元素</li>
<li>获取前驱</li>
<li>获取后继</li>
<li>在指定位置插入元素</li>
<li>删除指定位置的元素</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>用一段地址连续的存储单元一次存储线性表的数据元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要确定数组的长度，来分配固定长度的数组空间。<br>只要确定了存储顺序的起始地址，计算任一元素的存储地址时间是相等的。</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>用指针将存储线性表中数据元素的结点串联起来。只包含后继结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; head;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果以Node来实现链表，则需要一个空头结点。如果以List来实现，则List本身充当了空头节点，且可以添加其它属性。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul>
<li>头插法 在链表头部插入元素</li>
<li>尾插法 在链表尾部插入元素</li>
</ul>
<h3 id="循环列表"><a href="#循环列表" class="headerlink" title="循环列表"></a>循环列表</h3><p>将尾结点的后继指向头结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; head;</span><br><span class="line">    Node&lt;E&gt; last;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>包含前驱结点和后继结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; head;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序表VS链表"><a href="#顺序表VS链表" class="headerlink" title="顺序表VS链表"></a>顺序表VS链表</h3><ul>
<li>时间性能<br>顺序表： 随机访问快<br>链表： 插入和删除快</li>
<li>空间性能<br>顺序表： 需要预先分配一定长度的储存空间。<br>链表： 不需要预分配空间。</li>
</ul>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>用数组来表示单链表，用数组元素的下标来模拟单链表的指针。<br>由于它是利用数组定义的，属于静态存储分配，因此叫做静态链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node[] elements;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        int cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入和删除时只需修改游标（cur），但是没有解决存储分配带来的表长难以确定问题。</p>
<h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>将数组和指针结合起来，将数组中存储数据元素的单元改为存储指向该元素的指针。</p>
<p>保持了顺序表随机存取的优点，改进了插入和删除操作的时间性能，但是没有解决存储分配带来的表长难以确定问题。</p>
<p>Java中对象中存储的就是指针。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>线性表合并 O(m * n)<br>有序线性表合并 O(m + n)</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>大整数求和（顺序表）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-栈</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89-%E6%A0%88/</url>
    <content><![CDATA[<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>限定仅在表尾（栈顶）进行插入和删除操作的线性表。<br>具有后进先出（LIFO）的特性。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取长度</li>
<li>出栈</li>
<li>入栈</li>
<li>获取栈顶元素</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Stack&lt;E&gt; &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两栈共享空间：<br>    使用一个数组来存储两个栈，一个栈的栈底尾数组的始端，另一个栈的栈底为该数组的末端，每个栈从各自的端点向中间延伸。</p>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>通常用单链表实现。<br>使用头插法，将头指针指向栈顶元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Stack&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; node;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序栈-VS-链栈"><a href="#顺序栈-VS-链栈" class="headerlink" title="顺序栈 VS 链栈"></a>顺序栈 VS 链栈</h3><ul>
<li>时间性能<br>实现基本操作都只需要常数时间。</li>
<li>空间性能<br>顺序栈： 初始化时需要确定长度，有存储个数限制和空间浪费问题。<br>链栈： 每个元素都需要一个指针域，产生了结构性开销。</li>
</ul>
<p>使用过程中元素个数变化较大时，适合用链栈；反之，适合使用顺序栈。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>进制转换<br>表达式求值，括号匹配<br>递归</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-队列</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>只允许在一端（队头）进行插入操作，在另一端（队尾）进行删除操作的线性表。<br>具有先进先出（FIFO）的特性。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取队列长度</li>
<li>获取对头元素</li>
<li>出队</li>
<li>入队</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>可优化出队操作的开销，需要设置对头、队尾两个指针。<br>可用一个数据元素的空间，来解决队空和队满的判定。或添加一个标志。或者使用个数判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Queue&lt;E&gt; &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链队列"><a href="#单链队列" class="headerlink" title="单链队列"></a>单链队列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Queue&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; front;</span><br><span class="line">    Node&lt;E&gt; rear;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环队列-VS-链队列"><a href="#循环队列-VS-链队列" class="headerlink" title="循环队列 VS 链队列"></a>循环队列 VS 链队列</h3><ul>
<li>时间性能<br>实现基本操作都只需要常数时间O(1)。</li>
<li>空间性能<br>循环队列： 初始化时需要确定长度，有存储个数限制和空间浪费问题。<br>链队列： 每个元素都需要一个指针域，产生了结构性开销。</li>
</ul>
<p>使用过程中元素个数变化较大时，适合用链队列；反之，适合使用循环队列。</p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Queue&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; front;</span><br><span class="line">    Node&lt;E&gt; rear;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>阻塞队列<br>当队列为空时，获取元素的操作将被阻塞，直到其它线程往队列中插入新的元素。<br>当队列是满是，插入元素的操作将被阻塞，直到其它线程从队列中取出元素。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-串</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89-%E4%B8%B2/</url>
    <content><![CDATA[<p>字符串一般简称串。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>由零个或多个字符组成的有限序列。</p>
<h2 id="串VS线性表"><a href="#串VS线性表" class="headerlink" title="串VS线性表"></a>串VS线性表</h2><ul>
<li>逻辑结构： 串的数据对象约束为字符集。</li>
<li>操作： 线性表已单个元素作为操作对象，串以串的整体作为操作对象。</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>长度：串中字符的数目。<br>空串：零个字符的串<br>子串：串中任意个连续的字符组成的子序列。<br>主串：包含子串的串。<br>位置：字符在序列中的序号。<br>空格串： 由一个或多个空格组成的串。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>复制</li>
<li>判断是否为空</li>
<li>获取长度</li>
<li>拼接</li>
<li>字串</li>
<li>指定位置之后第一次出现字串的位置</li>
<li>替换</li>
<li>指定位置插入/删除</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h3><p>C中超过长度截断。Java中不允许超过已分配长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">    char[] value;</span><br><span class="line">    int length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆分配存储"><a href="#堆分配存储" class="headerlink" title="堆分配存储"></a>堆分配存储</h3><p>C中使用malloc和free控制内存，实际是基于复制实现。</p>
<h3 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h3><p>每个结点可以存放一个字符，也可以存放多个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line">    int length;</span><br><span class="line">    </span><br><span class="line">    class Node &#123;</span><br><span class="line">        char[] value;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><ul>
<li>BF算法（brute force 暴力）</li>
<li>KMP算法</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-数组</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%885%EF%BC%89-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>由类型相同的数据元素构成的有序集合，每个数据元素称为一个数组元素（简称元素），每个元素受n（n&gt;=1）个线性关系的约束，每个元素在n个线性关系中的序号称为该元素的下标，并称该数组为n维数组。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>数据元素本身可以具有某种结构，但属于同一数据类型。<br>一维数据可以看作一个线性表，二维数据可以看作线性表的线性表，以此类推。所以，数组是线性表的推广。<br>数组一般不做插入和删除操作。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>初始化</li>
<li>赋值</li>
<li>取值</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><ul>
<li>按行优先存储</li>
<li>按列优先存储</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h3><p>矩阵是很多科学与工程计算问题中的处理对象。<br>特殊矩阵： 有很多值相同的元素并且由一定的分布规律。（为多个值相同的元素只分配一个存储空间）<br>稀疏矩阵： 有很多零元素。（对零元素不分配存储空间）</p>
<h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>在一个n阶方阵中，有a<sub>ij</sub>=a<sub>ji</sub>。</p>
<h4 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h4><p>主对角线以上为常熟c，为下三角矩阵，主对角线以下为常数c，为上三角矩阵。</p>
<h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p>所有非零元素都集中在以主对角线为中心的带状区域，除了主对角线和它的上下若干条对角线的元素外，所有其它元素都为零。</p>
<h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p>零元素居多的矩阵。</p>
<ul>
<li>三元组顺序表</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>三元组-矩阵转置<br>三元组-快速转置<br>矩阵相加<br>矩阵相乘</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-广义表</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%886%EF%BC%89-%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是线性表的推广，允许元素拥有其自身结构。是一种非连续性的数据结构。<br>任何一个非空列表，其表头可能是原子，也可能是列表。其表尾一定是列表。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>原子 广义表中的单个元素。</li>
<li>子表 广义表中的广义表。</li>
<li>表头 当广义表非空时，第一个元素为表头。</li>
<li>表尾 除表头元素外，其余元素组成的表。</li>
</ul>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><ul>
<li>创建</li>
<li>复制</li>
<li>获取表的长度</li>
<li>获取表的深度</li>
<li>判断表是否为空</li>
<li>获取表头元素</li>
<li>获取表尾元素</li>
<li>插入元素</li>
<li>删除第一个元素</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>广义表中的数据元素可以拥有不同的结构，难以用顺序存储结构表示。</p>
<h3 id="头尾链表存储"><a href="#头尾链表存储" class="headerlink" title="头尾链表存储"></a>头尾链表存储</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class GList&lt;E&gt; &#123;</span><br><span class="line">    boolean isAtom;</span><br><span class="line">    E item;</span><br><span class="line">    GList&lt;E&gt; head, tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展式链表存储"><a href="#扩展式链表存储" class="headerlink" title="扩展式链表存储"></a>扩展式链表存储</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class GList&lt;E&gt; &#123;</span><br><span class="line">    boolean isAtom;</span><br><span class="line">    E item;</span><br><span class="line">    GList&lt;E&gt; head;</span><br><span class="line">    GList&lt;E&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>m元多项式</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>递归</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-二叉树</title>
    <url>/2021/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%887%EF%BC%89-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>二叉树适合计算机存储和处理。且所有的树结构都可以转为二叉树。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>n（n&gt;=0）个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>每个结点最多有两棵子树，不存在度大于2的结点。</li>
<li>二叉树是有序的，即使只有一棵子树，也要区分是左子树还是右子树。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取深度</li>
<li>获取根节点</li>
<li>获取结点的值</li>
<li>给结点赋值</li>
<li>获取左孩子结点</li>
<li>获取后孩子结点</li>
<li>获取兄弟结点</li>
<li>在指定位置插入孩子结点</li>
<li>删除指定位置的孩子结点</li>
<li>遍历</li>
</ul>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ul>
<li>斜树<br>所有结点都只有左子树称为左斜树，所有结点都只有右子树称为右斜树。</li>
<li>满二叉树<br>所有分支结点都存在左右子树，且所有的叶子结点都在同一层上。</li>
<li>完全二叉树<br>对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。<br>满二叉树必定是完全二叉树。</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul>
<li>先序 根 - 左 - 右</li>
<li>中序 左 - 根 - 右</li>
<li>后序 左 - 右 - 根</li>
<li>层序 广度优先，从上到下，从左到右</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>使用一维数组存储所有结点，按完全二叉树层序遍历顺序存储。<br>某结点存储位置为i，则其左孩子存储位置为2<em>i，右孩子存储位置为2</em>i+1。<br>会造成存储空间的浪费。<strong>顺序存储结构一般仅适用于存储完全二叉树。</strong></p>
<h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p>二叉树每个结点对应一个链表结点，数据元素包含左右孩子的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BiTNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; leftChild;</span><br><span class="line">    Node&lt;E&gt; rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h3><p>二叉树每个结点对应一个链表结点，数据元素包含父节点指针及左右孩子的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BiTNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; parent;</span><br><span class="line">    Node&lt;E&gt; leftChild;</span><br><span class="line">    Node&lt;E&gt; rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线索链表"><a href="#线索链表" class="headerlink" title="线索链表"></a>线索链表</h3><p>按照某种遍历次序对二叉树进行遍历，可以把二叉树中的所有结点排成一个线性序列。<br>一个具有n个结点的二叉链表，在2n个指针域中只有n-1个指针用来存储孩子结点的地址，存在n+1个空指针域。<br>因此，可以使用空指针域存储某种遍历序列中的前驱和后继结点。<br>指向前驱和后继结点的执政称为<strong>线索</strong>，加上线索的二叉树称为线索二叉树，加上线索的二叉链表称为线索链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BiTNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; left, right;</span><br><span class="line">    boolean leftFlag, rightFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在线索链表中，对任意结点，若存在左孩子结点，则左指针指向左孩子结点，否则指向该结点的前驱线索；右指针同理。数据元素包含左右指针，左右指针存放数据标志位。</p>
<p>二叉树遍历次序有4种，相应有四种线索链表：前序线索链表、中序线索链表、后序线索链表、层序线索链表。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>哈夫曼树、哈夫曼编码</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>遍历 - 递归<br>遍历 - 非递归算法<br>线索二叉树的遍历<br>深度</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-树</title>
    <url>/2021/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%888%EF%BC%89-%E6%A0%91/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>有n个结点的有限集合。<br>或者是空树，空树中不包含任何结点；或者是非空树，有且仅有一个特定的根节点，其余结点可分为m个互不相交的有限集，其每一个又是一棵树，且称为根的子树。<br>树的定义是递归的。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取深度</li>
<li>获取根节点</li>
<li>获取结点的值</li>
<li>给结点赋值</li>
<li>获取父节点</li>
<li>获取最左孩子结点</li>
<li>获取右兄弟结点</li>
<li>在指定位置插入孩子结点</li>
<li>删除指定位置的孩子结点</li>
<li>遍历</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul>
<li>前序遍历 根-左-右</li>
<li>后序遍历 左-右-根</li>
<li>层序遍历 树的广度遍历，从上到下，从左到右</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>静态链表。数组存放所有树结点，数据元素包含父节点在数组中的下标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    int parentCur;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode[];</span><br></pre></td></tr></table></figure>

<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>多重链表: 数据元素包含所有子节点的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多重链表的长度由树的度决定，会造成很大一部分的空间浪费。实际中不宜采用</p>
<p>孩子链表: 数据元素包含一个链表，链接所有子节点的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode&lt;E&gt; firstChilde;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双亲孩子表示法"><a href="#双亲孩子表示法" class="headerlink" title="双亲孩子表示法"></a>双亲孩子表示法</h3><p>双亲表示法+孩子链表表示法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode&lt;E&gt; parent;</span><br><span class="line">    TreeNode&lt;E&gt; firstChilde;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>二叉链表表示法。数据元素包含<em>结点的第一个子结点</em>及<em>右兄弟结点</em>的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode&lt;E&gt; nextSibling;</span><br><span class="line">    TreeNode&lt;E&gt; firstChilde;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>遍历<br>深度<br>回溯</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-图</title>
    <url>/2021/11/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%889%EF%BC%89-%E5%9B%BE/</url>
    <content><![CDATA[<p>图的存储结构应根据具体问题的要求来设计，文中列出的是常用的存储结构。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>在图结构中，任意两个顶点之间都可能有关系。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>图是由顶点的有穷非空集合和顶尖之间边的集合组成。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>查找顶点在图中位置</li>
<li>获取顶点值</li>
<li>设置顶点值</li>
<li>获取第一个邻接顶点</li>
<li>获取下一个邻接顶点</li>
<li>添加新顶点</li>
<li>删除顶点及相关的弧</li>
<li>添加弧</li>
<li>删除弧</li>
<li>遍历</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>深度优先遍历<br>广度优先遍历</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>图没有顺序存储结构，但可借助数组表示元素之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum GraphType &#123; DG, DN, UNG, UDN &#125; // 有向图，有向网，无向图，无向网</span><br></pre></td></tr></table></figure>
<h3 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class GNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    GNode[] next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个结点的度都不一样。若按最大度来存储，则可能造成很大的空间浪费；若按结点各自的度来存储，给操作带来不便。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>用一维数组存储顶点的信息，用二维数组存储图中边的信息，存储顶点之间的邻接关系的二维数组称为邻接矩阵。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    V[] vs;</span><br><span class="line">    Arc[][] as;</span><br><span class="line">    int vexnum, arcnum;</span><br><span class="line">    GraphType type;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        int adj; // 对无权图，用0、1表示是否相邻，对有权图，则为权值。</span><br><span class="line">        A item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>对图中每个顶点建立一个单链表，第i个单链表的结点表示依附于顶点vi的边（对有向图是以顶点vi为尾的弧）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    VNode[] vs;</span><br><span class="line">    GraphType type;</span><br><span class="line">    int vexum, arcnum; </span><br><span class="line">    </span><br><span class="line">    class VNode&lt;V, A&gt; &#123;</span><br><span class="line">        V item;</span><br><span class="line">        Arc&lt;A&gt; firstArc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        A item;</span><br><span class="line">        Arc&lt;A&gt; next;</span><br><span class="line">        int adjvex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>有向图的存储结构。将有向图的邻接表和逆邻接表结合起来的一种链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    VNode[] vs;</span><br><span class="line">    int vexnum, arcnum;</span><br><span class="line">    </span><br><span class="line">    class VNode&lt;V&gt; &#123;</span><br><span class="line">        V item;</span><br><span class="line">        Arc&lt;A&gt; firstIn, firstOut;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        Arc&lt;A&gt; head, tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链接多重表"><a href="#链接多重表" class="headerlink" title="链接多重表"></a>链接多重表</h3><p>无向图的存储结构。每一条边用一个结点表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    VNode[] vs;</span><br><span class="line">    int vexnum, arcnum;</span><br><span class="line">    </span><br><span class="line">    class VNode&lt;V&gt; &#123;</span><br><span class="line">        V item;</span><br><span class="line">        Arc&lt;A&gt; firstIn, firstOut;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        Arc&lt;A&gt; head, tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>深度/广度优先遍历<br>最小生成树<br>    普利姆算法<br>    克鲁斯卡尔算法<br>有向无环图 拓扑排序<br>最短路径</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-疑难解答</title>
    <url>/2021/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88X%EF%BC%89-%E7%96%91%E9%9A%BE%E8%A7%A3%E7%AD%94/</url>
    <content><![CDATA[<h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><table>
<thead>
<tr>
<th>结构</th>
<th>数据元素名称</th>
<th>数据元素关系</th>
</tr>
</thead>
<tbody><tr>
<td>线性结构</td>
<td>数据元素</td>
<td>前驱、后继</td>
</tr>
<tr>
<td>树结构</td>
<td>结点</td>
<td>双亲结点、孩子结点、兄弟结点</td>
</tr>
<tr>
<td>图结构</td>
<td>顶点</td>
<td>邻接</td>
</tr>
<tr>
<td>索引</td>
<td>记录</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="数组是一种数据结构么"><a href="#数组是一种数据结构么" class="headerlink" title="数组是一种数据结构么"></a>数组是一种数据结构么</h2><p>是一种数据结构。<br>数组是最基础的数据结构，所以几乎所有的程序设计语言都把数组设定为固定的基础变量类型。<br>在Java中，数据的ADT由底层实现，操作方式不同于其它的操作方式，有它独特的操作方式。如直接赋值，下标访问，初始化等。<br>当数组维度为1时，退化为顺序表。</p>
<h2 id="物理结构-存储结构"><a href="#物理结构-存储结构" class="headerlink" title="物理结构/存储结构"></a>物理结构/存储结构</h2><p>有说法：常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等。（百度百科：数据结构）<br>也有说法： 数据元素之间的关系有两种不同的表示方法：顺序映象和非顺序映象，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。（百度百科：存储结构）</p>
<p>根据物理结构的定义：数据及其逻辑结构在计算机中的表示。而其逻辑结构指的是数据元素之间的关系，即通过该元素，如何找到接下来的元素，即顺序存储和链式存储。<br>对于顺序存储，其关联元素位置由当前位置计算得出，不需要存储。而链式存储，关联元素位置需要存储。</p>
<p>所以，数据的存储结构就是指顺序存储结构和链式存储结构。</p>
<h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><p>树、二叉树、森林是不同的数据结构。二叉树并不是树的一种特殊情况，而是平行的概念，都属于树结构。<br>树、二叉树其定义与性质都不相同。<br>如果二叉树只是在树的定义上，新增了一条或多条，则二叉树可以理解为一种特殊的树。</p>
<h2 id="线性结构与线性表"><a href="#线性结构与线性表" class="headerlink" title="线性结构与线性表"></a>线性结构与线性表</h2><p>线性结构只有线性表么，队列、栈只是一种特殊的线性表，数组与广义表是线性表的推广，不属于线性结构，所以线性结构只有线性表。<br>一维数组也是线性结构。<br>所以线性结构不只是线性表。那还有其它的线性结构么？ - 串</p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><p>抽象数据类型是与程序设计语言相关的。每种语言对同一种数据结构所定义的抽象数据类型是不一致的。<br>抽象数据类型在面向对象中相当于接口，其不同的实现方式相当于实现类。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-线性结构</title>
    <url>/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><p>有序数据元素的集合。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>集合中必存在唯一的“第一个元素”；</li>
<li>集合中必存在唯一的“最后的元素”；</li>
<li>除最后元素外，其它数据元素均有唯一的“后继”；</li>
<li>除第一个元素外，其它数据元素均有唯一的“前驱”。</li>
</ol>
<h2 id="常用结构"><a href="#常用结构" class="headerlink" title="常用结构"></a>常用结构</h2><ul>
<li>线性表<ul>
<li>顺序表</li>
<li>单链表</li>
<li>循环链表</li>
<li>双向链表</li>
<li>静态链表</li>
</ul>
</li>
<li>栈</li>
<li>队列</li>
</ul>
<h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>不是线性结构，是由线性结构组成。</p>
<ul>
<li>数组</li>
<li>广义表</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-图状结构</title>
    <url>/2021/11/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89-%E5%9B%BE%E7%8A%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h2><p>数据元素对于关系的前驱和后继个数不加限制，即任意的关系，称为图形结构。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>顶点： 数据元素<br>简单图： 不存在顶点到其自身的边，且同一条边不重复出现<br>无向图： 任意两个顶底之间的边都是无向边<br>弧: 有向边<br>邻接：任意两个顶点存在边，则两个顶点互为邻接点<br>依附：边依附于顶点<br>无向完全图：无向图中，任意两个顶点之间都存在边<br>有向完全图： 有向图中，任意两顶点之间存在方向互为相反的两条弧<br>顶点的度： 无向图中，依附于该顶点的边的个数<br>顶点的入度： 有向图中，以该顶点为弧头的弧的个数<br>顶点的出度： 有向图中，以该顶点为弧为的弧的个数</p>
<p>权：对边赋予有意义的数值量<br>网：边上带权的图称为网</p>
<p>路径： 两顶点之间的路径是一个顶点序列<br>路径长度： 路径上边的数目<br>回路/环： 第一个顶点和最后一个顶点相同的路径<br>简单路径： 顶点不重复出现的路径<br>简单回路： 除了第一个和最后一个顶点，其余顶点不重复出现的回路</p>
<p>连通图： 无向图中，若任意的两个顶点之间有路径，则称该图是连通图<br>连通分量： 非连通图的极大连通子图<br>强连通图： 有向图中，对任意结点i、j，从顶点i到j均有路径，则称该有向图是强连通图<br>强连通分量： 非强连通图的极大强连通子图</p>
<p>生成树：…<br>生成森林：…</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>深度优先遍历<br>广度优先遍历</p>
<h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><ul>
<li>邻接矩阵<br>用一维数组存储顶点的信息，用二维数组存储图中边的信息，存储顶点之间的邻接关系的二维数组称为邻接矩阵。</li>
<li>邻接表</li>
<li>十字链表</li>
<li>链接多重表</li>
<li>最小生成树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-树形结构</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><p>层次的嵌套结构。树形结构的外层和内层有相似的结构。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>结点：数据元素<br>结点的度： 结点所拥有子树的个数<br>树的度： 树中个结点度的最大值<br>叶子结点： 度为0的结点<br>分支结点： 度不为0的结点<br>树的深度：树中所有结点的最大层数<br>层序编号：按照从上到下，从左到右的次序依次编号<br>有序树： 结点的各子树从左到右是有次序的。交换了结点各子树的相对位置，则构成不同的树。<strong>在数据结构中讨论的树一般是有序树</strong><br>森林： m棵互不相交的树的集合</p>
<h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><ul>
<li>二叉树</li>
<li>树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-排序</title>
    <url>/2021/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>排序的目的： 便于查找。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>记录： 数据元素。</li>
<li>趟： 将待排序的记录序列扫描一遍称为一趟。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>稳定排序 相等的记录排序前后相对位置不变。</li>
<li>不稳定排序 相等的记录排序前后相对位置可能改变。</li>
</ul>
<ul>
<li>内部排序 待排序记录放在内存中的排序过程。</li>
<li>外部排序 待排序记录数量很大，排序过程中需对外存进行访问的排序过程。</li>
</ul>
<h2 id="内部排序算法"><a href="#内部排序算法" class="headerlink" title="内部排序算法"></a>内部排序算法</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>依次将待排序序列中的每一个记录插入到一个已经排好序的序列中，直到全部记录都排好序。</p>
<p>当序列中的记录基本有序，或待排序记录较少时，是最佳的排序方式。数据量大时效率低。</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先将整个待排序记录序列分割成若干个子序列，在子序列中分别进行直接插入排序，待整个序列基本有序时，对全体记录进行一次直接插入排序。<br>是对直接插入排序的一种改进。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>两两比较相邻记录，如果反序则交换，直到没有反序的记录为止。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>首先选一个轴值，将待排序的记录划分为独立的两部分，然后分别对这两部分重复该过程，知道整个序列有序。<br>是对冒泡排序的一种改进。</p>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>第i趟排序在待排序序列中选取关键码最小的记录，并和第i个记录交换，作为有序序列的第i个记录。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>将待排序的记录序列构造称一个堆，然后将堆顶记录移走，并将剩余的记录再调整成堆，直到堆中只有一个记录为止。<br>是对简单选择排序的一种改进。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将若干有序序列逐步归并，最终归并为一个有序序列。<br>二路归并排序： 归并排序中最简单的排序方法，两两归并。</p>
<h3 id="桶式排序"><a href="#桶式排序" class="headerlink" title="桶式排序"></a>桶式排序</h3><p>假设待排序记录的值都在 0~m-1之间，设置m个桶，首先将值为i的记录分配到第i个桶中，然后再将各个桶中的记录依次收集起来。</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>将关键码看成由若干个子关键码复合而成，然后借助分配和收集操作采用LSD方法进行排序。</p>
<h2 id="各排序算法比较"><a href="#各排序算法比较" class="headerlink" title="各排序算法比较"></a>各排序算法比较</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th>稳定排序</th>
<th>平均时间复杂度</th>
<th>最坏时间复杂度</th>
<th>空间复杂度</th>
<th>简单性</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td>稳定</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>简单算法</td>
</tr>
<tr>
<td>希尔排序</td>
<td>不稳定</td>
<td>O(n*logn)~O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>改进算法</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>稳定</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>简单算法</td>
</tr>
<tr>
<td>快速排序</td>
<td>不稳定</td>
<td>O(n*logn)</td>
<td>O(n^2)</td>
<td>O(logn)~O(n)</td>
<td>改进算法</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>不稳定</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>简单算法</td>
</tr>
<tr>
<td>堆排序</td>
<td>不稳定</td>
<td>O(n*logn)</td>
<td>O(n*logn)</td>
<td>O(1)</td>
<td>改进算法</td>
</tr>
<tr>
<td>归并排序</td>
<td>稳定</td>
<td>O(n*logn)</td>
<td>O(n*logn)</td>
<td>O(n)</td>
<td>改进算法</td>
</tr>
<tr>
<td>桶式排序</td>
<td>稳定</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(m)</td>
<td>简单算法</td>
</tr>
<tr>
<td>基数排序</td>
<td>稳定</td>
<td>O(d(n+m))</td>
<td>O(d(n+m))</td>
<td>O(m)</td>
<td>改进算法</td>
</tr>
</tbody></table>
<p>n越小，采用简单排序算法约合适，n越大，采用改进算法约合适。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-索引</title>
    <url>/2021/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%85%AD%EF%BC%89-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>如果数据规模很大或者需要长期保存，则必须以文件的形式存储在外存。<br>索引是为了加快查找速度而设计的一种数据结构，索引技术是组织大型数据库及磁盘文件的一种重要技术。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li><p>记录 数据元素</p>
</li>
<li><p>文件 指存储在外存上的记录集合</p>
</li>
<li><p>索引 将关键码与它对应的记录相关联的过程。一个索引隶属于一个文件，由多个索引项组成。</p>
</li>
<li><p>索引项 至少包含关键码和关键码对应的记录在存储器中的位置等信息。</p>
</li>
<li><p>静态索引 文件创建时生成索引结构，只有当文件再组织是才发生改变。</p>
</li>
<li><p>动态索引 文件创建是生成的索引，在文件执行插入、删除等操作时，索引结构本身也随之发生改变。</p>
</li>
<li><p>线性索引/索引表 索引项组织为线性结构。</p>
</li>
<li><p>树形索引 索引项组织为树形结构。</p>
</li>
<li><p>多级索引 对索引再建立一个索引。</p>
</li>
</ul>
<h2 id="线性索引技术"><a href="#线性索引技术" class="headerlink" title="线性索引技术"></a>线性索引技术</h2><ul>
<li>稠密索引</li>
<li>分开索引</li>
<li>多重表</li>
<li>倒排表</li>
</ul>
<h2 id="树形索引"><a href="#树形索引" class="headerlink" title="树形索引"></a>树形索引</h2><p>树形索引多用于动态索引，常采用链式存储结构实现。<br>二叉排序树时一种最基本的树形索引，许多其它索引都是从它发展而来的。</p>
<ul>
<li>2-3树</li>
<li>B-树</li>
<li>B+树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-查找表</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%9F%A5%E6%89%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>查找表是由同一种数据元素构成的集合。<br>集合中的元素之间存在着完全松散的关系，也可以用其它数据结构来表示它。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol>
<li>查询某个特定的数据元素是否在表中；</li>
<li>检索某个特定的数据元素的各种属性；</li>
<li>在查找表中插入一个数据元素；</li>
<li>从查找表中删除某个数据元素。</li>
</ol>
<ul>
<li>静态查找表 只有查找操作，没有插入删除的查找表</li>
<li>动态查找表 有插入删除的查找表</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>关键码 可以标识一个记录的数据项</li>
<li>键值 关键码的值</li>
<li>主关键码 可以唯一地标识一个记录的关键码</li>
<li>此关键码 不能唯一标识一个记录的关键码</li>
<li><strong>查找结构</strong> 面向查找操作的数据结构</li>
</ul>
<h2 id="查找结构"><a href="#查找结构" class="headerlink" title="查找结构"></a>查找结构</h2><ul>
<li>线性表 适用于静态查找<ul>
<li>顺序表的查找</li>
<li>有序表的查找</li>
<li>折半查找技术</li>
<li>分块查找/索引顺序表查找</li>
</ul>
</li>
<li>树表 适用于动态查找<ul>
<li>二叉排序树</li>
<li>B-树</li>
</ul>
</li>
<li>散列表 均使用<ul>
<li>散列技术</li>
</ul>
</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>关心整体性能。<br>平均查找长度。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-分治法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89-%E5%88%86%E6%B2%BB%E6%B3%95/</url>
    <content><![CDATA[<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同。递归地解这些子问题，然后将各子问题的解合并到原问题的解。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>归并排序</li>
<li>快速排序</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-动态规划</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>与分治法类型，也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。<br>与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。</p>
<p>如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。为了达到这个目的，可以用一个表记录所有已解决的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>找出最优解的性质，并刻画其结构特征；</li>
<li>递归地定义最优值；</li>
<li>以自底向上的方式计算出最优值；</li>
<li>根据计算最优值是得到的信息，构造最优解。</li>
</ol>
<h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><h3 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h3><p>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p>
<h3 id="重叠子问题性质"><a href="#重叠子问题性质" class="headerlink" title="重叠子问题性质"></a>重叠子问题性质</h3><p>每次产生的子问题并不总是新问题，有些子问题被反复计算多次。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>矩阵连乘</li>
<li>最长公共子序列</li>
<li>0-1背包问题</li>
<li>最优二叉搜索树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-贪心算法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%883%EF%BC%89-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>贪心算法总是做出在当前看来最好的选择。贪心算法并不从整体最优考虑，它所做出的选择只是在某种意义上的局部最优选择。贪心算法得到的最终结果也是整体最优的。</p>
<h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><p>贪心算法通过一系列的选择得到问题的解。它所做出的每一个选择都时当前状态下的最好选择，即贪心选择。</p>
<h3 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h3><p>指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。</p>
<h3 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h3><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</p>
<h2 id="贪心-VS-动态规划"><a href="#贪心-VS-动态规划" class="headerlink" title="贪心 VS 动态规划"></a>贪心 VS 动态规划</h2><p>都要求问题具有最优子结构性质。</p>
<p>在动态规划算法中，每步所做出的选择往往依赖于相关子问题的解。因而只有解出相关子问题后，才能做出选择。<br>而在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择，然后再去解做出这个选择后产生的相应的子问题。</p>
<p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做出依次贪心选择就将所求问题简化为规模更小的子问题。</p>
<p>0-1背包问题与背包问题。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>哈夫曼编码</li>
<li>单源最短路径<br>  给定带权有向图G=(V, E)，其中每条边的权时非负实数。另外，还给定V中的一个顶点，称为源。计算从源到所有其它各顶点的最短路长度（路上各边权之和）。</li>
<li>最小生成树<ul>
<li>Prim 算法</li>
<li>Kruskal 算法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-回溯法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%884%EF%BC%89-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>从开始结点（根节点）出发，以深度优先方式搜索整个解空间。这个开始结点称为活结点，同时也称为当前的扩展结点。在当前扩展结点处，搜索向纵深方向移至一个新结点。这个新节点成为新的活结点，并称为当前扩展结点。如果在当前扩展结点处不能再向纵深方向移动，则当前扩展结点就称为死结点。此时，应往回移动（回溯）至最近的活结点处，并使这个活结点成为当前扩展结点。回溯法以这种工作方式递归地再解空间中搜索，直至找到所要求的解或解空间中已无活结点时为止。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>针对所给问题，定义问题的解空间；</li>
<li>确定易于搜索的解空间结构；</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ul>
<li>递归回溯 用递归方法实现回溯法。</li>
<li>迭代回溯 用树的非递归深度优先遍历算法，可将回溯法表示为一个非递归迭代过程。</li>
</ul>
<h2 id="解空间树"><a href="#解空间树" class="headerlink" title="解空间树"></a>解空间树</h2><ul>
<li>子集树<br>当所给问题是从n各元素的集合S中找出S满足某种性质的子级时，相应的解空间树称为子集树。<br>通常有2^n+1个结点，2^n个叶子结点。遍历需要Ω(2^n)计算时间。</li>
<li>排列树<br>当所给问题时确定n各元素满足某种性质的排列时，相应的解空间树称为排列树。<br>通常有n!个叶子结点。遍历需要Ω(n!)计算时间。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>0-1背包问题</li>
<li>最大团问题</li>
<li>图的m着色问题</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-分支限界法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%885%EF%BC%89-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>以广度优先或以最小耗费/最大效益有限的方式搜索问题的解空间树。每一个活结点只有依次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点将被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。</p>
<h2 id="分支限界-VS-回溯"><a href="#分支限界-VS-回溯" class="headerlink" title="分支限界 VS 回溯"></a>分支限界 VS 回溯</h2><p>都是在解空间树上搜索问题解的算法。</p>
<p>回溯法的求解目标时找出解空间树中满足约束条件的所有解。而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p>
<p>求解目标不同，导致堆解空间树的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树。而分支限界法以广度优先或以最小耗费优先的方式搜索解空间树。</p>
<h2 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h2><ul>
<li>队列式分支限界法<br>将活结点表组织成一个队列，并按队列的FIFO原则选取下一个结点为当前扩展结点。</li>
<li>优先队列式分支限界法<br>将活结点的表组织成一个优先队列，并按优先队列中规定的结点优先级选取优先级最高的下一个结点成为当前扩展结点。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>单源最短路径问题</li>
<li>0-1背包问题</li>
<li>最大团问题</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>C 介绍</title>
    <url>/2021/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>为了编写Unix系统，早期使用汇编语言，为了编写Unix系统，创建了C。但其发展早已超出了作为Unix操作系统的初衷。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>1973年 C语言诞生。<br>1978 K&amp;R 《The C Programming Language》 出版。<br>1983 ANSI（American National Standards Institute 美国国家标准学会）成立C标准委员会，建立C语言的标准。<br>1989 ANSI发布了第一个完整的C标准 ANSI X3.159-1989，简称C89。<br>1990 ISO（International Standard Organization 国际标准化组织）发布了 ISO/IEC 9899:1990，内容与C89一致，简称 C90。<br>1999 ISO发布了ISO/IEC 9899:1999， 简称 C99。<br>2011 ISO发布了ISO/IEC 9899:2011， 简称 C11。<br>2018 ISO发布了ISO/IEC 9899:2018， 简称 C18。</p>
<h2 id="基于C的语言"><a href="#基于C的语言" class="headerlink" title="基于C的语言"></a>基于C的语言</h2><p>C++：包含了所有C的特性，增加了类和其它特性以支持面向对象编程。<br>Java：基于C++，所以也继承了许多C的特性。<br>C#：由C++和Java发展起来的一门语言。<br>Prel: 脚本语言，发展过程中采取了许多C的特性。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>运行速度快、高效 </li>
<li>功能强大</li>
<li>灵活 为了系统编程设计，但不是只能编写系统。非法的操作在C中是允许的。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>危险性高</li>
<li>没有模块化</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>数据类型</li>
<li>流程控制语句</li>
<li>函数</li>
<li>编译 预处理阶段对程序文本进行宏替换、包含其它源文件以及进行条件编译。</li>
<li>处理大部分计算机能够处理的对象，如字符、数字、地址。</li>
<li>不提供直接处理复合对象的操作。</li>
<li>单线程</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>C 标准库</title>
    <url>/2021/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C-%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<h2 id="标准输入输出-lt-stdio-h-gt"><a href="#标准输入输出-lt-stdio-h-gt" class="headerlink" title="标准输入输出 &lt;stdio.h&gt;"></a>标准输入输出 &lt;stdio.h&gt;</h2><p>stdio standard input and output</p>
<p>stdin 标准输入<br>stdout 标准输出<br>stderr 标准错误输出</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>int getchar(void)</td>
<td>从标准输入（一般是键盘）中一次读取一个字符</td>
</tr>
<tr>
<td>int putchar(int)</td>
<td>将字符送至标准输出上</td>
</tr>
<tr>
<td>int printf(char *format, arg1, …)</td>
<td>格式化输出</td>
</tr>
<tr>
<td>int scanf(char *format, …)</td>
<td>格式化输入</td>
</tr>
<tr>
<td>int sscanf(char *string, char *format, arg1, …)</td>
<td>从一个字符串中读取字符序列</td>
</tr>
<tr>
<td>FILE *fopen(char *name, char *mode)</td>
<td>打开文件</td>
</tr>
<tr>
<td>int getc(FILE *fp)</td>
<td>从文件中返回下一个字符</td>
</tr>
<tr>
<td>int putc(int c, FILE *fp)</td>
<td>将字符写入文件中</td>
</tr>
<tr>
<td>int fscanf(FILE *fp, char *format,…)</td>
<td>文件格式化输入</td>
</tr>
<tr>
<td>int fprintf(FILE *fp, char *format,…)</td>
<td>文件格式化输出</td>
</tr>
<tr>
<td>int fclose(FILE *fp)</td>
<td>关闭文件</td>
</tr>
<tr>
<td>int feeor(FILE *fp)</td>
<td>流中出现错误，返回非零值</td>
</tr>
<tr>
<td>int feof(FILE *fp)</td>
<td>到达文件结尾，返回非零值</td>
</tr>
<tr>
<td>char *fgets(char *line, int maxline, FILE *fp)</td>
<td>从文件中读取下一个输入行，并放在字符数组中</td>
</tr>
<tr>
<td>int fput(char *line, FILE *fp)</td>
<td>将字符串写入到文件中</td>
</tr>
</tbody></table>
<h2 id="字符串操作-lt-string-h-gt"><a href="#字符串操作-lt-string-h-gt" class="headerlink" title="字符串操作 &lt;string.h&gt;"></a>字符串操作 &lt;string.h&gt;</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>strcat(char *s, char *t)</td>
<td>将t指向的字符串连接到s指向的字符串的末尾</td>
</tr>
<tr>
<td>strncat(char *s, char *t, int n)</td>
<td>将t指向的字符串中前n个字符连接到s指向的字符串的末尾</td>
</tr>
<tr>
<td>strcmp(char *s, char *t)</td>
<td>比较字符串大小</td>
</tr>
<tr>
<td>strncmp(char *s, char *t, int n)</td>
<td>比较字符串前n个字符大小</td>
</tr>
<tr>
<td>strcpy(char *s, char *t)</td>
<td>将t指向的字符串复制到s指向的位置</td>
</tr>
<tr>
<td>strlen(char *s)</td>
<td>返回s指向的字符串的长度</td>
</tr>
<tr>
<td>strchr(char *s, int c)</td>
<td>在s指向的字符串中查找c，返回第一次出现的位置的指针</td>
</tr>
<tr>
<td>strrchr(char *s, int c)</td>
<td>在s指向的字符串中查找c，返回最后一次出现的位置的指针</td>
</tr>
</tbody></table>
<h2 id="字符操作-lt-ctype-h-gt"><a href="#字符操作-lt-ctype-h-gt" class="headerlink" title="字符操作 &lt;ctype.h&gt;"></a>字符操作 &lt;ctype.h&gt;</h2><p>isalpha<br>isupper<br>islower<br>isdigit<br>isalnum<br>isspace<br>toupper<br>tolower</p>
<h2 id="通用-lt-stdlib-h-gt"><a href="#通用-lt-stdlib-h-gt" class="headerlink" title="通用 &lt;stdlib.h&gt;"></a>通用 &lt;stdlib.h&gt;</h2><p>atof<br>malloc<br>calloc<br>free<br>exit<br>system<br>frand</p>
<h2 id="数学函数-lt-math-h-gt"><a href="#数学函数-lt-math-h-gt" class="headerlink" title="数学函数 &lt;math.h&gt;"></a>数学函数 &lt;math.h&gt;</h2><p>sin<br>cos<br>atan2<br>exp<br>log<br>log10<br>pow<br>sqrt<br>fabs</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>C 语法</title>
    <url>/2021/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数据类型、运算符、表达式"><a href="#数据类型、运算符、表达式" class="headerlink" title="数据类型、运算符、表达式"></a>数据类型、运算符、表达式</h2><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><ul>
<li>数字及字母组成，以字母开头。</li>
<li>“_”被看作是字母，用来命名较长的变量名。</li>
<li>库例程的名字通常以下划线开头，因此变量不要以下划线开头。</li>
<li>严格区分大小写。</li>
<li>关键字不能用作变量，关键字中的字符小写。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>名称</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字符型</td>
<td>一个字节</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>所用机器中整数的最自然长度</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点型</td>
<td>-</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型</td>
<td>-</td>
</tr>
</tbody></table>
<h4 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h4><p>short/long 限定整型： short通常为16位，long通常为32位。<br>signed/unsigned: 限定char类型或任何整型。不带限定符的对象是否带符号取决于具体机器实现。<br>long double ： 表示高精度的浮点数。浮点型的长度取决于具体的实现。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="define"><a href="#define" class="headerlink" title="define"></a>define</h4><p>定义： #define 常量名 常量值 （宏定义）<br>常量类型通过后缀可以判断。无符号常量以u/U结尾。<br>const: 变量的值不能被修改。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举是一个常量整型值的列表。<br>定义： enum 枚举名 { 常量名[=值]… }<br>没有显示指定，第一个值为0，显示指定部分值，按最后一个指定值递增。</p>
<h4 id="define-VS-enum"><a href="#define-VS-enum" class="headerlink" title="define VS enum"></a>define VS enum</h4><p>enum常量值可以自动生成。<br>调试程序可以以符号形式打印出枚举变量的值。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>所有变量必须先声明后使用。<br>初始化表达式 变量名的后面紧跟一个等号以及一个表达式。<br>默认情况下，外部变量与静态变量将被初始化为0。未经显示初始化的自动变量的值为未定义值。</p>
<p>限定符<br>const 指定变量的值不能被修改。数组中所有元素的值都不能被修改。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>算术  + - * / %</li>
<li>关系  &gt; &gt;= &lt; &lt;=</li>
<li>相等性  == !=</li>
<li>逻辑  &amp;&amp; || （短路功能） ！</li>
<li>自增/自减  ++ –</li>
<li>按位  &amp; | ! ^ &lt;&lt; &gt;&gt; ~ （只能作用与整型）（算术移位/逻辑移位）</li>
<li>赋值  =</li>
<li>三元  ?:</li>
</ul>
<p>优先级<br><img src="/images/pasted-7.png" alt="upload successful"></p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>算术类型转换 运算时两个操作数类型不同，进行运算钱把“较低”的类型提升为“较高”的类型。（float不会自动转换为double）<br>赋值类型转换 超出的高位部分将被丢弃。<br>强制类型转换 显示类型转换 （类型名）表达式</p>
<p>char类型是较小的整型，因此在算术表达式中可以自由使用char类型的变量。</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>用运算符将运算对象连接起来的式子。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>语句： 表达式后加上一个分号（；）。分号是语句结束符。<br>程序块： 复合语句，把一组声明和语句用一对花括号（{}）括在一起。</p>
<ul>
<li>if-else 用于条件判定。</li>
<li>else-if 用于多路判定。</li>
<li>switch 多路判定语句，使用常量表达式。</li>
<li>while 循环体执行前对终止条件进行测试。</li>
<li>for 循环体执行前对终止条件进行测试；包含continue时可以和while转换。（包含简单的初始化和变量递增时更合适）</li>
<li>do-while 循环体执行后对终止条件进行测试，循环体被至少执行一次。</li>
<li>break 从switch中跳出，或在for、while、do-while最内层跳出。</li>
<li>continue 使for、while、do-while开始下一次的循环。</li>
<li>goto 跳到标号处执行。适合深度嵌套的处理过程。尽可能少的使用。</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名(参数声明表) &#123;</span><br><span class="line">    声明和语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果函数定义中省略了返回值类型，则默认为int类型。</li>
<li>声明函数参数类型及返回值类型。 返回值类型 函数名（参数类型）;。</li>
<li>没有声明过的函数会被隐式声明，返回值被假定为int类型，但并不对其参数进行假设。</li>
<li>函数不能嵌套定义。</li>
<li>没有参数使用void进行声明。</li>
<li>支持变长参数 … 。</li>
</ul>
<ul>
<li>自动变量 局部作用域变量。控制流进入变量作用域是系统自动为其分配存储空间，并在离开作用域时释放空间的一类变量。</li>
<li>外部变量 在函数外定义的全局变量。作用域：变量的定义处开始，到本程序文件的结尾。</li>
<li>内部变量 局部变量，指在一个函数内部或复合语句内部定义的变量。</li>
<li>全局变量 对所有程序文件都是可见的。</li>
</ul>
<h3 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h3><p>定义C中变量/函数的范围和声明周期。包括auto、register、static、extern。</p>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>只能修饰局部变量，局部变量的默认值。</p>
<h4 id="register"><a href="#register" class="headerlink" title="register"></a>register</h4><p>变量使用频率较高，将变量放在机器的寄存器上，使得程序更小，执行速度更快。但编译器可以忽略此选项。<br>register 声明只适用于自动变量以及函数的形式参数。</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li>静态变量 声明对象的作用域限定于被编译源文件的剩余部分。</li>
<li>静态函数 除了函数声明所在的文件外，其它文件都无法访问。</li>
<li>局部静态变量 一直占据存储空间。</li>
</ul>
<h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><p>只声明外部变量，不能初始化。<br>用于提供一个全局变量的引用。<br>声明后可在外部变量定义前使用该变量，或由其它源文件做定义。</p>
<h3 id="main函数参数"><a href="#main函数参数" class="headerlink" title="main函数参数"></a>main函数参数</h3><ul>
<li>int argc</li>
<li>char *argv[]</li>
</ul>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>包含函数声明和宏定义，被多个源文件中引用共享。<br>主要用于保存程序的声明。</p>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>预处理器是编译过程中单独执行的第一个步骤。</p>
<ul>
<li>文件包含 处理 #include 指令。</li>
<li>宏替换  替换 #define 变量。</li>
<li>条件包含  预处理执行的过程中进行计算。</li>
</ul>
<h2 id="指针、数组"><a href="#指针、数组" class="headerlink" title="指针、数组"></a>指针、数组</h2><p>指针： 一种保存变量地址的变量。<br>间接引用运算符： *。<br>取址运算符： &amp;。<br>void指针表示 无类型指针，没有特定的类型，因此可以指向任何类型的数据。参数声明表示可以是任意类型的指针。</p>
<h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><p>C中以传值的方式将参数值传递给被调用函数，被调用函数不能直接修改主调函数中变量的值。<br>指针参数使得被调用函数能够访问和修改主调函数中对象的值。<br>指针参数： 类型 *参数名， 。<br>返回指针： 类型 *函数名(…) {…} 。</p>
<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>数组： 存储在相邻内存区域中的对象组成的集合。<br>数组定义： 类型 变量[长度]; 。<br>指针加1： 指向指针所指对象的下一个对象。<br>通过数组和下标实现的表达式可等价的通过指针和偏移量实现。<br>当把数组作为参数传递给函数时，实际传递的是该数组第一个元素的地址，即一个存储地址值的变量，即指针。所以函数定义中，形参 char c[] 和 char *c 是等价的。<br>也可以将子数组的起始位置的指针传给函数，即将数组的一部分传递给了函数。</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>相同类型的指针之间的赋值运算。<br>指针同整数之间的加法和减法运算。<br>指向相同数组中元素的两个指针间的减法或比较运算。<br>将指针赋值为0或指针与0之间的比较运算。</p>
<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>存储指针的数组。指向指针的指针。<br>定义: 类型 *变量名[长度] 。<br>初始化： 字面量初始化。</p>
<h3 id="复杂声明"><a href="#复杂声明" class="headerlink" title="复杂声明"></a>复杂声明</h3><p>指针的指针 ： 类型 **参数名<br>数组的指针 ： 类型 (*参数名)[长度]<br>指针数组 ： 类型 *参数名[长度]<br>函数返回指针 : 类型 *函数名(…)<br>函数指针 ： 类型 (*函数名)(参数…)<br>？？？ ： 类型 (*(*函数名())[])()<br>？？？ ： 类型 (*(*函数名[长度])())[长度]</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>结构是一个或多个变量的集合。将一组相关的变量看作一个单元而不是各自读离的实体，因此有助于组织复杂的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct [结构标记] &#123;</span><br><span class="line">    类型 结构成员;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构成员、结构标记和普通变量可以采用相同名字而不会冲突。<br>声明： struct {…} x, y, z; 与基本类型变量声明一致。<br>成员运算符： . 。<br>初始化： 定义时初始化， 赋值初始化（结构名.成员）。<br>结构可以嵌套。</p>
<h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><p>向函数传参</p>
<ul>
<li><p>传递结构成员</p>
</li>
<li><p>传递结构  值传递，在函数里修改成员并不会影响原结构</p>
</li>
<li><p>传递结构指针<br>返回结构： struct 结构名 函数名(…) 。</p>
</li>
<li><p>结构数组</p>
</li>
<li><p>结构指针 struct 结构名 *函数名(…)</p>
</li>
<li><p>类型定义  typedef， 用来建立新的数据类型名。</p>
</li>
</ul>
<h2 id="联合-共用体"><a href="#联合-共用体" class="headerlink" title="联合/共用体"></a>联合/共用体</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union 共用体名 &#123;</span><br><span class="line">    类型 成员;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>共用体的所有成员占用同一段内存，占用的内存等于最长的成员占用的内存。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>CRLF</title>
    <url>/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CRLF/</url>
    <content><![CDATA[<h1 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h1><blockquote>
<p>How/Why</p>
</blockquote>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul>
<li>windows 使用crlf回车换行</li>
<li>linux使用lf换行</li>
<li>macos 之前使用cr回车，现在使用lf换行</li>
</ul>
<h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><ul>
<li>idea 编辑文件使用系统默认换行符即可。</li>
<li>git默认配置 atuocrlf=true，检出/提交时会自动转换换行符。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>原码、补码、反码</title>
    <url>/2020/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/</url>
    <content><![CDATA[<h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>用二进制表示，用最高位表示符号。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>直观。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>负数的运算通过累加器来实现，原码的方式不支持减法。</p>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>正数的反码是其本身，负数的反码是除符号位，其它位取反。</p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ul>
<li>符号位与数值一起参与运算</li>
<li>循环进位（最高位相加有进位时，送到最低位相加）</li>
<li>结果也是反码。<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4>解决减法问题<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li>
</ul>
<p>+0 和 -0 有两种表示方法。</p>
<h4 id="循环进位"><a href="#循环进位" class="headerlink" title="循环进位"></a>循环进位</h4><ul>
<li>两个正数相加，进位表示溢出</li>
<li>两个负数相加，若结果不溢出，产生进位</li>
<li>一正一负相加，若结果为负，没有进位，若结果为正，产生进位。</li>
</ul>
<p>反码加法按照 循环进位 的法则来算才能保证其正确性。</p>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>正数的补码是其本身，负数的补码符号位不变，其余各位取反，最后+1。</p>
<h4 id="运算-1"><a href="#运算-1" class="headerlink" title="运算"></a>运算</h4><ul>
<li>符号位参与运算</li>
<li>最高位相加后若出现进位，则舍弃</li>
<li>结果也是补码<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4>解决 +0 -0问题，有更大的表示范围。</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="模"><a href="#模" class="headerlink" title="模"></a>模</h3><p>计量系统的计数范围，如时针的模是12。</p>
<h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>两个正数a,b，如果除以正数m所得余数相同，则称a，b对于模同余。</p>
<h3 id="负数取模"><a href="#负数取模" class="headerlink" title="负数取模"></a>负数取模</h3><p>x mod y = x - y * ⌈x / y⌉ (向上取整) </p>
<h3 id="补码、反码"><a href="#补码、反码" class="headerlink" title="补码、反码"></a>补码、反码</h3><p>补码、反码和原码同余，只是模不同。</p>
<p>在不考虑溢出的情况下，如果a、b同余，则 a + c = b + c。所以，负数的加法可以通过反码、补码来计算。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2020/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>最近做小数计算，发现double比long的最大值大了好多，甚至float最大值都比long最大值大，而float是32位存储空间，long是64位存储空间，带着这个疑问，进行深入探索。<br>PS: 本文所提到的所有类型，以Java语言为准。</p>
</blockquote>
<h2 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>存储空间(bit)</th>
<th>存储范围</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1</td>
<td>0/1</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>-128~127</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>0~65536</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>-2,147,483,648~2,147,483,647</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>-9,223,372,036,854,775,808~9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>-3.4028235E38~3.4028235E38</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>-1.7976931348623157E308~1.7976931348623157E308</td>
</tr>
</tbody></table>
<h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><p>想要保存比long最大值还大的整数，使用BigInteger，性能会有所降低。</p>
<h3 id="double-VS-long"><a href="#double-VS-long" class="headerlink" title="double VS long"></a>double VS long</h3><ul>
<li>double和long都是64位，double最大值远大于long最大值<blockquote>
<p>存储方式不一样，double中可以使用阶数存储。<br>double 64位 = 1位符号 + 11位阶码（带符号） + 52位尾数</p>
</blockquote>
</li>
<li>E308，为何是308次方<blockquote>
<p>log(2^(2^10-1)) 大于308小于309。 2^10-1: 阶码最大值，阶码首位为符号，正数从0开始。log(2^X): 计算机中2为阶底，转为以10为阶底。</p>
</blockquote>
</li>
<li>double有效数字为16位，long有效数字为19<blockquote>
<p>使用阶数存储，但是需要丢失末尾的精确度，会四舍五入。<br>2^52 = 4,503,599,627,370,496, 最大值为16位数，所以有效数字为16位。</p>
</blockquote>
</li>
</ul>
<h3 id="float-VS-int"><a href="#float-VS-int" class="headerlink" title="float VS int"></a>float VS int</h3><p>与double、long同理</p>
<h2 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h2><p>二进制浮点数算术标准。Java中float，double都符合该标准。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学与技术</title>
    <url>/2021/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>计算机科学： 研究计算机及周围各种现象和规律的科学。亦即研究计算机系统结构、程序系统（即软件）、人工智能以及计算本身性质和问题的学科。<br>计算机技术： 指计算机领域中所御用的技术方法和技术手段，或指其硬件技术、软件技术及应用技术。</p>
<h2 id="计算机语言分类"><a href="#计算机语言分类" class="headerlink" title="计算机语言分类"></a>计算机语言分类</h2><blockquote>
<ul>
<li>解释型语言：运行时翻译成机器语言。效率比较低，依赖解释器。</li>
<li>编译型语言：运行前需要专门的编译过程，把程序编译为机器语言的文件。程序执行效率高，依赖编译器。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>系统语言：用来书写系统程序的程序设计语言。</li>
<li>脚本语言：用来控制软件应用程序。解释型语言。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>静态语言：在编译期进行类型检查。</li>
<li>动态语言：在运行期进行类型检查。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>强类型语言：强制类型定义的语言。一旦某个变量被定义类型，如果不经过强制转换，则它永远就是该类型。</li>
<li>弱类型语言：弱类型定义的语言。一个变量被定义类型，该变量可根据环境自动进行转换。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>通用语言： 不专用于某一个特定的应用领域。</li>
<li>专用语言： 用于某些特定领域的程序设计语言。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>面向过程： 分析出解决问题所需的步骤，用函数实现步骤，使用时依次调用。</li>
<li>面向对象： 把构成问题的事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</li>
</ul>
</blockquote>
<h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><ul>
<li>1936，图灵机，一种抽象的计算模型。</li>
<li>1946-2，第一台计算机问世，ENIAC。第一代计算机（电子管）。面向机器编程。</li>
<li>1951，汇编语言。</li>
<li>1954，第二代计算机（晶体管）。面向机器编程。</li>
<li>1956，IPL。Information Processing Language。</li>
<li>1957，Fortran formula translation， 第一个编译型语言。</li>
<li>1958，第三代计算机（集成电路）。操作系统、高级编程语言的基础。</li>
<li>1958，LISP。List，Processor，基于列表处理。</li>
<li>1964，Simula 67 面向对象的起源。</li>
<li>1970，第四代计算机（大规模/超规模继承电路）。</li>
<li>1970，Pascal 主要在教学领域。第一个结构化程序设计语言。</li>
<li>1971，Basic</li>
<li>1971-1，第一个4位微处理器芯片Inter 4004，微型计算机时代。</li>
<li>1972，C。初衷为编写Unix操纵系统，发展远不止于此。</li>
<li>1973，Unix操作系统。</li>
<li>1978-6，16位微处理器芯片Inter 8086。</li>
<li>1983，C++ 命令式面向对象语言，以Simula 67 的方式对命令式的编程的面向对象扩展。</li>
<li>1983，Objective-C 另一个对C进行面向对象扩展的语言。</li>
<li>1985，MicroSoft发布Windows 1.0。</li>
<li>1987，PERL。</li>
<li>1989，Internet从军用转向民用。</li>
<li>1990/1991-8-6，HTML。Web服务器：超文本服务器，存储超文本文件的服务器。第一个浏览器。</li>
<li>1991，Python 面向对象解释式脚本语言。</li>
<li>1993，Ruby 纯面向对象解释式脚本语言。</li>
<li>1993，CGI（Common Gateway Interface）。</li>
<li>1995-5，Java。Applet用于浏览器客户端，EE用于浏览器服务端，ME用于小型设备。</li>
<li>1995-6，PHP Web服务器脚本语言。</li>
<li>1995-12，JavaScript 浏览器脚本语言。</li>
<li>1997, UML。被采纳为为面向对象语言建模的国际标准。（不是唯一标准，不是强制标准。）</li>
<li>2001，C# .net平台主语言。</li>
<li>2001，Visual Basic.net</li>
<li>2003，Groovy</li>
<li>2003，Scala</li>
<li>2009，Go</li>
<li>2011，Dart</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>数字化、信息化。<br>本文网络指计算机网络。</p>
<h3 id="三网"><a href="#三网" class="headerlink" title="三网"></a>三网</h3><ul>
<li>电信网络 提供电话、电报、传真等服务。</li>
<li>有线电视网络 利用光缆或同轴电缆来传送广播电视信号或本地播放的电视信号的网络。提供各种电视节目。</li>
<li>计算机网络 计算机通信网。能够迅速传送数据，获取各种资料。</li>
</ul>
<h3 id="三网融合"><a href="#三网融合" class="headerlink" title="三网融合"></a>三网融合</h3><p>相互渗透，互相兼容，并逐步整合称为全世界统一的信息通信网络。</p>
<h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>网络 由若干结点和连接这些结点的链路组成。</li>
<li>互联网 网络的网络。网络把计算机连接在一起，而互联网把网络连接在一起。</li>
<li>因特网 世界上最大的互联网络。</li>
<li>网络互联 硬件+软件。</li>
<li>ISP 因特网服务提供商（Internet Service Provider）。</li>
</ul>
<h3 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h3><ol>
<li>第一阶段： 从单个网络ARPANET向互联网发展。</li>
<li>第二阶段： 三级结构的互联网。主干网、地区网、校园网/企业网。</li>
<li>第三阶段： 多层次ISP结构的互联网。</li>
</ol>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>计算机通信： 主机A的某个进程和主机B的另一个进程进行通信。</p>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ul>
<li>C/S 客户-服务器模式。</li>
<li>p2p 对等方式（peer to peer）。</li>
</ul>
<h3 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h3><ul>
<li>电路交换 整个报文的比特流连续地从源点直达重点。</li>
<li>报文交换 整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li>
<li>分组交换 单个分组传送到相邻结点（整个报文的一部分），存储下来后查找转发表，转发到下一个结点。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="按网络作用范围"><a href="#按网络作用范围" class="headerlink" title="按网络作用范围"></a>按网络作用范围</h3><ul>
<li>广域网WAN Wide Area Network</li>
<li>城域网MAN Metropolitan Area Network</li>
<li>局域网LAN Local Area Network</li>
<li>个人区域网PAN Personal Area Network</li>
</ul>
<h3 id="按使用者"><a href="#按使用者" class="headerlink" title="按使用者"></a>按使用者</h3><ul>
<li>公用网</li>
<li>专用网</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>速率 传输数据的速率。</li>
<li>带宽 网络的通信线路传送数据的能力。表示在单位时间内从网络的某一点到另一点所能通过的最高数据率。</li>
<li>吞吐量 单位时间内通过某个网络的数据量。</li>
<li>时延 数据从网络的一端传送到另一端的时间。总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延。</li>
<li>时延带宽积 传播时延 * 带宽。</li>
<li>往返时间RTT Round-Trip Time。从数据发送方发送数据开始，到发送方收到来自接收方的确认。</li>
<li>利用率 </li>
</ul>
<h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>为进行网络中的数据交换而建立的规则、标准或约定，称为网络协议。主要由以下三要素组成：</p>
<ul>
<li>语法 数据与控制信息的结构或格式。</li>
<li>语义 需要发出何种控制信息，完成何种动作以及做出何种响应。</li>
<li>同步 事件实现顺序的详细说明。</li>
</ul>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>各层之间是独立的、灵活性好、结构上可分隔开、易于实现和维护、能促进标准化工作。</p>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>把计算机网络的各层及其协议的集合，称为网络的体系结构。即计算机的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义。<br>体系结构是抽象的，而实现则是具体的。</p>
<h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI/RM: 开放系统互联模型（Open Systems Interconnection Reference Model）。</p>
<ul>
<li>⑦ 应用层 用户接口</li>
<li>⑥ 表示层 数据的表现形式，特定功能的实现</li>
<li>⑤ 会话层 对应用回话的管理同步</li>
<li>④ 传输层 可靠与不可靠的传输，传输前的错误检测，监控。</li>
<li>③ 网络层 提供逻辑地址，选路</li>
<li>② 数据链路层 成帧，用MAC地址访问媒介，错误检测与修正</li>
<li>① 物理层 设备之间的比特流传输，物理接口，电气特性。</li>
</ul>
<p>OSI七层模型只获得了一些理论研究的成果，以失败告终。</p>
<h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><ul>
<li>应用层 应用层+表示层+会话层</li>
<li>传输层</li>
<li>网络互联层</li>
<li>网络接口层 数据链路层+物理层</li>
</ul>
<p>实际事实标准。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>一般用来表示向某一个方向传送信息的媒体。<br>根据双方信息交互方式分类：</p>
<ul>
<li>单工通信 只能有一个方向的通信而美誉反方向的交互。（无线电广播、有线电广播、电视广播）</li>
<li>半双工通信 通信的双方都可以发送信息，单不能双方同时发送。</li>
<li>全双工通信 通信的双方可以同时发送和接受信息。</li>
</ul>
<h3 id="适配器-网卡"><a href="#适配器-网卡" class="headerlink" title="适配器/网卡"></a>适配器/网卡</h3><p>适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的。而适配器和计算机之间的通信是通过计算机主板上的I/O总线以并行传输方式进行的。</p>
<h3 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h3><p>非对称数字用户线ADSL技术是用数字技术对现有模拟电话用户线进行改造。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>是一种计算机局域网技术。</p>
<h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><p>PPP point to point protocol 点对点协议。<br>PPPOE PPP Over Ethernet 以太网上的点对点协议。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>任务：为分组交换网上的不同主机提供通信服务。<br>协议： IP</p>
<p>正向查询： 域名 -&gt; IP<br>反向查询： IP -&gt; 域名</p>
<h3 id="网段"><a href="#网段" class="headerlink" title="网段"></a>网段</h3><table>
<thead>
<tr>
<th>网段</th>
<th>最大网络数</th>
<th>ip范围</th>
<th>最大主机数</th>
<th>私有ip范围</th>
<th>子网掩码</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>2^7-2</td>
<td>1.0.0.0-126.255.255.255</td>
<td>2^24-2</td>
<td>10.0.0.0-10.255.255.255</td>
<td>255.0.0.0</td>
</tr>
<tr>
<td>B</td>
<td>2^14</td>
<td>128.0.0.0-191.255.255.255</td>
<td>2^16-2</td>
<td>172.16.0.0-127.31.255.255</td>
<td>255.255.0.0</td>
</tr>
<tr>
<td>C</td>
<td>2^21</td>
<td>192.0.0.0-223.255.255.255</td>
<td>2^8-2</td>
<td>192.168.0.0-192.168.255.255</td>
<td>255.255.255.0</td>
</tr>
</tbody></table>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>任务： 向两个主机中进程之间的通信提供通用的数据传输服务。<br>协议： TCP、UDP</p>
<ul>
<li>TCP 传输控制协议 提供面向连接的，可靠的数据传输服务。数据传输的单位是报文段。</li>
<li>UDP 用户数据报协议 提供无连接的，不可靠的数据传输服务。数据传输的单位是用户数据报。</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>任务： 通过应用进程间的交互来完成特定网络应用。<br>协议： 应用进程间通信和交互的规则。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>Domain Name System，域名系统。</p>
<h4 id="域名空间结构"><a href="#域名空间结构" class="headerlink" title="域名空间结构"></a>域名空间结构</h4><ul>
<li>. 便于分级管理，根域。</li>
<li>顶级域名/一级域名</li>
<li>二级域名</li>
<li>主机名</li>
</ul>
<h4 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h4><p>递归查询： 成功相应/失败相应。允许向其它DNS插叙<br>迭代查询： 服务器收到一次查询返回一次结果，结果不定。</p>
<h2 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h2><p>无线局域网 WLAN<br>无线城域网 WMAN<br>无线局域网标准 IEEE 802.11 凡使用802.11系列协议的局域网又称为WiFI。</p>
<h2 id="移动通信"><a href="#移动通信" class="headerlink" title="移动通信"></a>移动通信</h2><p>种类： 蜂窝移动通信（使用最多）、卫星移动通信、集群移动通信、无绳电话通信…<br>第一代蜂窝移动通信：1G<br>第二代蜂窝移动通信：2G…</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="TCP-IP连接"><a href="#TCP-IP连接" class="headerlink" title="TCP/IP连接"></a>TCP/IP连接</h3><p>三次握手，四次挥手</p>
<h3 id="常见协议端口"><a href="#常见协议端口" class="headerlink" title="常见协议端口"></a>常见协议端口</h3><ul>
<li>FTP 文件传输协议 20 21</li>
<li>SSH 安全shell协议 22</li>
<li>telnet 远程登录协议 23</li>
<li>DNS 域名系统 53</li>
<li>HTTP 超文本传输协议 80</li>
<li>HTTPS 43</li>
<li>SMTP 简单邮件传输协议 25</li>
<li>POP3 邮局协议3代 110</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>进制转换</title>
    <url>/2020/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="十进制-gt-二进制"><a href="#十进制-gt-二进制" class="headerlink" title="十进制 -&gt; 二进制"></a>十进制 -&gt; 二进制</h2><p>除二取余，余数倒序。</p>
<h2 id="二进制-gt-十进制"><a href="#二进制-gt-十进制" class="headerlink" title="二进制 -&gt; 十进制"></a>二进制 -&gt; 十进制</h2><p>按权展开相加。</p>
<h2 id="二进制-gt-八进制"><a href="#二进制-gt-八进制" class="headerlink" title="二进制 -&gt; 八进制"></a>二进制 -&gt; 八进制</h2><p>3位二进制数按权展开相加得到一位八进制数。</p>
<h2 id="八进制-gt-二进制"><a href="#八进制-gt-二进制" class="headerlink" title="八进制 -&gt; 二进制"></a>八进制 -&gt; 二进制</h2><p>八进制数同故宫除2取余法，得到二进制数，每个八进制为三个二进制，不足时在最左边补零。</p>
<h2 id="二进制-gt-十六进制"><a href="#二进制-gt-十六进制" class="headerlink" title="二进制 -&gt; 十六进制"></a>二进制 -&gt; 十六进制</h2><p>4位二进制数按权展开相加得到一位十六进制数。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一-定义"><a href="#一-定义" class="headerlink" title="一. 定义"></a>一. 定义</h2><pre><code>对其他对象提供一种代理以控制对这个对象的访问。
</code></pre>
<h2 id="二-原理"><a href="#二-原理" class="headerlink" title="二. 原理"></a>二. 原理</h2><pre><code>在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
动态代理实际上是JDK在运行期动态创建class字节码并加载的过程。
</code></pre>
<h2 id="三-JDK-静态代理"><a href="#三-JDK-静态代理" class="headerlink" title="三. JDK 静态代理"></a>三. JDK 静态代理</h2><pre><code>代理类与目标类实现同一个接口，调用目标对象的方法时，改为调用代理类的方法，通过代理类及反射来调用目标对象的方法，这样就可以通过在调用目标方法前后进行统一的逻辑处理。
在编译器就已经创建好代理对象。
</code></pre>
<ol>
<li>创建接口。</li>
<li>创建目标类。</li>
<li>创建代理类，通过构造方法注入目标类对象。</li>
<li>实例化目标类，传入目标类对象实例化代理类，调用代理类方法。<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4> 编译时产生class字节码文件，可以直接使用，效率高。    <h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4> 扩展性不足。<h2 id="四-JDK-动态代理"><a href="#四-JDK-动态代理" class="headerlink" title="四. JDK 动态代理"></a>四. JDK 动态代理</h2> 在运行期动态创建代理对象。<br> 采用JDK反射技术，基于接口，动态创建的代理类和目标类实现同一个接口，如果没有接口，则无法进行动态代理。<br> 动态代理实际上是JDK在运行期动态创建class字节码并加载的过程</li>
<li>创建接口。</li>
<li>创建目标类。</li>
<li>创建处理器，实现InvocationHandler接口，实现invoke方法。</li>
<li>通过Proxy.newProxyInstance()方法创建动态代理实例。<br> 参数1：接口的类加载器<br> 参数2：代理需要实现的接口数组<br> 参数3：InvocationHandler实例</li>
<li>调用动态代理实例的方法。<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4> 反射机制在生成类的过程中比较高效。<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4> 执行时通过发射调用目标类接口方法较慢。<br> 只能代理有接口实现的类。<h2 id="五-CGLIB代理"><a href="#五-CGLIB代理" class="headerlink" title="五. CGLIB代理"></a>五. CGLIB代理</h2> 采用底层字节码技术（asm），基于继承，因此无法代理final类，static方法，final方法。<br> // TODO 具体实现细节<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4> asm在生成类之后的相关代理类执行过程中比较高效。<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4> asm生成类的过程比较慢。</li>
</ol>
<p><em><strong>END</strong></em></p>
<ol>
<li><p>装饰器模式 （在不改变原有方法的基础上，对原有方法进行增强）</p>
<p>mybatis 二级缓存 CachingExecutor.java</p>
</li>
<li><p>代理模式 （在不改变原有方法的基础上，对原有方法进行增强）</p>
<p>spring aop</p>
</li>
<li><p>适配器模式 （接口的转换）</p>
<p>spring validation  SpringValidatorAdapter.java</p>
</li>
<li><p>工厂模式 （隐藏具体的实现细节，具体实现应该一系列步骤）</p>
<p>MyBatis  SqlSessionFactory.java</p>
</li>
</ol>
<p>代理模式 装饰器模式</p>
<ul>
<li>对设计模式调用的理解<br>之前对设计模式中调用方式，new个对象，然后再将这个对象作为参数在new对象，对这种调用方式不太理解，<br>今天突然想到，比如说要对方法做增强，那是谁想要增强呢—调用者，而且调用者也必然要知道要对那个对象做增强，做怎么样的增强，按这个理解这种调用方式就ok了<br>在运行时期，应该是通过配置，接口调用或者其他形式来实现的</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>设计模式-单例</title>
    <url>/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一个类只有一个实例，且该类能自行创建这个实例。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时才创建对象。线程不安全。</p>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次加载时创建对象。</p>
<h3 id="双重锁校验"><a href="#双重锁校验" class="headerlink" title="双重锁校验"></a>双重锁校验</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>volatile + synchronize 保证原子性、可见性、顺序性。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInner.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类只有第一次访问该类时才会加载，只访问外部类不会加载。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE,;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<br>减少内存开销，避免对资源的多重占用。</li>
<li>缺点<br>扩展困难，违背开闭原则。</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>懒汉模式最简单解决方式，在getInstance方法上添加synchronized，但是每次调用都会加锁。</li>
<li>类加载器不一致会导致所有形式都出现多个实例。自行指定类加载器，并指定同一个类加载器。</li>
<li>把所有方法和变量都定义为静态的，与单例区别。<ol>
<li>静态方法没有状态，单例有状态。</li>
<li>静态方法加载时全部加载到内存，单例方法调用时将该方法加载到内存。</li>
</ol>
</li>
<li>单例不适合继承。1. 构造器的访问权限； 2. 所有派生类的共享同一个实例变量。</li>
<li>违反单一职责。 负责管理自己的实例，且对外提供方法。</li>
<li>static修饰的意义：<ol>
<li>修饰方法，构造器私有化，只能通过static方法获取对象实例。</li>
<li>修饰变量，static引用会被存放在静态方法区中，避免被垃圾回收。否则，需要将单例对象的引用保存在另一个不会被回收的对象中。</li>
</ol>
</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>线程池、缓存、注册表、日志。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-单例</title>
    <url>/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。</p>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instance</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Instance instanceA = <span class="keyword">new</span> Instance();</span><br><span class="line">        Instance instanceB = <span class="keyword">new</span> Instance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Prototype prototypeA = <span class="keyword">new</span> Prototype();</span><br><span class="line">        Prototype prototypeB = prototypeA.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>实现Cloneable接口；</li>
<li>实现clone方法，调用super.clone();，修改返回值，处理异常；</li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<br>  隐藏创建新实例的复杂性。<br>  某些时候，复制对象比创建新对象更有效。</li>
<li>缺点<br>  对象的复制有时相当复杂。</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>深拷贝：显式调用嵌套对象的clone方法，嵌套对象都得实现cloneable接口。</li>
<li>使用子类clone对象时，子类得实现cloneable接口，父类不需要实现。</li>
<li>基类实现clone，可以将导出类转为基类进行clone，会保留导出类的属性。恢复时丢失类型。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-外观</title>
    <url>/2021/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SubSystemA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SubSystemB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SubSystemC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystemA subSystemA;</span><br><span class="line">    <span class="keyword">private</span> SubSystemB subSystemB;</span><br><span class="line">    <span class="keyword">private</span> SubSystemC subSystemC;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">(SubSystemA subSystemA, SubSystemB subSystemB, SubSystemC subSystemC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subSystemA = subSystemA;</span><br><span class="line">        <span class="keyword">this</span>.subSystemB = subSystemB;</span><br><span class="line">        <span class="keyword">this</span>.subSystemC = subSystemC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subSystemA.actionA();</span><br><span class="line">        subSystemB.actionA();</span><br><span class="line">        subSystemB.actionB();</span><br><span class="line">        subSystemC.actionC();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>外观</li>
<li>子系统</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<br>LoD的典型应用。<br>降低子系统与客户端的耦合度。<br>减少了客户处理的对象数目。<br>降低了大型软件系统中的编译依赖性。</li>
<li>缺点<br>不符合开闭原则。</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>没有封装子系统，只提供简化接口。客户端依然能访问系统完整的功能。</li>
<li>可以为子系统创建多个外观。</li>
<li>可以将子系统与客户端解耦。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK</li>
<li>Slf4j</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-工厂</title>
    <url>/2021/12/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<h2 id="简单工厂-静态工厂"><a href="#简单工厂-静态工厂" class="headerlink" title="简单工厂/静态工厂"></a>简单工厂/静态工厂</h2><p>将创建对象的操作解耦，以便扩展。<br>严格来说，不是一种设计模式。</p>
<h3 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        String type = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductA();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductB();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单工厂实现"><a href="#简单工厂实现" class="headerlink" title="简单工厂实现"></a>简单工厂实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product ac = SimpleFactory.createProduct(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ac.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul>
<li>简单工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<br>解耦。客户端只关系参数，而不关系产品的创建。</li>
<li>缺点<br>简单工厂使用了static，无法继承扩展。</li>
</ul>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。<br>相比于简单工厂，不同的工厂类创建产品的过程可能是不一样的。</p>
<h3 id="一般实现-1"><a href="#一般实现-1" class="headerlink" title="一般实现"></a>一般实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        String type = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductA();</span><br><span class="line">                <span class="comment">// product.doingA();</span></span><br><span class="line">                <span class="comment">// product.doingB();</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductB();</span><br><span class="line">                <span class="comment">// product.doingC();</span></span><br><span class="line">                <span class="comment">// product.doingA();</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> ProductA();</span><br><span class="line">        <span class="comment">// product.doingA();</span></span><br><span class="line">        <span class="comment">// product.doingB();</span></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> ProductB();</span><br><span class="line">        <span class="comment">// product.doingC();</span></span><br><span class="line">        <span class="comment">// product.doingA();</span></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> AFactory();</span><br><span class="line">        Product product = factory.createProduct();</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><ul>
<li>抽象工厂</li>
<li>具体工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>抽象出抽象工厂、抽象产品；</li>
<li>创建具体产品，具体工厂；</li>
<li>实现具体工厂创建产品；</li>
<li>修改客户端调用方式。</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<br>解耦，典型的解耦框架。<br>灵活性增强，扩展时只需添加新的工厂及产品，无需修改现有类。</li>
<li>缺点<br>产品过多会导致类很多。<br>抽象产品只能创建一种产品。（可用抽象工厂模式改善）</li>
</ul>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul>
<li>客户端从要知道创建哪个产品，改为要知道用哪个工厂创建产品，意义何在<br>对象的创建是复杂的过程，客户端只需知道产品是由谁创建的，而不需关系是怎么创建的。</li>
<li>工厂所创建对象的过程到底是不是复杂的<br>我觉得不一定是很复杂的过程，但总归不是new一个对象那么简单。如果只是new，那用简单工厂就可以实现了。而每个工厂创建的过程应该是不尽相同的，由此产生了差异化，从而需要抽象工厂的角色。</li>
<li>抽象工厂与抽象产品是同级的概念，其各自可以有多级，每有一级抽象工厂，就可以有一次抽象产品与之对应（也可以用上级抽象产品对应）。</li>
<li>具体工厂可以是一个简单工厂，直接new对象，或者通过类型new不同的对象。</li>
<li>只有一个具体工厂的情况<br>存在多个产品，如果后续还可能扩展，则使用工厂方法，如后续不太可能扩展，则使用简单工厂。<br>只有一个产品，那可以考虑使用其他的模式，或者不使用。</li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>提供一个创建一组相关或相互依赖对象的接口，且无须指定所要产品的具体类，得到同族的不同等级的产品。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>产品等级结构 产品的继承结构。</li>
<li>产品族 指由同一个工厂生产的，位于不同产品等级结构中的一组产品。</li>
</ul>
<h3 id="模式实现-1"><a href="#模式实现-1" class="headerlink" title="模式实现"></a>模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product1</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1A</span> <span class="keyword">extends</span> <span class="title">Product1</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1B</span> <span class="keyword">extends</span> <span class="title">Product1</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product2</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2A</span> <span class="keyword">extends</span> <span class="title">Product2</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2B</span> <span class="keyword">extends</span> <span class="title">Product2</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    Product1 product1;</span><br><span class="line">    Product2 product2;</span><br><span class="line">    Factory factory;</span><br><span class="line">    Product (Factory factory) &#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">constitute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.product1 = factory.createProduct1();</span><br><span class="line">        <span class="keyword">this</span>.product2 = factory.createProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Product1 <span class="title">createProduct1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Product2 <span class="title">createProduct2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product1 <span class="title">createProduct1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product1 product1 = <span class="keyword">new</span> Product1A();</span><br><span class="line">        <span class="comment">// product1.doingA();</span></span><br><span class="line">        <span class="comment">// product1.doingB();</span></span><br><span class="line">        <span class="keyword">return</span> product1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product2 <span class="title">createProduct2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product2 product2 = <span class="keyword">new</span> Product2A();</span><br><span class="line">        <span class="comment">// product2.doingA();</span></span><br><span class="line">        <span class="comment">// product2.doingB();</span></span><br><span class="line">        <span class="keyword">return</span> product2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product1 <span class="title">createProduct1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product1 product1 = <span class="keyword">new</span> Product1B();</span><br><span class="line">        <span class="comment">// product1.doingC();</span></span><br><span class="line">        <span class="comment">// product1.doingA();</span></span><br><span class="line">        <span class="keyword">return</span> product1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product2 <span class="title">createProduct2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product2 product2 = <span class="keyword">new</span> Product2B();</span><br><span class="line">        <span class="comment">// product2.doingC();</span></span><br><span class="line">        <span class="comment">// product2.doingA();</span></span><br><span class="line">        <span class="keyword">return</span> product2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product(<span class="keyword">new</span> AFactory());</span><br><span class="line">        product.constitute();</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">        product = <span class="keyword">new</span> Product(<span class="keyword">new</span> BFactory());</span><br><span class="line">        product.constitute();</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h3><ul>
<li>抽象工厂</li>
<li>具体工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
</ul>
<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><ol>
<li>从产品出抽象出相关或有依赖关系的产品族；</li>
<li>抽象出产品等级结构；</li>
<li>创建抽象工厂及具体工厂；</li>
<li>返回抽象工厂，创建产品族产品并使用。</li>
</ol>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<br>保证客户端始终只使用同一个产品族中的对象。</li>
<li>缺点<br>产品族扩展困难，要增加一个系列的某一产品，既要修改抽象工厂，又要修改具体工厂。</li>
</ul>
<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><ul>
<li>当系统中只存在一个等级结构的产品时，抽象工厂模式退化为工厂方法模式。</li>
<li>一组相关或相互依赖的对象，那么这些对象是怎么使用的呢？怎么才能表现出相关或相互依赖的特性？<br>在Head First中，有一个更大的对象，产品是对象的一部分，客户端实际需要的是一个大产品，而抽象工厂创建的是每个小产品，最后由大产品的容器进行组装返回给客户端。<br>还有其它形式？</li>
</ul>
<h2 id="工厂方法-与-抽象工厂"><a href="#工厂方法-与-抽象工厂" class="headerlink" title="工厂方法 与 抽象工厂"></a>工厂方法 与 抽象工厂</h2><ul>
<li>实现方式 工厂方法使用继承，抽象工厂使用组合。</li>
<li>使用方式 实例化一个工厂方法的工厂，由工厂创建产品对象；实例化一个抽象工厂的工厂，然后将它传入一个针对抽象类型的方法中，由该方法创建产品（使用工厂方法模式）并进行组装。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>Calender (工厂方法) ？<br>Collection (抽象工厂) ？</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-单例</title>
    <url>/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。<br>将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。</p>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public set ... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.setA(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        product.setB(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// product.set...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">(String a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">(String b)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Product <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        product.setA(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(String b)</span> </span>&#123;</span><br><span class="line">        product.setB(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.a(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        builder.b(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.construct();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>产品</li>
<li>抽象建造者</li>
<li>具体建造者</li>
<li>指挥者</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<br>  隐藏内部实现。<br>  实现可以被替换。</li>
<li>缺点<br>  需要具备更多的领域知识。</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>当一个类的构造函数参数个数超过4个，而且这些参数有些式可选的参数，考虑使用建造者模式。</li>
<li>可以使用不同的具体建造者来改变创建的顺序。</li>
<li>产品里的各个部分可以有不同的实现，由此扩展出多个具体建造者。 –类似于工厂方法模式。</li>
<li>与工厂模式的区别： 建造者注重产品细节、组成过程，工厂模式注重产品整体。</li>
<li>当只有一个产品，及顺序可以暴露给客户端时，即由客户端充当指挥者角色，可以省略抽象建造者，以内部类形式完成建造功能。</li>
<li>链式调用。每一步都返回对当前对象的引用。Lombok的支持。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>  StringBuilder</li>
<li>Mybatis<br>  SqlSessionFactoryBuilder</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-模板方法</title>
    <url>/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMethod1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMethod2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteMethod1 concreteMethod1 = <span class="keyword">new</span> ConcreteMethod1();</span><br><span class="line">        concreteMethod1.step1();</span><br><span class="line">        concreteMethod1.step2();</span><br><span class="line">        concreteMethod1.step3();</span><br><span class="line">        ConcreteMethod2 concreteMethod2 = <span class="keyword">new</span> ConcreteMethod2();</span><br><span class="line">        concreteMethod2.step1();</span><br><span class="line">        concreteMethod2.step2();</span><br><span class="line">        concreteMethod2.step3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">        step3();</span><br><span class="line">        hook();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">step1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hook</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 钩子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMethod1</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMethod2</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Template template = <span class="keyword">new</span> ConcreteMethod1();</span><br><span class="line">        template.templateMethod();</span><br><span class="line">        template = <span class="keyword">new</span> ConcreteMethod2();</span><br><span class="line">        template.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象模板 包括模板方法与基本方法，基本方法有抽象方法、具体方法、钩子方法。</li>
<li>具体实现</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>抽象算法骨架；</li>
<li>提取公关部分；</li>
<li>实现具体方法。</li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<br>封装了不变部分，扩展了可变部分。<br>父类提取了公共的部分代码，便于代码复用。</li>
<li>缺点<br>子类执行的结果会影响父类的结果，导致一种反向控制结构，提高了代码阅读的难度。</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>将变化的事物与保持不变的事物分离开。</li>
<li>钩子： 一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。</li>
<li>钩子功能：<ol>
<li>算法中可选的部分；</li>
<li>让子类由能力为抽象类做一些决定。</li>
</ol>
</li>
<li>将模板方法设置为final，避免子类修改顺序，将公共方法设置为final，避免子类重写。</li>
<li>策略实现的是整个算法，而模板方法实现的只是算法的一部分。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>Arrays.sort(…) (未使用继承，被实现为static方法，运行时和Comparable组合。)<br>InputStream.read(…)</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-比较与组合</title>
    <url>/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%AF%94%E8%BE%83%E4%B8%8E%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="工厂方法-VS-抽象工厂"><a href="#工厂方法-VS-抽象工厂" class="headerlink" title="工厂方法 VS 抽象工厂"></a>工厂方法 VS 抽象工厂</h2><ul>
<li>抽象工厂创建的是一系列相关或相互依赖的产品，工厂方法创建的是单个产品。</li>
</ul>
<h2 id="工厂方法-VS-建造者"><a href="#工厂方法-VS-建造者" class="headerlink" title="工厂方法 VS 建造者"></a>工厂方法 VS 建造者</h2><ul>
<li>工厂方法更关注对象整体，建造者更关注创建的细节和顺序。</li>
</ul>
<h2 id="适配器-VS-装饰器"><a href="#适配器-VS-装饰器" class="headerlink" title="适配器 VS 装饰器"></a>适配器 VS 装饰器</h2><ul>
<li>都是包装对象。</li>
<li>适配器改变接口，而装饰器不改变接口。</li>
<li>装饰器扩展功能，而适配器负责转发。</li>
</ul>
<h2 id="代理-VS-装饰器"><a href="#代理-VS-装饰器" class="headerlink" title="代理 VS 装饰器"></a>代理 VS 装饰器</h2><h2 id="模板方法-VS-策略"><a href="#模板方法-VS-策略" class="headerlink" title="模板方法 VS 策略"></a>模板方法 VS 策略</h2><ul>
<li>策略使用组合，模仿方法使用继承。</li>
<li>策略针对的是整个算法，模仿方法实现的只是算法的一部分。</li>
</ul>
<h2 id="装饰器-工厂"><a href="#装饰器-工厂" class="headerlink" title="装饰器 + 工厂"></a>装饰器 + 工厂</h2><h2 id="装饰器-建造者"><a href="#装饰器-建造者" class="headerlink" title="装饰器 + 建造者"></a>装饰器 + 建造者</h2><h2 id="工厂-策略"><a href="#工厂-策略" class="headerlink" title="工厂 + 策略"></a>工厂 + 策略</h2>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-策略</title>
    <url>/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>指对象有某个行为，但是在不同的场景中，该行为有不同的算法实现。<br>行为型模式。</p>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (ca) &#123;</span><br><span class="line">            result = computeA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            result = computeB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = computeC();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeA</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeB</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的条件，调用不同的方法。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (ca) &#123;</span><br><span class="line">            result = computeA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            result = computeB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = computeC();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeA</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeB</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">        <span class="keyword">int</span> result = strategy.compute();</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context c = <span class="keyword">new</span> Context(<span class="keyword">new</span> StrategyA());</span><br><span class="line">        <span class="comment">// 根据条件设置具体的策略</span></span><br><span class="line">        <span class="keyword">if</span> (ca) &#123;</span><br><span class="line">            c.setStrategy(<span class="keyword">new</span> StrategyA());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            c.setStrategy(<span class="keyword">new</span> StrategyB());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.setStrategy(<span class="keyword">new</span> StrategyC());</span><br><span class="line">        &#125;</span><br><span class="line">        c.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象出统一接口，根据不同的条件使用对应的对象，调用接口的方法。<br>if可以使用switch代替，也可以将由工厂模式完成，实现工厂+策略的组合使用。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>策略接口</li>
<li>策略具体实现类</li>
<li>容器类/上下文</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>将调用的不同方法抽象出策略接口</li>
<li>将不同方法调整为具体策略实现类</li>
<li>将策略接口注入到之前的上下文对象中</li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<br>算法、行为可以动态改变<br>扩展性良好，只需新增策略类<br>可以避免if判断</li>
<li>缺点<br>需要暴露所有策略类<br>每个策略都会产生一个新类，造成类过多</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>概念中的算法与行为，行为对应的是接口的方法，而接口的方法是不变的，即行为是不变的，变的只是行为的实现，即算法。</li>
<li>容器类存在的意义<ol>
<li>客户端与策略类解耦，改变、新增策略只需修改客户端代码。</li>
<li>根据定义，对象有某个行为，该对象应为上下文对象，而不是客户端对象，客户端只是调用上下文对象的方法，而不关心具体实现。</li>
</ol>
</li>
<li>客户端根据条件设置对应的策略，所以客户端需要知道所有的策略实现。</li>
<li>容器类与策略接口的关系应根据情况确定（持有（能否修改），参数传递）。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>Comparator - Collections<br>RejectedExecutionHandler - ThreadPoolExecutor</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-装饰器</title>
    <url>/2021/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorate</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorate</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Component <span class="title">getComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorateA</span> <span class="keyword">extends</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorate</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do ...</span></span><br><span class="line">        getComponent().action();</span><br><span class="line">        <span class="comment">// do ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorateB</span> <span class="keyword">extends</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorate</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(component);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do ...</span></span><br><span class="line">    <span class="keyword">super</span>.action();</span><br><span class="line">    <span class="comment">// do ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>抽象构件</li>
<li>具体构件</li>
<li>抽象装饰者 继承自抽象构件。</li>
<li>具体装饰者</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<br>不修改现有类的情况下，扩展现有类功能。<br>完全遵循开闭原则。</li>
<li>缺点<br>会增加许多子类，过度使用增加程序复杂性。</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>利用继承达到类型匹配，而不是利用继承获得行为。</li>
<li>可以扩展：不只是增强功能，而且可以感知其它装饰器的存在。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>Java IO</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-适配器</title>
    <url>/2021/12/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> <span class="keyword">extends</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.action();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>目标 客户端所期望的接口。</li>
<li>适配者 </li>
<li>适配器 </li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<br>复用了现存的类。<br>将目标类与适配者解耦。<br>符合开闭原则。</li>
<li>缺点<br>增加系统复杂性。</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>实现一个适配器所需要进行的工作，与目标接口的大小成正比。</li>
<li>按照定义，此处的接口并不是Java中的interface，而是具体的实现类。其接口的功能已经实现。如果未实现，此处只需要实现即可，不需要适配。</li>
<li>对象适配器：使用组合实现。类适配器：使用多重继承（Java中不支持）。<br>类适配器的意义在于，使用多重继承，就可以不用在适配器中定义不需要重写的方法，而这是对象适配器必须进行的工作。<br>如果使用内部类实现多重继承，内部类应继承Target，外围类继承Adaptee，而这时，仍需要在内部类中定义Adaptee中的所有方法，调用其外部类的父类的实现。而这样做的话，和对象适配器就没有什么差别乐。</li>
<li>双向适配器。实现两个接口（Java中的interface），将Target和Adaptee都作为成员变量，并实现所有方法。</li>
<li>适配器不是在设计时添加的，而是解决问题的一种方式。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>根据适配器定义，在JDK中不应有实现。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/12/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式：可复用面向对象软件的基础。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>创建型 将对象的创建与使用分离。</li>
<li>结构型 将类或对象按某种布局组成更大的结构。</li>
<li>行为型 类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务。</li>
</ul>
<h2 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h2><h3 id="依赖（Dependency）-use-a"><a href="#依赖（Dependency）-use-a" class="headerlink" title="依赖（Dependency） use a"></a>依赖（Dependency） use a</h3><p>表示一个类依赖于另一个类。具体形式为局部变量，静态方法调用，方法参数。<br>类图：虚线 + 普通箭头，从主类指向被依赖类。</p>
<h3 id="关联（Association）-has-a"><a href="#关联（Association）-has-a" class="headerlink" title="关联（Association） has a"></a>关联（Association） has a</h3><p>表现为全局变量。可以是单向，也可以是双向。<br>类图：实线 + 普通箭头，从主类指向被关联类。</p>
<h3 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h3><p>强的关联关联。强调一个是整体，一个是部分，但不是组成部分。<br>类图：空心菱形 + 实线 + 普通箭头，从主类指向被关联类。</p>
<h3 id="组合（Composition）-contain-a"><a href="#组合（Composition）-contain-a" class="headerlink" title="组合（Composition） contain a"></a>组合（Composition） contain a</h3><p>比聚合关系强的关系。强调部分是整体的组成部分，部分和整体拥有一致的生命周期。<br>类图：实心菱形 + 实线 + 普通箭头，从主类指向被关联类。</p>
<h3 id="泛化（Generalization）-is-a"><a href="#泛化（Generalization）-is-a" class="headerlink" title="泛化（Generalization） is a"></a>泛化（Generalization） is a</h3><p>表现为继承关系。具体形式为类与类之间的继承管理，接口与接口之间的继承关系。<br>类图：实线 + 三角空心箭头，从子类指向父类。</p>
<h3 id="实现-（Realization）-a-kind-of"><a href="#实现-（Realization）-a-kind-of" class="headerlink" title="实现 （Realization） a kind of"></a>实现 （Realization） a kind of</h3><p>表现为实现关系。具体形式为类对接口的实现关系。<br>类图：虚线 + 三角空心箭头，从实现类指向接口。</p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 OCP"></a>开闭原则 OCP</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Open-Close Principle。<br>软件实体应当对扩展开放，对修改关闭。（Software entites should be open for extension, but closed for modification）</p>
</blockquote>
<p>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>对软件测试的影响。</li>
<li>可以提高代码的可复用性。</li>
<li>可以调高软件的可维护性。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p>
<h3 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则 LSP"></a>里氏替换原则 LSP</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Liskov(提出者) Substitution Principle。<br>继承必须确保超类所拥有的性质在子类中仍然成立。（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）</p>
</blockquote>
<p>是继承复用的基础，它反映了基类与子类之间的关系。是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li>里氏替换原则是实现开闭原则的重要方式之一。</li>
<li>克服了继承中重写父类造成的可复用性变差的缺点。</li>
<li>是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li>
<li>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松。</li>
<li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li>
</ul>
<h3 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 DIP"></a>依赖倒置原则 DIP</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Dependence Inversion Principle。<br>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）</p>
</blockquote>
<p>是实现开闭原则的重要途径之一。</p>
<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ul>
<li>依赖倒置原则可以降低类间的耦合性。</li>
<li>依赖倒置原则可以提高系统的稳定性。</li>
<li>依赖倒置原则可以减少并行开发引起的风险。</li>
<li>依赖倒置原则可以提高代码的可读性和可维护性。</li>
</ul>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>通过面向接口编程来降低类间的耦合性。</p>
<ul>
<li>每个类尽量提供接口或抽象类，或者两者都具备。</li>
<li>变量的声明类型尽量是接口或者是抽象类。</li>
<li>任何类都不应该从具体类派生。</li>
<li>使用继承时尽量遵循里氏替换原则。</li>
</ul>
<h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 SRP"></a>单一职责原则 SRP</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Single Responsibility Principle。<br>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。（There should never be more than one reason for a class to change）</p>
</blockquote>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li>
<li>提高类的可读性。复杂性降低，自然其可读性会提高。</li>
<li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li>
<li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p>
<h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 ISP"></a>接口隔离原则 ISP</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Interface Segregation Principle。<br>客户端不应该被迫依赖于它不使用的方法。（Clients should not be forced to depend on methods they do not use）<br>一个类对另一个类的依赖应该建立在最小的接口上。（The dependency of one class to another one should depend on the smallest possible interface）</p>
</blockquote>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li>
<li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li>
<li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li>
<li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li>
<li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li>
</ul>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><ul>
<li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li>
<li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li>
<li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
</ul>
<h3 id="迪米特法则-最小知道原则-LoD"><a href="#迪米特法则-最小知道原则-LoD" class="headerlink" title="迪米特法则/最小知道原则 LoD"></a>迪米特法则/最小知道原则 LoD</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Law of Demeter。<br>只与你的直接朋友交谈，不跟“陌生人”说话。（Talk only to your immediate friends and not to strangers）</p>
</blockquote>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低了类之间的耦合度，提高了模块的相对独立性。</li>
<li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li>
</ul>
<h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><p>从依赖者的角度来说，只依赖应该依赖的对象。<br>从被依赖者的角度说，只暴露应该暴露的方法。</p>
<ul>
<li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li>
<li>在类的结构设计上，尽量降低类成员的访问权限。</li>
<li>在类的设计上，优先考虑将一个类设置成不变类。</li>
<li>在对其他类的引用上，将引用其他对象的次数降到最低。</li>
<li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li>
<li>谨慎使用序列化（Serializable）功能。</li>
</ul>
<h3 id="合成复用原则-CRP"><a href="#合成复用原则-CRP" class="headerlink" title="合成复用原则 CRP"></a>合成复用原则 CRP</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>Composite Reuse Principle。<br>在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
</blockquote>
<p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>
<li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>
</ul>
<h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>log</title>
    <url>/2021/09/03/%E9%A1%B9%E7%9B%AE/log/</url>
    <content><![CDATA[<ol>
<li><p>log path的配置，一般只输出指定路径的日志，那mybatis的日志和启动时打印的日志为什么不在此列</p>
</li>
<li><p>判断当前日志是否可用？？？</p>
</li>
<li><p>日志Facade<br> jcl commons-logging (已停止更新)</p>
<pre><code> 默认使用log4j的实现，找不到则使用jul的实现。
</code></pre>
<p> slf4j (simple log facade for java)</p>
</li>
<li><p>日志实现<br> jul (java.util.logging jdk1.4 开始提供)<br> log4j<br> logback</p>
<pre><code> logback-core
 logback-classic
 logback-access
</code></pre>
<p> log4j2</p>
<pre><code> log4j-api
 log4j-core
</code></pre>
</li>
<li><p>集成使用<br> 部分集成使用需要添加额外适配包</p>
<ol>
<li>jcl+log4j2<br> log4j-jcl</li>
<li>jcl+logback<br> jcl-over-slf4j</li>
<li>slf4j+jul<br> slf4j-jdk14</li>
<li>slf4j+log4j<br> slf4j-log4j12</li>
<li>slf4j+log4j2<br> log4j-slf4j-impl</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>城轨信号</title>
    <url>/2020/09/04/%E9%A1%B9%E7%9B%AE/%E5%9F%8E%E8%BD%A8%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="城市轨道交通信号系统"><a href="#城市轨道交通信号系统" class="headerlink" title="城市轨道交通信号系统"></a>城市轨道交通信号系统</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>信号</li>
<li>闭塞 为保证行车安全，而将列车正在运行、停放的线路区段予以“封闭”，不允许其他列车进入此区段，以防止对向列车、后续列车的正面冲突或追尾事故的发生。</li>
<li>联锁 联锁是指为保证行车安全，而将轨道交通线路中的所有信号机、进路及道岔等相对独立的信号设备构成一种相互制约、互为控制的连带环扣关系，即“联锁”关系。</li>
<li>ATC系统 根据与先行列车之间的距离和进路条件，在车内连续地显示出推荐的速度信息，或按设定的运行条件达到该推荐速度的距离信息，根据上述信息，列车自动地控制运行速度，进行超速防护，以达到自动调整行车间隔的目的，并实现列车在车站的定位停车。</li>
<li>IBP 综合后备盘，Integrated Backup Panel。</li>
<li>HMI 人机接口/人机界面，Human Machine Interface。</li>
<li>LOW 现场操作工作站，Local Operator Workstation。</li>
</ul>
<h3 id="信号系统"><a href="#信号系统" class="headerlink" title="信号系统"></a>信号系统</h3><p>狭义的信号系统是信号（显示）、闭塞、联锁三者之间相互制约、相互配合而成的统一体，而广义的信号系统是通信和信号两个系统的集合，建立在可靠的通信网络基础上的，因此信号系统功能更加全面和完善。</p>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><ul>
<li>信号 手势 -》 信号机 -》 车载信号</li>
<li>闭塞 人工闭塞 -》 轨道电路闭塞 -》 半自动闭塞 -》 自动闭塞 -》 移动闭塞</li>
<li>联锁 机械联锁 -》 电机联锁 -》 电气联锁 -》 电气集中联锁 -》 计算机联锁</li>
</ul>
<h3 id="城市轨道交通信号系统-1"><a href="#城市轨道交通信号系统-1" class="headerlink" title="城市轨道交通信号系统"></a>城市轨道交通信号系统</h3><p>城市轨道交通信号系统是保证列车运行安全，实现行车指挥和列车运行现代化，提高运输效率的关键系统设备。城市轨道交通信号系统是“信号（显示）”、“联锁”、“闭塞”的总称，是由各类信号显示、轨道电路（计轴）、道岔转辙装置等主体设备及其他有关附属设施构成的一个完整体系。<br>城市轨道交通信号是在铁路信号系统的基础上发展而来，对安全性有着更高的要求，科技含量也更高。城市轨道交通信号系统通常由列车运行自动控制系统（ATC）和车辆段信号控制系统两大部分组成，用于列车进路控制、列车间隔控制、调度指挥、信息管理、设备监测及维护管理，由此构成了一个高效的综合自动化系统。</p>
<h3 id="ATC系统分类"><a href="#ATC系统分类" class="headerlink" title="ATC系统分类"></a>ATC系统分类</h3><p>该系统由三个主要子系统组成：计算机联锁系统（CI）、ATP/ATO系统、列车自动监督（ATS）系统。</p>
<ul>
<li>按闭塞 固定闭塞、准移动闭塞、移动闭塞。</li>
<li>按机车信号传输方式 连续式（轨道电路、轨间电缆、无线）、点式。</li>
<li>按各系统设备所处地域 控制中心子系统、车站及轨旁子系统、车载设备子系统。</li>
</ul>
<h3 id="计算机联锁系统"><a href="#计算机联锁系统" class="headerlink" title="计算机联锁系统"></a>计算机联锁系统</h3><p>计算机联锁系统是负责处理进路内的道岔、信号机、轨道电路之间安全联锁关系用以保证行车安全的系统，联锁系统通过接受ATS或者操作员的控制指令，向ATP、ATS输出联锁信息。<br>计算机联锁系统能在规定的联锁条件和规定的时序下对进路、信号和道岔实行控制，满足联锁的技术条件和功能。<br>联锁系统功能： 1. 敌对进路； 2. 侧防； 3. 为后续列车提供信号及防护。</p>
<h3 id="ATP-ATO系统"><a href="#ATP-ATO系统" class="headerlink" title="ATP/ATO系统"></a>ATP/ATO系统</h3><p>该系统主要分为：轨旁子系统（WCU)和车载子系统（OBCU）。<br>轨旁子系统包括：道岔、计轴、信号机、应答器、AP。<br>ATP车载设备包括: 安装在列车上的车载计算机单元（OBCU）。<br>控制系统结构分布具体轨旁控制层（轨旁ATP）、车载应用层（ATP和ATO）和轨道通信层（计轴、应答器、无线系统）。</p>
<h3 id="ATS系统"><a href="#ATS系统" class="headerlink" title="ATS系统"></a>ATS系统</h3><p>ATS可自动或人工控制行车，同时向行车调度员和外部系统提供信息。<br>ATS系统由下述主要功能部件组成：<br>ATS一般包含位于OCC的中央ATS和位于车站的站级ATS。<br>1.基本组件：操作员控制台<br>2.自动组件：列车自动跟踪系统、自动进路排列系统、列车自动调整系统<br>3.调度组件：时刻表管理、时刻表构建<br>4.分析及培训组件：服务及诊断、记录和回放功能（用于中央操作控制系统）、存档（用于中央操作控制系统）、模拟培训。</p>
<h2 id="数字孪生（Digital-Twin）"><a href="#数字孪生（Digital-Twin）" class="headerlink" title="数字孪生（Digital Twin）"></a>数字孪生（Digital Twin）</h2><p>数字孪生是充分利用物理模型、传感器更新、运动历史等数据，集成多学科、多物理量、多尺度、多概率的仿真过程，在虚拟空间中完成映射，从而反映相对应的实体设备的全生命周期过程。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul>
<li>物理空间的实体产品。</li>
<li>虚拟空间的虚拟产品。</li>
<li>物理空间和虚拟空间之间的数据和信息交互接口。</li>
</ul>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>基于数字化模型进行各类仿真、分析、数据积累、挖掘，甚至人工智能的应用，确保与现实物理系统的适用性。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>数字孪生 + 3D仿真（VR + AR） + 物联网。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>SpringBoot + Mybatis、Mysql、Vue、WebSocket、3JS、Modbus。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>仿真</li>
<li>实训</li>
<li>剧本</li>
<li>绘图</li>
<li>运行图</li>
<li>派班计划</li>
<li>权限</li>
</ul>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ul>
<li>栈<br>车辆段回库、出库</li>
<li>队列<br>运行图车次，派班计划</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>模板方法<br>Simulation.run()</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>工作流</title>
    <url>/2020/09/04/%E9%A1%B9%E7%9B%AE/%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<h2 id="BPS"><a href="#BPS" class="headerlink" title="BPS"></a>BPS</h2><ul>
<li>EOS Studio 流程集成开发环境</li>
<li>EOS Server 流程运行环境</li>
<li>EOS Governor 流程治理工具</li>
</ul>
<h3 id="EOS-Studio"><a href="#EOS-Studio" class="headerlink" title="EOS Studio"></a>EOS Studio</h3><p>面向构件应用的开发。</p>
<ul>
<li>业务逻辑构件</li>
<li>展现逻辑构件</li>
<li>页面构件</li>
<li>数据逻辑构件</li>
<li>运算逻辑构件</li>
<li>工作流构件<ul>
<li>连接线 表示从一个活动执行到另一个活动的顺序。设置连接线的条件表达式，通过条件决定流程的流转。</li>
<li>开始</li>
<li>结束</li>
<li>人工活动 </li>
<li>自动活动 无需人工干预，系统自动执行的活动。</li>
<li>子流程 一种特殊的活动，指向一个流程，表示当流程运行到此处时，启动另外一个或多个流程。</li>
<li>路由 一种逻辑活动，在流程中起承上启下的作用，活动本身并不执行任何具体的任务。</li>
</ul>
</li>
</ul>
<h3 id="EOS-Server"><a href="#EOS-Server" class="headerlink" title="EOS Server"></a>EOS Server</h3><p>支撑SOA应用和服务的运行环境。<br>由SCA容器、构件运算环境、页面流引擎、逻辑流引擎、系统服务、基础服务等核心模块组成。</p>
<h2 id="流程引擎"><a href="#流程引擎" class="headerlink" title="流程引擎"></a>流程引擎</h2><p>EOS工作流最重要的组成部分是它的核心调度算法。由事件来驱动流程运转的引擎，数据库只是把引擎运转前后的状态持久化。<br>事件驱动优点：解耦；异步。</p>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><ul>
<li>会签<ul>
<li>按个数</li>
<li>按百分比</li>
</ul>
</li>
<li>子流程</li>
<li>参与者 机构、岗位、角色、人员、流转规则</li>
<li>流转历史</li>
<li>驳回</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>流程定义 WFProcessDefine</li>
<li>活动定义 WFActivityDefine</li>
<li>流程实例 WFProcessInst</li>
<li>活动实例 WFActivityInst</li>
<li>工作项 WFWorkItem</li>
<li>参与者 WFWIParticipant</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>课程</title>
    <url>/2021/11/05/%E9%A1%B9%E7%9B%AE/%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1上"><a href="#1上" class="headerlink" title="1上"></a>1上</h2><ul>
<li>计算机科学与技术导论</li>
<li>高数Ⅰ</li>
<li>程序设计（C）</li>
</ul>
<h2 id="1下"><a href="#1下" class="headerlink" title="1下"></a>1下</h2><ul>
<li>高数Ⅱ</li>
<li>线性代数</li>
<li>面向对象程序设计（C++）</li>
</ul>
<h2 id="2上"><a href="#2上" class="headerlink" title="2上"></a>2上</h2><ul>
<li>概率统计</li>
<li>离散数学</li>
<li>电子技术基础</li>
<li>数据结构（C）</li>
<li>Java程序设计</li>
<li>汇编语言程序设计</li>
</ul>
<h2 id="2下"><a href="#2下" class="headerlink" title="2下"></a>2下</h2><ul>
<li>统一建模语言（UML）</li>
<li>数据库系统</li>
<li>C#程序设计</li>
<li>计算机网络</li>
<li>数字图像处理（Matlab）</li>
<li>算法设计与分析</li>
<li>智能信息处理（Fortran？）</li>
</ul>
<h2 id="3上"><a href="#3上" class="headerlink" title="3上"></a>3上</h2><ul>
<li>J2EE架构与开发</li>
<li>Unix系统原理与应用</li>
<li>Web技术与应用</li>
<li>操作系统</li>
<li>计算机组成原理</li>
<li>软件工程</li>
<li>信息安全概论</li>
</ul>
<h2 id="3下"><a href="#3下" class="headerlink" title="3下"></a>3下</h2><ul>
<li>编译原理</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>项目经验</title>
    <url>/2020/09/04/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><ul>
<li><p>琏课堂 </p>
<ul>
<li>项目时间 2018.5 ~ …</li>
<li>参与时间 2018.8 ~ 2019.11.29</li>
<li>项目描述</li>
<li>主要职责</li>
</ul>
</li>
<li><p>PIS 到站提醒 </p>
<ul>
<li>项目时间 2019.4.17 ~ 2020.4.17</li>
<li>参与时间 2019.4.17 ~ 2019.11.26</li>
<li>项目描述
  </li>
</ul>
</li>
<li><p>军乐保小程序  </p>
<ul>
<li>项目时间 2019.9.17 ~ 2019.11.25 </li>
<li>参与时间 2019.9.17 ~ 2019.11.25 </li>
<li>项目描述</li>
<li>主要职责</li>
</ul>
</li>
<li><p>东电云 </p>
<ul>
<li>项目时间 2019.9.9 ~ 2020.7.17</li>
<li>参与时间 2019.9.9 ~ 2020.7.17</li>
<li>项目描述</li>
<li>主要职责</li>
</ul>
</li>
<li><p>电厂仿真</p>
<ul>
<li>项目时间 2020.5.9 ~ …</li>
<li>参与时间 2020.5.9 ~ …</li>
<li>项目描述</li>
<li>主要职责</li>
</ul>
</li>
<li><p>OA/CRM/ERP<br>基础功能模块： 用户管理，权限管理<br>OA（Office Automation）: 办公自动化<br>流程<br>CRM（Customer Relationship Mnagement）：客户关系管理<br>客户管理，联系人管理，项目管理，权限管理，任务管理<br>ERP（Enterprise Resource Planning）: 企业资源计划<br>物资资源管理（物流），人力资源管理（人流），财务资源管理（财流），信息资源管理（信息流）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>类加载</title>
    <url>/2021/12/16/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="类的声明周期"><a href="#类的声明周期" class="headerlink" title="类的声明周期"></a>类的声明周期</h2><p>加载 -&gt; 连接（验证 -&gt; 准备 -&gt; 解析） -&gt; 初始化 -&gt; 使用 -&gt; 卸载。<br>类型的加载、连接、初始化过程都是在程序运行期间完成的。</p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>加载、连接、初始化 三个阶段是连续完成的，所以合成为类加载或类初始化。</p>
<h2 id="各阶段功能"><a href="#各阶段功能" class="headerlink" title="各阶段功能"></a>各阶段功能</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>将class文件加载进方法区，在堆上创建class对象。class对象拥有访问方法区中数据的接口。<br>加载来源：</p>
<ul>
<li>从本地系统中直接加载。</li>
<li>从网络上下载.class文件</li>
<li>从zip、jar等归档文件中加载.class文件。</li>
<li>从专用数据库提取.class文件。</li>
<li>将java源文件动态编译为.class文件。</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>文件格式验证、元数据验证、字节码验证、符号引用验证。<br>不是必须的，可通过 -Xverifynone 关闭验证。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为static变量分配内存，并初始化为该数据类型的默认值。<br>如果是final修饰的字面量，则初始化为指定值。并放入常量池。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将符号引用替换为直接引用。<br>为了支持动态绑定，可以在初始化之后在解析。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>一般来说，当对类的是首次主动使用的时候才会导致类的初始化。<br>初始化阶段对static变量赋予指定值。<br>主动使用情况：</p>
<ul>
<li>new创建对象实例。</li>
<li>访问static变量或赋值。（在编译期把结果放入常量池的 static final 字段除外。）</li>
<li>调用static或方法。</li>
<li>反射，如Class.forName()。</li>
<li>初始化子类，父类也会被初始化。</li>
<li>Java虚拟机启动时被标明为启动类的类、Main方法所在的类。</li>
</ul>
<h3 id="声明周期结束"><a href="#声明周期结束" class="headerlink" title="声明周期结束"></a>声明周期结束</h3><ul>
<li>执行了System.exit()方法。</li>
<li>程序正常执行结束。</li>
<li>程序在执行过程中遇到了异常或错误而异常终止。</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止。</li>
</ul>
<h2 id="接口的加载"><a href="#接口的加载" class="headerlink" title="接口的加载"></a>接口的加载</h2><p>类加载会首先初始化其父类，但是接口只初始化自身，父接口只有用到时才去初始化。</p>
<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>对于子类直接访问父类static变量的情况，会初始化父类，但不会初始化子类。<br>子类直接访问父类static变量，导致父类初始化，说明子类知道这个变量是父类的，即子类的数据已被加载。那就是说子类加载了，但是没有初始化。所以在这种情况下， 加载、连接、初始化 就不是连续进行的了？？？</p>
<h2 id="预加载与按需加载"><a href="#预加载与按需加载" class="headerlink" title="预加载与按需加载"></a>预加载与按需加载</h2><p>Java运行所需要的基本类采用预加载方式，JRE运行时全部加载到内存中。<br>程序中需要使用的自定义类使用按需加载，需要用到的时候再加载。减少内存消耗。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><ul>
<li>委托：加载一个类的请求西安交给父类加载器，如果父类加载器找不到或不能加载时，再有子类加载器加载。</li>
<li>可见性：子类的加载器可以看见父类加载器加载的类，而父类加载器看不到子类加载器加载的类。</li>
<li>单一性：一个类只被加载一次。</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>引导类加载器</li>
<li>扩展类加载器</li>
<li>应用类加载器</li>
<li>自定义类加载器： 扩展java虚拟机动态加载类的机制。如加密字节码解密。</li>
</ul>
<h2 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h2><ul>
<li>隐式加载/静态加载 new、static、子类。</li>
<li>显示加载/动态加载 Class.forName()、 ClassLoader.loadClass()。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>运行时数据区</title>
    <url>/2021/12/16/Java/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>堆、方法区、程序寄存器、虚拟机栈、本地方法栈。<br>其中 堆、方法区是线程共享的，其它是每个线程各自的数据。</p>
<h2 id="程序寄存器"><a href="#程序寄存器" class="headerlink" title="程序寄存器"></a>程序寄存器</h2><p>每个CPU核心循环执行线程，使用程序寄存器保存当前方法执行的地方，以便下次执行。<br>唯一不会内存溢出的区域。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>保存方法调用栈，每次Java方法调用产生一个栈帧入栈，方法调用结束出栈。<br>每个栈帧包括 局部变量表、操作数栈、动态链接、方法出口。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>编译时确定大小。<br>非static方法第一个参数为调用对象。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>用来准备调用方法参数以及接受方法的返回结果。 ？？？<br>用来处理操作数操作符 ？？？</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>用来完成运行时绑定操作。 – 实现？？？</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈功能一致，但针对的时native方法。<br>在HotSpot虚拟机中，虚拟机栈与本地方法栈合二为一。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>字面量等等。<br>永久代。<br>属于类信息的一部分，还是单独保存？？？</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>内存最大的区域，垃圾回收器主要作用的地方。<br>分为新生代（Eden + From Survivor0 + To Survivor1）、老年代。</p>
<h3 id="JVM常见参数"><a href="#JVM常见参数" class="headerlink" title="JVM常见参数"></a>JVM常见参数</h3><ul>
<li>-Xms： 堆容量初始大小。</li>
<li>-Xmx： 堆最大大小。</li>
<li>-Xmn： 新生代容量大小。</li>
<li>-XX:SurvivorRatio: 设置新生代各部分比例。默认为8：1：1。</li>
</ul>
<h2 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h2><p>将方法区改为MetaSpace。<br>把方法区中的字符串常量池保存到堆中。<br>去掉永久代的概念。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>AQS</title>
    <url>/2020/07/27/Java/%E5%B9%B6%E5%8F%91/AQS/</url>
    <content><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AbstractQueuedSyncrinizer<br>通过双向链表方式实现。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>CountDownLatch</li>
<li>Semaphore</li>
<li>CyclicBarrier</li>
<li>ReentrantLock</li>
<li>Condition</li>
<li>FutureTask</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>CAS</title>
    <url>/2020/07/23/Java/%E5%B9%B6%E5%8F%91/CAS/</url>
    <content><![CDATA[<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>Compare And Swap。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>CAS是一种无锁算法，CAS有3个操作数，主内存值V，工作内存值A，要修改的新值B。当且仅当A和V相同时，将主内存值V改为B，否则什么都不做。  <br>valueOffset: 主内存地址的偏移量。  <br>value：使用volatile关键字保证可见性。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>ABA问题。JDK1.5提供了AtomicStampedReference类来解决，纪录值的版本。</li>
<li>循环时间长开销大。长时间不成功会一直自旋。</li>
<li>只能保证一个共享变量的原子操作。JDK1.5提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里进行CAS操作。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Executor</title>
    <url>/2020/09/10/Java/%E5%B9%B6%E5%8F%91/Executor/</url>
    <content><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java5引入，用于控制线程的启动、执行和关闭。  <br>基于生产者-消费者模式实现。</p>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><h3 id="Executor-1"><a href="#Executor-1" class="headerlink" title="Executor"></a>Executor</h3><p>接口，定义了线程池执行的方法，接收Runnale作为参数，无放回值。</p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>ExecutorService的子类接口，定义了线程池的生命周期。定义了submit方法，返回Future对象。及其它方法。</p>
<h3 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h3><p>ExecutorService 的抽象实现类，对ExecutorService中定义的方法做了默认的实现。</p>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>工具类，提供了一些常用的线程池，常用的线程池创建线程的工厂类。</p>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>常用的线程池，继承自AbastractExecutorService</p>
<h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p>可定时、周期执行的线程池，继承自ThreadPoolExecutor</p>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>可完成拆分合并的线程池，继承自AbstractExecutorService</p>
<h2 id="Executor-VS-Thread"><a href="#Executor-VS-Thread" class="headerlink" title="Executor VS Thread"></a>Executor VS Thread</h2><ul>
<li>性能</li>
<li>同一管理，线程间竞争</li>
<li>扩展性</li>
</ul>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>直接提交任务，而不保持。</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>无界队列，可以对无限多的任务排队</p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>延时队列，延时提交</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>有界队列，可以指定队列的长度。</p>
<h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p>ThreadPoolExecutor是最常用的线程池，该线程池创建需要以下参数。 </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>int</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>long</td>
<td>空闲线程保留最长时间</td>
</tr>
<tr>
<td>timeUnit</td>
<td>java.util.concurrent.TimeUnit</td>
<td>时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>java.util.concurrent.BlockingQueue</td>
<td>指定使用哪一种BlockingQueue</td>
</tr>
<tr>
<td>threadFactory</td>
<td>java.util.concurrent.ThreadFactory</td>
<td>指定线程池创建线程的工厂，默认工厂类为Executors.defaultThreadFactory</td>
</tr>
<tr>
<td>handler</td>
<td>java.util.concurrent.RejectedExecutionHandler</td>
<td>指定当任务超限后的处理方式，默认处理类为AbortPolicy</td>
</tr>
</tbody></table>
<h3 id="jdk提供的线程池"><a href="#jdk提供的线程池" class="headerlink" title="jdk提供的线程池"></a>jdk提供的线程池</h3><table>
<thead>
<tr>
<th>pool</th>
<th>corePoolSize</th>
<th>maximumPoolSize</th>
<th>keepAliveTime</th>
<th>timeUnit</th>
<th>workQueue</th>
<th>threadFactory</th>
<th>handler</th>
</tr>
</thead>
<tbody><tr>
<td>newFixedThreadPool</td>
<td>参数指定</td>
<td>参数指定</td>
<td>0</td>
<td>TimeUnit.MILLISECONDS</td>
<td>LinkedBlockingQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>TimeUnit.MILLISECONDS</td>
<td>LinkedBlockingQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
<tr>
<td>newCachedThreadPool</td>
<td>0</td>
<td>Integer.MAX_VALUE</td>
<td>60</td>
<td>TimeUnit.SECONDS</td>
<td>SynchronousQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>参数指定</td>
<td>Integer.MAX_VALUE</td>
<td>0</td>
<td>NANOSECONDS</td>
<td>DelayedWorkQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
</tbody></table>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>当调用executor.execute提交一个任务时，按照如下顺序处理： </p>
<ol>
<li>如果当前线程数量少于核心线程数，则创建一个新的线程。</li>
<li>如果当前线程数量大于等于核心线程数，但缓冲队列未满，则将新的任务添加到缓冲队列中，按照FIFO原则依次等待执行。</li>
<li>如果当前线程数量大于等于核心线程数，且缓冲队列已满，但当前数量小于最大线程数，则创建新的线程。</li>
<li>如果当前线程数量等于最大线程数，则调用handle方法处理。</li>
</ol>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li>RUNNING （初始状态）</li>
<li>SHUTDOWN （调用shutdown，等待任务执行完毕）</li>
<li>STOP （调用shutdownNow）</li>
<li>TIDYING （所有任务已终止）</li>
<li>TERMINATED （彻底终止）</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>RUNNING -&gt; SHUTDOWN -&gt; TIDYING -&gt; TERMINATED<br>RUNNING -&gt; STOP -&gt; TIDYING -&gt; TERMINATED</p>
<h2 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h2><table>
<thead>
<tr>
<th>类</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>AbortPolicy</td>
<td>throw new RejectedExecutionException</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>直接运行runable.run()</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>丢弃</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃队列头部任务</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Future</title>
    <url>/2020/09/10/Java/%E5%B9%B6%E5%8F%91/Future/</url>
    <content><![CDATA[<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>非阻塞模型。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/pasted-6.png" alt="upload successful"></p>
<h3 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture</h3><p>同时继承接口Runnable和Future。</p>
<h3 id="SchedualedFuture"><a href="#SchedualedFuture" class="headerlink" title="SchedualedFuture"></a>SchedualedFuture</h3><p>延时、定时执行。</p>
<h3 id="ForkJoinFuture"><a href="#ForkJoinFuture" class="headerlink" title="ForkJoinFuture"></a>ForkJoinFuture</h3><p>可被拆分、合并。</p>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>可以被显式完成。  </p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li>NEW</li>
<li>COMPLETING</li>
<li>NORMAL</li>
<li>EXCEPTIONAL</li>
<li>CANCELLED</li>
<li>INTERRUPTING</li>
<li>INTERRUPTED</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>NEW -&gt; COMPLETING -&gt; NORMAL<br>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL<br>NEW -&gt; CANCELLED<br>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2020/07/27/Java/%E5%B9%B6%E5%8F%91/JUC/</url>
    <content><![CDATA[<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>java.utils.concurrent</p>
<h2 id="autmic"><a href="#autmic" class="headerlink" title="autmic"></a>autmic</h2><ul>
<li>AutmicInteger</li>
<li>AutmicBoolean</li>
<li>AutmicLong</li>
<li>AutmicReference</li>
<li>LongAdder</li>
<li>AutmicIntegerArray</li>
<li>AutmicLongArray</li>
<li>AutmicReferenceArray</li>
<li>AutmicStampledReference</li>
</ul>
<h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><ul>
<li>CopyOnWriteArrayList</li>
<li>CopyOnWroteArraySet</li>
<li>ConcurrentSkipListSet</li>
<li>ConcurrentMap</li>
<li>ConcurrentSkipListMap</li>
</ul>
<h2 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h2><ul>
<li>Lock</li>
<li>ReentrantLock</li>
<li>ReadWriteLock</li>
</ul>
<h2 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h2><h2 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>netty</title>
    <url>/2020/09/18/Java/%E5%B9%B6%E5%8F%91/netty/</url>
    <content><![CDATA[<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><h3 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h3><p>线程池，继承自 ScheduledExecutorService。  <br>用做服务器时有两个线程池，分别为接收连接线程池与工作线程池。用作客户端时有一个线程池。  <br>具体实现类有NioEventLoop、DefaultEventLoop、EpollEventloop。</p>
<h3 id="AbstractBootstrap"><a href="#AbstractBootstrap" class="headerlink" title="AbstractBootstrap"></a>AbstractBootstrap</h3><p>启动类。服务器启动类为ServerBootstrap，客户端启动类为Bootstrap。</p>
<h4 id="group"><a href="#group" class="headerlink" title="group"></a>group</h4><p>指定线程池。</p>
<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>指定通道，根据通道可以判断是服务器/客户端、TCP/UDP。</p>
<h4 id="childHandle"><a href="#childHandle" class="headerlink" title="childHandle"></a>childHandle</h4><p>指定消息的处理器。</p>
<h4 id="option、childOption"><a href="#option、childOption" class="headerlink" title="option、childOption"></a>option、childOption</h4><p>通过常量指定TCP/UDP协议的相关配置。如backlog、keepalive等。</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>绑定端口。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>netty的通道。</p>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>继承自Future。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>nio</title>
    <url>/2020/09/18/Java/%E5%B9%B6%E5%8F%91/nio/</url>
    <content><![CDATA[<h2 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h2><p>io通过流来传输数据，而nio通过channel与buffer传输。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>通道。Stream是单向的，而channel是双向的。</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>缓冲区。</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>管理channel。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>synchronized</title>
    <url>/2020/09/17/Java/%E5%B9%B6%E5%8F%91/synchronized/</url>
    <content><![CDATA[<h2 id="synchronized使用及编译"><a href="#synchronized使用及编译" class="headerlink" title="synchronized使用及编译"></a>synchronized使用及编译</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>编译时添加ACC_SYNCHRONIZED标记。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>默认添加try-finally，编译生成一条monitorenter指令和两条monitorexit指令。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果synchronized作用的对象是非静态方法或者对象，则它取得锁是对象锁；如果synchronized作用的对象是静态方法或者类，则它取得的锁是类锁。类锁与对象锁是两把不同的锁。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>重量级锁依赖于系统的同步函数，在linux上使用mutex互斥锁，最底层实现依赖于futex。这些同步函数都涉及到用户态和内核态的切换，进程的上下文切换，成本较高。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>在JVM中，对象在内存中除了本身的数据外还会有对象头，对于普通对象而言，其对象头有两类信息：mark word和类型指针，对于数据而言含会有一份记录数据长度的数据。  <br>类型指针是指向该对象所属类对象的指针。mark word用于存储对象的HashCode、GC分代年龄、锁状态等信息，在32位系统中位32字节，64位系统中为64字节。  <br>Java中任意对象都可以用作锁，锁信息可以存在对象头中。  <br>mark word中存储数据根据锁类型改变，当对象为无状态锁时，存储hashCode，当对象为偏向锁时，存储线程id，当对象为轻量级锁时，存储线程栈中Lock Record的指针，当对象为重量级锁时，存储堆中的monitor对象的指针。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>传统意义上的锁，利用操作系统底层的同步机制实现Java中的线程同步。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>在运行时，同步块中的代码不存在竞争，不同的线程交替执行同步块中的代码。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在运行时，只有一个线程会调用相关同步方法。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>volatile</title>
    <url>/2020/07/23/Java/%E5%B9%B6%E5%8F%91/volatile/</url>
    <content><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>保证了所有线程对这个变量操作时的可见性。</li>
<li>禁止指令重排序。<br>PS: volatile只能保证对单次读/写的原子性，像i++属于复杂指令。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>读 当读一个volatile变量时，会将本地内存的值置为无效，直接从主内存中读取。</li>
<li>写 当写一个volatile变量时，JMM会把本地变量的值刷新到主内存。</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>指令屏障。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>并发模拟</title>
    <url>/2020/07/21/Java/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<ul>
<li>PostMan 请求模拟工具</li>
<li>Apache Bench 网站性能测试工具</li>
<li>Apache JMeter 压力测试工具</li>
<li>Semaphore、CountDownLatch 通过代码模拟测试 </li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/2020/07/21/Java/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>操作系统通过时间片算法来并行执行各个程序。  <br>并发编程是指在同一台处理器上，并发处理多个任务。</p>
</blockquote>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>操作系统进行资源分配的最小单位。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>操作系统能够进行运算调度的最小单位。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>表示一种公共资源或共享数据，同一时间，只允许一个线程访问。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>内存的一部分，用来缓冲输入或输出的数据。</p>
<h2 id="并发编程解决的问题"><a href="#并发编程解决的问题" class="headerlink" title="并发编程解决的问题"></a>并发编程解决的问题</h2><ul>
<li>线程间的通信问题<blockquote>
<p>通信方式</p>
</blockquote>
<ul>
<li>数据共享 通过读写公共内存中的公共状态来隐式进行通信。</li>
<li>消息传递 通过明确的发送消息来显式进行通信（Java中典型的消息传递方式是wait()和notify()）。</li>
</ul>
</li>
<li>线程间的同步问题<blockquote>
<p>同步 指程序用于控制不同线程之间操作发生相对顺序的机制。</p>
</blockquote>
</li>
</ul>
<h2 id="计算机内存模型"><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h2><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>随着CPU技术的发展，CPU的执行速度越来越快，而内存的速度没有多大变化，于是，为了提高CPU利用率，在CPU和内存之间增加高速缓存。  <br>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可分为一级缓存（L1），二级缓存（L2），部分高端CPU还具有三级缓存（L3）。  <br>多CPU/多核CPU每个核心都含有一套L1（L1、L2）缓存，而共享L2（L3）缓存。  <br>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为操作系统引入了一个新的问题—缓存一致性，从而带来更高的复杂度。</p>
<h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>MSI、MESI、MOSI、Synapse、Firefly、Dragon Protocol</p>
<h4 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h4><h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><ul>
<li>M Modified 修改</li>
<li>E Exclusive 独享</li>
<li>S Shared 共享</li>
<li>I Invalid 无效<h5 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h5>高速缓存行数据状态有四种，引起数据状态转换的操作也有四种，所以共有16中状态转换的情况。<br><img src="/images/pasted-1.png" alt="upload successful"><blockquote>
<p>CPU高速缓存通过总线连接，总线还连接了主存。<br>对于Local Read 和 Local Write 操作，不经过总线，不会被其它CPU控制器监听到。<br>对于Remote Read 和 Remote Write 操作，需要其它CPU共同参与，所以这两个操作所有CPU控制器都能监听到，并能知道是不是自己发出的。</p>
</blockquote>
</li>
</ul>
<h5 id="允许状态图"><a href="#允许状态图" class="headerlink" title="允许状态图"></a>允许状态图</h5><p>对于任意给定的高速缓存对，给定高速缓存行的允许状态如图。<br><img src="/images/pasted-2.png" alt="upload successful"></p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是编译器和处理器在执行程序时为了提供性能而做的一些优化。</p>
<p><img src="/images/pasted-4.png" alt="upload successful"></p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="编译器优化的重排序"><a href="#编译器优化的重排序" class="headerlink" title="编译器优化的重排序"></a>编译器优化的重排序</h4><p>编译器在不改变单线程程序语音的前提下，可以重新安排语句的执行顺序。</p>
<h4 id="指令集并行的重排序"><a href="#指令集并行的重排序" class="headerlink" title="指令集并行的重排序"></a>指令集并行的重排序</h4><p>如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
<h4 id="内存系统的重排序"><a href="#内存系统的重排序" class="headerlink" title="内存系统的重排序"></a>内存系统的重排序</h4><p>由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>重排序需要遵循一定的规则，不然其结果可能会影响程序的执行结果。</p>
<h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>数据依赖： 如果两个操作同时访问一个变量，其中一个操作时写操作，此时这两个操作就构成了数据依赖。</p>
<h4 id="控制依赖性"><a href="#控制依赖性" class="headerlink" title="控制依赖性"></a>控制依赖性</h4><h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h4><p>不管如果重排序，都必须保证代码在单线程下的运行正确。</p>
<h3 id="并发重排序"><a href="#并发重排序" class="headerlink" title="并发重排序"></a>并发重排序</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>如果代码中存在控制依赖的时候，会影响指令序列执行的并行度。因此，编译器和处理器会猜测（Speculation）执行来客服控制的相关性，所以重排序破坏了程序顺序规则。<br>程序顺序规则：指定执行顺序于实际代码中的执行顺序时一致的，但是处理器和编译器会进行冲重排序，只要最后的记过不会改变，该重排序就是合理的。  <br>在单线程程序中，由于as-if-serial的存在，对存在控制依赖的操作重排序，不会改变执行结果，但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。  <br>PS：一个线程里面的条件依赖于另一个线程里面的数据。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>内存屏障 Java编译器在适当的位置插入内存屏障指令来禁止特定类型的处理器重排序。</li>
</ul>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据JVM规范，JVM内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈五个部分。</p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li>不可见<blockquote>
<p>多个线程从主存中读取数据，其中一个线程的修改对其它线程不可见。</p>
</blockquote>
</li>
</ul>
<p>使用volatile关键字，表示只能从主存中读取，修改后写回主存。</p>
<ul>
<li>竞争<blockquote>
<p>多个线程同时修改同一份数据。</p>
</blockquote>
</li>
</ul>
<p>使用synchronized关键字，对数据加锁，释放锁之前其它线程不能访问。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>Java Memory Model，Java内存模型,定义了JVM在计算机内存中的工作方式。JVM是整个计算机虚拟模型，所以JMM属于JVM。  <br>在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，JMM就是为了屏蔽系统和硬件的差异。  </p>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>JMM用来描述JVM是如何和计算机内存交互的。而JVM是计算机的一个模型，自然包含内存结构。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>定义程序中各个变量的访问规则。</p>
<h3 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h3><p>JMM规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对象工作内存中的变量，线程间变量值的传递均需要在主内存中来完成。</p>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<h3 id="内存交互操作"><a href="#内存交互操作" class="headerlink" title="内存交互操作"></a>内存交互操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>作用于主内存的变量，把一个变量标识为一条线程独占状态。</td>
</tr>
<tr>
<td>unlock</td>
<td>作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。</td>
</tr>
<tr>
<td>read</td>
<td>作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。</td>
</tr>
<tr>
<td>load</td>
<td>作用于工作内存的变量，把read操作从主内存中得到的变量值存入工作内存的变量副本中。</td>
</tr>
<tr>
<td>use</td>
<td>作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时会执行这个操作。</td>
</tr>
<tr>
<td>assign</td>
<td>作用于工作内存的变量，把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时会执行这个操作。</td>
</tr>
<tr>
<td>store</td>
<td>作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作。</td>
</tr>
<tr>
<td>write</td>
<td>作用于主内存的变量，把store操作从工作内存中一个变量的值传送到主内存的变量中。</td>
</tr>
</tbody></table>
<p>对这8种指定的使用，有以下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li>
<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li>
<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li>
<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>
<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>
</ul>
<h3 id="特新"><a href="#特新" class="headerlink" title="特新"></a>特新</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指一个操作是不可终端的，即使是在多个线程一起执行的情况下，一个操作一旦考试执行，就不会收到其它线程的干扰。<br>JMM内存交互操作，在操作系统里都是不可分隔的单元。被synchronized关键字或其它锁包裹起来的操作也可以认为是原子的。从一个线程观察另一个线程时，看到的都是一个个原子性的操作。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>指在多线程情况下，当一个线程修改了某一个共享变量的值之后，其它线程是否能够立即知道这个修改。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句指“线程内表现为串行的语义”（as-if-serial），后半句值“指令重排序”和普通变量的”工作内存与主内存同步延迟“的现象。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>JMM使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。  <br>重排序需要遵循happens-before规则。</p>
<ul>
<li>程序次序规则(Program Order Rule)：在同一个线程中，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操纵。准确的说是程序的控制流顺序，考虑分支和循环等。</li>
<li>管理锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面（时间上的顺序）对同一个锁的lock操作。</li>
<li>volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面（时间上的顺序）对该变量的读操作。</li>
<li>传递性(Transitivity)：如果操作A 先行发生于操作B，操作B 先行发生于操作C，那么可以得出A 先行发生于操作C。</li>
<li>线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则(Thread Termination Rule)：线程的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时事件的发生。Thread.interrupted()可以检测是否有中断发生。</li>
<li>对象终结规则(Finilizer Rule)：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()的开始。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>锁</title>
    <url>/2020/07/23/Java/%E5%B9%B6%E5%8F%91/%E9%94%81/</url>
    <content><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>在计算机科学中，锁于互斥时一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。</p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。  <br>在Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>对于同一个数据的并发操作，乐观锁认为自己在使用数据的时候不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新乐这个数据。  <br>乐观锁在Java中是通过无锁编程来实现，最常采用的是CAS算法。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>乐观锁多用在读多写少的情况下。</li>
<li>悲观锁多用在读少写多的情况下。</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h3 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别的线程占用，那么此线程就无法获取到这把锁，该线程会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁（spinlock）。</p>
<h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><p>自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<h2 id="无锁、偏向锁、轻量级锁、重量级锁"><a href="#无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="无锁、偏向锁、轻量级锁、重量级锁"></a>无锁、偏向锁、轻量级锁、重量级锁</h2><h2 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>指多个线程按照申请锁的顺寻来获取锁，线程直接进入队列中排队，队列的第一个线程才能获取锁。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>等待锁的线程不会饿死。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>整体吞吐效率相对非公平锁低，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>指多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾排队。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>减少唤起线程的开销，整体的吞吐量高。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>处于等待队列中的线程可能会饿死。</p>
<h2 id="可重入锁、非可重入锁"><a href="#可重入锁、非可重入锁" class="headerlink" title="可重入锁、非可重入锁"></a>可重入锁、非可重入锁</h2><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入该线程的内层方法会自动获取锁。（前提是锁对象得是同一个对象或者class。）</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>可一定程度上避免死锁。</p>
<h2 id="独享锁、共享锁"><a href="#独享锁、共享锁" class="headerlink" title="独享锁、共享锁"></a>独享锁、共享锁</h2><h3 id="独享锁"><a href="#独享锁" class="headerlink" title="独享锁"></a>独享锁</h3><p>也叫排他锁、互斥锁，指该锁一次只能被一个线程所持有，获得该锁的线程既能读数据也能写数据。</p>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>该锁可被多个线程共享，获得共享锁的线程只能读数据，不能写数据。一个线程对某数据加了共享锁后，其它线程只能添加共享锁，不能加独享锁。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>盲区</title>
    <url>/2021/11/30/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E7%9B%B2%E5%8C%BA/</url>
    <content><![CDATA[<h2 id="1-1-抽象过程"><a href="#1-1-抽象过程" class="headerlink" title="1.1 抽象过程"></a>1.1 抽象过程</h2><ul>
<li>面向对象与面向过程的区别。 函数调用/对象。</li>
</ul>
<h2 id="1-2-抽象数据类型"><a href="#1-2-抽象数据类型" class="headerlink" title="1.2 抽象数据类型"></a>1.2 抽象数据类型</h2><ul>
<li>在面向对象程序设计中，使用class表示数据类型。即数据类型和类是等价的。</li>
<li>字段：数据成员；方法： 成员函数。 成员 = 字段+函数+内部类？</li>
</ul>
<h2 id="2-8-javadoc"><a href="#2-8-javadoc" class="headerlink" title="2.8 javadoc"></a>2.8 javadoc</h2><ul>
<li>自动生成文档，使用方面比源码更加方便。</li>
</ul>
<h2 id="3-操作符"><a href="#3-操作符" class="headerlink" title="3 操作符"></a>3 操作符</h2><ul>
<li>除了“=”可用于对象，“+=”、“=”可用于字符串。其它情况都是基本数据类型。</li>
<li>使用操作符会自动提升类型。</li>
<li>操作符优先级建议使用括号来明确表示。</li>
</ul>
<h2 id="5-4-this"><a href="#5-4-this" class="headerlink" title="5.4 this"></a>5.4 this</h2><ul>
<li>必须使用this情况： 1. 构造器初始化变量名区分； 2. return this;； 3. 构造器调用其它构造器； 4. this作为参数； 5. 泛型方法显式类型说明。</li>
</ul>
<h2 id="5-5-垃圾回收器"><a href="#5-5-垃圾回收器" class="headerlink" title="5.5 垃圾回收器"></a>5.5 垃圾回收器</h2><ul>
<li>自适应的、分代的、停止-复制、标记-清除 式垃圾回收器。</li>
<li>垃圾回收本身也有开销。</li>
</ul>
<h2 id="5-6-成员初始化"><a href="#5-6-成员初始化" class="headerlink" title="5.6 成员初始化"></a>5.6 成员初始化</h2><ul>
<li>自动初始化，在调用构造器之前进行。</li>
<li>每个对象都有相同的初值。</li>
</ul>
<h2 id="5-8-数组"><a href="#5-8-数组" class="headerlink" title="5.8 数组"></a>5.8 数组</h2><ul>
<li>Java不允许下标越界，通过每次在访问数组的时候检查边界实现。检查是需要开销的。</li>
</ul>
<h2 id="5-10-速度"><a href="#5-10-速度" class="headerlink" title="5.10 速度"></a>5.10 速度</h2><ul>
<li>Java 的速度问题是涉足某些特定编程领域的障碍。</li>
</ul>
<h2 id="6-1-CLASSPATH"><a href="#6-1-CLASSPATH" class="headerlink" title="6.1 CLASSPATH"></a>6.1 CLASSPATH</h2><ul>
<li>运行时通过参数指定CLASSPATH或者通过环境变量配置。</li>
</ul>
<h2 id="6-2-protected"><a href="#6-2-protected" class="headerlink" title="6.2 protected"></a>6.2 protected</h2><ul>
<li>protected处理的是继承的概念。也提供了包访问权限。</li>
</ul>
<h2 id="6-3-封装"><a href="#6-3-封装" class="headerlink" title="6.3 封装"></a>6.3 封装</h2><ul>
<li>访问权限的控制常被称为是具体实现的隐藏。把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作封装。其结果是一个同时带有特征和行为的数据类型。</li>
</ul>
<h2 id="7-8-final"><a href="#7-8-final" class="headerlink" title="7.8 final"></a>7.8 final</h2><ul>
<li>private方法被隐式声明为final。</li>
</ul>
<h2 id="7-9-初始化顺序"><a href="#7-9-初始化顺序" class="headerlink" title="7.9 初始化顺序"></a>7.9 初始化顺序</h2><ul>
<li>基类 static - 导出类 static - 初始化 - 基类构造器 - 导出类构造器 - 实例变量 - 其余部分。</li>
<li>构造器也是static方法。</li>
</ul>
<h2 id="8-2-动态绑定"><a href="#8-2-动态绑定" class="headerlink" title="8.2 动态绑定"></a>8.2 动态绑定</h2><ul>
<li>Java中除了static方法和final方法外，其他的所有方法都是后期绑定，且会自动发生。</li>
<li>想要实现动态绑定，就必须具有某种机制，在运行时判断对象的类型。</li>
</ul>
<h2 id="8-3-构造器和多态"><a href="#8-3-构造器和多态" class="headerlink" title="8.3 构造器和多态"></a>8.3 构造器和多态</h2><ul>
<li>准则：构造器只用来初始化，避免调用其它方法。</li>
</ul>
<h2 id="8-4-协变返回类型"><a href="#8-4-协变返回类型" class="headerlink" title="8.4 协变返回类型"></a>8.4 协变返回类型</h2><ul>
<li>在导出类的被覆盖方法可以返回基类的返回类型的某种导出类型。</li>
</ul>
<h2 id="9-2-包访问权限接口"><a href="#9-2-包访问权限接口" class="headerlink" title="9.2 包访问权限接口"></a>9.2 包访问权限接口</h2><ul>
<li>实现包访问权限的接口，其方法必须声明为public。</li>
</ul>
<h2 id="9-7-接口中的域"><a href="#9-7-接口中的域" class="headerlink" title="9.7 接口中的域"></a>9.7 接口中的域</h2><ul>
<li>如果是常量或常量表达式，则在类加载阶段赋值并放入常量池。如果是非常量表达式，则在类初始化阶段赋值。</li>
</ul>
<h2 id="9-8-嵌套接口"><a href="#9-8-嵌套接口" class="headerlink" title="9.8 嵌套接口"></a>9.8 嵌套接口</h2><ul>
<li>实现了一个private接口的内部类，同样可以被实现为public类，但是只能被其自身所使用。</li>
<li>实现一个private接口只是一种方式，强制该接口中的方法定义不要添加任何类型信息（不允许向上转型）。</li>
<li>返回对private接口的引用的public方法，只有以各种方式可用，就是将返回值交给有权使用它的对象。</li>
</ul>
<h2 id="11-13-Foreach与迭代器"><a href="#11-13-Foreach与迭代器" class="headerlink" title="11.13 Foreach与迭代器"></a>11.13 Foreach与迭代器</h2><ul>
<li>Iterable接口被foreach用来在序列中移动。</li>
</ul>
<h2 id="12-9-异常的限制"><a href="#12-9-异常的限制" class="headerlink" title="12.9 异常的限制"></a>12.9 异常的限制</h2><ul>
<li>当覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常。</li>
<li>异常限制对构造器不起作用。</li>
<li>派生类构造器的异常说明必须包含基类构造器的异常说明。</li>
<li>派生类构造器不能捕获基类构造器抛出的异常。</li>
<li>强制派生类遵守基类方法的异常说明。</li>
<li>派生类方法可以不抛出异常，即使它是基类所定义的异常。</li>
<li>异常说明本身并不属于方法类型的一部分，因此不能基于异常说明来重载方法。</li>
</ul>
<h2 id="14-3-instance-of-isInstance-isAssignableFrom"><a href="#14-3-instance-of-isInstance-isAssignableFrom" class="headerlink" title="14.3 instance of|isInstance|isAssignableFrom"></a>14.3 instance of|isInstance|isAssignableFrom</h2><ul>
<li>instance of 只能与命名类型比较，无法比较class对象。</li>
<li>isInstance动态测试对象是否是该类实例。</li>
<li>isAssignableFrom 针对子类class与父类class。</li>
</ul>
<h2 id="15-2-元组"><a href="#15-2-元组" class="headerlink" title="15.2 元组"></a>15.2 元组</h2><ul>
<li>元组（数据传送对象、信使）：将一组对象直接打包存储于其中的一个单一对象。这个对象容器允许读取其中元素，但是不允许向其中存放新的对象。</li>
</ul>
<h2 id="15-4-泛型方法"><a href="#15-4-泛型方法" class="headerlink" title="15.4 泛型方法"></a>15.4 泛型方法</h2><ul>
<li>泛型推断只对赋值操作有效。 JAVA SE7？</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2021/12/13/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8810%EF%BC%89%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"10.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"可以将一个类的定义放在另一个类的定义内部，这就是内部类。"}]},{"t":"heading","d":1,"p":{"lines":[3,4]},"v":"10.1 创建内部类","c":[{"t":"list_item","d":3,"p":{"lines":[4,5]},"v":"在外部类方法中使用内部类，与使用普通类没什么不同。"},{"t":"list_item","d":3,"p":{"lines":[5,6]},"v":"外部类有一个方法，该方法返回一个指向内部类的引用。"},{"t":"list_item","d":3,"p":{"lines":[6,7]},"v":"如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，必须具体地指明这个对象的类型。"}]},{"t":"heading","d":1,"p":{"lines":[8,9]},"v":"10.2 链接到外部类","c":[{"t":"list_item","d":3,"p":{"lines":[9,10]},"v":"当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。"},{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"内部类拥有其外围类的所有成员的访问权。"},{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"构建内部类对象时，需要一个指向其外围类对象的引用。"}]},{"t":"heading","d":1,"p":{"lines":[13,14]},"v":"10.3 使用.this与.new","c":[{"t":"list_item","d":3,"p":{"lines":[14,15]},"v":"需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型。"},{"t":"list_item","d":3,"p":{"lines":[15,16]},"v":"必须使用外部类的对象来创建内部类的对象。在new表达式中提供对外部类对象的引用。这也解决了内部类名字作用域的问题。"},{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"如果创建嵌套类（静态内部类），不需要对外部类对象的引用。"}]},{"t":"heading","d":1,"p":{"lines":[18,19]},"v":"10.4 内部类与向上转型","c":[{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"当将内部类向上转型为其基类，尤其时转型为一个接口的时候，内部类就有了用武之地。"},{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。"},{"t":"list_item","d":3,"p":{"lines":[21,22]},"v":"内部类（某个接口的实现）能够完全不可见，并且不可用，所得到的只是指向基类或接口的引用，所以能够很方便的隐藏实现细节。"},{"t":"list_item","d":3,"p":{"lines":[22,23]},"v":"private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。"}]},{"t":"heading","d":1,"p":{"lines":[24,25]},"v":"10.5 在方法和作用域内的内部类","c":[{"t":"list_item","d":3,"p":{"lines":[25,26]},"v":"理由： 1. 实现了某类型的接口，可以创建并返回对其的引用。 2. 解决复杂的问题，创建一个类来辅助解决方案，且不希望这个类是公共可用的。"},{"t":"list_item","d":3,"p":{"lines":[26,27]},"v":"在方法的作用域内创建一个完整的类，被称作局部内部类。"},{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"可以在任意的作用域（{}）内嵌入一个类。"}]},{"t":"heading","d":1,"p":{"lines":[29,30]},"v":"10.6 匿名内部类","c":[{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"将返回值的生成与表示这个返回值的类的定义结合在一起，且这个类是匿名的。"},{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"匿名内部类基类需要一个有参数的构造器，只需简单地传递合适的参数给基类的构造器即可。"},{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"匿名内部类末尾的分号，并不是用来标记此内部类结束的，标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类。"},{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"在匿名内部类中定义字段是，还能够对其执行初始化操作。"},{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"匿名类中不可能有命名构造器，但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果。限制：不能重载实例初始化方法。"},{"t":"list_item","d":3,"p":{"lines":[36,37]},"v":"匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。如果是实现接口，也只能实现一个接口。"},{"t":"list_item","d":3,"p":{"lines":[37,38]},"v":"匿名内部类实现工厂： 1. 产品构造器私有化； 2. 将工厂声明为产品的static域； 3. 使用匿名内部类实例化工厂。"}]},{"t":"heading","d":1,"p":{"lines":[39,40]},"v":"10.7 嵌套类","c":[{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为嵌套类。"},{"t":"list_item","d":3,"p":{"lines":[41,42]},"v":"要创建嵌套类的对象，并不需要其外围类的对象。"},{"t":"list_item","d":3,"p":{"lines":[42,43]},"v":"不能从嵌套类的对象中访问非静态的外围类对象。"},{"t":"list_item","d":3,"p":{"lines":[43,44]},"v":"普通的内部类不能有static成员，也不能包含嵌套类。但是嵌套类可以包含这些。"},{"t":"list_item","d":3,"p":{"lines":[44,45]},"v":"在一个普通的内部类中，通过一个特殊的this引用可以链接到其外围类对象。嵌套类没有这个特殊的this引用，使得它类似于一个static方法。"},{"t":"list_item","d":3,"p":{"lines":[45,46]},"v":"嵌套类可以作为接口的一部分。如果想创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。"},{"t":"list_item","d":3,"p":{"lines":[46,47]},"v":"一个内部类能透明地访问所有它嵌入的外围类的成员。"}]},{"t":"heading","d":1,"p":{"lines":[48,49]},"v":"10.8 为什么需要内部类","c":[{"t":"list_item","d":3,"p":{"lines":[49,50]},"v":"每个内部类都能独立的继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。"},{"t":"list_item","d":3,"p":{"lines":[50,51]},"v":"内部类允许继承多个非接口类型（类或抽象类）。"},{"t":"list_item","d":3,"p":{"lines":[51,52]},"v":"内部类特性：","c":[{"t":"list_item","d":5,"p":{"lines":[52,53],"index":1},"v":"1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。"},{"t":"list_item","d":5,"p":{"lines":[53,54],"index":2},"v":"2. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。"},{"t":"list_item","d":5,"p":{"lines":[54,55],"index":3},"v":"3. 创建内部类对象的时刻并不依赖于外围类对象的创建。"},{"t":"list_item","d":5,"p":{"lines":[55,56],"index":4},"v":"4. 内部类并没有“is-a”关系，它就是一个独立的实体。"}]},{"t":"list_item","d":3,"p":{"lines":[57,58]},"v":"闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。 -- 内部类是面向对象的闭包。"},{"t":"list_item","d":3,"p":{"lines":[58,59]},"v":"通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。"},{"t":"list_item","d":3,"p":{"lines":[59,60]},"v":"通过内部类提供的闭包功能实现回调，比指针更灵活、更安全。"},{"t":"list_item","d":3,"p":{"lines":[60,61]},"v":"回调的价值在于灵活性，可以在运行时动态地决定需要调用什么方法。"},{"t":"list_item","d":3,"p":{"lines":[62,63]},"v":"应用程序框架是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，已解决特定问题。 -- 模板方法。"},{"t":"list_item","d":3,"p":{"lines":[63,64]},"v":"控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统称为事件驱动系统。"},{"t":"list_item","d":3,"p":{"lines":[64,65]},"v":"内部类允许： 1. 控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。 2. 内部类能够很容易地访问外围类的任意成员，所以可以避免这种实现变的笨拙。"},{"t":"list_item","d":3,"p":{"lines":[65,66]},"v":"命令模式。"}]},{"t":"heading","d":1,"p":{"lines":[67,68]},"v":"10.9 内部类的继承","c":[{"t":"list_item","d":3,"p":{"lines":[68,69]},"v":"内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类时，必须使用外围类对象调用super，才能提供必要的引用。"}]},{"t":"heading","d":1,"p":{"lines":[70,71]},"v":"10.10 内部类可以被覆盖吗","c":[{"t":"list_item","d":3,"p":{"lines":[71,72]},"v":"当继承了某个外围类时，内部类并没有发生变化，子类的内部类与基类的内部类是连个完全独立的实体，各自在自己的命名空间内。"},{"t":"list_item","d":3,"p":{"lines":[72,73]},"v":"继承某个外围类的时候，可以明确地继承某个内部类。"}]},{"t":"heading","d":1,"p":{"lines":[74,75]},"v":"10.11 局部内部类","c":[{"t":"list_item","d":3,"p":{"lines":[75,76]},"v":"局部内部类不能有访问说明符，因为它不是外围类的一部分。"},{"t":"list_item","d":3,"p":{"lines":[76,77]},"v":"局部内部类可以访问当前代码块内的常量，以及此外围类的所有成员。"},{"t":"list_item","d":3,"p":{"lines":[77,78]},"v":"使用局部内部类而不使用匿名内部类的理由： 1. 需要一个已命名的构造器，或需要重载构造器； 2. 需要不止一个该内部类的对象。"}]},{"t":"heading","d":1,"p":{"lines":[79,80]},"v":"10.12 内部类标识符","c":[{"t":"list_item","d":3,"p":{"lines":[80,81]},"v":"规则： 外围类名字 + “$” + 内部类的名字。"},{"t":"list_item","d":3,"p":{"lines":[81,82]},"v":"编译器为匿名内部类产生一个数字作为其标识符。"}]},{"t":"heading","d":1,"p":{"lines":[83,84]},"v":"10.13 总结","c":[{"t":"list_item","d":3,"p":{"lines":[84,85]},"v":"比起面向对象编程中其他概念来说，接口和内部类更深奥复杂。"}]}],"p":{}}</svg>
              </div>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>本章有几个概念，外部类、外围对象、外围类，感觉傻傻分不清。不知道是不是翻译的问题，为什么用的名词不统一。</li>
<li>内部类的具体使用场景需要慢慢感受。</li>
</ul>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>持有对象</title>
    <url>/2021/12/14/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8811%EF%BC%89%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"11.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"如果一个程序只包含固定数量且生命周期都是已知的对象，那么这是一个非常简单的程序。"},{"t":"list_item","d":3,"p":{"lines":[2,3]},"v":"需要在任意时刻和任意位置创建任意数量的对象。所以，就不能依靠创建命名的引用来持有每一个对象。"},{"t":"list_item","d":3,"p":{"lines":[3,4]},"v":"Java实用类库提供了一套相当完整的容器类来保存对象，其中基本的类型是List、Set、Queue和Map。这些对象类型称为容器。容器提供了完善的方法来保存对象。"},{"t":"list_item","d":3,"p":{"lines":[4,5]},"v":"Java容器类都可以自动地调整自己的尺寸。"},{"t":"list_item","d":3,"p":{"lines":[5,6]},"v":"即使在Java中没有关键字支持，容器类仍旧是可以显著增强编程能力的基本工具。"}]},{"t":"heading","d":1,"p":{"lines":[7,8]},"v":"11.1 泛型和类型安全的容器","c":[{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"使用Java泛型来创建类会非常复杂。但是，应用预定义的泛型通常会很简单。"},{"t":"list_item","d":3,"p":{"lines":[9,10]},"v":"通过使用泛型，可以在编译器放置将错误类型的对象放置到容器中。"},{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"当指定了某个类型作为泛型参数时，并不仅限于只能将该确切类型的对象放置到容器中。向上转型也可以像作用于其他类型一样作用于泛型。"}]},{"t":"heading","d":1,"p":{"lines":[12,13]},"v":"11.2 基本概念","c":[{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"Java容器类类库的用途是“保存对象”，并将其划分为两个不同的概念：Collection 和 Map。"},{"t":"list_item","d":3,"p":{"lines":[14,15]},"v":"Collection，一个独立元素的序列，这些元素都服从一条或多条规则。"},{"t":"list_item","d":3,"p":{"lines":[15,16]},"v":"Map，一组成对的“键值对”对象，使用键查找值。"}]},{"t":"heading","d":1,"p":{"lines":[17,18]},"v":"11.3 添加一组元素","c":[{"t":"list_item","d":3,"p":{"lines":[18,19]},"v":"java.util.Arrays、Collections类中有很多实用方法。"},{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"Arrays.asList() 方法接受一个数组或是元素列表（可变参数），并将其转换为一个List对象。"},{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"Collections.addAll() 方法接受一个Collection对象，以及一个数组或是元素列表，将元素添加到Collection中。"},{"t":"list_item","d":3,"p":{"lines":[21,22]},"v":"Collection的构造器可以接受另一个Collection，用它来将自身初始化。"},{"t":"list_item","d":3,"p":{"lines":[22,23]},"v":"Arrays.asList() 方法的限制是对所产生的List的类型做出了最理想的假设。可以添加显式类型参数说明。"},{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"Map除了用另一个Map之外，Java标准库没有提供其他任何自动初始化的方式。"}]},{"t":"heading","d":1,"p":{"lines":[25,26]},"v":"11.4 容器的打印","c":[{"t":"list_item","d":3,"p":{"lines":[26,27]},"v":"默认的打印行为（使用容器提供的toString()方法）即可生成可读性很好的结果。"},{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"Collection打印出来的内容用方括号括住，每个元素由逗号分隔。"},{"t":"list_item","d":3,"p":{"lines":[28,29]},"v":"Map打印出来的内容用大括号括住，键与值由等号联系。"}]},{"t":"heading","d":1,"p":{"lines":[30,31]},"v":"11.5 List","c":[{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"List可以将元素维护在特定的序列中。"},{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"List接口在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素。"},{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"ArrayList，长于随机访问元素，但是在List的中间插入和移除元素时较慢。"},{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"LinkedList，通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问。它的特性集较ArrayList更大。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"方法：contains、remove、equals、indexOf、subList、containsAll、retainAll、removeAll、set、replace、addAll、isEmpty、clear、toArray。"}]},{"t":"heading","d":1,"p":{"lines":[37,38]},"v":"11.6 迭代器","c":[{"t":"list_item","d":3,"p":{"lines":[38,39]},"v":"任何容器类，都必须由某种方式可以插入元素并将它们再次取回。"},{"t":"list_item","d":3,"p":{"lines":[39,40]},"v":"迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端不必知道或关系该序列底层的结构。"},{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"迭代器通常被称为轻量级对象：创建它的代价小。因此迭代器有些限制。"},{"t":"list_item","d":3,"p":{"lines":[41,42]},"v":"Java中的Iterator只能单向移动。使用iterator()要求容器返回一个Iterator。只有next、hasNext、remove功能。"},{"t":"list_item","d":3,"p":{"lines":[42,43]},"v":"如果只是遍历，而不打算修改容器本身，foreach语法更加简洁。"},{"t":"list_item","d":3,"p":{"lines":[43,44]},"v":"接受对象容器并传递它，从而在每个对象上都执行操作，这种思想十分强大。"},{"t":"list_item","d":3,"p":{"lines":[44,45]},"v":"remove是“可选”方法，即不是所有的Iterator实现都必须实现该方法。但是，标准Java类库实现了remove()。"},{"t":"list_item","d":3,"p":{"lines":[45,46]},"v":"迭代器统一了对容器的访问方式。"},{"t":"list_item","d":3,"p":{"lines":[47,48]},"v":"ListIterator是一个更加强大的Iterator的子类型，只能用于各种List的访问。"},{"t":"list_item","d":3,"p":{"lines":[48,49]},"v":"ListIterator可以双向移动。产生相对于迭代器在列表中指向当前位置的前一个和后一个元素的索引。可以使用set方法替换访问过的最后一个元素。"},{"t":"list_item","d":3,"p":{"lines":[49,50]},"v":"通过调用listIterator方法产生ListIterator，还可以指定开始位置。"},{"t":"list_item","d":3,"p":{"lines":[50,51]},"v":"方法： hasNext、next、hasPrevious、previous、listIterator。"}]},{"t":"heading","d":1,"p":{"lines":[52,53]},"v":"11.7 LinkedList","c":[{"t":"list_item","d":3,"p":{"lines":[53,54]},"v":"LinkedList和ArrayList一样实现了基本的List接口，执行插入和移除时比ArrayList更高效，随机访问操作方面效率低"},{"t":"list_item","d":3,"p":{"lines":[54,55]},"v":"LinkedList还添加了可以使其作为栈、队列或双端队列的方法。"},{"t":"list_item","d":3,"p":{"lines":[55,56]},"v":"这些方法中有些彼此之间只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用。"},{"t":"list_item","d":3,"p":{"lines":[56,57]},"v":"getFirst、element、peek、removeFirst、remove、removeLast、poll、addFirst、add、addLast。"}]},{"t":"heading","d":1,"p":{"lines":[58,59]},"v":"11.8 Stack","c":[{"t":"list_item","d":3,"p":{"lines":[59,60]},"v":"栈通常是指后进先出（LIFO）的容器。"},{"t":"list_item","d":3,"p":{"lines":[60,61]},"v":"LinkedList具有能够直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用。"},{"t":"list_item","d":3,"p":{"lines":[61,62]},"v":"方法： push、peek、pop。"},{"t":"list_item","d":3,"p":{"lines":[62,63]},"v":"java.util.Stack 已过时。 只需要栈的行为，但是继承了Vector使得栈具有了其他方法。"}]},{"t":"heading","d":1,"p":{"lines":[64,65]},"v":"11.9 Set","c":[{"t":"list_item","d":3,"p":{"lines":[65,66]},"v":"Set不保存重复的元素。最常被使用的是测试归属性（HashSet）。"},{"t":"list_item","d":3,"p":{"lines":[66,67]},"v":"Set具有与Collection完全一样的接口，因此没有额外的功能。"},{"t":"list_item","d":3,"p":{"lines":[67,68]},"v":"HashSet使用散列，TreeSet将元素存储在红黑树数据结构中，LinkedHashSet使用散列，并用链表维护元素顺序。"}]},{"t":"heading","d":1,"p":{"lines":[69,70]},"v":"11.10 Map","c":[{"t":"list_item","d":3,"p":{"lines":[70,71]},"v":"将对象映射到其他对象的能力是一种解决编程问题的杀手锏。"},{"t":"list_item","d":3,"p":{"lines":[71,72]},"v":"Map与数组和其他的Collection一样，可以很容易扩展到多维。只需将其值设置为Map。"},{"t":"list_item","d":3,"p":{"lines":[72,73]},"v":"很容易地将容器组合起来从而快速生成强大的数据结构。"},{"t":"list_item","d":3,"p":{"lines":[73,74]},"v":"Map可以返回它的键的Set，值的Collection，或者它的键值对的Set。"}]},{"t":"heading","d":1,"p":{"lines":[75,76]},"v":"11.11 Queue","c":[{"t":"list_item","d":3,"p":{"lines":[76,77]},"v":"队列是一个典型的先进先出（FIFO）的容器。"},{"t":"list_item","d":3,"p":{"lines":[77,78]},"v":"队列在并发编程中特别重要。"},{"t":"list_item","d":3,"p":{"lines":[78,79]},"v":"优先级队列声明下一个弹出元素是最需要的元素（具有最高的优先级）。"}]},{"t":"heading","d":1,"p":{"lines":[80,81]},"v":"11.12 Collection与Iterator","c":[{"t":"list_item","d":3,"p":{"lines":[81,82]},"v":"Collection是描述所有序列容器的共性的跟接口，它可能会被认为是一个“附属接口”，即因为要表示其他若干个接口的共性而出现的接口。"},{"t":"list_item","d":3,"p":{"lines":[82,83]},"v":"java.util.AbstractCollection类提供了Collection的默认实现。"},{"t":"list_item","d":3,"p":{"lines":[83,84]},"v":"针对接口而非具体实现来编写代码，可以应用于更多的对象类型。"},{"t":"list_item","d":3,"p":{"lines":[84,85]},"v":"在Java中，用迭代器而不是Collection来表示容器之间的共性。但是这两种方法绑定到了一起，因为实现Collection就意味着需要提供iterator()方法。"},{"t":"list_item","d":3,"p":{"lines":[85,86]},"v":"Collection是Iterable类型。"}]},{"t":"heading","d":1,"p":{"lines":[87,88]},"v":"11.13 Foreach与迭代器","c":[{"t":"list_item","d":3,"p":{"lines":[88,89]},"v":"foreach语法可用于数组，也可应用于任何Collection对象。"},{"t":"list_item","d":3,"p":{"lines":[89,90]},"v":"Java SE5引入了新的Iterable接口，包含一个能够产生Iterator的iterator方法，并且Iterable接口被foreach用来在序列中移动。"},{"t":"list_item","d":3,"p":{"lines":[90,91]},"v":"创建了任何实现Iterable的类，都可以将它用于foreach语句中。"},{"t":"list_item","d":3,"p":{"lines":[91,92]},"v":"不存在任何数组到Iterable的自动转换，必须手工执行转换。"},{"t":"list_item","d":3,"p":{"lines":[92,93]},"v":"适配器，提供多种使用foreach的方式。"}]},{"t":"heading","d":1,"p":{"lines":[94,95]},"v":"11.14 总结","c":[{"t":"list_item","d":3,"p":{"lines":[95,96]},"v":"Java提供了大量持有对象的方式。"}]}],"p":{}}</svg>
              </div>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>通过异常处理错误</title>
    <url>/2021/12/15/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8812%EF%BC%89%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"12.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"Java的基本理念是“结构不佳的代码不能运行”。"},{"t":"list_item","d":3,"p":{"lines":[2,3]},"v":"发现错误的理想时机是在编译阶段。"},{"t":"list_item","d":3,"p":{"lines":[3,4]},"v":"编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。这就需要错误源能通过某种方式，把适当的信息传递给某个接收者，该接收者将知道如何正确处理这个问题。"},{"t":"list_item","d":3,"p":{"lines":[4,5]},"v":"改进的错误恢复机制是提供代码健壮性的最强有力的方式。"},{"t":"list_item","d":3,"p":{"lines":[5,6]},"v":"Java的主要目标之一是创建供他人使用的程序构件。Java使用异常来提供一致的错误报告模型，使得构件能够与客户端代码可靠地沟通问题。"},{"t":"list_item","d":3,"p":{"lines":[6,7]},"v":"Java中的异常处理的目的在于通过使用少于目前数量的代码来简化大型、可靠的程序的生成。"},{"t":"list_item","d":3,"p":{"lines":[7,8]},"v":"异常处理是Java中唯一正式的错误报告机制，并且通过编译器强制执行。"}]},{"t":"heading","d":1,"p":{"lines":[9,10]},"v":"12.1 概念","c":[{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"C以及其他早期语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的基础之上，而并不属于语言的一部分。"},{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"通常会返回某个特殊值或者设置某个标志，并且假定接收者将对这个返回值或标志进行检查，以判定是否发生了错误。"},{"t":"list_item","d":3,"p":{"lines":[12,13]},"v":"用强制规定的形式来消除错误处理过程中随心所欲的因素。往往能够降低错误处理代码的复杂度。"},{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"把“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。"}]},{"t":"heading","d":1,"p":{"lines":[15,16]},"v":"12.2 基本异常","c":[{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"异常情形是指阻止当前方法或作用域继续执行的问题。普通问题是指在当前环境下能得到足够的信息，总能够处理这个错误。"},{"t":"list_item","d":3,"p":{"lines":[17,18]},"v":"当抛出异常后，首先，将使用new在堆上创建异常对象；然后，当前的执行路径被终止，从当前环境中弹出对异常对象的引用，异常处理机制接管程序，执行异常处理程序。"},{"t":"list_item","d":3,"p":{"lines":[18,19]},"v":"异常处理程序的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。"},{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"创建一个代表错误信息的对象，并且将它从当前环境中抛出，把错误信息传播到更大的环境中，这被称为抛出一个异常。"},{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"异常允许强制程序停止运行，并报告出现了什么问题，或者强制程序处理问题，并返回到稳定状态。"},{"t":"list_item","d":3,"p":{"lines":[21,22]},"v":"标准异常构造器： 默认构造器；接受字符串作为参数。"},{"t":"list_item","d":3,"p":{"lines":[22,23]},"v":"使用new创建了异常对象之后，此对象的引用将传给throw。"},{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"可以简单地把异常处理堪称一种不同的返回机制。"},{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"能够抛出任意类型的Throwable对象，它使异常类型的根类。通常，对于不同类型的错误，要抛出相应的异常。"},{"t":"list_item","d":3,"p":{"lines":[25,26]},"v":"错误信息可以保存在异常对象或者用异常类的名称来暗示。通常，异常对象中仅有的信息就是异常类型，除此之外不包含任何有意义的内容。"}]},{"t":"heading","d":1,"p":{"lines":[27,28]},"v":"12.3 捕获异常","c":[{"t":"list_item","d":3,"p":{"lines":[28,29]},"v":"监控区域使一段可能产生异常的代码，并且后面跟着处理这些异常的代码。"},{"t":"list_item","d":3,"p":{"lines":[29,30]},"v":"如果在方法内部抛出了异常，且不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。这个块称为try块。"},{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"对于不支持异常处理的程序语言，要想仔细检查错误，就得在每个方法调用的前后加上设置和错误检查的代码，甚至在每次调用同以方法时也得这么做。"},{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"有了异常处理机制，可以把所有哦动作放在try块里，然后只需在一个地方就可以捕获所有异常。这意味着程序更容易编写和阅读。"},{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"抛出的异常必须在某处得到处理，这个地点就是异常处理程序。而且针对每个要捕获的异常，得准备相应的处理程序。"},{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"异常处理程序紧跟在try块之后，以关键字catch表示。"},{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"在try块内部，许多不同的方法调用可能会产生类型相同的异常，只需要提供一个针对此类型的异常处理程序。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"异常处理理论上由两种基本模型： 终止模型、恢复模型。"},{"t":"list_item","d":3,"p":{"lines":[36,37]},"v":"Java支持终止模型。程序无法返回到异常发生的地方继续执行。"},{"t":"list_item","d":3,"p":{"lines":[37,38]},"v":"恢复模型意思是异常处理程序的工作时修正错误，然后重新尝试调用出问题的方法。"},{"t":"list_item","d":3,"p":{"lines":[38,39]},"v":"Java实现类似恢复的行为：遇见错误时不能抛出异常，而是调用方法来修正该错误；或把try块放在while循环里。"},{"t":"list_item","d":3,"p":{"lines":[39,40]},"v":"恢复模型导致耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码。"}]},{"t":"heading","d":1,"p":{"lines":[41,42]},"v":"12.4 创建自定义异常","c":[{"t":"list_item","d":3,"p":{"lines":[42,43]},"v":"Java可以自己定义异常类来表示程序中可能会遇到的特定问题。"},{"t":"list_item","d":3,"p":{"lines":[43,44]},"v":"要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承。"},{"t":"list_item","d":3,"p":{"lines":[44,45]},"v":"对异常来说，最重要的部分是类名。"}]},{"t":"heading","d":1,"p":{"lines":[46,47]},"v":"12.5 异常说明","c":[{"t":"list_item","d":3,"p":{"lines":[47,48]},"v":"Java提供了异常说明，能以礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型，然后进行相应的处理。"},{"t":"list_item","d":3,"p":{"lines":[48,49]},"v":"异常说明属于方法声明的一部分，紧跟在形式参数列表之后。"},{"t":"list_item","d":3,"p":{"lines":[49,50]},"v":"异常说明使用了附件的关键字throws，后面接一个所有潜在异常类型的列表。"},{"t":"list_item","d":3,"p":{"lines":[50,51]},"v":"代码必须与异常说明一致。可以声明方法将抛出异常，实际上却不抛出。"},{"t":"list_item","d":3,"p":{"lines":[51,52]},"v":"在编译时被强制检查的异常称为被检查的异常。"}]},{"t":"heading","d":1,"p":{"lines":[53,54]},"v":"12.6 捕获所有异常","c":[{"t":"list_item","d":3,"p":{"lines":[54,55]},"v":"可以只写一个异常处理程序来捕获所有类型的异常。"},{"t":"list_item","d":3,"p":{"lines":[55,56]},"v":"Throwable方法： getMessage、getLocalizedMessage、toString、printStackTrace、fillInStackTrace。"},{"t":"list_item","d":3,"p":{"lines":[56,57]},"v":"getStackTrace方法返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一帧。"},{"t":"list_item","d":3,"p":{"lines":[57,58]},"v":"有时希望把刚捕获的异常重新抛出。调用fillInStackTrace更新异常信息。有关原来异常发生点的信息会丢失，类似于捕获之后抛出另一种异常。"},{"t":"list_item","d":3,"p":{"lines":[58,59]},"v":"在捕获一个异常后抛出另一个异常，并且希望把原始异常信息保存下来，这被称为异常链。"},{"t":"list_item","d":3,"p":{"lines":[59,60]},"v":"Java SE5之后，Throwable的子类可以在构造器中接受一个cause对象作为参数，用来表示原始异常。"},{"t":"list_item","d":3,"p":{"lines":[60,61]},"v":"Throwable的子类中，只有三种基本的异常类提供了带cause参数的构造器： Error（用于Java虚拟机报告系统错误）、Exception、RuntimeException。"},{"t":"list_item","d":3,"p":{"lines":[61,62]},"v":"如果要把其他类型的异常链接起来，应该使用initCause方法而不是构造器。"}]},{"t":"heading","d":1,"p":{"lines":[63,64]},"v":"12.7 Java标准异常","c":[{"t":"list_item","d":3,"p":{"lines":[64,65]},"v":"Throwable用来表示任何可以作为异常被抛出的类。分为两种类型：Error、Exception。"},{"t":"list_item","d":3,"p":{"lines":[65,66]},"v":"Error用来表示编译时和系统错误。"},{"t":"list_item","d":3,"p":{"lines":[66,67]},"v":"Exception是可以被抛出的基本类型。"},{"t":"list_item","d":3,"p":{"lines":[67,68]},"v":"运行时异常都是从RuntimeException类继承未来，也被称为“不受检查异常”。这种异常属于错误，将被自动捕获。代表的是编程错误。"},{"t":"list_item","d":3,"p":{"lines":[68,69]},"v":"不应把Java的异常处理机制当成是单一用途的工具。"}]},{"t":"heading","d":1,"p":{"lines":[70,71]},"v":"12.8 使用finally进行清理","c":[{"t":"list_item","d":3,"p":{"lines":[71,72]},"v":"finally子句总能被执行。"},{"t":"list_item","d":3,"p":{"lines":[72,73]},"v":"对于没有垃圾回收和析构函数自动调用机制的语言来说，finally非常重要。"},{"t":"list_item","d":3,"p":{"lines":[73,74]},"v":"Java中当要把除内存之外的资源恢复到它们的初始状态时，就要用到finally子句。"},{"t":"list_item","d":3,"p":{"lines":[74,75]},"v":"如果把finally子句和带标签的break及continue配合使用，在Java里就没有必要使用goto语句了。"},{"t":"list_item","d":3,"p":{"lines":[75,76]},"v":"因为finally子句总是会执行，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行。"},{"t":"list_item","d":3,"p":{"lines":[76,77]},"v":"用某些特殊的方式使用finally子句，会导致异常丢失。 1. 在finally中抛异常； 2. 在finally中return。"}]},{"t":"heading","d":1,"p":{"lines":[78,79]},"v":"12.9 异常的限制","c":[{"t":"list_item","d":3,"p":{"lines":[79,80]},"v":"当覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常。"},{"t":"list_item","d":3,"p":{"lines":[80,81]},"v":"异常限制对构造器不起作用。"},{"t":"list_item","d":3,"p":{"lines":[81,82]},"v":"派生类构造器的异常说明必须包含基类构造器的异常说明。"},{"t":"list_item","d":3,"p":{"lines":[82,83]},"v":"派生类构造器不能捕获基类构造器抛出的异常。"},{"t":"list_item","d":3,"p":{"lines":[83,84]},"v":"强制派生类遵守基类方法的异常说明。"},{"t":"list_item","d":3,"p":{"lines":[84,85]},"v":"派生类方法可以不抛出异常，即使它是基类所定义的异常。"},{"t":"list_item","d":3,"p":{"lines":[85,86]},"v":"异常说明本身并不属于方法类型的一部分，因此不能基于异常说明来重载方法。"},{"t":"list_item","d":3,"p":{"lines":[86,87]},"v":"在继承和覆盖的过程中，某个特定方法的“异常说明的接口”不是变大了而是变小了。这恰好和类接口在继承时的情形相反。"}]},{"t":"heading","d":1,"p":{"lines":[88,89]},"v":"12.10 构造器","c":[{"t":"list_item","d":3,"p":{"lines":[89,90]},"v":"如果构造器在其执行过程中半途而废，也许该对象的某些部分还没有被成功创建，而这些部分在finally子句中却是要被清理的。"},{"t":"list_item","d":3,"p":{"lines":[90,91]},"v":"对于在构造阶段可能会抛异常，并且要求清理的类，最安全的使用方式是使用嵌套的try子句（try嵌套try）。"}]},{"t":"heading","d":1,"p":{"lines":[92,93]},"v":"12.11 异常匹配","c":[{"t":"list_item","d":3,"p":{"lines":[93,94]},"v":"抛出异常的时候，异常处理系统会按照代码的书写顺序找出最近的处理程序。"},{"t":"list_item","d":3,"p":{"lines":[94,95]},"v":"找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。"},{"t":"list_item","d":3,"p":{"lines":[95,96]},"v":"查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序。"}]},{"t":"heading","d":1,"p":{"lines":[97,98]},"v":"12.12 其他可选方式","c":[{"t":"list_item","d":3,"p":{"lines":[98,99]},"v":"异常处理的一个重要原则是“只有在知道如何处理的情况下才捕获异常”。"},{"t":"list_item","d":3,"p":{"lines":[99,100]},"v":"异常处理的一个重要目标是把错误处理的代码同错误发生的地点相分离。"},{"t":"list_item","d":3,"p":{"lines":[100,101]},"v":"被检查的异常强制在可能还没准备好处理错误的适合被迫加上catch子句，导致了“吞食则有害”的问题。"},{"t":"list_item","d":3,"p":{"lines":[101,102]},"v":"异常处理历史、Java发明了“被检查的异常”，及作者观点。"},{"t":"list_item","d":3,"p":{"lines":[102,103]},"v":"反射和泛型用来补偿静态类型检查所带来的过多限制。"},{"t":"list_item","d":3,"p":{"lines":[103,104]},"v":"处理被检查的异常：1. 传递给控制台； 2. 转换为不检查的异常。"}]},{"t":"heading","d":1,"p":{"lines":[105,106]},"v":"12.13 异常使用指南","c":[{"t":"list_item","d":3,"p":{"lines":[106,107]},"v":"再恰当的级别处理问题。"},{"t":"list_item","d":3,"p":{"lines":[107,108]},"v":"解决问题并且重新调用产生异常的方法。"},{"t":"list_item","d":3,"p":{"lines":[108,109]},"v":"进行少许修补，然后绕过异常发生的地方继续执行。"},{"t":"list_item","d":3,"p":{"lines":[109,110]},"v":"用别的数据进行计算，以代替方法预计会返回的值。"},{"t":"list_item","d":3,"p":{"lines":[110,111]},"v":"把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。"},{"t":"list_item","d":3,"p":{"lines":[111,112]},"v":"把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。"},{"t":"list_item","d":3,"p":{"lines":[112,113]},"v":"终止程序。"},{"t":"list_item","d":3,"p":{"lines":[113,114]},"v":"进行简化。"},{"t":"list_item","d":3,"p":{"lines":[114,115]},"v":"让类库和程序更安全。"}]},{"t":"heading","d":1,"p":{"lines":[116,117]},"v":"12.14 总结","c":[{"t":"list_item","d":3,"p":{"lines":[117,118]},"v":"异常是Java程序设计不可分隔的一部分，如果不了解如何使用，只能完成很有限的工作。"},{"t":"list_item","d":3,"p":{"lines":[118,119]},"v":"Java坚定地强调将所有的错误都已异常形式报告。"}]}],"p":{}}</svg>
              </div>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>12.6 Throwable的子类在构造器都可以接受一个cause对象作为参数。在Throwable子类中，只有三种基本的异常类提供了带cause参数的构造器。这里冲突了？？？</li>
<li>使用initCause方法而不是构造器？？？</li>
</ul>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2021/12/16/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8813%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"13.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"可以证明，字符串操作是计算机程序设计中最常见的行为。"}]},{"t":"heading","d":1,"p":{"lines":[3,4]},"v":"13.1 不可变String","c":[{"t":"list_item","d":3,"p":{"lines":[4,5]},"v":"String对象是不可变的。"},{"t":"list_item","d":3,"p":{"lines":[5,6]},"v":"String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修稿后的字符串内容。"}]},{"t":"heading","d":1,"p":{"lines":[7,8]},"v":"13.2 重载“+”与StringBuilder","c":[{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"不可变性会带来一定的效率问题。"},{"t":"list_item","d":3,"p":{"lines":[9,10]},"v":"重载：一个操作符在应用于特定的类时，被赋予了特殊的意义。"},{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"进行重载时，编译器自动引入了StringBuilder类，因为它更高效。"},{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"显式创建StringBuilder允许预先指定大熊啊，避免多次重新分配缓存。"},{"t":"list_item","d":3,"p":{"lines":[12,13]},"v":"如果在字符串拼接中使用循环，最好创建一个StringBuilder，用它来构造最终的结果。"},{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"StringBuilder方法：append、insert、replace、substring、reverse、toString。"}]},{"t":"heading","d":1,"p":{"lines":[15,16]},"v":"13.3 无意识的递归","c":[{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"toString中使用this，导致递归调用。发生了自动转换，编译器将this转换为String，调用this上的toString。"}]},{"t":"heading","d":1,"p":{"lines":[18,19]},"v":"13.4 String上的操作"},{"t":"heading","d":1,"p":{"lines":[20,21]},"v":"13.5 格式化输出","c":[{"t":"list_item","d":3,"p":{"lines":[21,22]},"v":"Java SE5 推出了C语言中printf风格的格式化输出功能。"},{"t":"list_item","d":3,"p":{"lines":[22,23]},"v":"占位符，称作格式修饰符。"},{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"Java SE5 引入的format方法可用于PrintStream或PrintWriter对象，其中也包括System.out对象。"},{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"在Java中，所有新的格式化功能都有java.util.Formatter类处理。"},{"t":"list_item","d":3,"p":{"lines":[25,26]},"v":"格式修饰符语法： %[argument_index$][flags][width][.precision]coversion。"},{"t":"list_item","d":3,"p":{"lines":[26,27]},"v":"类型转换字符：d（十进制整数）、c（Unicode字符）、b（Boolean值）、s（String）、f（十进制浮点数）、e（科学技术浮点数）、x（十六进制整数）、h（十六进制散列码）、%。"},{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"Java SE5参考了C中的sprintf方法，以生成格式化的String对象。"},{"t":"list_item","d":3,"p":{"lines":[28,29]},"v":"String.format是一个static方法，接受与Formatter.format方法一样的参数，返回一个String对象。"},{"t":"list_item","d":3,"p":{"lines":[29,30]},"v":"在String。format内部，也是创建一个Formatter对象，然后将传入的参数转给该Formatter。"},{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"使用String.format，制作以十六进制格式查看内容的工具。"}]},{"t":"heading","d":1,"p":{"lines":[32,33]},"v":"13.6 正则表达式","c":[{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"在Java中，字符串操作主要集中在String、StringBuffer和StringTokenizer类，与正则表达式相比，只能提供相当简单的功能。"},{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"正则表达式是一种强大而灵活的文本处理工具。使用正则表达式，能够以编程的方式，构造复杂的文本模式，并对输入的字符串进行搜索。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"正则表达式提供一种完全通用的方式，能够解决各种字符串处理相关的问题：匹配、选择、编译及验证。"},{"t":"list_item","d":3,"p":{"lines":[37,38]},"v":"一般来说，正则表达式就是以某种方式来描述字符串。"},{"t":"list_item","d":3,"p":{"lines":[38,39]},"v":"Java对反斜线的不同处理。"},{"t":"list_item","d":3,"p":{"lines":[39,40]},"v":"应用正则表达式最简单的途径，就是利用String类内建的功能。matches、split、replace、replaceAll、replaceFirst。"},{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"如果正则表达式不是只使用一次的话，非String对象的正则表达式明显具备更佳的性能。"},{"t":"list_item","d":3,"p":{"lines":[42,43]},"v":"参考java.util.regex.Pattern。"},{"t":"list_item","d":3,"p":{"lines":[44,45]},"v":"量词描述了一个模式吸收输入文本的方式： 贪婪型、勉强型、占有型。"},{"t":"list_item","d":3,"p":{"lines":[45,46]},"v":"接口CharSequence从CharBuffer、String、StringBuffer、StringBuilder类之中抽象出了字符序列的一般化定义： charAt、length、subSequence、toString。"},{"t":"list_item","d":3,"p":{"lines":[46,47]},"v":"多数正则表达式都接受CharSequence类型的参数。"},{"t":"list_item","d":3,"p":{"lines":[48,49]},"v":"使用Pattern.compile方法编译正则表达式构造功能强大的正则表达式对象。"},{"t":"list_item","d":3,"p":{"lines":[49,50]},"v":"Pattern.matcher方法生成要给Matcher对象。参考java.util.regex.Matcher。"},{"t":"list_item","d":3,"p":{"lines":[50,51]},"v":"组是用括号划分的正则表达式，可以根据组的编号来引用某个组。组号为0表示整个表达式。"},{"t":"list_item","d":3,"p":{"lines":[51,52]},"v":"Pattern标记。"}]},{"t":"heading","d":1,"p":{"lines":[53,54]},"v":"13.7 扫描输入","c":[{"t":"list_item","d":3,"p":{"lines":[54,55]},"v":"Java SE5新增了Scanner类，可以大大减轻扫描输入的工作负担。"},{"t":"list_item","d":3,"p":{"lines":[55,56]},"v":"Scanner的构造器可以接受任何类型的输入对象，包括File、InputStream、String、Readable。"},{"t":"list_item","d":3,"p":{"lines":[56,57]},"v":"默认情况下，Scanner根据空白字符对输入进行分词，但可用正则表达式指定所需的定界符。"},{"t":"list_item","d":3,"p":{"lines":[57,58]},"v":"使用正则表达式指定定界符时，仅仅针对下一个输入分词进行匹配，如果正则表达式中含有定界符，那永远不可能匹配成功。"}]},{"t":"heading","d":1,"p":{"lines":[59,60]},"v":"13.8 StringTokenizer","c":[{"t":"list_item","d":3,"p":{"lines":[60,61]},"v":"在Java引入正则表达式（J2SE 1.4）和Scanner（Java SE5）类之前，分隔字符串的唯一方法是使用StringTokenizer来分词。"},{"t":"list_item","d":3,"p":{"lines":[61,62]},"v":"StringTokenizer已经可以废弃不用了。"}]},{"t":"heading","d":1,"p":{"lines":[63,64]},"v":"13.9 总结","c":[{"t":"list_item","d":3,"p":{"lines":[64,65]},"v":"过去，Java对字符串操作的支持相当不完善。到目前为止，已经很完善了。"}]}],"p":{}}</svg>
              </div>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>类型信息</title>
    <url>/2021/12/20/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8814%EF%BC%89%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"14.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"运行时类型信息（Runtime Type Information, RTTI）使得可以在程序运行时发现和使用类型信息。"},{"t":"list_item","d":3,"p":{"lines":[2,3]},"v":"从只能在编译期执行面向类型的操作的禁锢中解脱了出来。"},{"t":"list_item","d":3,"p":{"lines":[3,4]},"v":"Java在运行时识别对象和类的信息： 1. “传统的”RTTI，假定在编译时已经知道了所有的类型； 2. 反射，在运行时发现和使用类的信息。"}]},{"t":"heading","d":1,"p":{"lines":[5,6]},"v":"14.1 为什么需要RTTI","c":[{"t":"list_item","d":3,"p":{"lines":[6,7]},"v":"在Java中，所有的类型转换都是在运行时进行正确性检查的。"},{"t":"list_item","d":3,"p":{"lines":[7,8]},"v":"RTTI名字的含义：在运行时，识别一个对象的类型。"},{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"RTTI类型转换，在编译时，由容器和Java泛型系统来强制确保；在运行时，由类型转换操作来确保。"},{"t":"list_item","d":3,"p":{"lines":[9,10]},"v":"多态机制决定引用所指向的具体对象实际执行的代码。"},{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"特殊的编程问题，需要知道某个泛化引用的确切类型，使用最简单的问题解决。 -- 使用RTTI。"}]},{"t":"heading","d":1,"p":{"lines":[12,13]},"v":"14.2 Class对象","c":[{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的。 -- Class对象。"},{"t":"list_item","d":3,"p":{"lines":[14,15]},"v":"Class对象包含了与类有关的信息。Class对象就是用来创建类的所有“常规”对象的。"},{"t":"list_item","d":3,"p":{"lines":[15,16]},"v":"Java使用Class对象来执行其RTTI。"},{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"类是程序的一部分，每个类都有一个Class对象。"},{"t":"list_item","d":3,"p":{"lines":[17,18]},"v":"JVM使用类加载来生成这个类的对象。"},{"t":"list_item","d":3,"p":{"lines":[18,19]},"v":"所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。 -- 构造器也是类的静态方法。"},{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"Class对象仅在需要的时候才被加载，static初始化是在类加载时进行的。"},{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"Class.forName 时取得Class对象的引用的一种方法。副作用：没有类还没有加载就加载它。"},{"t":"list_item","d":3,"p":{"lines":[21,22]},"v":"只要想在运行时使用类型信息，就必须首先获得对恰当的Class对象的引用。 1. Class.forName；2. getClass； 3. 类字面常量 .class。"},{"t":"list_item","d":3,"p":{"lines":[22,23]},"v":"Class方法：getName、getSimpleName、getCanonicalName、getInterfaces、getSuperclass、newInstance。"},{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"类字面常量更简单、跟安全。因为在编译时就会受到检查。"},{"t":"list_item","d":3,"p":{"lines":[25,26]},"v":"类字面常量可用于普通的类、接口、数组以及基本数据类型。"},{"t":"list_item","d":3,"p":{"lines":[26,27]},"v":"类字面常量对于基本数据类型的包装器，有一个标准字段TYPE，是一个引用，指向对应的基本数据类型的Class对象。"},{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"为了使用类而做的准备工作的步骤： 1. 加载； 2. 链接； 3. 初始化。"},{"t":"list_item","d":3,"p":{"lines":[28,29]},"v":"类字面常量不会自动地初始化该Class对象，被延迟到对静态方法或者非常数静态域进行首次引用时才执行。"},{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"Class引用表示的是所指向的对象的确切类型，而该对象是Class类的一个对象。"},{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"Java SE5 通过对Class引用所指向的Class对象的类型进行限定，使得类型变得更具体了一些。"},{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"通过使用泛型语法，可以让编译器强制执行额外的类型检查。"},{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"使用通配符“?”在使用泛化的Class引用时放松限制。"},{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"在Java SE5中，Class&lt;?&gt;由于平凡的Class，即便它们时等价的。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"使用通配符与extends关键字结合，创建一个范围。"},{"t":"list_item","d":3,"p":{"lines":[36,37]},"v":"向Class引用添加泛型语法的原因仅仅时为了提供编译期类型检查。否则直到运行时才发现错误，显得很不方便。"},{"t":"list_item","d":3,"p":{"lines":[38,39]},"v":"Java SE5添加了用于Class引用的转型语法cast。"},{"t":"list_item","d":3,"p":{"lines":[39,40]},"v":"新的转型语法对于无法使用普通转型的情况显得非常有用。存储了Class引用，并希望以后通过这个引用来执行转型。"},{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"Java SE5中另一个没有任何用处的新特性是asSubclass。将一个类对象转型为更加具体的类型。"}]},{"t":"heading","d":1,"p":{"lines":[42,43]},"v":"14.3 类型转换前先做检查","c":[{"t":"list_item","d":3,"p":{"lines":[43,44]},"v":"RTTI形式： 1. 传统的类型转换，由RTTI确保类型转换的正确性； 2. 代表对象的类型Class对象，获取运行时所需的信息； 3. instanceof。"},{"t":"list_item","d":3,"p":{"lines":[44,45]},"v":"对instanceof有比较严格的限制：只可将其与命名类型进行比较，而不能与Class对象作比较。"},{"t":"list_item","d":3,"p":{"lines":[45,46]},"v":"使用类字面常量代替Class.forName。"},{"t":"list_item","d":3,"p":{"lines":[46,47]},"v":"Class.isInstance方法提供了一种动态地测试对象的途径。"},{"t":"list_item","d":3,"p":{"lines":[47,48]},"v":"Class.isAssignableFrom。"}]},{"t":"heading","d":1,"p":{"lines":[49,50]},"v":"14.4 注册工厂","c":[{"t":"list_item","d":3,"p":{"lines":[50,51]},"v":"使用工厂方法设计模式，将对象的创建工作交给类自己完成。"}]},{"t":"heading","d":1,"p":{"lines":[52,53]},"v":"14.5 instanceof与Class的等价性","c":[{"t":"list_item","d":3,"p":{"lines":[53,54]},"v":"instanceof和isInstance保持了类型的概念。"},{"t":"list_item","d":3,"p":{"lines":[54,55]},"v":"用==比较实际的Class对象，没有考虑继承。"}]},{"t":"heading","d":1,"p":{"lines":[56,57]},"v":"14.6 反射：运行时的类信息","c":[{"t":"list_item","d":3,"p":{"lines":[57,58]},"v":"在编译时，编译器必须知道所有要通过RTTI来处理的类。"},{"t":"list_item","d":3,"p":{"lines":[58,59]},"v":"RTTI限制：获取一个指向某个并不在程序空间中的对象的引用，在编译时程序无法获知这个对象所属的类。 1. 基于构件的编程； 2. GUI事件的构件。"},{"t":"list_item","d":3,"p":{"lines":[59,60]},"v":"反射提供了一种机制，用来检查可用的方法，并返回方法名。"},{"t":"list_item","d":3,"p":{"lines":[60,61]},"v":"运行时获取类的信息的另一个动机：希望提供在跨网络的远程平台上创建和运行对象的能力。 --RMI。"},{"t":"list_item","d":3,"p":{"lines":[61,62]},"v":"远程方法调用（RMI）允许一个Java程序员将对象分布到多态机器上。"},{"t":"list_item","d":3,"p":{"lines":[62,63]},"v":"Class类与java.lang.reflect类库（包含Field、Method以及Constructor，都实现了Member接口）一起对反射的概念进行了支持。"},{"t":"list_item","d":3,"p":{"lines":[63,64]},"v":"匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。"},{"t":"list_item","d":3,"p":{"lines":[64,65]},"v":"RTTI和反射之间的真正区别只在于，对RTTI来说，编译器在编译时打开和检查.class文件，而对于反射来说，是在运行时打开和检查.class文件。"},{"t":"list_item","d":3,"p":{"lines":[65,66]},"v":"反射在Java中是用来支持其他特性的，例如对象序列化和JavaBean。"},{"t":"list_item","d":3,"p":{"lines":[66,67]},"v":"反射机制提供了一种方法，能够编写可以自动展示完整接口的简单工具。 -- 类方法提取器。"}]},{"t":"heading","d":1,"p":{"lines":[68,69]},"v":"14.7 动态代理","c":[{"t":"list_item","d":3,"p":{"lines":[69,70]},"v":"代理是为了提供额外的或不同的操作，而插入的用来代替实际对象的对象。"},{"t":"list_item","d":3,"p":{"lines":[70,71]},"v":"Java的动态代理比代理的思想更向前迈进了一步，因为它可以动态地创建代理并动态地代理对所代理方法的调用。"},{"t":"list_item","d":3,"p":{"lines":[71,72]},"v":"在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的对策。"},{"t":"list_item","d":3,"p":{"lines":[72,73]},"v":"通过调用静态方法Proxy.newProxyInstance()可以创建动态代理。"}]},{"t":"heading","d":1,"p":{"lines":[74,75]},"v":"14.8 空对象","c":[{"t":"list_item","d":3,"p":{"lines":[75,76]},"v":"当使用内置的null表示缺少对象时，在每次使用引用时都必须测试其是否为null，这显得枯燥，而且势必产生相当乏味的代码。"},{"t":"list_item","d":3,"p":{"lines":[76,77]},"v":"null除了在试图用它执行任何操作来产生NPE之外，没有其它任何行为。"},{"t":"list_item","d":3,"p":{"lines":[77,78]},"v":"空对象可以接受传递给它的所代表对象的消息，但是将返回表示为实际上并不存在任何“真实”对象的值。"},{"t":"list_item","d":3,"p":{"lines":[78,79]},"v":"空对象是看作是策略模式的特例。"},{"t":"list_item","d":3,"p":{"lines":[79,80]},"v":"到处使用空对象没有任何意义。"},{"t":"list_item","d":3,"p":{"lines":[80,81]},"v":"空对象最有用之处在于它更靠近数据，因为对象表示的是问题空间内的实体。"},{"t":"list_item","d":3,"p":{"lines":[81,82]},"v":"即使空对象可以相应实际对象可以相应的所有消息，仍需要某种方式去测试其是否为空。 -- 创建标记接口，使用内置工具instanceof。"},{"t":"list_item","d":3,"p":{"lines":[82,83]},"v":"空对象都是单例。使用静态内部类实现，添加static final域。"},{"t":"list_item","d":3,"p":{"lines":[83,84]},"v":"在某些地方仍必须测试空对象，与检查是否为null没有差异，但在其它地方不必执行额外测试，而可以直接假设所有的对象都是有效的。"},{"t":"list_item","d":3,"p":{"lines":[84,85]},"v":"多种不同类型的空对象。 -- 动态代理。"},{"t":"list_item","d":3,"p":{"lines":[85,86]},"v":"空对象的逻辑变体是模拟对象和桩。只是假扮可以传递实际信息的存活对象。"}]},{"t":"heading","d":1,"p":{"lines":[87,88]},"v":"14.9 接口与类型信息","c":[{"t":"list_item","d":3,"p":{"lines":[88,89]},"v":"interface关键字的一种重要目标是允许程序员隔离构件，进而降低耦合性。但是通过类型信息，这种耦合性还是会传播出去。"},{"t":"list_item","d":3,"p":{"lines":[89,90]},"v":"解决方案：1. 直接声明，自己负责； 2. 对实现使用包访问权限（反射可访问，没有任何方式可以阻止。final域不能修改）。"},{"t":"list_item","d":3,"p":{"lines":[90,91]},"v":"所有违反访问权限的操作并非世上最糟之事。通常反射带来的好处是不可否认的。"}]},{"t":"heading","d":1,"p":{"lines":[92,93]},"v":"14.10 总结","c":[{"t":"list_item","d":3,"p":{"lines":[93,94]},"v":"使用RTTI在代码开发和维护过程中损失了多态机制的重要价值。"},{"t":"list_item","d":3,"p":{"lines":[94,95]},"v":"面向编程语言的目的是凡是可以使用的地方都使用多态机制，只在必需的时候使用RTTI。"},{"t":"list_item","d":3,"p":{"lines":[95,96]},"v":"RTTI与多态的冲突。"},{"t":"list_item","d":3,"p":{"lines":[96,97]},"v":"反射允许更加动态的编程风格，开创了编程的新世界。"},{"t":"list_item","d":3,"p":{"lines":[97,98]},"v":"一致的错误报告模型的存在使得能够通过使用反射编写动态代码。"}]}],"p":{}}</svg>
              </div>
  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2021/12/20/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8815%EF%BC%89%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"15.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。"},{"t":"list_item","d":3,"p":{"lines":[2,3]},"v":"在面向对象编程语言中，多态算是一种泛化机制。这种灵活性大多数时候也会有一些性能损耗。"},{"t":"list_item","d":3,"p":{"lines":[3,4]},"v":"有时候，拘泥于单继承体系，会使程序受限太多。有的时候，即便使用了接口，对程序的约束也还是太强。"},{"t":"list_item","d":3,"p":{"lines":[4,5]},"v":"泛型实现了参数化类型的概念，使代码可以应用于多种类型。"},{"t":"list_item","d":3,"p":{"lines":[5,6]},"v":"泛型在编程语言中出现时，最初的目的是希望类或方法能够具备最广泛的表达能力。通过解耦类或方法与所使用的类型之间的约束。"},{"t":"list_item","d":3,"p":{"lines":[6,7]},"v":"Java中的泛型并没有这么高的追求。"}]},{"t":"heading","d":1,"p":{"lines":[8,9]},"v":"15.1 与C++的比较","c":[{"t":"list_item","d":3,"p":{"lines":[9,10]},"v":"设计Java的灵感主要来自C++。尽管如此，学习Java时，基本上可以不用参考C++。除非与C++的比较可以加深理解。"},{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"Java中的泛型需要与C++进行一番比较。理解C++模板的某些方面，有助于理解泛型的基础。"}]},{"t":"heading","d":1,"p":{"lines":[12,13]},"v":"15.2 简单泛型","c":[{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"有许多原因促成了泛型的出现，而最引人注目的一个原因，就是为了创造容器类。"},{"t":"list_item","d":3,"p":{"lines":[14,15]},"v":"泛型的主要目的之一是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。"},{"t":"list_item","d":3,"p":{"lines":[15,16]},"v":"Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。"},{"t":"list_item","d":3,"p":{"lines":[17,18]},"v":"有了泛型，能够仅一次方法调用就能返回多个对象。同时，在编译期就能确保类型安全。"},{"t":"list_item","d":3,"p":{"lines":[18,19]},"v":"元组（数据传送对象、信使）：将一组对象直接打包存储于其中的一个单一对象。这个对象容器允许读取其中元素，但是不允许向其中存放新的对象。"},{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型。"},{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"可以读取，随心所欲的使用，但是无法赋值。使用 public final修饰。"},{"t":"list_item","d":3,"p":{"lines":[21,22]},"v":"利用继承机制实现长度更长的元组。"},{"t":"list_item","d":3,"p":{"lines":[22,23]},"v":"为了使用元组，只需定义一个长度适合的元组，将其作为方法的返回值，然后在return语句中创建该元组，并返回即可。"},{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"使用泛型实现内部链式存储机制。"},{"t":"list_item","d":3,"p":{"lines":[25,26]},"v":"使用末端哨兵来判断何时为空。"},{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"使用泛型构建一个可以应用于各种类型的对象的工具。"}]},{"t":"heading","d":1,"p":{"lines":[29,30]},"v":"15.3 泛型接口","c":[{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"生成器，一种专门负责创建对象的类。是工厂方法的一种应用（生成器不需要参数，而工厂方法一般需要参数）。"},{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"基本类型无法作为类型参数。 -- 自动装箱、自动拆箱。"},{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"适配器。"}]},{"t":"heading","d":1,"p":{"lines":[34,35]},"v":"15.4 泛型方法","c":[{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"可以在类中包含参数化方法。是否拥有泛型方法，与其所在的类是否是泛型类没有关系。"},{"t":"list_item","d":3,"p":{"lines":[36,37]},"v":"泛型方法使得该方法能够独立于类而产生变化。"},{"t":"list_item","d":3,"p":{"lines":[37,38]},"v":"如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法。对于一个static方法而言，无法访问泛型类的类型参数。"},{"t":"list_item","d":3,"p":{"lines":[38,39]},"v":"使用泛型类时，必须在创建对象的时候指定类型参数的值。而使用泛型方法的时候，通常不必指明参数类型，编译器会进行类型参数推断。"},{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"使用泛型类无法进行泛型推断。 -- 创建工具类，定义泛型方法，简化部分工作。 -- 额外复杂度。"},{"t":"list_item","d":3,"p":{"lines":[41,42]},"v":"类型推断只对赋值操作有效，其他时候并不起作用。"},{"t":"list_item","d":3,"p":{"lines":[42,43]},"v":"在泛型方法中，可以显式地指明类型。必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内。"},{"t":"list_item","d":3,"p":{"lines":[43,44]},"v":"显式指明类型时，如果时定义在该方法的类的内部，必须在点操作符之前使用this关键字。如果是static方法，必须在点操作符之前加上类名。"},{"t":"list_item","d":3,"p":{"lines":[44,45]},"v":"只有在编写非赋值语句时，才需要显式指明类型。"},{"t":"list_item","d":3,"p":{"lines":[46,47]},"v":"泛型方法与可变参数列表能够很好的共存。"},{"t":"list_item","d":3,"p":{"lines":[48,49]},"v":"有了类型参数推断，再加上static方法，可以重新编写之前的元组工具，使其成为更通用的工具类库。"},{"t":"list_item","d":3,"p":{"lines":[50,51]},"v":"用Set来表达数学中的关系式。并集、交集、差集、补集。"}]},{"t":"heading","d":1,"p":{"lines":[52,53]},"v":"15.5 匿名内部类","c":[{"t":"list_item","d":3,"p":{"lines":[53,54]},"v":"泛型可以应用于内部类以及匿名内部类。"}]},{"t":"heading","d":1,"p":{"lines":[55,56]},"v":"15.6 构建复杂类型","c":[{"t":"list_item","d":3,"p":{"lines":[56,57]},"v":"泛型的一个重要好处是能够简单而安全地创建复杂的模型。"}]},{"t":"heading","d":1,"p":{"lines":[58,59]},"v":"15.7 擦除的神秘之处","c":[{"t":"list_item","d":3,"p":{"lines":[59,60]},"v":"在泛型代码内部，无法获得任何有关泛型参数类型的信息。"},{"t":"list_item","d":3,"p":{"lines":[60,61]},"v":"Java泛型是使用擦除来实现的。使用泛型时，任何具体的类型信息都被擦除了。"},{"t":"list_item","d":3,"p":{"lines":[62,63]},"v":"C++中，当模板被实例化时，模板代码知道其模板参数的类型。Java必须给定泛型类的边界，重用extends关键字。"},{"t":"list_item","d":3,"p":{"lines":[63,64]},"v":"泛型类型参数将擦除到它的第一个边界。"},{"t":"list_item","d":3,"p":{"lines":[64,65]},"v":"希望代码能够跨多个类工作时，使用泛型才有所帮助。"},{"t":"list_item","d":3,"p":{"lines":[66,67]},"v":"擦除不是一个语言特性，是Java的泛型实现的一种折中。"},{"t":"list_item","d":3,"p":{"lines":[67,68]},"v":"擦除减少了泛型的泛化性。"},{"t":"list_item","d":3,"p":{"lines":[68,69]},"v":"在基于擦除的实现中，泛型类被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型。"},{"t":"list_item","d":3,"p":{"lines":[69,70]},"v":"泛型类型只有在静态类型检查期间才出现，在此之后，程序中所有的泛型类型都将被擦除，替换为它们的非泛型上界。"},{"t":"list_item","d":3,"p":{"lines":[70,71]},"v":"擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“迁移兼容性”。"},{"t":"list_item","d":3,"p":{"lines":[72,73]},"v":"擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作之中。例如转型、instanceof操作和new表达式。"},{"t":"list_item","d":3,"p":{"lines":[73,74]},"v":"擦除和迁移兼容性意味着，使用泛型并不是强制的。"},{"t":"list_item","d":3,"p":{"lines":[74,75]},"v":"当希望将类型参数不要仅仅当作Object处理时，需要付出额外努力来管理边界。"},{"t":"list_item","d":3,"p":{"lines":[75,76]},"v":"Java SE5提供了@SuppressWarnings注解关闭警告。"},{"t":"list_item","d":3,"p":{"lines":[77,78]},"v":"泛型最令人困惑的方面源自：可以表示没有任何意义的事物。"},{"t":"list_item","d":3,"p":{"lines":[78,79]},"v":"对于在泛型中创建数组，使用Array.newInstance是推荐的方式。"},{"t":"list_item","d":3,"p":{"lines":[79,80]},"v":"即便擦除在方法或类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性。"},{"t":"list_item","d":3,"p":{"lines":[80,81]},"v":"因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点。"},{"t":"list_item","d":3,"p":{"lines":[81,82]},"v":"在泛型中的所有动作都发生在边界处。对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。"}]},{"t":"heading","d":1,"p":{"lines":[83,84]},"v":"15.8 擦除的补偿","c":[{"t":"list_item","d":3,"p":{"lines":[84,85]},"v":"擦除丢失了在泛型代码中执行某些操作的能力。任何在运行时需要知道确切类型信息的操作都将无法工作。"},{"t":"list_item","d":3,"p":{"lines":[85,86]},"v":"有时必须通过引入类型标签来对擦除进行补偿。这意味着需要显式传递类型的Class对象，以便在类型表达式中使用。"},{"t":"list_item","d":3,"p":{"lines":[86,87]},"v":"编译器将确保类型标签可以匹配泛型参数。"},{"t":"list_item","d":3,"p":{"lines":[88,89]},"v":"无法创建一个new T()。在C++中，这种操作很自然、很直观，并且很安全。在编译期受到检查。"},{"t":"list_item","d":3,"p":{"lines":[89,90]},"v":"Java中的解决方案是传递一个工厂对象，并使用它来创建新的实例。最便利的工厂对象就是Class对象。"},{"t":"list_item","d":3,"p":{"lines":[90,91]},"v":"Sun建议使用显式的工厂，并将限制其类型，使得只能接受实现了这个工厂的类。"},{"t":"list_item","d":3,"p":{"lines":[91,92]},"v":"另一种方式是模板方法设计模式。"},{"t":"list_item","d":3,"p":{"lines":[93,94]},"v":"不能创建泛型数组。一般的解决方案是使用ArrayList。这将获得数组的行为，以及由泛型提供的编译期的类型安全。"},{"t":"list_item","d":3,"p":{"lines":[94,95]},"v":"可以定义一个泛型数组引用，但是永远都不能创建这个确切类型的数组（包括类型参数）。"},{"t":"list_item","d":3,"p":{"lines":[95,96]},"v":"创建一个Object数组，并将其转型为泛型数组类型。这可以编译，但是不能运行，将产生ClassCaseException。"},{"t":"list_item","d":3,"p":{"lines":[96,97]},"v":"所有数组无论它们持有的类型如何，都具有相同的结构（每个数组槽位的尺寸和数组的布局）。"},{"t":"list_item","d":3,"p":{"lines":[97,98]},"v":"成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型。"},{"t":"list_item","d":3,"p":{"lines":[98,99]},"v":"最好是在集合内部使用Object[]，使用数组元素时，添加一个对T的转型。"},{"t":"list_item","d":3,"p":{"lines":[99,100]},"v":"Java SE5标准类库的源代码，从Object数组到参数化类型的转型遍及各处"},{"t":"list_item","d":3,"p":{"lines":[100,101]},"v":"即使在Java类库源代码中出现了某些惯用法，也不能表示这就是正确的解决之道。"}]},{"t":"heading","d":1,"p":{"lines":[102,103]},"v":"15.9 边界","c":[{"t":"list_item","d":3,"p":{"lines":[103,104]},"v":"边界使得可以在用于泛型的参数类型上设置限制条件。"},{"t":"list_item","d":3,"p":{"lines":[104,105]},"v":"尽管可以强制规定泛型可以应用的类型，但是其潜在的一个更重要的效果是可以按照自己的边界类型来调用方法。"},{"t":"list_item","d":3,"p":{"lines":[105,106]},"v":"extends关键字在泛型边界上下文环境中和在普通情况下所具有的意义是完全不同的。"},{"t":"list_item","d":3,"p":{"lines":[106,107]},"v":"在继承的每个层次上添加边界限制。"},{"t":"list_item","d":3,"p":{"lines":[107,108]},"v":"通配符被限制为单一边界。"}]},{"t":"heading","d":1,"p":{"lines":[109,110]},"v":"15.10 通配符","c":[{"t":"list_item","d":3,"p":{"lines":[110,111]},"v":"可以向导出类型的数组赋予基类型的数组引用。 -- 向上转型不合适用在这里。"},{"t":"list_item","d":3,"p":{"lines":[111,112]},"v":"数组的行为是它可以持有其它对象。数据对象可以保留有关它们包含的对象类型的规则。"},{"t":"list_item","d":3,"p":{"lines":[112,113]},"v":"对数组的赋值，在运行时可以发现插入了不正确的类型，但是泛型的主要目标之一是将这种错误检测移入到编译期。"},{"t":"list_item","d":3,"p":{"lines":[113,114]},"v":"试图使用泛型容器来代替数组。 -- 编译错误。"},{"t":"list_item","d":3,"p":{"lines":[114,115]},"v":"与数组不通过，泛型没有内建的协变类型。数组在语言中是完全定义的，因此可以内建了编译期和运行时的检查。"},{"t":"list_item","d":3,"p":{"lines":[115,116]},"v":"在两个类型之间建立某种类型的向上转型关系，这是通配符所允许的。 -- 丢失向其中床底任何对象的能力。"},{"t":"list_item","d":3,"p":{"lines":[117,118]},"v":"ArrayList，add接受一个具有泛型参数类型的参数，但是contains和indexOf接受Object类型的参数。"},{"t":"list_item","d":3,"p":{"lines":[118,119]},"v":"编译器将直接拒绝对参数列表中设计通配符的方法的调用。"},{"t":"list_item","d":3,"p":{"lines":[120,121]},"v":"超类型通配符，可以声明通配符是由某个特定类的任何基类来界定的。"},{"t":"list_item","d":3,"p":{"lines":[121,122]},"v":"不能对泛型类型给出一个超类型边界（&lt;T super MyClass&gt;）。使得可以安全地传递一个类型对象到泛型类型中。"},{"t":"list_item","d":3,"p":{"lines":[122,123]},"v":"超类型边界放松了在可以向方法传递的参数上所作的限制。"},{"t":"list_item","d":3,"p":{"lines":[124,125]},"v":"使用无界通配符好像等价于使用原生类型。"},{"t":"list_item","d":3,"p":{"lines":[125,126]},"v":"在处理多个泛型参数时，有时允许一个参数可以是任何类型（使用无界通配符），同时为其它参数确定某种特定类型。"},{"t":"list_item","d":3,"p":{"lines":[126,127]},"v":"原生类型将持有任何类型的组合，而通配符将持有具有某种具体类型的同构集合。"},{"t":"list_item","d":3,"p":{"lines":[127,128]},"v":"编译器何时关注原生类型和设计无界通配符的类型之间的差异？ -- 示例。"},{"t":"list_item","d":3,"p":{"lines":[128,129]},"v":"使用确切类型代替通配符类型的好处是，可以用泛型参数来做更多的事。"},{"t":"list_item","d":3,"p":{"lines":[129,130]},"v":"使用通配符必须接受范围更宽的参数化类型作为参数。"},{"t":"list_item","d":3,"p":{"lines":[131,132]},"v":"有一种情况特别需要使用&lt;?&gt;而不是原生类型。"},{"t":"list_item","d":3,"p":{"lines":[132,133]},"v":"如果向一个使用&lt;?&gt;的方法传递原生类型，编译器可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。这被称为捕获转换。"},{"t":"list_item","d":3,"p":{"lines":[133,134]},"v":"捕获转换只有在方法内部，且需要使用确切的类型的情况下可以工作。"}]},{"t":"heading","d":1,"p":{"lines":[135,136]},"v":"15.11 问题","c":[{"t":"list_item","d":3,"p":{"lines":[136,137]},"v":"基本类型不能作为类型参数。 -- 包装器类及自动装箱。"},{"t":"list_item","d":3,"p":{"lines":[137,138]},"v":"自动包装机制不能应用于数组。"},{"t":"list_item","d":3,"p":{"lines":[139,140]},"v":"一个类不能实现同一个泛型接口的两种变体。由于擦除的原因，这两个变体会成为相同的接口。"},{"t":"list_item","d":3,"p":{"lines":[141,142]},"v":"使用带有泛型类型参数的转型或instanceof不会由任何效果。"},{"t":"list_item","d":3,"p":{"lines":[142,143]},"v":"有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。"},{"t":"list_item","d":3,"p":{"lines":[144,145]},"v":"由于擦除的原因，重载方法就产生相同的类型签名。"},{"t":"list_item","d":3,"p":{"lines":[145,146]},"v":"当被擦除的参数不能产生唯一的参数列表时，必须提供明显有区别的方法名。"},{"t":"list_item","d":3,"p":{"lines":[147,148]},"v":"基类劫持了接口。"}]},{"t":"heading","d":1,"p":{"lines":[149,150]},"v":"15.12 自限定的类型","c":[{"t":"list_item","d":3,"p":{"lines":[150,151]},"v":"古怪的循环泛型（CRG）的本质：基类用导出类替代其参数。"},{"t":"list_item","d":3,"p":{"lines":[151,152]},"v":"CRG意味着泛型基类变成了一种其所有导出类的公共功能的模板。在所产生的类中将使用确切类型而不是基类型。"},{"t":"list_item","d":3,"p":{"lines":[153,154]},"v":"自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。"},{"t":"list_item","d":3,"p":{"lines":[154,155]},"v":"自限定的参数意义：可以保证类型参数必须与正在被定义的类相同。"},{"t":"list_item","d":3,"p":{"lines":[155,156]},"v":"自限定限制只能强制作用于继承关系。"},{"t":"list_item","d":3,"p":{"lines":[156,157]},"v":"如果使用自限定，就应该了解这个类所使用的类型参数将于使用这个参数的类具有相同的基类型。"},{"t":"list_item","d":3,"p":{"lines":[158,159]},"v":"自限定的价值在于它们可以产生协变参数类型（方法参数类型会随子类而变化）。"},{"t":"list_item","d":3,"p":{"lines":[159,160]},"v":"如果不适用自限定，将重载参数类型。如果使用了自限定，只能获得某个方法的一个版本，它将接受确切的参数类型。"}]},{"t":"heading","d":1,"p":{"lines":[161,162]},"v":"15.13 动态类型安全","c":[{"t":"list_item","d":3,"p":{"lines":[162,163]},"v":"Java SE5的Collections中有一组工具，可以解决向之前的代码传递泛型容器，从而可能会破坏容器的类型检查问题。"},{"t":"list_item","d":3,"p":{"lines":[163,164]},"v":"工具：checkedCollection、checkedList、checkedMap、checkedSet、checkedSortedMap、checkedSortedSet。"}]},{"t":"heading","d":1,"p":{"lines":[165,166]},"v":"15.14 异常","c":[{"t":"list_item","d":3,"p":{"lines":[166,167]},"v":"由于擦除的原因，将泛型应用于异常是非常受限的。"},{"t":"list_item","d":3,"p":{"lines":[167,168]},"v":"catch语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。"},{"t":"list_item","d":3,"p":{"lines":[168,169]},"v":"泛型类也不能直接或间接继承自Throwable。"},{"t":"list_item","d":3,"p":{"lines":[169,170]},"v":"类型参数可能会在一个方法的throws子句中用到，这使得可以编写随检查型异常的类型而发生变化大的泛型代码。"}]},{"t":"heading","d":1,"p":{"lines":[171,172]},"v":"15.15 混型","c":[{"t":"list_item","d":3,"p":{"lines":[172,173]},"v":"混型基本概念是：混合多个类的能力，以产生一个可以表示混型中所有类型的类。"},{"t":"list_item","d":3,"p":{"lines":[173,174]},"v":"混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。"},{"t":"list_item","d":3,"p":{"lines":[174,175]},"v":"如果在混型中修改某些东西，这些修改会应用于混型所应用的所有类型之上。"},{"t":"list_item","d":3,"p":{"lines":[176,177]},"v":"在C++中，使用多重继承的最大理由，就是为了使用混型。"},{"t":"list_item","d":3,"p":{"lines":[177,178]},"v":"对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。"},{"t":"list_item","d":3,"p":{"lines":[178,179]},"v":"在C++中，可以很容易的创建混型，因为C++能够记住其模板参数的类型。 -- Java泛型不允许这样，擦除会忘记基类类型。"},{"t":"list_item","d":3,"p":{"lines":[180,181]},"v":"一种更常见的推荐解决方案是使用接口来产生混型效果。 -- 使用代理。"},{"t":"list_item","d":3,"p":{"lines":[182,183]},"v":"可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器的继承结构。"},{"t":"list_item","d":3,"p":{"lines":[183,184]},"v":"装饰器只是对由混型提出的问题的一种局限的解决方案。"},{"t":"list_item","d":3,"p":{"lines":[185,186]},"v":"可以使用动态代理来创建一种比装饰器更贴近混型模型的机制。"},{"t":"list_item","d":3,"p":{"lines":[186,187]},"v":"通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。"},{"t":"list_item","d":3,"p":{"lines":[187,188]},"v":"仍旧不如C++的方式好，因为在调用方法之前，必须先向下转型。但是，它更接近于真正的混型。"}]},{"t":"heading","d":1,"p":{"lines":[189,190]},"v":"15.16 潜在类型机制","c":[{"t":"list_item","d":3,"p":{"lines":[190,191]},"v":"潜在类型机制是一种代码组织和复用机制。"},{"t":"list_item","d":3,"p":{"lines":[191,192]},"v":"两种支持潜在类型机制的语言实例是Python（动态类型语言）和C++（静态类型语言）。"},{"t":"list_item","d":3,"p":{"lines":[192,193]},"v":"Java没有对这种特性的支持。"}]},{"t":"heading","d":1,"p":{"lines":[194,195]},"v":"15.17 对缺乏潜在类型机制的补偿","c":[{"t":"list_item","d":3,"p":{"lines":[195,196]},"v":"通过反射使用潜在类型机制。但是将所有的类型检查都转移到了运行时。"},{"t":"list_item","d":3,"p":{"lines":[196,197]},"v":"反射和可变参数，内建的Iterable接口。"},{"t":"list_item","d":3,"p":{"lines":[197,198]},"v":"用适配器仿真潜在类型机制。"}]},{"t":"heading","d":1,"p":{"lines":[199,200]},"v":"15.18 将函数对象用作策略","c":[{"t":"list_item","d":3,"p":{"lines":[200,201]},"v":"函数对象就是在某种程度上行为像函数的对象。"},{"t":"list_item","d":3,"p":{"lines":[201,202]},"v":"函数对象的价值在于，与普通方法不同，它们可以传递出去，并且还可以拥有在多个调用之间持久化的状态。"},{"t":"list_item","d":3,"p":{"lines":[202,203]},"v":"在C++中，潜在类型机制将在调用函数是负责协调各个操作，但是在Java中，需要编写函数对象来将泛型方法适配为特定的需求。"},{"t":"list_item","d":3,"p":{"lines":[203,204]},"v":"适配器模式和策略模式的结合。"}]},{"t":"heading","d":1,"p":{"lines":[205,206]},"v":"15.19 总结"}],"p":{}}</svg>
              </div>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/12/21/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8816%EF%BC%89%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"16.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"对数组的基本看法是，可以创建并组装它们，通过使用整形索引值访问它们的元素，并且它们的尺寸不能改变。"},{"t":"list_item","d":3,"p":{"lines":[2,3]},"v":"如何更加深入地思考数组。"}]},{"t":"heading","d":1,"p":{"lines":[4,5]},"v":"16.1 数组为什么特殊","c":[{"t":"list_item","d":3,"p":{"lines":[5,6]},"v":"数组与其它种类的容器之间的区别有三方面：效率、类型和保存基本类型的能力。"},{"t":"list_item","d":3,"p":{"lines":[6,7]},"v":"在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。"},{"t":"list_item","d":3,"p":{"lines":[7,8]},"v":"为速度所付出的代价是数组对象的大小被固定，并且在其生命周期中不可改变。"}]},{"t":"heading","d":1,"p":{"lines":[9,10]},"v":"16.2 数组是第一级对象","c":[{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"数组标识符只是一个引用，指向在堆中创建的一个真实对象，这个对象用以保存指向其他对象的引用。"},{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"可以作为数组初始化语法的一部分隐式地创建此对象，或者用new表达式显式地创建。"},{"t":"list_item","d":3,"p":{"lines":[12,13]},"v":"聚集初始化操作必须在定义数组的位置使用。"},{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"动态聚集初始化可以在任意位置创建和初始数组对象。"}]},{"t":"heading","d":1,"p":{"lines":[15,16]},"v":"16.3 返回一个数组","c":[{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"C/C++不能返回一个数组，而只能返回指向数组的指针。"}]},{"t":"heading","d":1,"p":{"lines":[18,19]},"v":"16.4 多维数组","c":[{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"对于多维数组，可以通过花括号将每个向量分割开。"},{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"Java SE5 Arrays.deepToString 可以将多维数组转换为多个String。"},{"t":"list_item","d":3,"p":{"lines":[21,22]},"v":"数组中构成矩阵的每个向量都可以具有任意的长度（粗糙数组）。"}]},{"t":"heading","d":1,"p":{"lines":[23,24]},"v":"16.5 数组与泛型","c":[{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"通常，数组与泛型不能很好的结合。不能实例化具有参数化类型的数组。可以参数化数组本身的类型（T[]）。"},{"t":"list_item","d":3,"p":{"lines":[25,26]},"v":"使用参数化方法而不使用参数化类的方便之处在于：不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且可以将其定义为静态的。"},{"t":"list_item","d":3,"p":{"lines":[26,27]},"v":"可以创建对泛型数组的引用，但是不能实例化。可以创建非泛型的数组，然后将其转型。"},{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"数组是协变类型的。"}]},{"t":"heading","d":1,"p":{"lines":[29,30]},"v":"16.6 创建测试数据","c":[{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"Arrays.fill：只能用一个值填充各个位置，对对象而言，就是复制同一个引用进行填充。"}]},{"t":"heading","d":1,"p":{"lines":[32,33]},"v":"16.7 Arrays使用功能","c":[{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"Arrays基本方法：equals、fill、sort、binarySearch、toString、hashCode。"},{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"System.arraycopy，复制数组比用for循环复制要快很多。针对所有类型做了重载。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"Arrays.equals 用来比较整个数组，对所有类型做了重载。数组相等的条件是元素个数相等，且对应位置的元素也相等。"},{"t":"list_item","d":3,"p":{"lines":[36,37]},"v":"Java有两种方式用来提供比较功能，1. Comparable接口； 2. Comparator接口。"},{"t":"list_item","d":3,"p":{"lines":[37,38]},"v":"使用内置的排序方法，就可以对任意的基本类型数组排序；也可以对任意的对象数组排序，只要该对象实现了Comparable接口或具有相关联的Comparator。"},{"t":"list_item","d":3,"p":{"lines":[38,39]},"v":"基本类型数组无法是哦那个Comparator进行排序。"}]},{"t":"heading","d":1,"p":{"lines":[40,41]},"v":"16.8 总结","c":[{"t":"list_item","d":3,"p":{"lines":[41,42]},"v":"在使用最近的Java版本编程时，应该优选容器而不是数组。"}]}],"p":{}}</svg>
              </div>
  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>容器深入研究</title>
    <url>/2021/12/21/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8817%EF%BC%89%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"17.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"更深入地探索这个重要的类库。"}]},{"t":"heading","d":1,"p":{"lines":[3,4]},"v":"17.1 完整的容器分类法","c":[{"t":"list_item","d":3,"p":{"lines":[4,5]},"v":"Java SE5 新添加了Queue、PriorityQueue、BlockingQueue、ConcurrentMap、ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteSet、EnumSet、EnumMap、Collections中的多个便利方法。"}]},{"t":"heading","d":1,"p":{"lines":[6,7]},"v":"17.2 填充容器","c":[{"t":"list_item","d":3,"p":{"lines":[7,8]},"v":"Collections.fill，只复制同一个对象引用来填充整个容器，只对List对象有用。"},{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"Collections.nCopies填充。"},{"t":"list_item","d":3,"p":{"lines":[9,11]},"v":""}]},{"t":"heading","d":1,"p":{"lines":[11,12]},"v":"17.3 Collection的功能方法","c":[{"t":"list_item","d":3,"p":{"lines":[12,13]},"v":"add、addAll、contains、containsAll、isEmpty、iterator、remove、removeAll、retainAll、size、toArray。"},{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"不包括随机访问所选择元素的get方法。如果想检查Collection中的元素，那就必须使用迭代器。"}]},{"t":"heading","d":1,"p":{"lines":[15,16]},"v":"17.4 可选操作","c":[{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"执行各种不同的添加和移除的方法在Collection接口中都是可选操作。这意味着实现类并不需要为这些方法提供功能定义。"},{"t":"list_item","d":3,"p":{"lines":[17,18]},"v":"可选操作声明调用某些方法将不会执行有意义的行为，相反，它们会抛出异常。"},{"t":"list_item","d":3,"p":{"lines":[18,19]},"v":"如果一个操作是可选的，编译器仍旧会严格要求只能调用该接口中的方法。"},{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"将Collection当作参数接受的大部分方法只会从该Collection中读取，而Collection的读取方法都不是可选的。"},{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"将方法定义为可选的，可以防止在设计中出现接口爆炸的情况。"},{"t":"list_item","d":3,"p":{"lines":[21,22]},"v":"未获支持的操作只有在运行时才能探测到，因此它们表示动态类型检查。"},{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"最常见的未获支持的操作，都来源于背后由固定尺寸的数据结构支持的容器。Arrays.asList、Collections类中unmodifiable的方法等。"},{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"对于将容器作为参数接受的方法，其文档应该指定哪些可选方法必须实现。"}]},{"t":"heading","d":1,"p":{"lines":[26,27]},"v":"17.5 List的功能方法","c":[{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"大多数时候只是调用add添加对象，使用get一次取出一个元素，以及调用iterator获取用于该序列的Iterator。"}]},{"t":"heading","d":1,"p":{"lines":[29,30]},"v":"17.6 Set和存储顺序","c":[{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"Set与Collection有完全一样的接口。"},{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"HashSet，为快速查找而设计的Set。元素必须定义hashCode。"},{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"TreeSet，保持次序的Set，底层为树结构。元素必须实现Comparable接口。"},{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"LinkedHashSet，具有HashSet的查询速度，且内部使用链表维护元素插入的顺序。"},{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"应该在覆盖equals时，覆盖hashCode方法。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"SortedSet方法：first、last、subSet、headSet、tailSet。"}]},{"t":"heading","d":1,"p":{"lines":[37,38]},"v":"17.7 队列","c":[{"t":"list_item","d":3,"p":{"lines":[38,39]},"v":"除了并发应用，Queue在Java SE5中仅有的两个实现是LinkedList和PriorityQueue。它们的差异在于排序行为而不是性能。"},{"t":"list_item","d":3,"p":{"lines":[39,40]},"v":"优先队列的排序顺序也是通过实现Comparable而进行控制的。"},{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"双向队列，可以在任何一端添加或移除元素。"},{"t":"list_item","d":3,"p":{"lines":[41,42]},"v":"在LinkedList中包含支持双向队列的方法，但是Java标准类库中没有任何显式的用于双向队列的接口。"}]},{"t":"heading","d":1,"p":{"lines":[43,44]},"v":"17.8 理解Map","c":[{"t":"list_item","d":3,"p":{"lines":[44,45]},"v":"映射表的基本思想是它维护的是键-值关联，可以使用键来查找值。"},{"t":"list_item","d":3,"p":{"lines":[45,46]},"v":"标准的Java类库中包含了Map的几种基本实现，包括：HashMap、TreeMap、LinkedHashMap、WeakHashMap、ConcurrentHashMap、IdentityHashMap。"},{"t":"list_item","d":3,"p":{"lines":[46,47]},"v":"它们的行为特性各不相同，表现在效率、键值对的保存及呈现次序、对象的保存周期、映射表如何在多线程中工作和判断键等价的策略等方面。"},{"t":"list_item","d":3,"p":{"lines":[47,48]},"v":"hashCode是根类Object中的方法，因此所有Java对象都能产生散列码。"},{"t":"list_item","d":3,"p":{"lines":[48,49]},"v":"IdentityHashMap使用==代替equals，用来解决某种特定问题。"}]},{"t":"heading","d":1,"p":{"lines":[50,51]},"v":"17.9 散列与散列码","c":[{"t":"list_item","d":3,"p":{"lines":[51,52]},"v":"Object的hashCode方法，默认使用对象的地址计算散列码。"},{"t":"list_item","d":3,"p":{"lines":[52,53]},"v":"正确的equals方法必须满足5个条件： 1. 自反性； 2. 对称性； 3. 传递性； 4. 一致性； 5. 对任何不是null的x，x.equals(null)一定返回false。"},{"t":"list_item","d":3,"p":{"lines":[53,54]},"v":"默认的Object.equals只是比较对象的地址。"},{"t":"list_item","d":3,"p":{"lines":[54,55]},"v":"如果要使用自己的类作为HashMap的键，必须同时重载hashCode和equals。"}]},{"t":"heading","d":1,"p":{"lines":[56,57]},"v":"17.10 选择接口的不同实现","c":[{"t":"list_item","d":3,"p":{"lines":[57,58]},"v":"实际上只有四种容器：Map、List、Set和Queue。但是每种接口都有不止一个实现版本。"},{"t":"list_item","d":3,"p":{"lines":[58,59]},"v":"性能表现。"},{"t":"list_item","d":3,"p":{"lines":[59,60]},"v":"HashMap的性能因子：容量、初始容量、尺寸、负载因子。"}]},{"t":"heading","d":1,"p":{"lines":[61,62]},"v":"17.11 实用方法","c":[{"t":"list_item","d":3,"p":{"lines":[62,63]},"v":"java.util.Collections类内部的静态方法。"},{"t":"list_item","d":3,"p":{"lines":[63,64]},"v":"unmodifiable、synchronized。"},{"t":"list_item","d":3,"p":{"lines":[64,65]},"v":"Java容器有一种保护机制，能够防止多个线程同时修改同一个容器的内容。-- 快速报错机制。ConcurrentModificationException。"}]},{"t":"heading","d":1,"p":{"lines":[66,67]},"v":"17.12 持有引用","c":[{"t":"list_item","d":3,"p":{"lines":[67,68]},"v":"java.lang.ref类库包含了一组类，这些类为垃圾回收提供了更大的灵活性。"},{"t":"list_item","d":3,"p":{"lines":[68,69]},"v":"有三个继承自抽象类Reference的类: SoftReference、WeakReference、PhantomReference。"},{"t":"list_item","d":3,"p":{"lines":[69,70]},"v":"容器类中有一种特殊的Map，即WeakHashMap，被用来保存WeakReference。"}]},{"t":"heading","d":1,"p":{"lines":[71,72]},"v":"17.13 Java1.0/1.1的容器","c":[{"t":"list_item","d":3,"p":{"lines":[72,73]},"v":"Vector、Enumeration、Hashtable、Stack、BitSet"}]},{"t":"heading","d":1,"p":{"lines":[74,75]},"v":"17.14 总结","c":[{"t":"list_item","d":3,"p":{"lines":[75,76]},"v":"容器类库对于面向对象语言来说是最重要的类库，"},{"t":"list_item","d":3,"p":{"lines":[76,77]},"v":"Java容器类库具有成熟的类库应该具有的完备的功能。"}]}],"p":{}}</svg>
              </div>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>Java I/O系统</title>
    <url>/2021/12/27/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8818%EF%BC%89Java%20IO%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","p":{}}</svg>
              </div>
  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>枚举类型</title>
    <url>/2021/12/27/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8819%EF%BC%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","p":{}}</svg>
              </div>
  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>对象导论</title>
    <url>/2021/11/30/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%881%EF%BC%89%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"前言","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"Sun对Java的设计目标：“我们关系的是，减少开发健壮代码所需的事件以及困难。” -- 为程序员减少复杂性。"}]},{"t":"heading","d":1,"p":{"lines":[3,4]},"v":"1.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[4,5]},"v":"计算机革命起源于机器，因此，编程语言的产生也始于对机器的模仿。"},{"t":"list_item","d":3,"p":{"lines":[5,6]},"v":"计算机并非只是机器那么简单，计算机是头脑延伸的工具，同时还是一种不同类型的表达媒体。"}]},{"t":"heading","d":1,"p":{"lines":[7,8]},"v":"1.1 抽象过程","c":[{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"所有编程语言都提供抽象机制。"},{"t":"list_item","d":3,"p":{"lines":[9,10]},"v":"建立机器模型（位于“解空间”）和实际待解决问题的模型（位于“问题空间”）之间的关联。"},{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"面向对象思想实质：程序可以通过添加新类型的对象使本身适用于某个特定问题。"},{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。"},{"t":"list_item","d":3,"p":{"lines":[12,13]},"v":"OOP与计算机的联系：每个对象看起来都有点像一台微型计算机，具有状态和操作，用户可以要求对象执行这些操作。"},{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"对象具有状态、行为和标识。每一个对象在内存中都有一个唯一的地址。"}]},{"t":"heading","d":1,"p":{"lines":[15,16]},"v":"1.2 每个对象都有一个接口","c":[{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"创建抽象数据类型（类）使面向对象程序设计的基本概念之一。"},{"t":"list_item","d":3,"p":{"lines":[17,18]},"v":"在面向对象程序设计中，实际进行的是创建新的数据类型，但事实上所有的面向对象程序设计语言都使用class关键词来表示数据类型。即类型和类是等价的。"},{"t":"list_item","d":3,"p":{"lines":[18,19]},"v":"类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。"}]},{"t":"heading","d":1,"p":{"lines":[20,21]},"v":"1.3 每个对象都提供服务","c":[{"t":"list_item","d":3,"p":{"lines":[21,22]},"v":"将对象看作“服务提供者”。程序本身向用户提供服务，它将通过调用其它对象提供的服务来实现这一目的。"},{"t":"list_item","d":3,"p":{"lines":[22,23]},"v":"有助于提供对象的内聚性。高内聚是软件设计的基本质量要求之一，意味着一个软件构件的各个方面组合得很好。"},{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"构件是可复用的软件组成成分，可以是类、对象、方法等等。"}]},{"t":"heading","d":1,"p":{"lines":[25,26]},"v":"1.4 被隐藏的具体实现","c":[{"t":"list_item","d":3,"p":{"lines":[26,27]},"v":"访问权限控制。"}]},{"t":"heading","d":1,"p":{"lines":[28,29]},"v":"1.5 复用具体实现","c":[{"t":"list_item","d":3,"p":{"lines":[29,30]},"v":"组合（has-a）、继承（is-a）。"},{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"组合与继承的使用选择：首先考虑组合，因为更加灵活。"}]},{"t":"heading","d":1,"p":{"lines":[32,33]},"v":"1.6 继承","c":[{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"两个类型可以有相同的特性和行为，但是其中一个类型可能必另一个含有更多的特性，并且可以处理更多的消息（或以不同的方式来处理消息）。"},{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"基类与导出类产生差异方法：在导出类中添加新方法（is-like-a），改变现有基类方法的行为（is-a）。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"导出类与基类具有相同的类型，但表示完全相同的类型。"}]},{"t":"heading","d":1,"p":{"lines":[37,38]},"v":"1.7 伴随多态的可转换对象","c":[{"t":"list_item","d":3,"p":{"lines":[38,39]},"v":"处理类型的层次结构使，经常把一个对象不当作它所属的特定类型来对待，而是将其当作基类的对象来堆到。从而可以编写出不依赖于特定类型的代码。"},{"t":"list_item","d":3,"p":{"lines":[39,40]},"v":"编译器不可能产生传统意义上的函数调用。"},{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"前期绑定：编译器将产生对一个具体函数名字的调用，而运行时将这个调用解析到将要被执行代码的绝对地址。"},{"t":"list_item","d":3,"p":{"lines":[41,42]},"v":"后期绑定/动态绑定：当向对象发送消息时，被调用的代码直到运行时才能确定。"},{"t":"list_item","d":3,"p":{"lines":[42,43]},"v":"Java中为了执行后期绑定，使用一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址。"},{"t":"list_item","d":3,"p":{"lines":[43,44]},"v":"C++中使用virtual关键字来实现后期绑定。而在Java中，动态绑定是默认行为。"}]},{"t":"heading","d":1,"p":{"lines":[45,46]},"v":"1.8 单根继承结构","c":[{"t":"list_item","d":3,"p":{"lines":[46,47]},"v":"终极基类：Object。"},{"t":"list_item","d":3,"p":{"lines":[47,48]},"v":"在OOP中，C++使用多根继承。"},{"t":"list_item","d":3,"p":{"lines":[48,49]},"v":"单根继承保证所有对象都具备某些功能。"}]},{"t":"heading","d":1,"p":{"lines":[50,51]},"v":"1.9 容器","c":[{"t":"list_item","d":3,"p":{"lines":[51,52]},"v":"创建一种新的对象类型，持有对其它对象的引用。可以用数组来实现相同的功能。这个类型通常被称为容器/集合。"},{"t":"list_item","d":3,"p":{"lines":[52,53]},"v":"Java类库以不同的含义使用“集合”这个术语。"},{"t":"list_item","d":3,"p":{"lines":[53,54]},"v":"参数化类型是一个编译器可以自动定制作用于特定类型上的类。"}]},{"t":"heading","d":1,"p":{"lines":[55,56]},"v":"1.10 对象的创建和生命周期","c":[{"t":"list_item","d":3,"p":{"lines":[56,57]},"v":"对象创建位置：堆栈、堆。"},{"t":"list_item","d":3,"p":{"lines":[57,58]},"v":"堆栈：容易控制、牺牲了灵活性。"},{"t":"list_item","d":3,"p":{"lines":[58,59]},"v":"堆： 直到运行时才知道需要多少对象，及他们的生命周期，具体类型。"},{"t":"list_item","d":3,"p":{"lines":[59,60]},"v":"Java完全采用了动态内存分配方式。"},{"t":"list_item","d":3,"p":{"lines":[60,61]},"v":"C++必须通过编程方式来确定合适销毁对象。Java提供了“垃圾回收器”机制。"}]},{"t":"heading","d":1,"p":{"lines":[62,63]},"v":"1.11 异常处理：处理错误","c":[{"t":"list_item","d":3,"p":{"lines":[63,64]},"v":"Java内置了一场处理，并且强制要求必须使用。是唯一可接受的错误报告方式。"},{"t":"list_item","d":3,"p":{"lines":[64,65]},"v":"异常处理并不是面向对象的特征，尽管在面向对象语言中异常常被表示成一个对象。"}]},{"t":"heading","d":1,"p":{"lines":[66,67]},"v":"1.12 并发编程","c":[{"t":"list_item","d":3,"p":{"lines":[67,68]},"v":"同一时刻处理多个任务。"},{"t":"list_item","d":3,"p":{"lines":[68,69]},"v":"Java的并发是内置于语言的。"}]},{"t":"heading","d":1,"p":{"lines":[70,71]},"v":"1.13 Java与Internet","c":[{"t":"list_item","d":3,"p":{"lines":[71,72]},"v":"Java促使计算机编程语言向前迈进了革命性的一步。 -- 解决了在万维网（World Wide Web）上的程序设计问题。"},{"t":"list_item","d":3,"p":{"lines":[72,73]},"v":"C/S结构：过去所作的，都是针对某个问题发明一个单独的解决方案，所以每一次都要发明一个新的方案。这些方案难以开发且难以使用，而且用户对每一个方案都要学习新的接口。"},{"t":"list_item","d":3,"p":{"lines":[73,74]},"v":"客户端编程：在客户端浏览器中运行程序的能力。"},{"t":"list_item","d":3,"p":{"lines":[74,75]},"v":"Web最初的B/S设计是为了能够提供交互性的内容，但是其交互性完全由服务器提供。通过Web服务器提供的通用网关接口（Common Gateway Interface, CGI）实现。"},{"t":"list_item","d":3,"p":{"lines":[75,76]},"v":"客户端编程方式：","c":[{"t":"list_item","d":5,"p":{"lines":[76,77],"index":1},"v":"1. 插件"},{"t":"list_item","d":5,"p":{"lines":[77,78],"index":2},"v":"2. 脚本语言 JavaScript不需要插件。可以解决80%问题。"},{"t":"list_item","d":5,"p":{"lines":[78,79],"index":3},"v":"3. Java Applet 需要插件，JRE环境。用来解决剩下的20%问题。"},{"t":"list_item","d":5,"p":{"lines":[79,80],"index":4},"v":"4. FLash 几乎所有浏览器都支持。备选方案。"},{"t":"list_item","d":5,"p":{"lines":[80,81],"index":5},"v":"5. C#.NET"},{"t":"list_item","d":5,"p":{"lines":[81,82],"index":6},"v":"6. Intranet 企业内部网。"}]},{"t":"list_item","d":3,"p":{"lines":[82,83]},"v":"服务端编程：过去，Python、C++使用CGI，Java使用servlet。将重点放在数据存储及业务逻辑上。"}]},{"t":"heading","d":1,"p":{"lines":[84,85]},"v":"1.14 总结","c":[{"t":"list_item","d":3,"p":{"lines":[85,86]},"v":"过程型语言： 数据定义和函数调用。"},{"t":"list_item","d":3,"p":{"lines":[86,87]},"v":"OOP和Java也许并不适合所有的人。"}]}],"p":{}}</svg>
              </div>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>本章介绍了面向对象的一些基本特征，并将Java中的实现方式与其它OOP语言（主要是C++）做了对比，体现出Java语言的优势。</li>
<li>理解本章内容需要过程编程及面向对象背景有一定的了解，从而更能感受到面向对象的优势。如果一上来就使用面向对象，甚至Java，则感觉不知所云。</li>
<li>之前也阅读过第一章内容，但是感觉云里雾里。刚好前段时间又重新学习了一下C，在回过头来看，有些概念就很容易理解了。</li>
<li>另一方面，需要对web的发展，以及Java诞生时的历史背景有所了解，这样才更能理解Java对于其它OOP语言来说，它的绝对优势是什么。我想这也是第14节用了比其它小节更多篇幅来描述Java与Internet关系的原因吧。</li>
<li>每一种语言，都有它流行的原因，也有它不得已而为之的地方。例如C++，它之所以流行是因为它完全向前兼容了C，而这也是它里面有些语法令人诟病的地方。Java同样也是。</li>
</ul>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2021/12/28/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8820%EF%BC%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","p":{}}</svg>
              </div>
  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>并发</title>
    <url>/2021/12/28/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8821%EF%BC%89%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","p":{}}</svg>
              </div>
  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>图形化用户界面</title>
    <url>/2021/12/31/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%8822%EF%BC%89%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","p":{}}</svg>
              </div>
  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>一切都是对象</title>
    <url>/2021/12/01/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%882%EF%BC%89%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"2.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"Java是杂合型语言。 --允许多种编程风格。"}]},{"t":"heading","d":1,"p":{"lines":[3,4]},"v":"2.1 用引用操纵对象","c":[{"t":"list_item","d":3,"p":{"lines":[4,5]},"v":"每种编程语言都有自己的操纵内存中元素的方式。Java中一切都被视为对象，因此可采用单一固定的语法。操纵的标识符实际上是对象的一个“引用”。"},{"t":"list_item","d":3,"p":{"lines":[5,6]},"v":"引用不一定需要一个对象与之关联。"}]},{"t":"heading","d":1,"p":{"lines":[7,8]},"v":"2.2 必须由你创建所有对象","c":[{"t":"bullet_list","d":2,"p":{"lines":[8,13]},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"通常使用new操作符来将一个新的对象和创建的引用相关联。"},{"t":"list_item","d":3,"p":{"lines":[9,10]},"v":"对象存储位置：寄存器（处理器内部）、堆栈、堆、常量存储（ROM）、非RAM存储（流对象、持久化对象）。"},{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"基本类型需要特殊对待，置于堆栈中。"},{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"基本类型所占存储空间大小是不变的。"}]},{"t":"table","d":2,"p":{"lines":[13,24]},"v":"","c":[{"t":"thead","d":3,"p":{"lines":[13,14]},"v":"","c":[{"t":"th","d":5,"p":{"lines":[13,14]},"v":"基本类型"},{"t":"th","d":5,"p":{"lines":[13,14]},"v":"大小"},{"t":"th","d":5,"p":{"lines":[13,14]},"v":"最小值"},{"t":"th","d":5,"p":{"lines":[13,14]},"v":"最大值"},{"t":"th","d":5,"p":{"lines":[13,14]},"v":"包装器类型"}]},{"t":"tbody","d":3,"p":{"lines":[15,24]},"v":"","c":[{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"boolean"},{"t":"td","d":5,"p":{},"v":"1bit"},{"t":"td","d":5,"p":{},"v":"-"},{"t":"td","d":5,"p":{},"v":"-"},{"t":"td","d":5,"p":{},"v":"Boolean"}]},{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"char"},{"t":"td","d":5,"p":{},"v":"16bit"},{"t":"td","d":5,"p":{},"v":"Unicode 0"},{"t":"td","d":5,"p":{},"v":"Unicode 2^16-1"},{"t":"td","d":5,"p":{},"v":"Character"}]},{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"byte"},{"t":"td","d":5,"p":{},"v":"8bit"},{"t":"td","d":5,"p":{},"v":"-128"},{"t":"td","d":5,"p":{},"v":"+127"},{"t":"td","d":5,"p":{},"v":"Byte"}]},{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"short"},{"t":"td","d":5,"p":{},"v":"16bit"},{"t":"td","d":5,"p":{},"v":"-2^15"},{"t":"td","d":5,"p":{},"v":"+2^15-1"},{"t":"td","d":5,"p":{},"v":"Short"}]},{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"int"},{"t":"td","d":5,"p":{},"v":"32bit"},{"t":"td","d":5,"p":{},"v":"-2^31"},{"t":"td","d":5,"p":{},"v":"+2^31-1"},{"t":"td","d":5,"p":{},"v":"Int"}]},{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"long"},{"t":"td","d":5,"p":{},"v":"64bit"},{"t":"td","d":5,"p":{},"v":"-2^63"},{"t":"td","d":5,"p":{},"v":"+2^63-1"},{"t":"td","d":5,"p":{},"v":"Long"}]},{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"float"},{"t":"td","d":5,"p":{},"v":"32bit"},{"t":"td","d":5,"p":{},"v":""},{"t":"td","d":5,"p":{},"v":""},{"t":"td","d":5,"p":{},"v":"Float"}]},{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"double"},{"t":"td","d":5,"p":{},"v":"64bit"},{"t":"td","d":5,"p":{},"v":""},{"t":"td","d":5,"p":{},"v":""},{"t":"td","d":5,"p":{},"v":"Double"}]},{"t":"tr","d":4,"p":{},"v":"","c":[{"t":"td","d":5,"p":{},"v":"void"},{"t":"td","d":5,"p":{},"v":"-"},{"t":"td","d":5,"p":{},"v":"-"},{"t":"td","d":5,"p":{},"v":"-"},{"t":"td","d":5,"p":{},"v":"Void"}]}]}]},{"t":"bullet_list","d":2,"p":{"lines":[25,30]},"v":"","c":[{"t":"list_item","d":3,"p":{"lines":[25,26]},"v":"高精度数字：BigInteger、BigDecimal。支持任意精度。使用方法调用取代运算符，运算速度慢。"},{"t":"list_item","d":3,"p":{"lines":[26,27]},"v":"数组：几乎所有的程序设计语言都支持数组。"},{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"安全性史Java的主要目标之一，确保数组会被初始化，使用时进行范围检查。以内存开销及运行时的下标检查为代价。"},{"t":"list_item","d":3,"p":{"lines":[28,29]},"v":"创建数组对象时，实际创建了一个引用数组。数组中的每个对象都为null。"}]}]},{"t":"heading","d":1,"p":{"lines":[30,31]},"v":"2.3 永远不需要销毁对象","c":[{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"在大多数程序设计语言中，变量生命周期的概念，占据了程序设计工作中非常重要的部分。"},{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"作用域定义了在其内定义的变量名的可见性和生命周期。作用域由花括号的位置决定。在作用域里定义的变量只可用于作用域结束之前。"},{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。"},{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"Java垃圾回收器，用来监视new创建的所有对象，并辨别那些不会在被引用的对象。"}]},{"t":"heading","d":1,"p":{"lines":[36,37]},"v":"2.4 创建新的数据类型：类","c":[{"t":"list_item","d":3,"p":{"lines":[37,38]},"v":"从历史发展角度来看，大多数面向对象的程序设计语言习惯用关键字class来表示创建新的数据类型。"},{"t":"list_item","d":3,"p":{"lines":[38,39]},"v":"class关键字之后紧跟着的是新类型的名称。"},{"t":"list_item","d":3,"p":{"lines":[39,40]},"v":"可以在类中设置两种类型的元素：字段（数据成员）和方法（成员函数）。"},{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"在Java中所作的全部工作就是定义类，产生那些类的对象，以及发送消息给这些对象。"},{"t":"list_item","d":3,"p":{"lines":[41,42]},"v":"每个对象都有用来存储其字段的空间，普通字段不能在对象间共享。"},{"t":"list_item","d":3,"p":{"lines":[42,43]},"v":"点号操作符：引用对象的成员。"},{"t":"list_item","d":3,"p":{"lines":[43,44]},"v":"基本类型变量，即使没有初始化，Java确保获得一个默认值（只有成员变量）。"}]},{"t":"heading","d":1,"p":{"lines":[45,46]},"v":"2.5 方法、参数和返回值","c":[{"t":"list_item","d":3,"p":{"lines":[46,47]},"v":"方法的基本组成包括：名称、参数、返回值和方法体。"},{"t":"list_item","d":3,"p":{"lines":[47,48]},"v":"方法签名（方法名+参数列表）唯一地标识出某个方法。"},{"t":"list_item","d":3,"p":{"lines":[48,49]},"v":"Java中的方法只能作为类的一部分创建，只有通过对象/类才能调用。"},{"t":"list_item","d":3,"p":{"lines":[49,50]},"v":"点号操作符：调用方法。对象名.方法名(参数列表)。"},{"t":"list_item","d":3,"p":{"lines":[50,51]},"v":"调用方法的行为通常被称为发送消息给对象。即向对象发送消息。"},{"t":"list_item","d":3,"p":{"lines":[51,52]},"v":"方法参数传递的实际是引用（除基本类型），且引用的类型必须正确。"},{"t":"list_item","d":3,"p":{"lines":[52,53]},"v":"return： 1. 离开此方法；2. 此方法产生了一个值。若返回类型是void，return关键字的作用只是用来退出方法。"}]},{"t":"heading","d":1,"p":{"lines":[54,55]},"v":"2.6 构建一个Java程序","c":[{"t":"list_item","d":3,"p":{"lines":[55,56]},"v":"名字管理对任何程序设计语言来说，都是一个重要问题。"},{"t":"list_item","d":3,"p":{"lines":[56,57]},"v":"C++类将函数包于其类，从而避免于其他类中的函数名相冲突。C++允许全局数据和全局函数的存在，使用名字空间来解决。"},{"t":"list_item","d":3,"p":{"lines":[57,58]},"v":"Java采用域名反转的方式，保证类库生成不会于其它名字混淆的名字。Java语言本身解决了同一个文件内的每个类都有唯一的标识符。"},{"t":"list_item","d":3,"p":{"lines":[58,59]},"v":"Java消除了“向前引用”问题：可以在类中使用在该类的后面定义的类。"},{"t":"list_item","d":3,"p":{"lines":[59,60]},"v":"使用import准确引入位于其它文件中的类，消除混淆情况。可以使用通配符“*”。"},{"t":"list_item","d":3,"p":{"lines":[60,61]},"v":"当创建类是，就是在描述那个类的对象的外观与行为。执行new创建对象时，数据存储空间才会被分配，其方法才供外界调用。"},{"t":"list_item","d":3,"p":{"lines":[61,62]},"v":"static： 1. 为特定域分配的那一存储空间；2. 方法不于包含它的那个类的任何对象关联（没有创建对象，也能调用方法）。"},{"t":"list_item","d":3,"p":{"lines":[62,63]},"v":"类数据、类方法，代表那些数据和方法只能是作为整个类，而不是类的某个特定对象而存在的。"},{"t":"list_item","d":3,"p":{"lines":[63,64]},"v":"引用static变量：1. 对象.变量名； 2. 类.变量名（推荐）。 调用static方法：1. 对象.方法名(...)； 2. 类.方法名(...)（推荐）。"},{"t":"list_item","d":3,"p":{"lines":[64,65]},"v":"当static作用于某个字段是，会改变数据创建的方式。static作用于方法，区别不大。"}]},{"t":"heading","d":1,"p":{"lines":[66,67]},"v":"2.7 第一个Java程序","c":[{"t":"list_item","d":3,"p":{"lines":[67,68]},"v":"在每个程序文件的开头，声明import语句，引入在文件代码中需要用到的额外类（java.lang会自动被导入到每一个Java文件中）。"},{"t":"list_item","d":3,"p":{"lines":[68,69]},"v":"创建一个独立运行的程序，文件中必须存在某个类于该文件同名，且那个类包含一个main方法。"},{"t":"list_item","d":3,"p":{"lines":[69,70]},"v":"main方法参数args用来存储命令行参数。"},{"t":"list_item","d":3,"p":{"lines":[70,71]},"v":"编译（javac命令）、运行（java命令）Java程序必须要有Java开发环境JDK。"}]},{"t":"heading","d":1,"p":{"lines":[72,73]},"v":"2.8 注释和嵌入式文档","c":[{"t":"list_item","d":3,"p":{"lines":[73,74]},"v":"块注释：以“/*”开头，以“*/”结束，中间可以跨多行。源于C/C++。"},{"t":"list_item","d":3,"p":{"lines":[74,75]},"v":"单行注释：“//”。源于C++。"},{"t":"list_item","d":3,"p":{"lines":[75,76]},"v":"Java为实现代码同文档连接起来，使用一种特殊的注释语法来标记文档，还需要一个工具（javadoc，JDK安装的一部分）来提取注释，并将其转换成有用的形式。"},{"t":"list_item","d":3,"p":{"lines":[76,77]},"v":"javadoc输出的是一个HTML文件。"},{"t":"list_item","d":3,"p":{"lines":[77,78]},"v":"注释文档：以“/**”开头，以“*/”结束。可以使用嵌入式文档HTML和文档标签。"},{"t":"list_item","d":3,"p":{"lines":[78,79]},"v":"文档标签有独立文档标签（以”@“字符开头的命令，至于注释行”*“之后最前面）和行内文档标签（以”@“开头，括在花括号内）。"},{"t":"list_item","d":3,"p":{"lines":[79,80]},"v":"三种类型的注释文档，分别对应于注释位置后面的三种元素：类、域和方法。"}]},{"t":"heading","d":1,"p":{"lines":[81,82]},"v":"2.9 编码风格","c":[{"t":"list_item","d":3,"p":{"lines":[82,83]},"v":"类的首字母要大写。"},{"t":"list_item","d":3,"p":{"lines":[83,84]},"v":"使用“驼峰风格”。"}]}],"p":{}}</svg>
              </div>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>本章讲述Java程序的基本组成部分，以及编写一个程序时所需要注意的地方，另外还有与其它语言的对比。</li>
</ul>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>操作符</title>
    <url>/2021/12/02/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%883%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"3.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"在最底层，Java中的数据是通过使用操作符来操作的。"}]},{"t":"heading","d":1,"p":{"lines":[3,4]},"v":"3.1 更简单的打印语句","c":[{"t":"list_item","d":3,"p":{"lines":[4,5]},"v":"静态导入static import。"}]},{"t":"heading","d":1,"p":{"lines":[6,7]},"v":"3.2 使用Java操作符","c":[{"t":"list_item","d":3,"p":{"lines":[7,8]},"v":"操作符作用于操作数，接受一个或多个参数，并生成一个新值。参数形式与普通方法调用不同。"},{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"副作用：操作符改变操作数自身的值。"},{"t":"list_item","d":3,"p":{"lines":[9,10]},"v":"能改变其操作数的操作符，最普遍的用途是用来产生副作用。使用有副作用的操作符和没有副作用的操作符，生成的值没有什么区别。"},{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"几乎所有的操作符都只能操作基本类型。例外的操作符是“=”、“==”、“！=”，这些能操作所有的对象。String类支持“+”、“+=”操作符。"}]},{"t":"heading","d":1,"p":{"lines":[12,13]},"v":"3.3 优先级","c":[{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"当一个表达式中存在多个操作符时，操作符的优先级决定了各部分的计算顺序。"},{"t":"list_item","d":3,"p":{"lines":[14,15]},"v":"最简单的规则是先乘除后加减。程序员经常会忘记其他优先级规则，所以应该用括号明确规定计算顺序。"}]},{"t":"heading","d":1,"p":{"lines":[16,17]},"v":"3.4 赋值","c":[{"t":"list_item","d":3,"p":{"lines":[17,18]},"v":"取右边的值，把它复制给左边。右值可以是任何常数、变量或者表达式。但左值必须是一个明确的，已命名的变量。即必须有一个物理空间可以存储等号右边的值。"},{"t":"list_item","d":3,"p":{"lines":[18,19]},"v":"基本类型存储了实际的数值，为其赋值时，是直接将一个地方的内容复制到了另一个地方。"},{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"别名现象：多个变量引用指向同一个对象。"}]},{"t":"heading","d":1,"p":{"lines":[21,22]},"v":"3.5 算术操作符","c":[{"t":"list_item","d":3,"p":{"lines":[22,23]},"v":"包括&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;%&quot;。整数除法会直接去掉结果的小数位。"},{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"操作符简化：&quot;+=&quot;, &quot;-=&quot;, &quot;*=&quot;, &quot;/=&quot;, &quot;%=&quot;。"},{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"一元加减号：编译器自动识别，规范加括号。（eg：x = a*(-b)）。"},{"t":"list_item","d":3,"p":{"lines":[25,26]},"v":"一元减号用于改变数据的符号. 一元加号只是为了与一元减号对应，但可以将较小类型的操作数提升为int。"}]},{"t":"heading","d":1,"p":{"lines":[27,28]},"v":"3.6 自动递增和递减","c":[{"t":"list_item","d":3,"p":{"lines":[28,29]},"v":"递增、递减是两种快捷运算。Java提供了大量的快捷运算，使编码更方便。"},{"t":"list_item","d":3,"p":{"lines":[29,30]},"v":"包括&quot;i++&quot;,&quot;++i&quot;,&quot;i--&quot;,&quot;--i&quot;。"},{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"前缀会先执行运算，在生成值。后缀会先生成值，在执行运算。"},{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"除涉及赋值的操作符以外，唯一具有&quot;副作用&quot;的操作符（会改变操作数）。"}]},{"t":"heading","d":1,"p":{"lines":[33,34]},"v":"3.7 关系操作符","c":[{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"包括&quot;&gt;&quot;, &quot;&lt;&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;==&quot;, &quot;!=&quot;。生成的是一个boolean结果（true/false）。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"&quot;==&quot;,&quot;!=&quot;适用于所有基本类型，其它不适用于boolean类型。"},{"t":"list_item","d":3,"p":{"lines":[36,37]},"v":"==：比较引用。equals默认比较引用，重写比较内容，不适合用于基本类型。"}]},{"t":"heading","d":1,"p":{"lines":[38,39]},"v":"3.8 逻辑操作符","c":[{"t":"list_item","d":3,"p":{"lines":[39,40]},"v":"包括&quot;&amp;&amp;&quot;, &quot;||&quot;, &quot;!&quot;。能根据参数的逻辑关系，生成一个boolean值。"},{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"只可应用于boolean值。"},{"t":"list_item","d":3,"p":{"lines":[41,42]},"v":"短路：一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下的部分了。潜在的性能提升。"}]},{"t":"heading","d":1,"p":{"lines":[43,44]},"v":"3.9 直接常量","c":[{"t":"list_item","d":3,"p":{"lines":[44,45]},"v":"编译器可以明确地知道要生成什么样的类型。用与直接常量相关的某些字符来额外增加一些信息。"},{"t":"list_item","d":3,"p":{"lines":[45,46]},"v":"直接常量后面的后缀字符标志了它的类型。直接常量的前缀标识不同进制。"},{"t":"list_item","d":3,"p":{"lines":[46,47]},"v":"前缀：&quot;0x&quot;十六进制，&quot;0&quot;十进制。"},{"t":"list_item","d":3,"p":{"lines":[47,48]},"v":"后缀：&quot;l/L&quot;浮点型，&quot;d/D&quot;双精度型。"},{"t":"list_item","d":3,"p":{"lines":[48,49]},"v":"指数记数：e 代表 &quot;10的幂次&quot;。"}]},{"t":"heading","d":1,"p":{"lines":[50,51]},"v":"3.10 按位操作符","c":[{"t":"list_item","d":3,"p":{"lines":[51,52]},"v":"包括&quot;&amp;&quot;, &quot;|&quot;, &quot;~&quot;, &quot;^&quot;。用来操作整个基本数据类型的单个bit，即二进制位。"},{"t":"list_item","d":3,"p":{"lines":[52,53]},"v":"来源于C语言面向底层的操作。Java的设计初衷是嵌入电视机顶盒内，所以这种操作被保留了下来。但是不会过多的使用到。"},{"t":"list_item","d":3,"p":{"lines":[53,54]},"v":"除“~”（一元操作符）外，可与&quot;=&quot;联合使用."}]},{"t":"heading","d":1,"p":{"lines":[55,56]},"v":"3.11 移位操作符","c":[{"t":"list_item","d":3,"p":{"lines":[56,57]},"v":"包括&quot;&lt;&lt;&quot;(左移，低位补0), &quot;&gt;&gt;&quot;(有符号右移，高位正插0，负插1), &quot;&gt;&gt;&gt;&quot;(无符号右移，高位插0)。操作对象是二进制的bit。"},{"t":"list_item","d":3,"p":{"lines":[57,58]},"v":"只可用来处理整数类型（基本数据的一种）。"},{"t":"list_item","d":3,"p":{"lines":[58,59]},"v":"可与&quot;=&quot;联合使用。"}]},{"t":"heading","d":1,"p":{"lines":[60,61]},"v":"3.12 三元操作符 if-else","c":[{"t":"list_item","d":3,"p":{"lines":[61,62]},"v":"三元操作符也称条件操作符。有三个操作数。"},{"t":"list_item","d":3,"p":{"lines":[62,63]},"v":"表达式：boolean-exp ? value0 : value1;。"}]},{"t":"heading","d":1,"p":{"lines":[64,65]},"v":"3.13 字符串操作符","c":[{"t":"list_item","d":3,"p":{"lines":[65,66]},"v":"包括&quot;+&quot;， &quot;+=&quot;。用来连接不同的字符串。"},{"t":"list_item","d":3,"p":{"lines":[66,67]},"v":"C++可以为几乎所有操作符增加功能。而Java不能实现自己的重载操作符。"},{"t":"list_item","d":3,"p":{"lines":[67,68]},"v":"如果表达式以一个字符串起头，那么后续所有操作数都必须是字符串类型（编译器会把双引号内的字符序列自动转成字符串）。"}]},{"t":"heading","d":1,"p":{"lines":[69,70]},"v":"3.14 使用操作符时常犯的错误","c":[{"t":"list_item","d":3,"p":{"lines":[70,71]},"v":"即使对表达式如何计算优点不确定，也不愿意使用括号。"},{"t":"list_item","d":3,"p":{"lines":[71,72]},"v":"“=”“==”、“&amp;”“&amp;&amp;”、“|”“||” 可能会输入错误。Java编译器可防止这种错误发生，因为不允许把一种类型当作另一种类型来用。"}]},{"t":"heading","d":1,"p":{"lines":[73,74]},"v":"3.15 类型转换操作符","c":[{"t":"list_item","d":3,"p":{"lines":[74,75]},"v":"类型转换(cast)。显式的进行类型的转换，或者在不能自动进行转换时强制进行类型转换。"},{"t":"list_item","d":3,"p":{"lines":[75,76]},"v":"将float、double转为整型，会截尾，即向下取整。可以使用Math.round()，四舍五入。"},{"t":"list_item","d":3,"p":{"lines":[76,77]},"v":"对基本数据类型进行执行算术运算或按位运算，只要类型比int小，在运算之前，会自动转换成int，最终结果就是int型，如果要把结果赋值给较小的类型，就必须使用类型转换。"}]},{"t":"heading","d":1,"p":{"lines":[78,79]},"v":"3.16 Java没有sizeof","c":[{"t":"list_item","d":3,"p":{"lines":[79,80]},"v":"C/C++中，sizeof()操作符返回数据分配的字节数。使用sizeof最大的原因是为了“移植”。"},{"t":"list_item","d":3,"p":{"lines":[80,81]},"v":"Java不需要sizeof，因为所有类型在所有机器中的大小是相同的。"}]},{"t":"heading","d":1,"p":{"lines":[82,83]},"v":"3.17 操作符小结","c":[{"t":"list_item","d":3,"p":{"lines":[83,84]},"v":"对boolean的运算有限，只能赋予true和false。"},{"t":"list_item","d":3,"p":{"lines":[84,85]},"v":"对char、byte、short进行任何算术运算时，数据类型会提示为int。必须显示转换为原来的类型（可能会丢失信息）。"},{"t":"list_item","d":3,"p":{"lines":[85,86]},"v":"对int执行乘法运算，结果可能会溢出。"}]}],"p":{}}</svg>
              </div>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>C中明确比较了操作符的优先级，而Java则建议使用括号来明确优先级。</li>
<li>除了字符串支持（+=、+）及赋值（=）操作符，其它操作符的操作数都是基本类型。</li>
</ul>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>控制执行流程</title>
    <url>/2021/12/02/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%884%EF%BC%89%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"4.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"Java使用了C的所有流程控制语句。"}]},{"t":"heading","d":1,"p":{"lines":[3,4]},"v":"4.1 true和false","c":[{"t":"list_item","d":3,"p":{"lines":[4,5]},"v":"所有条件语句都利用表达式的真或假来决定执行路径。"}]},{"t":"heading","d":1,"p":{"lines":[6,7]},"v":"4.2 if-else","c":[{"t":"list_item","d":3,"p":{"lines":[7,8]},"v":"控制程序流程最基本的形式。"},{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"else是可选的。"}]},{"t":"heading","d":1,"p":{"lines":[10,11]},"v":"4.3 迭代","c":[{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"while、do-while、for。"},{"t":"list_item","d":3,"p":{"lines":[12,13]},"v":"do-while至少会执行一次。"},{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"Java中唯一用到逗号操作符的地方就是for循环的控制表达式。用逗号操作符隔开的语句，均会独立执行。（逗号分隔符用来分隔函数不同参数。）"}]},{"t":"heading","d":1,"p":{"lines":[15,16]},"v":"4.4 Foreach语法","c":[{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"更加简洁的for语法用于数组和容器。"},{"t":"list_item","d":3,"p":{"lines":[17,18]},"v":"不必创建int变量去访问项构成的序列进行计数，foreach将自动产生每一项。"}]},{"t":"heading","d":1,"p":{"lines":[19,20]},"v":"4.5 return","c":[{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"指定一个方法的返回值。退出当前方法。"}]},{"t":"heading","d":1,"p":{"lines":[22,23]},"v":"4.6 break 和 continue","c":[{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"break用于强行退出循环，不执行循环中剩余的语句。"},{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"continue用于停止执行当前的迭代，然后退回循环起始处，开始下一次迭代。"}]},{"t":"heading","d":1,"p":{"lines":[26,27]},"v":"4.7 臭名昭著的goto","c":[{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"goto起源于汇编语言的程序控制。Java编译器生成自己的“汇编代码”，运行在JVM上，而不是CPU硬件上。"},{"t":"list_item","d":3,"p":{"lines":[28,29]},"v":"goto是Java的保留字，但Java中没有goto。Java中使用相同机制的 标签（label: (后面紧跟冒号的标识符)），作为中断迭代语句的一种方法。"},{"t":"list_item","d":3,"p":{"lines":[29,30]},"v":"Java中使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。"}]},{"t":"heading","d":1,"p":{"lines":[31,32]},"v":"4.8 switch","c":[{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"根据表达式的值，从一系列代码中选出一段去执行。"},{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"选择因子：int(byte，char，short 会自动转型为int)，enum（Java SE 5.0），String (Java SE 7)。"}]}],"p":{}}</svg>
              </div>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>大多数编程语言都具有的基本特性：运算、操作符优先级、类型转换、选择、循环等。</li>
<li>在大多数情况下，for、while可以相互转换，但是有break、continue时不能转换。</li>
<li>流程控制看似简单，但是日常开发中最常用的。</li>
</ul>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>初始化与清理</title>
    <url>/2021/12/03/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%885%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"5.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。"},{"t":"list_item","d":3,"p":{"lines":[2,3]},"v":"初始化和清理正是设计安全的两个问题。"}]},{"t":"heading","d":1,"p":{"lines":[4,5]},"v":"5.1 用构造器确保初始化","c":[{"t":"list_item","d":3,"p":{"lines":[5,6]},"v":"创建对象时，如果其内具有构造器，Java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。"},{"t":"list_item","d":3,"p":{"lines":[6,7]},"v":"构造器命名：与类名相同，所以&quot;每个方法首字母小写&quot;的编程风格不适用于构造器。1. 不会与其它方法冲突；2. 编译器直到该调用哪个方法。"},{"t":"list_item","d":3,"p":{"lines":[7,8]},"v":"构造器有助于减少错误，并使代码更易于阅读。从概念上讲，初始化与创建使彼此独立的，在Java中，捆绑在一起，两者不能分离。"},{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"构造器没有返回值，与void不同。new表达式返回了对新建对象的引用，但构造器本身并没有返回任何值。"}]},{"t":"heading","d":1,"p":{"lines":[10,11]},"v":"5.2 方法重载","c":[{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"方法重载：对相同的概念使用相同的名字。"},{"t":"list_item","d":3,"p":{"lines":[12,13]},"v":"在Java和C++中，构造器是强制重载方法的一个原因。构造器的名字已经由类名确定。"},{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"方法重载是构造器所必需的，但亦可用于其他方法。"},{"t":"list_item","d":3,"p":{"lines":[14,15]},"v":"每个重载的方法都必须有一个独一无二的参数类型列表（参数类型、参数顺序（会使代码难以维护））。"},{"t":"list_item","d":3,"p":{"lines":[15,16]},"v":"基本类型当作参数会先提升类型，然后传参。"},{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"根据返回值无法区分方法重载。为了副作用而调用就会忽略其返回值。"}]},{"t":"heading","d":1,"p":{"lines":[18,19]},"v":"5.3 默认构造器","c":[{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"如果类中没有构造器，编译器会自动创建一个默认构造器。"},{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"如果已有构造器，则不会创建。"}]},{"t":"heading","d":1,"p":{"lines":[22,23]},"v":"5.4 this关键字","c":[{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"为了能用简便、面向对象的语法来编写代码，编译器做了一些幕后工作，把&quot;所操作对象的引用&quot;作为第一个参数传给方法(方法在内存中只有一份)。"},{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"只能在方法内部使用，表示对&quot;调用方法的那个对象&quot;的引用。"},{"t":"list_item","d":3,"p":{"lines":[25,26]},"v":"使用高级语言的原因之一就是它会帮我们做一些事情。如传递对当前对象的引用（this），所以除非必要，则不用使用this。"},{"t":"list_item","d":3,"p":{"lines":[26,27]},"v":"必须使用this的情况：1. 需要返回当前对象的引用时，return this;。2. 将当前对象作为参数传递给其他对象。3. 在构造器中调用构造器(只能调用一个，且必须将构造器的调用至于最起始处)。4. 参数名和数据成员名称相同时，使用this来代表数据成员。"},{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"static方法：没有this的方法（不用将当前对象引用作为第一个参数传给方法）。"},{"t":"list_item","d":3,"p":{"lines":[28,29]},"v":"static主要用途：没有创建任何对象的前提下，使用类本身调用。"},{"t":"list_item","d":3,"p":{"lines":[29,30]},"v":"static不是面向对象的？"}]},{"t":"heading","d":1,"p":{"lines":[31,32]},"v":"5.5 清理：终结处理和垃圾回收","c":[{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"程序员都了解初始化的重要性，但常常会忘记同样也重要的清理工作。Java有垃圾回收器负责回收无用对象占据的内存资源。"},{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"在C++中，对象一定会被销毁（析构函数）。而在Java中，对象并非总是被垃圾回收。1. 对象可能不被垃圾回收；2. 垃圾回收不等于析构；3. 垃圾回收只与内存有关。"},{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"垃圾回收本身也有开销。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"不论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。"},{"t":"list_item","d":3,"p":{"lines":[36,37]},"v":"本地方法（在Java中调用非Java代码的方式）通过某种创建对象方式以外的方式为对象分配了存储空间，需要在finalize()方法来释放。"},{"t":"list_item","d":3,"p":{"lines":[37,38]},"v":"本地方法目前只支持C/C++，但它们可以调用其它任何语言的代码，相当于可以调用任何代码。"},{"t":"list_item","d":3,"p":{"lines":[38,39]},"v":"Java不允许创建局部对象。C++局部对象销毁动作发生在}为边界。"},{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"在堆上分配对象的代价十分高昂，涉及到对象销毁后重新利用内存。"},{"t":"list_item","d":3,"p":{"lines":[41,42]},"v":"Java垃圾回收器对于对象创建速度有明显的提高。Java从堆分配空间的速度，可以和其它语言从堆栈上分配空间的速度相媲美。"},{"t":"list_item","d":3,"p":{"lines":[42,43]},"v":"引用计数：常用来说明垃圾收集的工作方式。"},{"t":"list_item","d":3,"p":{"lines":[43,44]},"v":"更快的模式：从堆栈和静态存储区考试，遍历所有引用。"},{"t":"list_item","d":3,"p":{"lines":[44,45]},"v":"Java虚拟机采用自适应的垃圾回收技术，如何处理找到的存活对象，却决于不同的虚拟机实现。有一种做法是“停止-复制”。"},{"t":"list_item","d":3,"p":{"lines":[45,46]},"v":"停止-复制问题：1. 得有两个堆，空间大（按需分配几款较大的内存）； 2. 可能只有少量垃圾，甚至没有垃圾（转到标记-清扫）。"},{"t":"list_item","d":3,"p":{"lines":[46,47]},"v":"标记-清扫：从堆栈和静态存储区考试，遍历所有引用，标记存活对象，全部标记工作完成之后，清理动作才会开始，清理过程中，没有标记的对象将被释放，不会发生任何复制动作。 -- 希望得到连续空间就得重新整理。"},{"t":"list_item","d":3,"p":{"lines":[47,48]},"v":"垃圾回收动作发生的同时，程序将会被暂停（停止-复制、标记-清扫）。"},{"t":"list_item","d":3,"p":{"lines":[48,49]},"v":"在Java虚拟机中，内存分配以较大的“块”为单位。如果对象较大，会占用单独的块。"},{"t":"list_item","d":3,"p":{"lines":[49,50]},"v":"每个块都有相应的代数来记录它是否存活。清理时，大型对象不会被复制，只是增加代数。"},{"t":"list_item","d":3,"p":{"lines":[50,51]},"v":"自适应：Java虚拟机监视结果，自动切换“停止-复制”与“标记-清扫”。"},{"t":"list_item","d":3,"p":{"lines":[51,52]},"v":"自适应的、分代的、停止-复制、标记-清扫 式垃圾回收器。"},{"t":"list_item","d":3,"p":{"lines":[52,53]},"v":"Java虚拟机中有许多附加技术用以提升速度。如HotSpot中的JIT（Just-In-Time）。"}]},{"t":"heading","d":1,"p":{"lines":[54,55]},"v":"5.6 成员初始化","c":[{"t":"list_item","d":3,"p":{"lines":[55,56]},"v":"Java尽力保证：所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。"},{"t":"list_item","d":3,"p":{"lines":[56,57]},"v":"类的数据成员(全局变量)，基本类型会默认有一个初始值，对象引用会获得特殊值null。"},{"t":"list_item","d":3,"p":{"lines":[57,58]},"v":"可以在定义类成员变量的地方为其赋值。可以调用方法。方法可以带参，但是参数必须时已初始化的。"},{"t":"list_item","d":3,"p":{"lines":[58,59]},"v":"每个对象都有相同的初值。"}]},{"t":"heading","d":1,"p":{"lines":[60,61]},"v":"5.7 构造器初始化","c":[{"t":"list_item","d":3,"p":{"lines":[61,62]},"v":"通过构造器来进行初始化(无法阻止自动初始化的进行，它将在构造器调用之前发生)。"},{"t":"list_item","d":3,"p":{"lines":[62,63]},"v":"变量定义的先后顺序决定了初始化的顺序。"},{"t":"list_item","d":3,"p":{"lines":[63,64]},"v":"静态数据只占用一份存储区域。static关键字不能应用于局部变量，只能作用于域。"},{"t":"list_item","d":3,"p":{"lines":[64,65]},"v":"静态数据在第一次访问静态数据（构造器也是static方法）时被初始化。"},{"t":"list_item","d":3,"p":{"lines":[65,66]},"v":"显式的静态数据初始化：静态代码块。"},{"t":"list_item","d":3,"p":{"lines":[66,67]},"v":"非静态实例初始化：普通代码块(匿名内部类的初始化)。"},{"t":"list_item","d":3,"p":{"lines":[67,68]},"v":"构造器没有显式地使用static，但也是静态方法。"}]},{"t":"heading","d":1,"p":{"lines":[69,70]},"v":"5.8 数组初始化","c":[{"t":"list_item","d":3,"p":{"lines":[70,71]},"v":"数组是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。通过方括号下标操作符来定义和使用。"},{"t":"list_item","d":3,"p":{"lines":[71,72]},"v":"声明数组时编译器不允许指定数组的大小（只是创建了一个数组的引用并未该引用分配了空间，并没有给数组本身分配空间）。"},{"t":"list_item","d":3,"p":{"lines":[72,73]},"v":"初始化表达式：由一对花括号括起来的值组成。在这种情况下，存储空间的分配(等价于使用new)由编译器负责。"},{"t":"list_item","d":3,"p":{"lines":[73,74]},"v":"所有数组都有一个固有成员length，用来获知数组内包含了多少个元素。只能访问不能修改。"},{"t":"list_item","d":3,"p":{"lines":[74,75]},"v":"Java不允许下标越界，一旦越界，就会出现运行时错误。通过每次在访问数组的时候检查边界实现，检查是需要开销的，且无法禁用。"},{"t":"list_item","d":3,"p":{"lines":[75,76]},"v":"可以用new在数组里创建元素（只能用在数组被定义之处），也可以用花括号括起来的列表来初始化对象数组（可以在任何地方使用）。"},{"t":"list_item","d":3,"p":{"lines":[76,77]},"v":"使用可变参数，指定参数时，编译器会自动填充为数组，获取的仍旧是个数组。"},{"t":"list_item","d":3,"p":{"lines":[77,78]},"v":"int数组的class： [I。"},{"t":"list_item","d":3,"p":{"lines":[78,79]},"v":"应该只在重载方法的一个版本上使用可变参数列表，或者压根不使用。（可变参数列表使得重载过程变得复杂了，每一种情况，编译器都会使用自动包装机制来匹配重载的方法，然后调用最明确匹配的方法。）"}]},{"t":"heading","d":1,"p":{"lines":[80,81]},"v":"5.9 枚举类型","c":[{"t":"list_item","d":3,"p":{"lines":[81,82]},"v":"枚举类型的实例是常量，按照命名惯例使用大写字母表示(多个单词用下划线隔开)。"},{"t":"list_item","d":3,"p":{"lines":[82,83]},"v":"为了使用enum，需要创建一个该类型的引用，并将其赋值给某个实例。"},{"t":"list_item","d":3,"p":{"lines":[83,84]},"v":"创建enum时，编译器自动添加toString()，ordinal()(声明顺序)，values()(按声明顺序，产生由常量构成的数组)方法。"},{"t":"list_item","d":3,"p":{"lines":[84,85]},"v":"与switch配合使用。"}]},{"t":"heading","d":1,"p":{"lines":[86,87]},"v":"5.10 总结","c":[{"t":"list_item","d":3,"p":{"lines":[87,88]},"v":"Java的速度问题是涉足某些特定编程领域的障碍。"}]}],"p":{}}</svg>
              </div>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>Java中付出了一定的开销，来保证代码的安全性，使使用更简单。这种权衡使得Java更加面向上层应用开发，而更加使底层开发者望而却步。</li>
</ul>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>访问权限控制</title>
    <url>/2021/12/04/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%886%EF%BC%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"6.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"重构即重写代码，以使得它更可读、更易理解，并因此而更具有可维护性。"},{"t":"list_item","d":3,"p":{"lines":[2,3]},"v":"面向对象中需要考虑的一个基本问题：如何把变动的事物与保持不变的事物区分开来。"},{"t":"list_item","d":3,"p":{"lines":[3,4]},"v":"Java提供了访问权限修饰词，以供类库开发人员向客户端程序员指明哪些式可用的，哪些式不可用的。"},{"t":"list_item","d":3,"p":{"lines":[4,5]},"v":"访问权限控制的等级，从最大权限到最小权限依次为：public、protected、包访问权限、private。"},{"t":"list_item","d":3,"p":{"lines":[5,6]},"v":"Java中用关键字package将构建捆绑到一个内聚的类库单元中。而访问权限修饰词会因类是存在于一个相同的包，还是存在于一个单独的包而受到影响。"}]},{"t":"heading","d":1,"p":{"lines":[7,8]},"v":"6.1 包：库单元","c":[{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"包内包含有一组类，它们在单一的名字空间之下被组织在了一起。"},{"t":"list_item","d":3,"p":{"lines":[9,10]},"v":"import关键字是程序变得简单。不使用import得用类全名来指定。"},{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"没有指定package，则在未命名包/默认包中。"},{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"每个编译单元都只能有一个public类，该类的名称必须与文件名称相同（包括大小写，不包括后缀名）。其它额外的类在包之外无法看到，因为它们主要用来为主public类提供支持。"},{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"当编译.java文件时，文件中的每个类都会有一个输出文件。因此，在编译少量.java文件之后，会得到大量的.class文件。"},{"t":"list_item","d":3,"p":{"lines":[14,15]},"v":"Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR，Java Archive）的.class文件。Java解释器负责这些文件的查找、装载和解释。"},{"t":"list_item","d":3,"p":{"lines":[15,16]},"v":"类库实际上是一组类文件，如果希望这些构件从属于同一个群组，就可以使用关键字package。如果使用package语句，它必须是文件中除注释以外的第一句程序代码。"},{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"package和import关键字是将单一的全局名字空间分隔开，使得不会出现名称冲突问题。"},{"t":"list_item","d":3,"p":{"lines":[18,19]},"v":"一个包从未真正将被打包的东西包装成单一的文件，并且要给包可以由许多.class文件构成。 -- 操作系统层次化文件结构、jar工具？。"},{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"将所有的文件收入子目录还可以解决另外两个问题：怎样创建独一无二的名称以及怎样查找有可能隐藏于目录结构中某处的类。"},{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"package的第一部分是类的创建者的反顺序的域名，第二部分是把package分解为机器上的一个目录。"},{"t":"list_item","d":3,"p":{"lines":[21,22]},"v":"Java解释器运行过程：找出CLASSPATH（包含一个或多个目录，及JAR文件路径），从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，产生一个路径名称，查找相关的.class文件。"},{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"Java没有C的条件编译功能，该功能绝大多数情况下是用来解决跨平台的问题的，对Java而言没有必要。"},{"t":"list_item","d":3,"p":{"lines":[25,26]},"v":"务必记住，无论合适创建包，都已经在给定包的名称的时候隐含地指定了目录结构。这个包必须位于其名称所指定的目录之中，而该目录必须是在以CLASSPATH开始的目录中可以查询到的。"}]},{"t":"heading","d":1,"p":{"lines":[27,28]},"v":"6.2 Java访问权限修饰词","c":[{"t":"list_item","d":3,"p":{"lines":[28,29]},"v":"访问修饰词public、protected、private置于类中每个成员（域、方法）的定义之前。每个访问权限修饰词仅控制它所修饰的特定定义的访问权。"},{"t":"list_item","d":3,"p":{"lines":[29,30]},"v":"如果不提供任何访问权限修饰词，则意味着它是“包访问权限”。"},{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"默认访问权限没有任何关键字，通常指包访问权限。意味着当前的包中的其他所有类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员却是private。"},{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"一个编译单元只能隶属于一个包，所以经由包访问权限，处于一个编译单元中的所有类彼此之间都是自动可访问的。"},{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"包访问权限为把类群聚在一个包中的做法提供了意义和理由。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"关键字public意味着之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。"},{"t":"list_item","d":3,"p":{"lines":[36,37]},"v":"Java将没有设定任何包名称的文件自动看作是隶属于该目录的默认包之中。"},{"t":"list_item","d":3,"p":{"lines":[37,38]},"v":"// TODO -- 与设定了包名称的？？？"},{"t":"list_item","d":3,"p":{"lines":[39,40]},"v":"private除了包含该成员的类之外，其他任何类都无法访问这个成员。"},{"t":"list_item","d":3,"p":{"lines":[41,42]},"v":"protected处理的是继承的概念。"},{"t":"list_item","d":3,"p":{"lines":[42,43]},"v":"protected也提供了包访问权限。"}]},{"t":"heading","d":1,"p":{"lines":[44,45]},"v":"6.3 接口和实现","c":[{"t":"list_item","d":3,"p":{"lines":[45,46]},"v":"访问权限的控制常被称为是具体实现的隐藏。把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作封装。其结果是一个同时带有特征和行为的数据类型。"},{"t":"list_item","d":3,"p":{"lines":[46,47]},"v":"访问权限控制将权限的边界划在了数据类型的内部。1. 要设定客户端程序员可以使用和不可以使用的界限；2. 将接口和具体实现进行分离。"},{"t":"list_item","d":3,"p":{"lines":[47,48]},"v":"javadoc所提供的注释文档功能降低了程序代码的可读性对客户端程序员的重要性。"}]},{"t":"heading","d":1,"p":{"lines":[49,50]},"v":"6.4 类的访问权限","c":[{"t":"list_item","d":3,"p":{"lines":[50,51]},"v":"访问权限修饰词也可以用于确定库中的哪些类对于该库的使用者是可用的。"},{"t":"list_item","d":3,"p":{"lines":[51,52]},"v":"每个编译单元都只能包含有一个public类，且public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写。"},{"t":"list_item","d":3,"p":{"lines":[52,53]},"v":"编译单元可以不带public类。在这种情况下，可以随意对文件命名，该类只可以用于该包之中。"},{"t":"list_item","d":3,"p":{"lines":[53,54]},"v":"类不可以是private的，也不可以是protected的。"},{"t":"list_item","d":3,"p":{"lines":[54,55]},"v":"如果不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private。 -- static例外。"},{"t":"list_item","d":3,"p":{"lines":[55,56]},"v":"单例模式。"}]}],"p":{}}</svg>
              </div>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>可以不使用操作系统的层次化文件结构，而直接使用package来指定，但这样会存在冲突。</li>
<li>package是java建立的用于解决命名冲突的。而这在实际开发中确实很有用，省去了很多麻烦。</li>
<li>访问权限控制虽然只有几个关键字，但要用好却不是一件简单的事。</li>
</ul>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>复用类</title>
    <url>/2021/12/04/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%887%EF%BC%89%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"7.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情。"},{"t":"list_item","d":3,"p":{"lines":[2,3]},"v":"使用类而不破坏现有程序代码。 1. 组合； 2. 继承。"},{"t":"list_item","d":3,"p":{"lines":[3,4]},"v":"继承是面向对象程序设计的基石之一。"}]},{"t":"heading","d":1,"p":{"lines":[5,6]},"v":"7.1 组合语法","c":[{"t":"list_item","d":3,"p":{"lines":[6,7]},"v":"将对象引用置于新类中。"},{"t":"list_item","d":3,"p":{"lines":[7,8]},"v":"组合对象初始化：1. 在定义对象的地方；2. 在类的构造器中；3. 使用对象之前； 4. 使用实例初始化（代码块）。"}]},{"t":"heading","d":1,"p":{"lines":[9,10]},"v":"7.2 继承语法","c":[{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"继承是所有OOP语言和Java语言不可缺少的组成部分。"},{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"当创建一个类时，总是在继承。除非已明确指出要从其他类中继承，否则就是在隐式地从Java的标准跟类Object进行继承。"},{"t":"list_item","d":3,"p":{"lines":[12,13]},"v":"继承声明式通过在类主体的左边花括号之前，书写后面紧随基类名称的关键字extends而实现的。会自动得到基类中所有域和方法。"},{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"Java中用super关键字表示超类的意思，当前类就是从超类继承的来。"},{"t":"list_item","d":3,"p":{"lines":[14,15]},"v":"在继承的过程中，并不一定非得使用基类的方法，也可以在导出类中添加新方法。"},{"t":"list_item","d":3,"p":{"lines":[15,16]},"v":"在构造器中调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需要的所有知识和能力。Java会自动在导出类的构造器中插入对基类构造器的调用。"},{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"如果没有默认的基类构造器，或想调用一个带参数的基类构造器，就必须用super显式地编写调用基类构造器的语句，并且配以适当的参数列表。"}]},{"t":"heading","d":1,"p":{"lines":[18,19]},"v":"7.3 代理","c":[{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"Java没有提供对代理的直接支持。"},{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"这是继承域组合之间的中庸之道，将一个成员对象置于所要构造的类中（就像组合），与此同时在新类中暴露了该成员对象的所有方法（就像继承）。"}]},{"t":"heading","d":1,"p":{"lines":[22,23]},"v":"7.4 结合使用组合和继承","c":[{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"虽然编译器强制要求初始化基类，并且要求在构造器起始处就要这么做，但是并不监督必须将成员对象也初始化。"},{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"try-finally。"},{"t":"list_item","d":3,"p":{"lines":[25,26]},"v":"手动清理时注意清理顺序。一般来说与生成顺序相反。"},{"t":"list_item","d":3,"p":{"lines":[26,27]},"v":"如果Java的基类拥有多个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本（与C++不同）。无论是在该层或者它的基类中对方法进行定义，重载机制都可以正常工作。"},{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"Java SE5.0 新增加了@Override注解表示覆写每个方法。可以防止在不想重载时而意外地进行了重载。"}]},{"t":"heading","d":1,"p":{"lines":[29,30]},"v":"7.5 在组合与继承之间选择","c":[{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"组合和继承都允许在新的类中放置子对象，组合是显式做，继承是隐式地做。"},{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"组合技术通常用于想在新类中使用现有类地功能而非它地接口这种情形。即在新类中嵌入某个对象，让其实现所需要的功能，但类中的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口。"},{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"在继承地时候，使用某个现有类，并开发一个它的特殊版本。"}]},{"t":"heading","d":1,"p":{"lines":[34,35]},"v":"7.6 protected关键字","c":[{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"就类用户而言，这是private的，但对于任何继承于此类的导出类或其他任何位于同一个包内的类来说，它却是可以访问的。"},{"t":"list_item","d":3,"p":{"lines":[36,37]},"v":"尽管可以创建protected域，但最好的方式还是将域保持为private，应当一直保留“更改底层实现”的权利，然后通过protected方法来控制类的继承者的访问权限。"}]},{"t":"heading","d":1,"p":{"lines":[38,39]},"v":"7.7 向上转型","c":[{"t":"list_item","d":3,"p":{"lines":[39,40]},"v":"“为新的类提供方法”并不是继承技术最重要的方面，其最重要的方面是用来表现新类和基类之间的关系。这种关系可以用“新类是现有类的一种类型”这句话加以概括。"},{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"这个描述并非只是一种解释继承的华丽的方式，这直接是由语言所支撑的。"},{"t":"list_item","d":3,"p":{"lines":[41,42]},"v":"传统类的继承图的绘制方法：将根置于页面的顶端，然后逐渐向下。"},{"t":"list_item","d":3,"p":{"lines":[42,43]},"v":"由导出类转型成基类，在继承图上是向上移动的，因此一般成为向上转型。"},{"t":"list_item","d":3,"p":{"lines":[43,44]},"v":"在向上转型的过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们。"},{"t":"list_item","d":3,"p":{"lines":[44,45]},"v":"慎用。"}]},{"t":"heading","d":1,"p":{"lines":[46,47]},"v":"7.8 final关键字","c":[{"t":"list_item","d":3,"p":{"lines":[47,48]},"v":"根据上下文环境，Java的关键字final的含义存在着细微的区别，但通常指的是“这是无法改变的”。"},{"t":"list_item","d":3,"p":{"lines":[48,49]},"v":"final可用于 数据、方法和类。"},{"t":"list_item","d":3,"p":{"lines":[50,51]},"v":"编译时常量（带有恒定初始值）： final 基本类型/基本类型计算式。必须在定义的时候对其进行赋值。"},{"t":"list_item","d":3,"p":{"lines":[51,52]},"v":"一个既是static又是final的域只占据一段不能改变的存储空间。"},{"t":"list_item","d":3,"p":{"lines":[52,53]},"v":"对于基本类型，final使数值恒定不变；而用于对象引用，final使引用恒定不变。对象自身是可以被修改的。"},{"t":"list_item","d":3,"p":{"lines":[53,54]},"v":"static final 基本类型：用大写表示，用下划线分隔单词。"},{"t":"list_item","d":3,"p":{"lines":[54,55]},"v":"看起来，使引用成为final没有使基本类型成为final的用处大。"},{"t":"list_item","d":3,"p":{"lines":[56,57]},"v":"空白final，指被声明为final但未给定处置的域。"},{"t":"list_item","d":3,"p":{"lines":[57,58]},"v":"编译器确保空白final在使用前必须被初始化。"},{"t":"list_item","d":3,"p":{"lines":[58,59]},"v":"空白final在关键字final的使用上提供了更大的灵活性。"},{"t":"list_item","d":3,"p":{"lines":[60,61]},"v":"Java允许在参数列表中以声明的方式将参数指明为final。意味着无法在方法中更改参数引用所指向的对象。或无法修改基本类型的参数。"},{"t":"list_item","d":3,"p":{"lines":[61,62]},"v":"这一特性主要用来向匿名内部类传递数据。"},{"t":"list_item","d":3,"p":{"lines":[63,64]},"v":"final方法：1. 锁定方法，以防继承。确保在继承中使方法行为保持不变，并且不会被覆盖；2. 效率（早期版本）。"},{"t":"list_item","d":3,"p":{"lines":[64,65]},"v":"类中所有的private方法都隐式地指定为是final的。"},{"t":"list_item","d":3,"p":{"lines":[65,66]},"v":"覆盖只有在某方法是基类的接口的一部分是才会出现。如果某方法是private，只不过是具有相同的名称而已。"},{"t":"list_item","d":3,"p":{"lines":[67,68]},"v":"当将某个类的整体定义为final时，表明了你不打算继承该类，而且也不允许别人这样做。"},{"t":"list_item","d":3,"p":{"lines":[68,69]},"v":"final类的域可以根据需要选择为是或不是final。不论类是否被定义为final，相同的规则都适用于定义为final的域。"},{"t":"list_item","d":3,"p":{"lines":[69,70]},"v":"final类中的方法都隐式指定为是final的。可以添加final修饰词，但没有任何意义。"},{"t":"list_item","d":3,"p":{"lines":[71,72]},"v":"要预见类是如何被复用的一般是很困难的。"}]},{"t":"heading","d":1,"p":{"lines":[73,74]},"v":"7.9 初始化及类的加载","c":[{"t":"list_item","d":3,"p":{"lines":[74,75]},"v":"在许多传统语言中，程序是作为启动过程的一部分立刻被加载的。然后是初始化，紧接着程序开始运行。"},{"t":"list_item","d":3,"p":{"lines":[75,76]},"v":"Java采用了一种不同的加载方式。每个类的编译代码都存在于它自己的独立的文件中，该文件只在需要使用程序代码时才会被加载。"},{"t":"list_item","d":3,"p":{"lines":[76,77]},"v":"构造器也是static方法。类是在任何static成员被访问时加载的。"},{"t":"list_item","d":3,"p":{"lines":[77,78]},"v":"加载顺序：基类static - 导出类static - 初始化 - 基类构造器 - 导出类构造器 - 实例变量 - 其余部分。"}]},{"t":"heading","d":1,"p":{"lines":[79,80]},"v":"7.10 总结","c":[{"t":"list_item","d":3,"p":{"lines":[80,81]},"v":"继承和组合都能从现有类型生成新类型。组合一般是将现有类型作为新类型底层实现的一部分来加以复用，而继承复用的是接口。"},{"t":"list_item","d":3,"p":{"lines":[81,82]},"v":"程序开发是一个增量过程。"}]}],"p":{}}</svg>
              </div>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>继承是面向对象的基础，但是每个语言的实现却并不相同。</li>
</ul>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>多态</title>
    <url>/2021/12/04/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%888%EF%BC%89%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"8.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征。"},{"t":"list_item","d":3,"p":{"lines":[2,3]},"v":"多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。"},{"t":"list_item","d":3,"p":{"lines":[3,4]},"v":"多态的作用是消除类型之间的耦合关系。"}]},{"t":"heading","d":1,"p":{"lines":[5,6]},"v":"8.1 再论向上转型","c":[{"t":"list_item","d":3,"p":{"lines":[6,7]},"v":"忘记对象类型。"}]},{"t":"heading","d":1,"p":{"lines":[8,9]},"v":"8.2 转机","c":[{"t":"list_item","d":3,"p":{"lines":[9,10]},"v":"将一个方法调用同一个方法主体关联起来被称为绑定。"},{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"在程序执行前进行绑定（如果有的话，由编译器和连接程序实现）叫做前期绑定。 --面向过程语言中不需要选择就默认的绑定方式。"},{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"在运行时根据对象的类型进行绑定叫做后期绑定（也叫动态绑定或运行时绑定）。"},{"t":"list_item","d":3,"p":{"lines":[12,13]},"v":"如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法。"},{"t":"list_item","d":3,"p":{"lines":[13,14]},"v":"Java中除了static方法和final方法之外，其他的所有方法都是后期绑定，且会自动发生。"},{"t":"list_item","d":3,"p":{"lines":[14,15]},"v":"在编译时，编译器不需要获得任何特殊信息就能进行正确的调用。"},{"t":"list_item","d":3,"p":{"lines":[15,16]},"v":"只与基类通信，这样的程序时可扩展的，因为可以从通用的基类继承出新的数据类型，从而新添一些功能。那些操作基类的接口的方法不需要任何改动就可以应用于新类。"},{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"只有非private才可以被覆盖。在导出类中，对于基类中的private方法，最好采用不同的名字。"},{"t":"list_item","d":3,"p":{"lines":[17,18]},"v":"只有普通方法的方法调用可以是多态的。任何域访问操作都由编译器解析。"}]},{"t":"heading","d":1,"p":{"lines":[19,20]},"v":"8.3 构造器和多态","c":[{"t":"list_item","d":3,"p":{"lines":[20,21]},"v":"只有基类的构造器才具有恰当的知识和权限来对自己的元素进行初始化。因此，必须令所有构造器都得到调用，否咋就不可能正确构造完整对象。"},{"t":"list_item","d":3,"p":{"lines":[21,22]},"v":"通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行处理。"},{"t":"list_item","d":3,"p":{"lines":[22,23]},"v":"构造器内部的多态方法的行为。 --可能会造成一些难于发现的隐藏错误。"},{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"初始化过程：1. 分配对象存储空间初始化； 2. 调用基类构造器； 3. 按照声明顺序调用成员的初始化方法； 4. 调用导出类的构造器主体。"},{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"构造器准则：用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其他方法。"}]},{"t":"heading","d":1,"p":{"lines":[26,27]},"v":"8.4 协变返回类型","c":[{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"Java SE5 中添加了协变返回类型，它表示在导出类的被覆盖方法可以返回基类的返回类型的某种导出类型。"}]},{"t":"heading","d":1,"p":{"lines":[29,30]},"v":"8.5 用继承进行设计","c":[{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"用继承表达行为间的差异，并用字段表达状态上的变化。"},{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"状态模式。"},{"t":"list_item","d":3,"p":{"lines":[32,33]},"v":"is-a：采用纯粹的方式来创建继承层次结构。"},{"t":"list_item","d":3,"p":{"lines":[33,34]},"v":"is-like-a：有着相同的基本接口，但是它还具有由额外方法实现的其他特性。"},{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"必须由某种方法来确保向下转型的正确性。早某些程序设计语言中，必须执行一个特殊的操作符来获得安全的向下转型。在Java中，所有转型都会得到检查。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"在运行期间对类型进行检查的行为称作“运行时类型识别（RTTI）”。"}]}],"p":{}}</svg>
              </div>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>Java比其它一些程序设计语言在底层做了更多的事，让程序员能够更加不关心底层实现，这样做在使用上会比其他程序设计语言更加简单。</li>
<li>虽然有些操作编译器运行我们进行，但结果可能并不是期望的。所以在实际使用时还得遵循一些准则。</li>
</ul>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2021/12/12/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%889%EF%BC%89%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"9.0 序","c":[{"t":"list_item","d":3,"p":{"lines":[1,2]},"v":"接口和内部类提供了一种将接口与实现分离的更加结构化的概念。"},{"t":"list_item","d":3,"p":{"lines":[2,3]},"v":"这种机制在编程语言中并不通用。在Java中存在语言关键字提供了直接支持。"}]},{"t":"heading","d":1,"p":{"lines":[4,5]},"v":"9.1 抽象类和抽象方法","c":[{"t":"list_item","d":3,"p":{"lines":[5,6]},"v":"创建抽象类是希望通过这个通用接口操纵一系列类。"},{"t":"list_item","d":3,"p":{"lines":[6,7]},"v":"相较于没有抽象类的情况，抽象类可以在编译器捕获问题。"},{"t":"list_item","d":3,"p":{"lines":[7,8]},"v":"包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。"},{"t":"list_item","d":3,"p":{"lines":[8,9]},"v":"抽象类是不完整的，为抽象类创建对象是不安全的。"},{"t":"list_item","d":3,"p":{"lines":[9,10]},"v":"没有任何抽象方法的抽象类。 -- 阻止产生这个类的任何对象。"},{"t":"list_item","d":3,"p":{"lines":[10,11]},"v":"抽象类和抽象方法可以使类的抽象性明确起来。是很有用的重构工具。"},{"t":"list_item","d":3,"p":{"lines":[11,12]},"v":"用abstract关键字来限定抽象类和抽象方法。"}]},{"t":"heading","d":1,"p":{"lines":[13,14]},"v":"9.2 接口","c":[{"t":"list_item","d":3,"p":{"lines":[14,15]},"v":"interface关键字使抽象的概念更向前迈进了一步。"},{"t":"list_item","d":3,"p":{"lines":[15,16]},"v":"interface关键字产生一个完全抽象的类，没有提供任何具体实现。"},{"t":"list_item","d":3,"p":{"lines":[16,17]},"v":"接口被用来建立类与类之间的协议。"},{"t":"list_item","d":3,"p":{"lines":[17,18]},"v":"interface允许通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继承的特性。"},{"t":"list_item","d":3,"p":{"lines":[18,19]},"v":"接口可以包含域，隐式声明为 static final。"},{"t":"list_item","d":3,"p":{"lines":[19,20]},"v":"接口中的方法隐式声明为 public。实现一个接口时，实现的方法必须被定义为是public的。（Java编译器不允许继承过程中访问权限被降低。） 包访问权限的public意义？？？"}]},{"t":"heading","d":1,"p":{"lines":[21,22]},"v":"9.3 完全解耦","c":[{"t":"list_item","d":3,"p":{"lines":[22,23]},"v":"能够根据所传递的参数对象的不同而具有不同行为的方法，被称为策略模式。"},{"t":"list_item","d":3,"p":{"lines":[23,24]},"v":"复用不在同一继承结构中的某个类。1. 遵循接口编写实现类。2. 适配器。"},{"t":"list_item","d":3,"p":{"lines":[24,25]},"v":"将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现，因此代码更具可复用性。"}]},{"t":"heading","d":1,"p":{"lines":[26,27]},"v":"9.4 Java中的多重继承","c":[{"t":"list_item","d":3,"p":{"lines":[27,28]},"v":"接口没有具体实现，也就是说，没有任何与接口相关的存储。因此，无法阻止与接口的组合。"},{"t":"list_item","d":3,"p":{"lines":[28,29]},"v":"在C++中，组合多个类的接口的行为被称为多重继承（C++对接口只有间接的支持）。在Java中可以执行相同的行为，但是只有一个类可以有具体实现。"},{"t":"list_item","d":3,"p":{"lines":[29,30]},"v":"从一个非接口的类继承，只能从一个类去继承，其它的基元素必须是接口。"},{"t":"list_item","d":3,"p":{"lines":[30,31]},"v":"可以继承任意多个接口，并可以向上转型为每个接口，因为每一个接口都是一个独立类型。"},{"t":"list_item","d":3,"p":{"lines":[31,32]},"v":"使用接口的原因：1. 为了能够向上转型为多个基类型； 2. 防止创建该类的对象。"}]},{"t":"heading","d":1,"p":{"lines":[33,34]},"v":"9.5 通过继承来扩展接口","c":[{"t":"list_item","d":3,"p":{"lines":[34,35]},"v":"通过继承，可以在接口中添加新的方法声明，还可以在新街口中组合接口。这两种情况都可以获得新的接口。"},{"t":"list_item","d":3,"p":{"lines":[35,36]},"v":"在打算组合的不同接口中使用相同的方法名通常会造成代码可读性的混乱。应尽量避免这种情况。"}]},{"t":"heading","d":1,"p":{"lines":[37,38]},"v":"9.6 适配接口","c":[{"t":"list_item","d":3,"p":{"lines":[38,39]},"v":"允许同一个接口具有不同的具体实现。"},{"t":"list_item","d":3,"p":{"lines":[39,40]},"v":"interface提供伪多重继承机制。适配器。"},{"t":"list_item","d":3,"p":{"lines":[40,41]},"v":"让方法接受接口类型，是一种让任何类都可以对该方法进行适配的方式。"}]},{"t":"heading","d":1,"p":{"lines":[42,43]},"v":"9.7 接口中的域","c":[{"t":"list_item","d":3,"p":{"lines":[43,44]},"v":"接口中的域自动是 public static final，所以接口成为了一种很便捷的创建常量组的工具。在Java SE5 之前，产生与enum具有相同效果的类型的唯一途径。"},{"t":"list_item","d":3,"p":{"lines":[44,45]},"v":"Java中表示具有常量初始值的static final时，使用大写字母的风格（下划线分隔多个单词）。"},{"t":"list_item","d":3,"p":{"lines":[45,46]},"v":"接口中定义的域不能是“空final”，但可以是被非常量表达式初始化。在类第一次被加载时初始化。值被存储在该接口的静态存储区域内。"}]},{"t":"heading","d":1,"p":{"lines":[47,48]},"v":"9.8 嵌套接口","c":[{"t":"list_item","d":3,"p":{"lines":[48,49]},"v":"接口可以嵌套在类或其它接口中。嵌套接口可以被实现为private。"},{"t":"list_item","d":3,"p":{"lines":[49,50]},"v":"实现了一个private接口的内部类，同样可以被实现为public类，但是只能被其自身所使用。"},{"t":"list_item","d":3,"p":{"lines":[50,51]},"v":"实现一个private接口只是一种方式，强制该接口中的方法定义不要添加任何类型信息（不允许向上转型）。"},{"t":"list_item","d":3,"p":{"lines":[51,52]},"v":"返回对private接口的引用的public方法，只有以各种方式可用，就是将返回值交给有权使用它的对象。"},{"t":"list_item","d":3,"p":{"lines":[52,53]},"v":"嵌套在另一个接口中的接口自动就是public的，而不能声明为private的。"},{"t":"list_item","d":3,"p":{"lines":[53,54]},"v":"当实现某个接口时，并不需要实现嵌套在其内部的任何接口。"},{"t":"list_item","d":3,"p":{"lines":[54,55]},"v":"private接口不能在定义它的类之外被实现。"}]},{"t":"heading","d":1,"p":{"lines":[56,57]},"v":"9.9 接口与工厂","c":[{"t":"list_item","d":3,"p":{"lines":[57,58]},"v":"生成遵循某个接口的对象的典型方式就是工厂方法设计模式。"},{"t":"list_item","d":3,"p":{"lines":[58,59]},"v":"更加优雅的工厂实现方式： 匿名内部类。"}]},{"t":"heading","d":1,"p":{"lines":[60,61]},"v":"9.10 总结","c":[{"t":"list_item","d":3,"p":{"lines":[61,62]},"v":"对于创建类，几乎在任何时刻，都可以替代为创建一个接口和一个工厂。"},{"t":"list_item","d":3,"p":{"lines":[62,63]},"v":"任何抽象性都应该是应真正的需求而产生的。"}]}],"p":{}}</svg>
              </div>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul>
<li>接口和抽象类在某些方面确实做得很好。但是，添加了新的类型，意味着需要了解更多，才能更好的掌握它。如接口中域被非常量表达式初始化，需要了解类加载过程；接口中嵌套的修饰，需要了解其意义所在。</li>
</ul>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> ]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
</search>
