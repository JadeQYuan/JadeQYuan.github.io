<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js prototye</title>
    <url>/2021/07/29/JS/js-prototye/</url>
    <content><![CDATA[<ol>
<li><strong>proto</strong> 和 contructor 是对象属性，prototype是函数属性（函数也是对象）。</li>
<li><strong>proto</strong> 由一个对象指向它的原型对象。</li>
<li>prototype 从一个函数指向所创建实例的原型对象。</li>
<li>contructor 从一个对象指向给对象的构造函数。</li>
</ol>
<h2 id="prototype-的目的"><a href="#prototype-的目的" class="headerlink" title="prototype 的目的"></a>prototype 的目的</h2><p>共享方法、共享属性、面向对象</p>
<ol>
<li>函数内部定义的变量及函数，只能在内部调用，是私有的，外部无法访问。</li>
<li>函数添加静态变量及函数，通过函数对象本身可以访问，但是通过实例访问不到。</li>
<li>函数内部通过this添加变量及函数，创建实例时详单与做了拷贝，无法共享。（函数本身拷贝没有意义，且浪费资源）</li>
</ol>
<p>故，只要创建一个函数，就为该函数创建一个prototype属性，prototype本身是个对象，其contructor属性指向该函数本身，其__proto__属性指向Function.prototype。</p>
<h2 id="对象创建方式及区别"><a href="#对象创建方式及区别" class="headerlink" title="对象创建方式及区别"></a>对象创建方式及区别</h2><ol>
<li>字面量创建<br> <strong>proto</strong> 指向Object.prototype。</li>
<li>函数对象<br> <strong>proto</strong> 指向Function.prototype。<br> prototype 指向 该对象的prototype。</li>
<li>new创建<ol>
<li>生成一个新对象</li>
<li>设置对象__proto__指向函数的prototype属性。</li>
<li>绑定this</li>
<li>返回</li>
</ol>
</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code>内部使用this变量，使用new调用创建。
构造函数生成的实例对象都有__proto__属性，指向构造函数的prototype。
利用构造函数继承属性，利用原型对象继承方法。（组合继承）
</code></pre>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><pre><code>构造函数的另一种写法。
语法糖。
</code></pre>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><pre><code>1. 原型链继承
2. 构造函数继承
3. 组合继承
其它。。。
</code></pre>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/2020/02/05/Java/AOP/</url>
    <content><![CDATA[<h2 id="一-什么是AOP"><a href="#一-什么是AOP" class="headerlink" title="一. 什么是AOP"></a>一. 什么是AOP</h2><pre><code>AOP（Aspect Oriented Programing），面向切面编程，是对OOP的补充，通过预编译方式或运行期动态代理实现程序功能的统一维护的一种技术。
</code></pre>
<h2 id="二-意图"><a href="#二-意图" class="headerlink" title="二. 意图"></a>二. 意图</h2><pre><code>将与业务无关的代码，如日志记录，性能监控，事务处理等从业务逻辑代码中划分出来，将它们独立到非业务逻辑方法中，使得与业务方法解耦，并且在改变相关逻辑的时候不影响业务逻辑的代码。
</code></pre>
<h2 id="三-AOP-概念"><a href="#三-AOP-概念" class="headerlink" title="三. AOP 概念"></a>三. AOP 概念</h2><h4 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面 Aspect"></a>切面 Aspect</h4><pre><code>切面是一个横切关注点。
</code></pre>
<h4 id="连接点-JointPoint"><a href="#连接点-JointPoint" class="headerlink" title="连接点 JointPoint"></a>连接点 JointPoint</h4><pre><code>连接点是具体执行增强的点，比如方法执行，构造器调用，成员赋值。
</code></pre>
<h4 id="切点-PointCut"><a href="#切点-PointCut" class="headerlink" title="切点 PointCut"></a>切点 PointCut</h4><pre><code>匹配连接点的正则表达式，是连接点的集合。
</code></pre>
<h4 id="通知-Advice"><a href="#通知-Advice" class="headerlink" title="通知 Advice"></a>通知 Advice</h4><pre><code>对连接点的进行的操作。
</code></pre>
<h4 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入 Weaving"></a>织入 Weaving</h4><pre><code>把切面应用到目标对象，并创建代理对象的过程。切面在指定的连接点被织入到目标对象。
</code></pre>
<h2 id="四-AOP流行框架比较"><a href="#四-AOP流行框架比较" class="headerlink" title="四. AOP流行框架比较"></a>四. AOP流行框架比较</h2><pre><code>当下最流行的AOP框架为Spring AOP 及 AspectJ。
</code></pre>
<ol>
<li>能力和目标</li>
</ol>
<ul>
<li>Spring AOP<br>  旨在通过Spring IOC 提供一个简单的AOP实现。<br>  不是一个完整的AOP解决方案，只能用于被Spring容器管理的bean。</li>
<li>AspectJ<br>  完整的AOP解决方案，比Spirng AOP复杂。<br>  可以在应用于所有领域对象。</li>
</ul>
<ol start="2">
<li>织入时机</li>
</ol>
<ul>
<li>Spring AOP<br>  只能在运行时织入。</li>
<li>AspectJ<br>  可以在编译期，加载期，编译后（jar包和字节码文件）。</li>
</ul>
<ol start="3">
<li>依赖</li>
</ol>
<ul>
<li>Spring AOP<br>  使用JDK动态代理或者VGLIB代理。</li>
<li>AspectJ<br>  不依赖任何运行时环境，只需要AspectJ compiler(ajc)在运行前完成织入。</li>
</ul>
<ol start="4">
<li>连接点</li>
</ol>
<ul>
<li>Spring AOP<br>  由于要使用代理模式，所以不能作用域final类，static方法，final方法。<br>  只支持方法执行连接点。</li>
<li>AspectJ<br>  没有限制。<br>  方法调用，方法执行，构造器调用，构造器执行，静态初始化执行，对象初始化，成员引用，成员赋值，处理器执行，通知执行。</li>
</ul>
<ol start="5">
<li>复杂度</li>
</ol>
<ul>
<li>Spring AOP<br>  不需要额外的编译器，只能和Spirng管理的bean一起工作。</li>
<li>AspectJ<br>  需要引入ajc并重新打包。</li>
</ul>
<ol start="6">
<li>总结</li>
</ol>
<table>
<thead>
<tr>
<th>Spring AOP</th>
<th>AspectJ</th>
</tr>
</thead>
<tbody><tr>
<td>Implemented in pure Java</td>
<td>Implemented using extensions of Java programming language</td>
</tr>
<tr>
<td>No need for separate compilation process</td>
<td>Needs AspectJ compiler (ajc) unless LTW is set up</td>
</tr>
<tr>
<td>Only runtime weaving is available</td>
<td>Runtime weaving is not available. Supports compile-time, post-compile, and load-time Weaving</td>
</tr>
<tr>
<td>Less Powerful – only supports method level weaving</td>
<td>More Powerful – can weave fields, methods, constructors, static initializers, final class/methods, etc…</td>
</tr>
<tr>
<td>Can only be implemented on beans managed by Spring container</td>
<td>Can be implemented on all domain objects</td>
</tr>
<tr>
<td>Supports only method execution pointcuts</td>
<td>Support all pointcuts</td>
</tr>
<tr>
<td>Proxies are created of targeted objects, and aspects are applied on these proxies</td>
<td>Aspects are weaved directly into code before application is executed (before runtime)</td>
</tr>
<tr>
<td>Much slower than AspectJ</td>
<td>Better Performance</td>
</tr>
<tr>
<td>Easy to learn and apply</td>
<td>Comparatively more complicated than Spring AOP</td>
</tr>
</tbody></table>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><pre><code>https://www.baeldung.com/spring-aop-vs-aspectj
</code></pre>
<p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象。</p>
<p>织入时期：编译器（aspectj），装载器（cglib），运行期</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>jvm</title>
    <url>/2020/09/23/JVM/jvm/</url>
    <content><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>Java 虚拟机。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>加载、验证、准备、解析、初始化、使用、卸载</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>BootStrap ClassLoader、Extension ClassLoader、Application ClassLoader、User ClassLoader</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>方法区、堆、栈、程序计数器、本地方法栈</p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>BeanValidation</title>
    <url>/2020/02/05/Java/BeanValidation/</url>
    <content><![CDATA[<h2 id="Bean-Validation"><a href="#Bean-Validation" class="headerlink" title="Bean Validation"></a>Bean Validation</h2><pre><code>Bean Validation是一个运行时的数据验证框架，为JavaBean验证定义了相应的元数据模型和Api。
</code></pre>
<table>
<thead>
<tr>
<th>JSR版本</th>
<th>Bean Validation版本</th>
<th>发布时间</th>
<th>hibernate实现版本</th>
<th>apache BLal实现版本</th>
</tr>
</thead>
<tbody><tr>
<td>303</td>
<td>1.0</td>
<td>2009年javaee 6</td>
<td>4.3.1.Final</td>
<td>0.5</td>
</tr>
<tr>
<td>349</td>
<td>1.1</td>
<td>2013年javaee 7</td>
<td>5.1.1.Final</td>
<td>1.1.1</td>
</tr>
<tr>
<td>380</td>
<td>2.0</td>
<td>2017年javaee 8</td>
<td>6.0.1.Final</td>
<td>2.0.3</td>
</tr>
</tbody></table>
<h2 id="Hibernate-Validation"><a href="#Hibernate-Validation" class="headerlink" title="Hibernate Validation"></a>Hibernate Validation</h2><pre><code>hibernate validation是对这个规范的实践，他提供了相应的实现，并增加了一些其他校验注解(后期规范更新，hibernate将重复的标记了@Departure)，他们位于org.hibernate.validator.constraints包下。
</code></pre>
<h2 id="Spring-Validataion"><a href="#Spring-Validataion" class="headerlink" title="Spring Validataion"></a>Spring Validataion</h2><pre><code>spring validation对hibernate validation进行了二次封装，在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类（BindingResult）中。
</code></pre>
<h2 id="Validated-和-Valid-的区别"><a href="#Validated-和-Valid-的区别" class="headerlink" title="@Validated 和 @Valid 的区别"></a>@Validated 和 @Valid 的区别</h2><ul>
<li>@Validted 支持分组校验，@Valid不支持。</li>
<li>@Valid支持嵌套验证，@Validated不支持。</li>
<li>@Validated可以将校验结果绑定到BindingResult中，而不抛出异常。<br>  必须一个校验对象一个BindingResult，一一对应且紧随其后。</li>
<li>在没有分组校验及嵌套校验的情况下， 效果一致。</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><pre><code>https://beanvalidation.org
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java版本与特性</title>
    <url>/2020/07/21/Java/Java%E7%89%88%E6%9C%AC%E4%B8%8E%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>Java是由Sun Microsystems公司（简称Sun公司）于1995年5月推出的Java程序设计语言和Java平台的总称。“Write Once, Run Anywhere”。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>JDK: Java Development Kit，Java开发工具包，包括JVM、Java类库、Java工具。</li>
<li>Java 平台: 用Java语言编写的软件运行的平台，包括SE、ME、EE。</li>
</ul>
<h2 id="Java-发展史"><a href="#Java-发展史" class="headerlink" title="Java 发展史"></a>Java 发展史</h2><ul>
<li>1995-5-23，Oak语言更名为Java，并发布JDK 1.0α2和HotJava 浏览器（1999年停止发展）。10月，发布JDK 1.0β。</li>
<li>1996-1-23，JDK 1.0发布，Java语言第一个正式版本的运行环境。</li>
<li>1997-2-19，JDK 1.1发布。</li>
<li>1998-12-4，Java2平台拆为3个方向，J2SE 1.2（JDK 1.2）发布。</li>
<li>1999-4-27，HotSpot虚拟机发布。</li>
<li>1999-12-12, J2EE 1.2发布。</li>
<li>2000-5-8，J2SE 1.3（JDK 1.3）发布。</li>
<li>2001-9-24，J2EE 1.3发布。</li>
<li>2002-2-13，J2SE 1.4（JDK 1.4）发布。</li>
<li>2003-11-11，J2EE 1.4发布。</li>
<li>2004-9-30，J2SE 5.0（JDK 1.5）发布，修改版本号命名方式，1.x保留为内部命名方式。</li>
<li>2006-11-13，Sun在GPL许可证下开源Java。</li>
<li>2006-12-11，Java SE 6发布，使用Java SE替换J2SE，版本号去掉“.0”。</li>
<li>2006-5-11，Java EE 5发布。</li>
<li>2009-4-20，Oracle以74亿美元收购Sun。</li>
<li>2011-7-28，Java SE 7发布，LTS（2022-7）。</li>
<li>2013-5-28，Java EE 7发布。</li>
<li>2014-3-18，Java SE 8发布，LTS（2030-12）。</li>
<li>2017-8-31，Java EE 8发布。</li>
<li>2018-9-25，Java SE 11发布，LTS（2026-9）。</li>
<li>2019-9-10，Jakarta EE8发布，Java EE更名为Jakarta EE。</li>
<li>2020-11-22，Jakarta EE9发布。</li>
<li>2021-9-17，Java SE 17发布，从此免费提供，LTS（2029-9）。</li>
</ul>
<h2 id="Java-JDK-新特性"><a href="#Java-JDK-新特性" class="headerlink" title="Java/JDK 新特性"></a>Java/JDK 新特性</h2><h3 id="Java-SE-11"><a href="#Java-SE-11" class="headerlink" title="Java SE 11"></a>Java SE 11</h3><ul>
<li>String API isBlank、strip、stripTrailing、stripLeading、repeat、lines.count</li>
<li>Optinal API isEmpty…</li>
<li>局部变量类型推断加强 var上可以加注解</li>
<li>HttpClient</li>
<li>垃圾回收ZGC</li>
</ul>
<h3 id="Java-SE-10"><a href="#Java-SE-10" class="headerlink" title="Java SE 10"></a>Java SE 10</h3><ul>
<li>局部变量类型推断</li>
<li>不可变集合的改进</li>
<li>并行全垃圾回收器 G1</li>
<li>线程本地握手</li>
<li>Optional新增orElseThrow()方法</li>
<li>类数据共享</li>
<li>Unicode 语言标签扩展</li>
<li>根证书</li>
</ul>
<h3 id="Java-SE-9"><a href="#Java-SE-9" class="headerlink" title="Java SE 9"></a>Java SE 9</h3><ul>
<li>模块化</li>
<li>jShell</li>
<li>接口可定义private方法 （只能在接口内部调用）</li>
<li>try with resource 优化</li>
<li>String, StringBuilder, StringBuffer 中的value由char[]改为byte[]</li>
<li>List、Set、Map 添加of方法创建只读集合</li>
<li>InputStream流加强</li>
<li>StreamAPI takeWhile、dropWhile、ofNullable、iterate</li>
<li>Optional增加stream()</li>
<li>垃圾回收机制</li>
</ul>
<h3 id="Java-SE-8"><a href="#Java-SE-8" class="headerlink" title="Java SE 8"></a>Java SE 8</h3><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><ul>
<li>lambda 表达式和函数式接口</li>
<li>接口的默认方法和静态方法</li>
<li>方法引用</li>
<li>重复注释</li>
<li>更好的类型推断</li>
<li>注解的扩展 （扩展了注解可以使用的范围，包括：局部变量，泛型，超类，接口实现，方法的exception声明等）</li>
</ul>
<h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><ul>
<li>参数名字</li>
</ul>
<h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><ul>
<li>Optional</li>
<li>Stream</li>
<li>时间日期API</li>
<li>Nashorn javascript引擎</li>
<li>Base64</li>
<li>并行数组 （增加了支持并行的数组处理）</li>
<li>并发 （新增StampedLock、DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder等）</li>
</ul>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul>
<li>Nashorn引擎 jjs</li>
<li>类依赖分析工具 jdeps</li>
</ul>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul>
<li>JVM内存永久区被metaspace替换，JVM参数 -XX:PermSize 和 -XX:MaxPermSize 被 -XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 代替。</li>
</ul>
<h3 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h3><ul>
<li>switch 支持String字符串类型</li>
<li>try-with-resources，资源自动关闭</li>
<li>整数类型能够用二进制来表示</li>
<li>数字常量支持下划线</li>
<li>泛型实例化类型自动推断,即”&lt;&gt;”</li>
<li>catch捕获多个异常类型，用（|）分隔开</li>
<li>全新的NIO2.0 API</li>
<li>Fork/join 并行执行任务的框架</li>
</ul>
<h3 id="JDK-1-6"><a href="#JDK-1-6" class="headerlink" title="JDK 1.6"></a>JDK 1.6</h3><ul>
<li>java.awt新增Desktop类和SystemTray类</li>
<li>使用JAXB2来实现对象与XML之间的映射</li>
<li>轻量级 Http Server API</li>
<li>插入式注解处理API(lombok使用该特性来实现的)</li>
<li>STAX，处理XML文档的API</li>
<li>Compiler API</li>
<li>对脚本语言的支持（ruby, groovy, javascript）</li>
</ul>
<h3 id="JDK-1-5"><a href="#JDK-1-5" class="headerlink" title="JDK 1.5"></a>JDK 1.5</h3><ul>
<li>自动装箱拆箱</li>
<li>泛型</li>
<li>元数据</li>
<li>Introspector 内省</li>
<li>枚举</li>
<li>静态引入</li>
<li>可变长参数</li>
<li>foreach</li>
<li>JMM</li>
<li>concurrent</li>
</ul>
<h3 id="JDK-1-4"><a href="#JDK-1-4" class="headerlink" title="JDK 1.4"></a>JDK 1.4</h3><ul>
<li>XML解析器</li>
<li>Java打印服务</li>
<li>Logging API（日志功能）</li>
<li>Java Web Start</li>
<li>JDBC 3.0 API（jdbc高级)</li>
<li>断言</li>
<li>Preferences API</li>
<li>链式异常处理</li>
<li>支持IPV6</li>
<li>支持正则表达式</li>
<li>引入Imgae I/O API （图片流);</li>
<li>NIO（高级流）</li>
<li>XSLT转换器</li>
</ul>
<h3 id="JDK-1-3"><a href="#JDK-1-3" class="headerlink" title="JDK 1.3"></a>JDK 1.3</h3><ul>
<li>数学运算</li>
<li>Timer API</li>
<li>Java Sound API</li>
<li>CORBA IIOP实现RMI的通信协议</li>
<li>Java 2D</li>
<li>JAR文件索引</li>
</ul>
<h3 id="JDK-1-2"><a href="#JDK-1-2" class="headerlink" title="JDK 1.2"></a>JDK 1.2</h3><ul>
<li>J2SE/J2EE/J2ME</li>
<li>EJB</li>
<li>Java IDL（平台对象请求代理体系结构）</li>
<li>集合框架</li>
<li>JIT(Just In Time)编译器</li>
<li>数字签名</li>
<li>JFC(Java Foundation Classes), 包括Swing1.0, 拖放和Java2D类库</li>
<li>Java Plug-In（运行插件)</li>
<li>JDBC中引入可滚动结果集,BLOB,CLOB,批量更新和用户自定义类型</li>
<li>Applet中添加声音支持</li>
<li>字符串常量做内存映射</li>
<li>控制授权/访问系统资源的策略工具</li>
</ul>
<h3 id="JDK-1-1"><a href="#JDK-1-1" class="headerlink" title="JDK 1.1"></a>JDK 1.1</h3><ul>
<li>JAR</li>
<li>JDBC</li>
<li>JavaBeans</li>
<li>RMI</li>
<li>Inner Class</li>
<li>Reflection</li>
</ul>
<h3 id="JDK-1-0"><a href="#JDK-1-0" class="headerlink" title="JDK 1.0"></a>JDK 1.0</h3><ul>
<li>Classic VM（虚拟机）</li>
<li>Applet（java小应用程序）</li>
<li>AWT（java图形设计）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Lombok 填坑</title>
    <url>/2021/06/24/Java/Lombok-%E5%A1%AB%E5%9D%91/</url>
    <content><![CDATA[<h2 id="lombok-getset生成"><a href="#lombok-getset生成" class="headerlink" title="lombok getset生成"></a>lombok getset生成</h2><p>属性名第一个字母小写，第二个字母大写<br>lombok生成的为 getXX<br>java官方默认的为 getxX</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Stream原理</title>
    <url>/2020/09/09/Java/Stream%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><p>Java 8 中定义了四种流，分别是Stream、IntStream、LongStream、DoubleStream。每种流的操作、参数等都有区别。</p>
<h3 id="BaseStream"><a href="#BaseStream" class="headerlink" title="BaseStream"></a>BaseStream</h3><p>所有流接口的父级接口。</p>
<h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><p>工具类。</p>
<h3 id="StreamSupport"><a href="#StreamSupport" class="headerlink" title="StreamSupport"></a>StreamSupport</h3><p>创建流的工具，多用于类库</p>
<h2 id="PipelineHelper"><a href="#PipelineHelper" class="headerlink" title="PipelineHelper"></a>PipelineHelper</h2><p>流水线，通过其将流串起来。</p>
<h3 id="AbastractPipeline"><a href="#AbastractPipeline" class="headerlink" title="AbastractPipeline"></a>AbastractPipeline</h3><p>抽象类，定义了流水线串联起来的属性，及一些方法。</p>
<h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>与流类型，也分为四类。ReferencePipeline、IntPipeline、LongPipeline、DoublePipeline。</p>
<h4 id="ReferencePipeline"><a href="#ReferencePipeline" class="headerlink" title="ReferencePipeline"></a>ReferencePipeline</h4><p>引用类型的流水线，抽象类，其实现类主要有，Head、StatelessOp、StatefulOp，分别表示第一个、无状态的和有状态。</p>
<h2 id="OP"><a href="#OP" class="headerlink" title="OP"></a>OP</h2><p>操作</p>
<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><h4 id="有状态的操作"><a href="#有状态的操作" class="headerlink" title="有状态的操作"></a>有状态的操作</h4><ul>
<li>distinct</li>
<li>sorted</li>
<li>limit</li>
<li>skip<h4 id="无状态的操作"><a href="#无状态的操作" class="headerlink" title="无状态的操作"></a>无状态的操作</h4></li>
<li>map</li>
<li>filter</li>
<li>peek<h3 id="结束操作"><a href="#结束操作" class="headerlink" title="结束操作"></a>结束操作</h3>TerminalOP。<h4 id="短路操作"><a href="#短路操作" class="headerlink" title="短路操作"></a>短路操作</h4></li>
<li>match</li>
<li>find<h4 id="非短路操作"><a href="#非短路操作" class="headerlink" title="非短路操作"></a>非短路操作</h4></li>
<li>foreach</li>
<li>reduce</li>
</ul>
<h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><p>真正的执行者。</p>
<h3 id="TerminalSink"><a href="#TerminalSink" class="headerlink" title="TerminalSink"></a>TerminalSink</h3><p>标识是结束操作。</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>返回值。</p>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>通过ForkJoinTask来实现并行流的处理。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="编码流程"><a href="#编码流程" class="headerlink" title="编码流程"></a>编码流程</h3><ol>
<li>创建一个stream</li>
<li>添加中间操作，包括有状态、无状态操作</li>
<li>添加结束操作</li>
<li>如果有返回值，接收返回值</li>
</ol>
<h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><ol>
<li>创建steam，其类型为Head</li>
<li>每一步中间操作，创建一个新的stream，其类型为StatelessOp或StatefulOp，并在新的steam中保存上一个stream的引用</li>
<li>对于结束操作，创建一个新的TerminalSink</li>
<li>通过stream中的引用，逆序对每一个中间操作创建一个Sink，因为Sink继承自Consumer，在accpet中调用下流sink</li>
<li>接收返回值</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>String</title>
    <url>/2021/11/15/Java/String/</url>
    <content><![CDATA[<p>在C/C++中，字符串作为字符的数组被实现。而在Java中，字符串是作为对象实现，字符串实际上是对象类型。</p>
<p>Java字面量：<br>    基本数据类型<br>    字符串<br>    数组 - 实际也是对象？</p>
<p>字符串常量池： 在类加载时，在堆（方法区？）中创建一个对象，然后将它的引用存放在池中（还是方法区？）的一个常量表中。并且不会被垃圾回收。</p>
<p>使用new创建字符串，是在运行期创建的。</p>
<p>String s1 = “abc”;<br>String s2 = new String(“abc”);<br>s1.equals(s2) &amp;&amp; s1 != s2 &amp;&amp; s1.value == s2.value<br>字符串的值使用数组实现，在java中也是对象，s1，s2 的值都指向常量池中的数组对象。</p>
<p>String intern(): 把自身替换为常量池中的引用</p>
<p>字符串拼接：<br>    字面量拼接： 优化为一个字面量<br>    字面量和变量拼接： 使用StringBuilder优化<br>    int + char -&gt; char<br>    int + string -&gt; string<br>    string + 任意 -&gt; string</p>
<p>String 实现方式<br>    Jdk 6 char[]、offset、count、hash<br>    Jdk 7、8  char[]、hash<br>    Jdk 9  byte[]、coder、hash  </p>
<p>数组：<br>    数据是对象，但不是从某个类实例化来的，而是由JVM直接创建的，其父类是Object。<br>    每个数据都对应一个Class对象，通过RTTI，可以检查数据的运行时类型，签名，基类等。</p>
<pre><code>数组        RTTI
char[]        [C
int[]        [I
long[]        [J
float[]        [F
String[]    [Ljava.lang.String;
</code></pre>
<p>字面量初始化<br>int          直接定义, int i = 1;<br>short         2个字节以内的int，short s = (short)1;<br>long        l/L 结尾<br>byte        1个字节以内的byte，byte b = (byte)1;<br>float        f/F 结尾<br>double        整数+d/D结尾或小数<br>char        单引号<br>boolean     true/false<br>string        双引号<br>[]            大括号{} （简化了new）</p>
<p>null        null</p>
<p>null：<br>    null是一种数据类型，但可以忽略。<br>    null是关键字，是所有对象类型的默认值。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>SnowFlakeId</title>
    <url>/2021/01/02/Java/SnowFlakeId/</url>
    <content><![CDATA[<h2 id="SnowFlakeId"><a href="#SnowFlakeId" class="headerlink" title="SnowFlakeId"></a>SnowFlakeId</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.hibernate.engine.spi.SharedSessionContractImplementor;</span><br><span class="line">import org.hibernate.id.IdentityGenerator;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class SnowFlakeIdGenerator extends IdentityGenerator &#123;</span><br><span class="line"></span><br><span class="line">    // ==============================Fields===========================================</span><br><span class="line">    /** 开始时间截 (2015-01-01) */</span><br><span class="line">    private final long twepoch = 1420041600000L;</span><br><span class="line"></span><br><span class="line">    /** 机器id所占的位数 */</span><br><span class="line">    private final long workerIdBits = 5L;</span><br><span class="line"></span><br><span class="line">    /** 数据标识id所占的位数 */</span><br><span class="line">    private final long datacenterIdBits = 5L;</span><br><span class="line"></span><br><span class="line">    /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span><br><span class="line">    private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    /** 支持的最大数据标识id，结果是31 */</span><br><span class="line">    private final long maxDataCenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    /** 序列在id中占的位数 */</span><br><span class="line">    private final long sequenceBits = 12L;</span><br><span class="line"></span><br><span class="line">    /** 机器ID向左移12位 */</span><br><span class="line">    private final long workerIdShift = sequenceBits;</span><br><span class="line"></span><br><span class="line">    /** 数据标识id向左移17位(12+5) */</span><br><span class="line">    private final long datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    /** 时间截向左移22位(5+5+12) */</span><br><span class="line">    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span><br><span class="line">    private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    /** 工作机器ID(0~31) */</span><br><span class="line">    private long workerId;</span><br><span class="line"></span><br><span class="line">    /** 数据中心ID(0~31) */</span><br><span class="line">    private long datacenterId;</span><br><span class="line"></span><br><span class="line">    /** 毫秒内序列(0~4095) */</span><br><span class="line">    private long sequence = 0L;</span><br><span class="line"></span><br><span class="line">    /** 上次生成ID的时间截 */</span><br><span class="line">    private long lastTimestamp = -1L;</span><br><span class="line"></span><br><span class="line">    //==============================Constructors=====================================</span><br><span class="line">    public SnowFlakeIdGenerator() &#123;</span><br><span class="line">        this.workerId = 0;</span><br><span class="line">        this.datacenterId = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造函数</span><br><span class="line">     * @param workerId 工作ID (0~31)</span><br><span class="line">     * @param datacenterId 数据中心ID (0~31)</span><br><span class="line">     */</span><br><span class="line">    public SnowFlakeIdGenerator(long workerId, long datacenterId) &#123;</span><br><span class="line">        if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        if (datacenterId &gt; maxDataCenterId || datacenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;, maxDataCenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        this.workerId = workerId;</span><br><span class="line">        this.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ==============================Methods==========================================</span><br><span class="line">    /**</span><br><span class="line">     * 获得下一个ID (该方法是线程安全的)</span><br><span class="line">     * @return SnowflakeId</span><br><span class="line">     */</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span><br><span class="line">        if (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果是同一时间生成的，则进行毫秒内序列</span><br><span class="line">        if (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + 1) &amp; sequenceMask;</span><br><span class="line">            //毫秒内序列溢出</span><br><span class="line">            if (sequence == 0) &#123;</span><br><span class="line">                //阻塞到下一个毫秒,获得新的时间戳</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //时间戳改变，毫秒内序列重置</span><br><span class="line">        else &#123;</span><br><span class="line">            sequence = 0L;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //上次生成ID的时间截</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        //移位并通过或运算拼到一起组成64位的ID</span><br><span class="line">        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) //</span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) //</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) //</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 阻塞到下一个毫秒，直到获得新的时间戳</span><br><span class="line">     * @param lastTimestamp 上次生成ID的时间截</span><br><span class="line">     * @return 当前时间戳</span><br><span class="line">     */</span><br><span class="line">    private long tilNextMillis(long lastTimestamp) &#123;</span><br><span class="line">        long timestamp = timeGen();</span><br><span class="line">        while (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        return timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回以毫秒为单位的当前时间</span><br><span class="line">     * @return 当前时间(毫秒)</span><br><span class="line">     */</span><br><span class="line">    private long timeGen() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Serializable generate(SharedSessionContractImplementor s, Object obj) &#123;</span><br><span class="line">        return nextId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p style="text-align: center"><strong>END</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>classloader</title>
    <url>/2021/09/03/Java/classloader/</url>
    <content><![CDATA[<ol>
<li><p>classloader<br> 将class文件加载到jvm虚拟机中，使得程序可以运行。<br> jvm启动时，并不会一次性加载所有class文件，而是根据需要动态加载。 ？？？</p>
</li>
<li><p>系统类加载器</p>
<ol>
<li>Bootstrap ClassLoader  加载环境变量[sun.boot.class.path]目录下jar和class。</li>
<li>Extention ClassLoader  加载环境变量[java.ext.dirs]目录下jar和class。</li>
<li>AppClass Loader 加载环境变量[java.class.path]目录下jar和class（项目当前路径）。</li>
<li>如需加载其它路径，或重写加载规则，需自定义classLoader。</li>
<li>每个classLoader都有一个parent，在创建时指定。AppClassLoader的parent为ExtClassLoader，自定义parent默认为AppClassLoader。</li>
<li>Context ClassLoader - Thread ClassLoader，线程默认加载器为AppClassLoader，可自行设置更改，子线程会继承父线程的ClassLoader。</li>
</ol>
</li>
<li><p>双亲委派机制<br> 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时，子加载器才会尝试自己去加载。</p>
<p> 优点：</p>
<pre><code> 安全、性能（避免重复加载，避免核心类被篡改）。
</code></pre>
<p> 缺陷：</p>
<pre><code> 基础类无法调用用户类。
 （不知道具体实现类，无法创建对象）
 （如果类A中调用了类B，那么加载B的时候，需要使用A的类加载器去加载B。
 如果A是基础类，B是用户类，那么A对应的最上层类加载器，是没办法处理下层的用户类的。）
 
</code></pre>
<p> 解决：</p>
<pre><code> SPI + Thread ClassLoader。
 1. SPI只是一种机制/规范，具体加载部分还是使用Thread ClassLoader加载。
 2. 使用Thread ClassLoader 破坏了双亲委派机制。
</code></pre>
</li>
<li><p>加载</p>
<ol>
<li>虚拟机启动时，加载执行的主类。</li>
<li>new、getstatic、putstatic、invokestatic字节码指定。<ol>
<li>使用new实例化对象。</li>
<li>读取/设置静态字段。</li>
<li>调用静态方法。</li>
</ol>
</li>
<li>使用反射调用。</li>
<li>加载子类时，父类未被加载，优先加载父类。</li>
</ol>
<p> 不会加载</p>
<pre><code> 1. 常量在编译阶段会存入调用类的常量池中，使用常量不会加载。
 2. 创建数组不会加载。
 3. 通过子类引用父类静态属性/方法，只会加载父类。
</code></pre>
</li>
<li><p>Launcher<br> Launcher是jvm的启动类。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>io</title>
    <url>/2020/09/17/Java/io/</url>
    <content><![CDATA[<h2 id="按流向"><a href="#按流向" class="headerlink" title="按流向"></a>按流向</h2><h4 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h4><p>以自己为参照，从外面读取为输入。</p>
<h4 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h4><p>以自己为参照，向外面写为输出。</p>
<h2 id="按最小数据单元"><a href="#按最小数据单元" class="headerlink" title="按最小数据单元"></a>按最小数据单元</h2><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>以8位（8bit即1byte）作为一个数据单元。</p>
<h5 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h5><p>以16位（16bit即2byte）作为一个数据单元。<br>Java中的字符是Unicode编码，一个字符占用两个字节。</p>
<h2 id="按功能"><a href="#按功能" class="headerlink" title="按功能"></a>按功能</h2><h4 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h4><p>可以</p>
<ul>
<li>文件流</li>
<li>数组流</li>
<li>字符串流</li>
<li>管道流<h4 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h4>对一个已存在的流的连接和封装，通过对数据的处理为程序提供更为强大的读写功能。</li>
<li>缓冲流</li>
<li>转换流： 字节转字符，流中数据上全是字节。</li>
<li>数据流</li>
</ul>
<ul>
<li>getResourceAsStream<ol>
<li>Class.getResourceAsStream(String)<ul>
<li>相对路径：当前类路径下</li>
<li>绝对路径：classpath路径下</li>
</ul>
</li>
<li>Class.getClassLoader.getResourceAsStream(String)<br>相对路径，不能是绝对路径</li>
<li>ServletContext.getResourceAsStream(String)<br>resource目录下，相对/绝对都一样</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>lamada</title>
    <url>/2020/02/05/Java/lamada/</url>
    <content><![CDATA[<p>lamada 本质上可以理解为匿名内部类，在编译时传入的是实现了方法接口的匿名内部类。</p>
<p>lamada VS 匿名内部类</p>
<ol>
<li>匿名内部类编译后会出现 类名$1.class 的字节码，lamada没有。</li>
<li>通过反编译（javap），lamada在类中创建了一个 lamada$所在方法名$1 的static方法。</li>
<li>匿名内部类通过构造函数传入了一个原类的final实例。</li>
</ol>
<p>==？？？lamada是怎么访问方法局部变量的？？？==</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h4 id="java8-内置核心函数式接口"><a href="#java8-内置核心函数式接口" class="headerlink" title="java8 内置核心函数式接口"></a>java8 内置核心函数式接口</h4><ol>
<li>Consumer<T> 消费型<br> void accept(T t);</li>
<li>Supplier<T> 提供型<br> T get();</li>
<li>Function&lt;T, R&gt; 函数型<br> R apply(T t);</li>
<li>Predicate<T> 断定型<br> boolean test(T t);<h4 id="java8-其它函数式接口"><a href="#java8-其它函数式接口" class="headerlink" title="java8 其它函数式接口"></a>java8 其它函数式接口</h4></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>validate</title>
    <url>/2020/07/14/Java/validate/</url>
    <content><![CDATA[<h2 id="JSR303-JSR-349"><a href="#JSR303-JSR-349" class="headerlink" title="JSR303, JSR-349"></a>JSR303, JSR-349</h2><p>JSR303是一项标准,JSR-349是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，他们位于javax.validation.constraints包下，只提供规范不提供实现。</p>
<p>@Null 被注释的元素必须为null<br>@NotNull 被注释的元素必须不为null<br>@AssertTrue 被注释的元素必须为true<br>@AssertFalse 被注释的元素必须为false<br>@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>@Size(max, min) 被注释的元素的大小必须在指定的范围内<br>@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内<br>@Past 被注释的元素必须是一个过去的日期<br>@Future 被注释的元素必须是一个将来的日期<br>@Pattern(value) 被注释的元素必须符合指定的正则表达式</p>
<h2 id="hibernate-validation"><a href="#hibernate-validation" class="headerlink" title="hibernate validation"></a>hibernate validation</h2><p>hibernate validation是对这个规范的实践（不要将hibernate和数据库orm框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，他们位于org.hibernate.validator.constraints包下。<br>@Email 被注释的元素必须是电子邮箱地址<br>@Length 被注释的字符串的大小必须在指定的范围内<br>@NotEmpty 被注释的字符串的必须非空<br>@Range 被注释的元素必须在合适的范围内</p>
<h2 id="spring-validation"><a href="#spring-validation" class="headerlink" title="spring validation"></a>spring validation</h2><p>spring validation对hibernate validation进行了二次封装，在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中</p>
<ul>
<li>注意，必须相邻，如果有多个参数需要校验，形式可以如下。valid(@Validated Person person, BindingResult fooBindingResult ，@Validated Bar bar, BindingResult barBindingResult);即一个校验类对应一个校验结果。</li>
<li>校验结果会被自动填充</li>
<li>不加BindingResult ，会抛出BindException</li>
</ul>
<ol>
<li><p>@Validate 和 @Valid 的区别<br>而<br>而万能的spring为了给开发者提供便捷，对hibernate validation进行了二次封装，显示校验validated bean时，你可以使用spring validation或者hibernate validation，而spring validation另一个特性，便是其在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中。这无疑便捷了我们的web开发。<br>@Validate 支持分组验证，@Valid 支持嵌套验证</p>
</li>
<li><p>@Validate 用在方法入参和类上面的区别（能否用在方法上）</p>
</li>
<li><p>spring controller 验证</p>
</li>
<li><p>方法参数验证</p>
</li>
<li><p>自定义校验注解</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2021/09/03/Java/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><pre><code>参数化类型，将类型由原来的具体类型参数化，然后在使用/调用的时候传入具体的类型。
参数化： 在不创建新的类型的情况下， 通过泛型指定的不同类型来控制形参具体限制的类型。
</code></pre>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre><code>    泛型类型用于类的定义中，被成为泛型类。
    在实例化类的时候指明泛型的具体类型，或子类实现/继承时指定类型。
</code></pre>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><pre><code>    在调用方法的时候指明泛型的具体类型。
    静态方法无法访问类定义上的泛型。
</code></pre>
<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><pre><code>    ？
</code></pre>
<h3 id="泛型边界"><a href="#泛型边界" class="headerlink" title="泛型边界"></a>泛型边界</h3><pre><code>    上界 extends
    下界 super
</code></pre>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><pre><code>避免过多的创建类而造成的运行时的过度消耗。
泛型的约束在编译期生效，在运行期无效，可以在运行期忽略泛型。
</code></pre>
<h2 id="获取具体类型"><a href="#获取具体类型" class="headerlink" title="获取具体类型"></a>获取具体类型</h2><h3 id="获取父类具体类型"><a href="#获取父类具体类型" class="headerlink" title="获取父类具体类型"></a>获取父类具体类型</h3><pre><code>    eg: public class TestA extends ParentA&lt;String&gt; &#123;&#125;

    ParameterizedType type = (ParameterizedType)子类对象.getClass().getGenericSuperClass();
    type.getActualTypArguments();
</code></pre>
<h3 id="获取接口具体类型"><a href="#获取接口具体类型" class="headerlink" title="获取接口具体类型"></a>获取接口具体类型</h3><pre><code>    eg：public class TestB&lt;T&gt; implements InterfaceA&lt;T&gt; &#123;&#125;

    ParameterizedType[] types = (ParameterizedType)子类对象.getClass().getGenericInterfaces();
    ...
</code></pre>
<h3 id="获取泛型方法返回值类型"><a href="#获取泛型方法返回值类型" class="headerlink" title="获取泛型方法返回值类型"></a>获取泛型方法返回值类型</h3><pre><code>    ParameterizedType type = getMethod(&quot;...&quot;).getGenericReturnType();
    type.getActualTypArguments();
</code></pre>
<h3 id="获取泛型方法参数具体理性"><a href="#获取泛型方法参数具体理性" class="headerlink" title="获取泛型方法参数具体理性"></a>获取泛型方法参数具体理性</h3><pre><code>    Type[] genericParameterTypes=method.getGenericParameterTypes();
    ...
</code></pre>
<h3 id="通过泛型成员获取具体类型"><a href="#通过泛型成员获取具体类型" class="headerlink" title="通过泛型成员获取具体类型"></a>通过泛型成员获取具体类型</h3><pre><code>    eg: List&lt;String&gt; list;
    
    ParameterizedType type = (ParameterizedType) field.getGenericType();
    type.getActualTypArguments();
</code></pre>
<h3 id="类定义时没有指定泛型类型，而在使用时指定泛型类型，这种情况无法获取具体类型信息，这时getClass-获取的是类模板上的信息。"><a href="#类定义时没有指定泛型类型，而在使用时指定泛型类型，这种情况无法获取具体类型信息，这时getClass-获取的是类模板上的信息。" class="headerlink" title="类定义时没有指定泛型类型，而在使用时指定泛型类型，这种情况无法获取具体类型信息，这时getClass()获取的是类模板上的信息。"></a>类定义时没有指定泛型类型，而在使用时指定泛型类型，这种情况无法获取具体类型信息，这时getClass()获取的是类模板上的信息。</h3><pre><code>比如 List&lt;String&gt; list = new ArrayList&lt;&gt;(); 无法获取list的具体类型信息。
</code></pre>
<h2 id="Type-接口"><a href="#Type-接口" class="headerlink" title="Type 接口"></a>Type 接口</h2><pre><code>GenericArrayType, ParameterizedType, WildcardTYpe, TypeVariable， Class
</code></pre>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><pre><code>只有使用泛型通配符，在使用过程中，或定义泛型方法参数时才能使用super关键字。
</code></pre>
<h3 id="泛型推导"><a href="#泛型推导" class="headerlink" title="泛型推导"></a>泛型推导</h3><pre><code>https://www.cnblogs.com/heimianshusheng/p/5766573.html
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS8</title>
    <url>/2020/02/05/Linux/CentOS8/</url>
    <content><![CDATA[<blockquote>
<p>最近centos 8发布，而且之前系统安装软件、文件路径都不太符合现在所理解的一些规范，所以准备重新安装系统。</p>
</blockquote>
<h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><h3 id="机器配置"><a href="#机器配置" class="headerlink" title="机器配置"></a>机器配置</h3><ul>
<li>型号： HP200 Pro G1 MT（(J1800)）</li>
<li>处理器： Intel Celeron J1800(2.41GHz/L3 1M)，双核双线程</li>
<li>内存： 4G DDR3 1600</li>
<li>硬盘： 500G机械硬盘</li>
</ul>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol>
<li>阿里云下载centos8 iso镜像，制作U盘启动。</li>
<li>开机时不插键盘，出现键盘找不到时，插入usb键盘，按esc，设置引导。</li>
<li>选择最小安装，设置磁盘分区，开启网络配置，开始安装。</li>
</ol>
<h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><table>
<thead>
<tr>
<th>路径</th>
<th>格式</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>/boot</td>
<td>-</td>
<td>512MB</td>
</tr>
<tr>
<td>/boot/efi</td>
<td>-</td>
<td>256MB</td>
</tr>
<tr>
<td>swap</td>
<td>-</td>
<td>8GB</td>
</tr>
<tr>
<td>/home</td>
<td>-</td>
<td>150GB</td>
</tr>
<tr>
<td>/var</td>
<td>-</td>
<td>50GB</td>
</tr>
<tr>
<td>/</td>
<td>-</td>
<td>260GB左右(剩余全部)</td>
</tr>
</tbody></table>
<h3 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>主板键盘为ps/2接口，只能通过ps/2接口进入BIOS设置（ps/2转usb转换头也不行）。<blockquote>
<p>开机时不插键盘，出现键盘找不到时，插入usb键盘，按esc。</p>
</blockquote>
</li>
<li>镜像开机时选择install选项后不出现安装界面。<blockquote>
<p>选择install选项，按e键进入编辑页面，将label设置为/dev/sdb4，按ctrl+X执行安装。<br>PS1: 可以先修改为linux dd查看设备，确定之后在修改。<br>PS2：在引导系统中，按Ctrl + Shift + Delete 组合键重启。</p>
</blockquote>
</li>
<li>使用DVD镜像安装时，提示 Pane is DEAD，而使用虚拟机安装是没有问题的。<blockquote>
<p>使用网络版镜像安装，在设置安装源时，先联网，然后选择从网络安装，设置镜像仓库地址。<br>PS：网络版镜像应该不是官网的，而是阿里云提供的。</p>
</blockquote>
</li>
</ul>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>/usr/lcoal 安装系统软件<br>/opt 安装临时软件，存储安装包（压缩包安装方式）<br>/var 放日志文件</p>
<h3 id="开放端口及服务"><a href="#开放端口及服务" class="headerlink" title="开放端口及服务"></a>开放端口及服务</h3><ul>
<li>查看指定区域(public)所有开启的端口号/服务<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports / --list-service</span><br></pre></td></tr></table></figure></li>
<li>开放端口/服务（防火墙重启生效）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp / --add-service=http --permanent</span><br></pre></td></tr></table></figure></li>
<li>查看所有服务<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><ul>
<li>查看自带的，yum search docker 发现自带的不是我们想要的。</li>
<li>下载docker-ce repo<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li>安装containerd.io依赖<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm</span><br></pre></td></tr></table></figure></li>
<li>安装docker<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure></li>
<li>设置开机启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><ul>
<li>安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure></li>
<li>设置开机启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure></li>
<li>nginx配置文件路径：/etc/nginx/nginx.conf</li>
<li>nginx日志文件路径：/var/nginx</li>
</ul>
<p>  ngigx路径/结尾</p>
<ul>
<li>在某些情况下，Nginx内部重定向规则会被启动，例如，当 URL 指向一个目录并且在最后没有包含“/”时，Nginx 内部会自动的做一个 301 重定向</li>
<li>location<ul>
<li>以/结尾：url与location路径完全匹配</li>
<li>不以/结尾：模糊匹配，以location路径开头。</li>
</ul>
</li>
<li>proxy_pass<ul>
<li>以/结尾：访问服务proxy + (uri - location)路径</li>
<li>ip/域名结尾：访问服务proxy + url路径</li>
<li>其它：访问服务proxy + (uri - location)路径 (字符串拼接，没有/)</li>
</ul>
</li>
<li>root<ul>
<li>一致</li>
</ul>
</li>
</ul>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><blockquote>
<p>通过docker安装mysql服务，简单，省事。<br>但是docker容器具有临时性，而mysql的数据要持久化，所以通过docker启动MySQL，然后通过挂载卷的方式保存数据，是否是个好的选择呢？</p>
</blockquote>
<ul>
<li>拉取镜像<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:8</span><br></pre></td></tr></table></figure></li>
<li>启动容器<br>  将容器设置为自动重启，这样服务器开机或docker服务重启时会自动启动容器。<br>  使用 -e 选项为mysql设置root账号密码。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root --restart=always --name mysql mysql:8</span><br></pre></td></tr></table></figure>
<ul>
<li>进入容器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h3><blockquote>
<p>使用docker安装jenkins，方便，省事。</p>
</blockquote>
<ul>
<li>拉取镜像<br>  使用latest版本<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jenkinsci/blueocean</span><br></pre></td></tr></table></figure></li>
<li>启动容器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -u root -d -p 8080:8080 -v /var/jenkins_data:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock --restart=always --name jenkins jenkinsci/blueocean</span><br></pre></td></tr></table></figure></li>
<li>获取admin默认密码</li>
<li>自定义安装插件</li>
<li>创建管理员用户密码</li>
</ul>
<h4 id="填坑-1"><a href="#填坑-1" class="headerlink" title="填坑"></a>填坑</h4><ol>
<li>启动jenkins容器，配置nginx代理，静态资源访问不到</li>
<li>开启防火墙，启动jenkins容器，开放8080端口，内网访问不到</li>
<li>在2的前提下，关闭防火墙，内网可以访问，但是jenkins提示离线</li>
<li>开机启动docker，firewalld，然后关闭防火墙，启动容器，启动不起来，提示： docker: Error response from daemon: driver failed programming external connectivity on endpoint jenkins (0a8069842c234eaae6d36192f62b5d9503926c0167cae15711300168103c5b1e):  (iptables failed: iptables –wait -t nat -A DOCKER -p tcp -d 0/0 –dport 8080 -j DNAT –to-destination 172.17.0.2:8080 ! -i docker0: iptables: No chain/target/match by that name.</li>
<li>最终解决办法：开机启动docker，firewallld, 然后关闭防火墙，docker服务重启，然后启动容器，ok！（问题，怎么能不关闭防火墙）<br>PS: 每次防火墙重启时都需要重启docker服务。</li>
</ol>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><blockquote>
<p>github国内访问有点慢，有时候提交需要等好一会儿，而且自己的那点代码，感觉放在开源网站有点low，所以决定在自己服务器安装一个git服务器，等项目做的有点水平了，在放到github上去。</p>
</blockquote>
<h4 id="ssh版本"><a href="#ssh版本" class="headerlink" title="ssh版本"></a>ssh版本</h4><blockquote>
<p>Protocol 2</p>
</blockquote>
<h4 id="git协议选择"><a href="#git协议选择" class="headerlink" title="git协议选择"></a>git协议选择</h4><blockquote>
<p>通过查看git官网文档，git有四种可选择的协议来传输资料，分别是local，git，ssh，http。<br>其中local是本地协议，不能通过网络访问，git协议缺乏授权机制。<br>http协议安装比较复杂，等后期对相关知识更加了解在做。<br>暂时选择git协议，使用密钥的方式进行授权，添加访问用户时需要添加公钥到服务器。</p>
</blockquote>
<h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><ol>
<li>安装git软件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure></li>
<li>创建git用户<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adduser git (不用设置密码)</span><br></pre></td></tr></table></figure></li>
<li>在git根目录下创建.ssh文件夹</li>
<li>在git/.ssh目录下创建 authorized_keys 文件，用来存放用户公钥。</li>
<li>设置git目录所属用户为git，.ssh目录权限为700，authorized_keys 文件权限为600。</li>
<li>限制git账号使用ssh连接。<br>git-shell: 登录成功后自动退出的shell<br>查看git-shell命令路径： where is git-shell<br>修改/etc/passwd中 git账号登录后的shell为git-shell全路径</li>
<li>打开RSA认证。<br>修改配置文件/etc/ssh/sshd_config 中 设置<br>RSAAuthentication yes(centos 7.4 已弃用，忽略不设置)<br>PubkeyAuthentication yes<br>AuthorizedKeysFile .ssh/authorized_keys<h4 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h4><blockquote>
<p>在git目录下新建.git结尾文件夹，进入文件夹，创建一个裸仓库。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init --bare</span><br></pre></td></tr></table></figure>
<h4 id="填坑-2"><a href="#填坑-2" class="headerlink" title="填坑"></a>填坑</h4></li>
</ol>
<ul>
<li>git用户密码<blockquote>
<p>git用户不必设置密码，没有必要。</p>
</blockquote>
</li>
<li>权限问题<blockquote>
<p>git用户根目录下的所有文件及目录都应该属于git用户，每次创建完git仓库时也要修改目录所属用户，否则会提示 无权限访问。</p>
</blockquote>
</li>
<li>公钥<blockquote>
<p>使用 &gt;&gt; 操作可以将公钥追加到文件里面。<br>使用 &gt; 操作会清空文件的内容，并把新内容添加到文件里面。</p>
</blockquote>
</li>
<li>git clone<blockquote>
<p>在使用 TortoistGit 进行git clone 的时候，需要勾选 Load Putty Key 选项，并选择私钥。<br>在使用 git bash clone的时候需要保证当前用户目录.ssh文件夹下面存在私钥。</p>
</blockquote>
</li>
<li>RSA<blockquote>
<p>RSAAuthentication 是对ssh 1版本的支持，在本环境中，使用ssh 2，所以没有这个配置，忽略即可。<br>如果自己手动加上了这个配置，在查看日志文件时会有警告。</p>
</blockquote>
</li>
<li>bare<blockquote>
<p>裸仓库即不包含工作目录的仓库。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2021/11/28/Linux/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>/bin 系统普通用户命令</li>
<li>/sbin root命令</li>
<li>/usr/bin 系统普通用户命令</li>
<li>/usr/sbin root命令</li>
<li>/etc 系统默认配置目录</li>
<li>/root </li>
<li>/home </li>
<li>/lib 函数库</li>
<li>/media 光盘</li>
<li>/mnt U盘、硬盘</li>
<li>/misc 磁带</li>
<li>/proc 内存的过载点</li>
<li>/sys 内存的过载点</li>
<li>/temp 临时目录</li>
<li>/usr 系统资源</li>
<li>/var 系统可变文档</li>
<li>/boot 启动目录</li>
</ul>
<h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><ul>
<li>0 关机</li>
<li>1 单用户模式</li>
<li>2 不完全的命令行</li>
<li>3 完全的命令行</li>
<li>4 系统保留</li>
<li>5 图形界面</li>
<li>6 重启</li>
</ul>
<p>查看： run level<br>修改： init x<br>修改开始时级别： /etc/inittab</p>
<h2 id="用户、用户组"><a href="#用户、用户组" class="headerlink" title="用户、用户组"></a>用户、用户组</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>/etc/group 存储当前系统中所有用户组信息 （组名称:组密码占位符:组编号:组中用户名列表）</li>
<li>/etc/gshadow 存储当前系统中用户组的密码信息 （组名称:组密码:组管理者:组中用户列表）</li>
<li>/etc/passwd 存储用户组中用户信息 （用户名:密码占位符:用户编号:用户组编号:用户注释信息:用户主目录:shell类型）</li>
<li>/etc/shadow 存储用户密码信息 （用户:密码:……）</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>添加用户组： groupadd 组名</li>
<li>修改用户组名称： groupmod -n 新组名 旧组名</li>
<li>修改用户组编号： groupmod -g 编号 组名</li>
<li>删除用户组：groupdel 组名</li>
<li>添加用户： useradd 用户名</li>
<li>修改用户： usermod -l 旧名 新名</li>
<li>删除用户： userdel 用户名</li>
<li>锁定： passwd 用户名 -l</li>
<li>解锁： passwd 用户名 -u</li>
<li>清除命令： passwd 用户名 -d</li>
</ul>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [选项] 模式 文件名</span><br><span class="line">chown [组名:]用户名 文件名</span><br><span class="line">chgrp 组名 文件名</span><br></pre></td></tr></table></figure>
<p>-R 递归</p>
<h2 id="压缩-解压缩"><a href="#压缩-解压缩" class="headerlink" title="压缩/解压缩"></a>压缩/解压缩</h2><p>压缩文件格式： .zip、.gz、.bz2、.tar.gz、.tar.gz2</p>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><ul>
<li>-c 打包、-x 解压、 -t 查看</li>
<li>-v 显示过程</li>
<li>-f 指定打包后的文件名</li>
<li>-z .tar.gz格式 -j .tar.bz2格式</li>
</ul>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><ul>
<li>压缩文件 zip *.zip *</li>
<li>压缩目录 zip -r *.zip 目录</li>
<li>解压缩 unzip 压缩文件</li>
</ul>
<h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><ul>
<li>压缩文件 gzip 源文件 （源文件消失）</li>
<li>压缩目录 gzip  -r 目录</li>
<li>解压 gunzip 压缩文件</li>
<li>解压 gzip -d 压缩文件</li>
</ul>
<h3 id="bzip"><a href="#bzip" class="headerlink" title="bzip"></a>bzip</h3><ul>
<li>压缩文件 bzip2 源文件</li>
<li>不能压缩目录</li>
<li>解压 bzip2 -d 压缩文件</li>
<li>解压 bunzip2 压缩文件</li>
</ul>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul>
<li>查看级别 map -f 命令  -&gt;  whatis 命令</li>
<li>查找  map -k 命令  -&gt;  apropos 命令</li>
</ul>
<h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><h2 id="ssh操作"><a href="#ssh操作" class="headerlink" title="ssh操作"></a>ssh操作</h2><ul>
<li>ctrl + L  清屏</li>
<li>ctrl + c  强制退出</li>
<li>ctrl + u  删除至行首</li>
<li>ctrl + a  Home</li>
<li>ctrl + e  End</li>
<li>ctrl + r  在历史命令搜索</li>
<li>ctrl + z  放入后台</li>
</ul>
<h2 id="VI操作模式"><a href="#VI操作模式" class="headerlink" title="VI操作模式"></a>VI操作模式</h2><p>virsual interface<br>命令模式、输入模式、底行模式</p>
<ul>
<li>:w 保存</li>
<li>:q 退出</li>
<li>:! 强制执行</li>
<li>:ls 列出当前打开文件</li>
<li>:n 切换到下一个打开的文件</li>
<li>:N 切换到上一个打开的文件</li>
<li>:15 定位到15行</li>
<li>/xxx 向后搜索</li>
<li>?xxx 向前搜索</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>命令格式： 命令 [选项] [参数]</p>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>print working directory</p>
<ul>
<li>~ 当前用户家目录</li>
<li><h1 id="管理员用户"><a href="#管理员用户" class="headerlink" title="管理员用户"></a>管理员用户</h1></li>
<li>$ 普通用户</li>
</ul>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ul>
<li>-a all</li>
<li>-l long 文件类型（-、d、l、…）</li>
<li>-d 目录属性</li>
<li>-h human 人性化显示</li>
<li>-i inode i结点</li>
</ul>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [原文件/目录] [目标文件/目录]</span><br></pre></td></tr></table></figure>

<h3 id="创建目录-mkdir"><a href="#创建目录-mkdir" class="headerlink" title="创建目录 mkdir"></a>创建目录 mkdir</h3><ul>
<li>-p 递归创建</li>
</ul>
<h3 id="删除-rm"><a href="#删除-rm" class="headerlink" title="删除 rm"></a>删除 rm</h3><ul>
<li>-f force 强制</li>
<li>-r 删除目录</li>
</ul>
<h3 id="复制-cp"><a href="#复制-cp" class="headerlink" title="复制 cp"></a>复制 cp</h3><ul>
<li>-r 目录</li>
<li>-p 连带文件属性复制</li>
<li>-d 若源文件是链接文件，则复制链接属性</li>
</ul>
<h3 id="链接-ln"><a href="#链接-ln" class="headerlink" title="链接 ln"></a>链接 ln</h3><p>ln [原文件] [目标文件]<br>-s 软链接</p>
<h3 id="文件搜索-locate"><a href="#文件搜索-locate" class="headerlink" title="文件搜索 locate"></a>文件搜索 locate</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate 文件名</span><br></pre></td></tr></table></figure>

<h3 id="命令搜索"><a href="#命令搜索" class="headerlink" title="命令搜索"></a>命令搜索</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">where is 命令</span><br><span class="line">which 命令</span><br></pre></td></tr></table></figure>
<p>where 查看命令所在位置-b 和帮助文档-m<br>which 查看命令所在位置和别名</p>
<h3 id="字符串搜索-grep"><a href="#字符串搜索-grep" class="headerlink" title="字符串搜索 grep"></a>字符串搜索 grep</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [选项] 字符串 文件名</span><br></pre></td></tr></table></figure>
<ul>
<li>-i 忽略大小写</li>
<li>-v 取反</li>
</ul>
<h3 id="文件搜索-find"><a href="#文件搜索-find" class="headerlink" title="文件搜索 find"></a>文件搜索 find</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [搜索目录] [搜索条件（通配符）]</span><br></pre></td></tr></table></figure>
<ul>
<li>atime 文件访问时间</li>
<li>ctime 改变文件属性时间</li>
<li>mtime 改变内容时间</li>
<li>-10 10天内修改</li>
<li>+10 10天前修改</li>
<li>10 10天前当天修改</li>
<li>-size 25k/+25k/-25k</li>
<li>-inum</li>
<li>-a and</li>
<li>-o or</li>
</ul>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><ul>
<li>-l 本地磁盘</li>
<li>-a 所有文件系统</li>
<li>-h 1024 进制换算</li>
<li>-H 1000 进制换算</li>
<li>-T 分区类型</li>
<li>-t 显示指定类型</li>
<li>-x 不显示指定类型</li>
</ul>
<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount ntfs-3g 目录 目录</span><br><span class="line">umount 目录</span><br></pre></td></tr></table></figure>

<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li>du 统计磁盘上的文件大小<ul>
<li>-b -k -m</li>
<li>-h -H </li>
<li>-s 指定统计目标</li>
</ul>
</li>
<li>fdish 添加MBR分区</li>
<li>parted 添加GPT/MBR分区</li>
<li>mkfs 格式化</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>WSL2</title>
    <url>/2021/06/03/Linux/WSL2/</url>
    <content><![CDATA[<h1 id="WSL2"><a href="#WSL2" class="headerlink" title="WSL2"></a>WSL2</h1><blockquote>
<p>How/Why</p>
</blockquote>
<h2 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h2><p>一、 更新windows<br>    wsl2需要： ×64架构 需要1903及更高<br>    下载windows易升，从1909版本升级到20H2。</p>
<p>二、 启用windows功能<br>    适用于Linux的Windows子系统<br>    虚拟机平台  wsl2需要</p>
<p>三、 登录microsoft账号，加入windows预览体验计划    只是简化安装需要<br>    下载ubuntu，windows terminal</p>
<p>四、 wsl2<br>    下载linux内核更新包并运行<br>    设置默认版本为2</p>
<h2 id="安装centos"><a href="#安装centos" class="headerlink" title="安装centos"></a>安装centos</h2><ol>
<li>下载镜像 <a href="https://github.com/CentOS/sig-cloud-instance-images/tree/CentOS-8-x86_64">https://github.com/CentOS/sig-cloud-instance-images/tree/CentOS-8-x86_64</a></li>
<li>windows安装Chocolatey</li>
<li>通过Chocolatey安装LxRunOffline</li>
<li>通过LxRunOffline安装centos<br> LxRunOffline.exe  install -n centos -d E:\WSL\CentOS -f  E:\WSL\centos-8-x86_64.tar.xz<pre><code> -n 名称
 -d 安装路径
 -f 文件路径
</code></pre>
 启动： LxRunOffline run -n centos</li>
<li>安装VcXsrc<br> 需要VcXsrc来显示</li>
<li>安装图形界面<br> yum install -y epel-release<br> yum groupinstall -y “Xfce”<br> 重启<br> export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk ‘{print $2; exit;}’):0.0<br> startxfce4 export DISPLAY=172.20.128.1:0.0</li>
</ol>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>LxRunOffline.exe  install -n c8 -d D:\WSL2\WSL_C8 -f  E:\down\centos-8-x86_64.tar.xz</li>
<li>yum install net-tools -y</li>
<li>yum -y install xorg-x11-xauth</li>
<li>yum -y install firefox ( libXcomposite libXcursor libXft libXi libXinerama libXrandr libXrender libXtst libXpm )</li>
<li>yum -y install mesa-libGL</li>
</ol>
<p>yum -y install which</p>
<p>bat启动文件<br>.\config.xlaunch<br>start /min wsl -d c8 idea</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>安装jdk： yum install -y java-1.8.0-openjdk</li>
<li>安装mysql: yum install -y mysql-server</li>
<li>安装maven：下载、解压、设置环境变量</li>
<li>安装node：yum install -y nodejs</li>
<li>安装git：yum install -y git</li>
<li>安装svn：</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux软件安装</title>
    <url>/2021/11/28/Linux/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="源码包安装"><a href="#源码包安装" class="headerlink" title="源码包安装"></a>源码包安装</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>C语言编译器gcc</li>
<li>源码包 *.tar.gz</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>解压缩</li>
<li>进入解压缩目录</li>
<li>./config 软件配置与检查</li>
<li>make / make clean 编译</li>
<li>make install 编译安装</li>
<li>启动</li>
</ol>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>直接删除安装目录即可。</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><ul>
<li>源码保存位置 /usr/local/src/</li>
<li>安装位置 /usr/local</li>
</ul>
<h2 id="RPM安装"><a href="#RPM安装" class="headerlink" title="RPM安装"></a>RPM安装</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>软件包名-版本-发布次数.适合平台.适合硬件平台.rpm</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>树依赖、环形依赖、库文件依赖/模块依赖</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>rpm -ivh 包全名<br>-i install 安装<br>-e erase 卸载<br>-v verbose 显示详细信息<br>-h hase 显示进度</p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>rpm -uvh 包全名<br>-u upgrade 升级</p>
<h3 id="卸载-1"><a href="#卸载-1" class="headerlink" title="卸载"></a>卸载</h3><p>rpm -e 包名<br>-e erase 卸载</p>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>rpm -v 包名<br>-v validate 校验</p>
<h3 id="查询命令"><a href="#查询命令" class="headerlink" title="查询命令"></a>查询命令</h3><ul>
<li>-q query</li>
<li>-a all</li>
<li>-i information</li>
<li>-p package</li>
<li>-l list</li>
<li>-f file</li>
</ul>
<h3 id="默认安装路径"><a href="#默认安装路径" class="headerlink" title="默认安装路径"></a>默认安装路径</h3><p>rpm包安装位置由rpm包确定，可以指定perfix，但不建议。<br>/etc/ 配置文件<br>/usr/share/doc/ 软件使用手册<br>/usr/bin/ 可执行命令<br>/usr/shar/man/ 帮助文件<br>/usr/lib/ 程序所使用函数库</p>
<h3 id="文件提取"><a href="#文件提取" class="headerlink" title="文件提取"></a>文件提取</h3><p>rpm2cpio 包全名 | epio -idu 文件绝对路径</p>
<h2 id="yum在线安装"><a href="#yum在线安装" class="headerlink" title="yum在线安装"></a>yum在线安装</h2><p>服务器使用最小化安装，用什么装什么，尽量不卸载。</p>
<h3 id="yum源文件"><a href="#yum源文件" class="headerlink" title="yum源文件"></a>yum源文件</h3><p>/etc/yum.repos.d/Centos-Base.repo</p>
<ul>
<li>[base]: 容器名称</li>
<li>name: 容器说明</li>
<li>mrrorlist: 镜像站点</li>
<li>baseurl: yum源服务器地址</li>
<li>enable: 是否生效，默认1，1生效，0无效</li>
<li>gpgcheck: RPM数字证书，1生效，0无效</li>
<li>gpgkey: 数字证书公钥文件保存位置</li>
</ul>
<h3 id="配置光盘yum源"><a href="#配置光盘yum源" class="headerlink" title="配置光盘yum源"></a>配置光盘yum源</h3><ol>
<li>挂载光盘</li>
<li>使默认失效，修改名字</li>
<li>修改光盘配置yum源</li>
</ol>
<h3 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h3><ul>
<li>yum list</li>
<li>yum search 关键字</li>
<li>yum -y install 包名</li>
<li>yum -y update 包名</li>
<li>yum -y remove 包名</li>
<li>yum grouplist</li>
<li>yum groupinstall 软件组名</li>
<li>yum groupremove 软件组名</li>
</ul>
<h2 id="脚本安装"><a href="#脚本安装" class="headerlink" title="脚本安装"></a>脚本安装</h2><p>eg nginx</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h3><ul>
<li>优点 开源，安装功能可配置，卸载方便，干净。</li>
<li>缺点 编译时间长，编译出错重复安装，安装步骤多。<h3 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h3></li>
<li>优点 安装、升级、查询、卸载简单，速度快。</li>
<li>缺点 不开源，不灵活，依赖性强。<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3></li>
<li>优点 简单、迅速、方便。</li>
<li>缺点 软件版本、功能不能自定义。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>selinux，firewalld，iptable</title>
    <url>/2020/02/05/Linux/selinux%EF%BC%8Cfirewalld%EF%BC%8Ciptable/</url>
    <content><![CDATA[<p>selinux  ( /etc/selinux/config)<br>    安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。<br>    SELinux 主要由美国国家安全局开发。2.6 及以上版本的 Linux 内核都已经集成了 SELinux 模块。<br>    SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）。</p>
<p>firewalld<br>    firewall能够允许哪些服务可用，那些端口可用…. 属于更高一层的防火墙。<br>    firewall的底层是使用iptables进行数据过滤，建立在iptables之上。<br>    firewall是动态防火墙，使用了D-BUS方式，修改配置不会破坏已有的数据链接。</p>
<p>iptables<br>    iptables用于过滤数据包，属于网络层防火墙.<br>    在设置iptables后需要重启iptables，会重新加载防火墙模块，而模块的装载将会破坏状态防火墙和确立的连接。会破坏已经对外提供数据链接的程序。可能需要重启程序。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>命令</title>
    <url>/2020/02/05/Linux/%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>x86泛指一系列基于Intel 8086且向后兼容的中央处理器指令集架构<br>x86_64 = x64</p>
<p>Nginx 13: Permission denied</p>
<ol>
<li>nginx user 设置为root</li>
<li>访问的目录/文件不存在</li>
<li>selinux 关闭</li>
</ol>
<p>查看时区 timedatectl<br>查看可设置时区 timedatectl list<br>设置时区 timedatectl set-timezone Asia/Shanghai (设置完之后硬件时间跟着变了，why？)</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2020/07/14/Maven/maven/</url>
    <content><![CDATA[<h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><ul>
<li>relativePath / pom<br>  relativePath 默认情况下，从当前pom.xml的父级目录查找， 为空值时从仓库查找<br>  pom 聚合工程，install时不会jar包，其它文件都会生成</li>
</ul>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>pom.xml</title>
    <url>/2021/06/24/Maven/pom-xml/</url>
    <content><![CDATA[<h2 id="dependencyManagemet与dependency"><a href="#dependencyManagemet与dependency" class="headerlink" title="dependencyManagemet与dependency"></a>dependencyManagemet与dependency</h2><p>dependencyManagemet 只是管理版本，并不下载依赖<br>dependency 添加依赖</p>
<h2 id="pachaging-默认jar，可选jar、pom、war"><a href="#pachaging-默认jar，可选jar、pom、war" class="headerlink" title="pachaging 默认jar，可选jar、pom、war"></a>pachaging 默认jar，可选jar、pom、war</h2><ul>
<li>jar 调用或者作为服务</li>
<li>pom 一般为父子继承使用</li>
<li>war web项目</li>
</ul>
<h2 id="spring-boot-parent-与-spring-boot-dependency"><a href="#spring-boot-parent-与-spring-boot-dependency" class="headerlink" title="spring-boot-parent 与 spring-boot-dependency"></a>spring-boot-parent 与 spring-boot-dependency</h2><ul>
<li>风格不同，功能一样</li>
<li>如果有自己的parent，则无法使用spring-boot-parent，只能使用spring-boot-dependency方式</li>
<li>使用spring-boot-parent需要配置 <relativePath/></li>
<li>使用spirng-boot-dependency 需要配置 scope=import、type=pom</li>
</ul>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis 源码</title>
    <url>/2021/06/24/Mybatis/Mybatis-%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>动态代理 Mapper、Inteceptor<br>装饰器 Executor<br>建造者 Environment.Builder</p>
<pre><code>动态代理 - 接口、类加载器
ognl表达式
mapper 实例化、单例 
Log
TypeDiscriminator
@Select &lt;script&gt; 与不加
</code></pre>
<ol>
<li>属性替换： 每次加载节点，转换为XNode数据时，在XNode构造方法中实现 ${} 属性替换。 即 XNode.evalNode(“”)时。</li>
<li>setting赋值顺寻：</li>
<li>TypeHandler中存储数据：保存在typeHandlerMap中。保存的是实例。如果javaType为null（实现TypeHandler接口 &amp;&amp; 不适用注解  或者手动注册null），则忽略。</li>
<li>TypeHandler配置优先级： xml配置 &gt; 注解 &gt; 泛型（继承BaseHandler），手动使用TypeReference也会检查注解。</li>
<li>cache、cache-ref 只能存在一个且只能配置一份。 ？？？</li>
<li>如果指定了databaseId，则每个sql、statement标签都需要指定databaseId。 ？？？</li>
<li>SelectKey</li>
<li>mapUnderscoreToCamelCase 默认false, 要真正存在一个与它对应的驼峰Bean才生效</li>
</ol>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><ul>
<li><p>org.apache.ibatis.session</p>
</li>
<li><p>typeHandlerRegistry</p>
</li>
<li><p>typeAliasRegistry</p>
</li>
<li><p>interceptorChain</p>
</li>
<li><p>mapperRegister</p>
</li>
<li><p>ScriptMap sqlFragments  解析sql标签的语句</p>
</li>
<li><p>loadedResources<br>  key：     通过mapper标签指定url： url</p>
<pre><code>      通过mapper标签指定resource： resource
      通过mapper解析namespace: `namespace:` + namespace
      通过java类解析：`interface ` + className
      通过java类解析相同名称及路径的xml：`namespace:` + className
</code></pre>
</li>
<li><p>addMapper() / addMappers() -&gt; mapperRegister.addMapper()/addMappers()</p>
</li>
</ul>
<h3 id="BaseBuilder"><a href="#BaseBuilder" class="headerlink" title="BaseBuilder"></a>BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder</li>
<li>Configuration</li>
<li>typeAliasRegistry</li>
<li>typeHandlerRegistry</li>
</ul>
<h3 id="XMLConfigBuilder-extends-BaseBuilder"><a href="#XMLConfigBuilder-extends-BaseBuilder" class="headerlink" title="XMLConfigBuilder extends BaseBuilder"></a>XMLConfigBuilder extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>XPathPaser</li>
<li>environment</li>
<li>parse()</li>
</ul>
<h3 id="XPathPaser"><a href="#XPathPaser" class="headerlink" title="XPathPaser"></a>XPathPaser</h3><ul>
<li>org.apache.ibatis.parsing</li>
<li>Properties variables</li>
</ul>
<h3 id="ResolverUtil"><a href="#ResolverUtil" class="headerlink" title="ResolverUtil"></a>ResolverUtil<T></h3><ul>
<li><p>org.apache.ibatis.io</p>
</li>
<li><p>定义接口及实现类，进行条件匹配。</p>
</li>
<li><p>定义classloader、matches</p>
</li>
<li><p>根据接口查询、根据注解查询、根据条件查询</p>
</li>
<li><p>解析类有多步操作，用一个属性存储之前的结果，所有操作结束后调用方法返回所有结果。</p>
</li>
<li><p>接口参数后期才能确定，直接把接口作为参数。</p>
</li>
</ul>
<h3 id="TypeAliasRegistry"><a href="#TypeAliasRegistry" class="headerlink" title="TypeAliasRegistry"></a>TypeAliasRegistry</h3><ul>
<li>org.apache.ibatis.type</li>
<li>注册别名，不是匿名类、不是接口、不是成员类</li>
<li>获取注解指定别名</li>
<li>别名转小写</li>
<li>解析别名，不存在根据字符串解析，但不存储。</li>
<li>对基础类型及常用类型的保存。</li>
<li>直接根据类注册，跳过的类类型的判断。</li>
<li>根据别名、字符串注册与其它方式注册 加载类方式不一样，一种是直接通过classloader 加载，另一种通过resource加载。</li>
</ul>
<h3 id="TypeHandlerRegistry"><a href="#TypeHandlerRegistry" class="headerlink" title="TypeHandlerRegistry"></a>TypeHandlerRegistry</h3><ul>
<li>org.apache.ibatis.type</li>
<li>register  Map&lt;Type, Map&lt;JdbcType, TypeHandler<?>>> typeHandlerMap、 Map<Class<?>, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap：<br>  第一步：<pre><code>  1. 查找MappedTypes注解，注册其每一个value。
  2. 判断是否实现TypeReference，若是，注册。
  3. 注册javaType为null。
</code></pre>
  第二步： <pre><code>  1. 查找MappedJdbcTypes注册，注册其每一个value，并判断是否也需要注册jdbcType为null。
  2. 注册jdbcType为null。
</code></pre>
  第三步：<pre><code>  1. 若javaType不为null，则添加到typeHandlerMap。
  2. 以typeHandler.getClass()为key，添加到allTypeHandlersMap。
</code></pre>
  添加方法：<pre><code>  register(TypeHandler);
  register(Class, TypeHandler);
  private register(Type, TypeHandler);  相当于第一个通用处理方法。
  register(TypeReference, TypeHandler);
  register(Class, JdbcType, TypeHandler);
  private register(Type, JdbcType, TypeHandler); 第二个通用处理方法。
  另外支持TypeHandler 以Class为参数，通过getInstence转换， jdbcType不支持String。
  支持String代替Class，通过Resource转换。
  支持包名全部注册。
</code></pre>
</li>
<li>register Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;  jdbcTypeHandlerMap： register(JdbcType, TypeHandler)。</li>
<li>TypeHandler<Object> unknownTypeHandler</li>
<li>Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler</li>
<li>getTypeHandler:</li>
</ul>
<h3 id="MapperRegistry"><a href="#MapperRegistry" class="headerlink" title="MapperRegistry"></a>MapperRegistry</h3><ul>
<li>org.apache.ibatis.binding</li>
<li>Configuration</li>
<li>Map&lt;Class<?>, MapperProxyFactory<?>&gt; knownMappers</li>
<li>addMapper(Class) 最终执行方法</li>
<li>addMappers(String packageName)</li>
<li>addMappers(String packageName, Class superType)</li>
</ul>
<h3 id="MapperProxyFactory"><a href="#MapperProxyFactory" class="headerlink" title="MapperProxyFactory"></a>MapperProxyFactory</h3><ul>
<li>org.apache.ibatis.binding</li>
<li>Class mapperInterface</li>
<li>Map&lt;Method, MapperMethodInvoker&gt; methodCache</li>
</ul>
<h3 id="XMLMapperBuilder-extends-BaseBuilder"><a href="#XMLMapperBuilder-extends-BaseBuilder" class="headerlink" title="XMLMapperBuilder extends BaseBuilder"></a>XMLMapperBuilder extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>parser</li>
<li>MapperBuilderAssistant mapperBuilderAssistant</li>
<li>sqlFragments</li>
<li>parse()</li>
</ul>
<h3 id="MapperAnnotationBuilder"><a href="#MapperAnnotationBuilder" class="headerlink" title="MapperAnnotationBuilder"></a>MapperAnnotationBuilder</h3><ul>
<li>org.apache.ibatis.builder.annotation</li>
<li>configuration</li>
<li>mapperBuilderAssistant</li>
<li>type</li>
<li>解析：<br>  解析Cache: @CacheNamespace<br>  解析CacheRef: @CacheNamespaceRef<br>  解析ResultMap: </li>
</ul>
<h3 id="MapperBuilderAssistant-extends-BaseBuilder"><a href="#MapperBuilderAssistant-extends-BaseBuilder" class="headerlink" title="MapperBuilderAssistant extends BaseBuilder"></a>MapperBuilderAssistant extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>namespace</li>
<li>resource</li>
</ul>
<h3 id="XMLStatementBuilder-extends-BaseBuilder"><a href="#XMLStatementBuilder-extends-BaseBuilder" class="headerlink" title="XMLStatementBuilder extends BaseBuilder"></a>XMLStatementBuilder extends BaseBuilder</h3><ul>
<li>org.apache.ibatis.builder.xml</li>
<li>mapperBuilderAssistant 为XMLMapperBuilder的成员变量</li>
</ul>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li>mapper通过url、resource、class加载，且xml会加载class，class会加载xml，怎么去重<br> 所有的资源都在configuration的loadedResources中保存，加载xml其key为resource路径/url路径，加载class其key为 class.toString(), 通过class加载xml与通过xml加载class 都是通过全限定类名/namespace查询加载，其key相同，为 <code>namespace:</code> + 全限定类名。</li>
<li>加载class -&gt; 先加载xml -&gt; xml加载完查询class加载 —&gt; … 会一直加载下去么<br> class的加载，都需经过mapperRegistry的addMapper()方法， 先行存储加载的class。<br> 通过xml加载后，会根据namespace加载class，并在此判断mapperRegistry中是否已加载该class。</li>
<li>会不会加载完xml找不到对应的class，从而getMapper拿不到实体<br> xml可以加载，mapper拿不到。</li>
<li>getMapper()返回的代理类是每次创建么，如果不是，怎么保存的<br> 不是，因为每次调用的sqlSession是不同的，创建出来的代理的sqlSession为当前sqlSession。</li>
<li>mybatis获取不到接口的参数名，而只能使用param1、param2之类的<br> java在编译的时候，默认不会保留方法名参数，因此无法在运行时获取参数名称。<br> 编译时可以使用-g参数来保留方法名参数。<br> maven在编译时会默认添加-g参数，所以通过maven可以拿到具体方法名参数。</li>
<li>resultMap标签中的type、ofType、javaType、resultType<br> type: resultMap标签的属性，为类的全限定名称，表示返回的结果。<br> ofType：collection标签的属性，表示哪一种类型的集合。<br> javaType：property标签的属性，表示这个属性的类型。<br> resultType：select标签的属性。</li>
<li>XmlMapperBuilder、MapperBuilderAssistant、MapperAnnotationBuilder<br> XMLMapperBuilder、MapperAnnotationBuilder 继承自BaseBuilder，为什么AnnotationMapperBuilder没有呢？<br> XMlMapperBuilder、MapperAnnotationBuilder都定义了MapperBuilderAssistant属性，是抽象公用？<br> 因为除了AnnotationMapperBuilder，其它都是解析xml，BaseBuilder提供了将字符串解析为对象的方法，而注解可以直接使用类型定义。<br> MapperBuilderAssistant相当于工具类，且需要使用BaseBuilder的基础方法。</li>
<li>为什么XML和DAO中的ResultMap不能通用呢？<br> 注解方式ResultMap是通过 类名、方法名、方法参数 拼起来的， 可以通过@Results的id属性指定。<br> XML方式是显示id和namespace拼接的，xml的id必须指定，通过dtd约束。<br> 使用解析后的resultMapId是可以通用的。</li>
<li>MapperProxy中的MapperMethodInvoker与使用函数式接口的区别。<ol>
<li>通过接口能体现出多态的特性。</li>
<li>接口需要在其它地方引用。</li>
</ol>
</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol>
<li>MapperRegistry中config属性只为创建XmlAnnotationBuilder，没有其它使用地方。将其作为全局变量来存储，而不是方法参数带过来。</li>
</ol>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><h4 id="构建方式"><a href="#构建方式" class="headerlink" title="构建方式"></a>构建方式</h4><ol>
<li>通过xml方式<br>将配置信息放在xml中，然后通过加载xml配置文件，使用SqlSessionFactoryBuilder来创建。</li>
<li>通过java代码<br>通过DataSource、 Enverionment、 TransactionFactory、 Configuration 等类来创建。</li>
<li>通过spring<br>// TODO<br>3.1 通过xml<br>3.2 通过yml</li>
</ol>
<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><pre><code>try (SqlSession session = sqlSessionFactory.openSession()) &#123;
    ...
&#125;
</code></pre>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><pre><code>绑定映射语句的接口。
</code></pre>
<h2 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h2><ul>
<li>properties</li>
<li>settings</li>
<li>typeAliases<ol>
<li>通过typeAlia标签配置</li>
<li>通过package标签及@Alias注解（没有注解时使用Java Bean首字母小写的非限定类名）配置</li>
</ol>
</li>
<li>typeHandlers<ol>
<li>通过typeHandler标签配置</li>
<li>通过package标签</li>
</ol>
</li>
<li>objectFactory 无自动义的情况下使用默认的DefaultObjectFactory.java</li>
<li>plugins<br>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)<br>ParameterHandler (getParameterObject, setParameters)<br>ResultSetHandler (handleResultSets, handleOutputParameters)<br>StatementHandler (prepare, parameterize, batch, update, query)</li>
<li>environments<br>每个environment 包含transactionMangager 和 dataSource 配置‘<br>transactionManager 配置事务的提交和回滚规则，使用数据库提供的（type=JDBC），还是自己配置的（type=MANAGED）。</li>
<li>databaseIdProvider</li>
<li>mappers<ol>
<li>通过mapper标签，使用resource/URL/class属性。</li>
<li>通过package标签</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/2020/07/14/Mybatis/mybatis/</url>
    <content><![CDATA[<ul>
<li>mybatis 基于注解的sql可以不用写script？<br>  script 标签中可以使用xml中的标签来实现复杂语句的查询</li>
<li>mybatis 多个参数时使用@Param 注解指定？<br>  不使用@Param注解：<pre><code>  参数为基本类型，可以有多个
  参数为javabean对象，且只能有一个，使用时直接用对象的属性（注解无法获取多个属性，只能获取嵌套属性）
</code></pre>
  参数为String时，必须指定@Param注解，但是当有多个参数时，可以不用注解，猜想可能是把多个参数自动封装成一个对象了</li>
<li>mybatis 基于注解使用@ResultMap(“?”) 来使用xml中定义的reslutmap<br>  只能引用通过@Result注解定义的，并指定名称的resultmap</li>
<li>当方法传入多个参数且包含复杂对象时，使用 对象.属性 来引用，可以使用@Param起别名。如果其中有基本参数类型，直接引用即可。</li>
</ul>
<ul>
<li>读mybatis二级缓存有感<br>mybatis二级缓存使用装饰器模式实现，涉及的类有: Executor, CachingExecutor<br>装饰器模式并没有要求被装饰类和装饰器抽象出一个接口，被装饰类本身就有一个接口，装饰器类只是实现了被装饰类的接口（即如果没有装饰器类，接口的存在也没有不合适）<br>PS1： 如果被装饰类本身没有接口，这种情况（装饰器模式的意义在于动态的扩展一个对象的功能，即对功能做增强操作。一个对象的功能即行为，接口抽象的就是行为，抽象类抽象的是属性，那这时候去定义一个接口也是合适的）<br>PS2:  装饰器抽象类，这个角色是否有存在的意义。</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql 填坑</title>
    <url>/2021/06/24/Mysql/Mysql-%E5%A1%AB%E5%9D%91/</url>
    <content><![CDATA[<h2 id="mysql-left-on-where"><a href="#mysql-left-on-where" class="headerlink" title="mysql left on where"></a>mysql left on where</h2><p>过程： from + left 生成中间表 -&gt; 对中间表进行where过滤<br>on 是在生成中间表的时候的条件， 不管on后的条件是否满足，都会返回主表的所有数据<br>where 是对中间表过滤的条件</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title>ssh</title>
    <url>/2020/02/05/Linux/ssh/</url>
    <content><![CDATA[<p>SSH （ Secure Shell ），建立在应用层基础上的安全协议</p>
<p>SCP（Secure Copy）、SFTP（SSH File Transfer Protocol）是基于ssh的协议，使用了ssh的加密功能</p>
<p>使用ssh-copy-id命令将公钥复制到远程主机。ssh-copy-id会将公钥写到远程主机的 ~/ .ssh/authorized_key 文件中</p>
<p>SSH之所以能够保证安全，原因在于它采用了非对称加密技术(RSA)加密了所有传输的数据。<br>从客户端来看，SSH提供两种级别的安全验证。<br>第一种级别（基于口令的安全验证）<br>第二种级别（基于密匙的安全验证）</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>spring cloud</title>
    <url>/2020/07/14/Spring/spring%20cloud/</url>
    <content><![CDATA[<ol>
<li>eureka server<br>依赖<br> spring-cloud-starter-eureka-server<br>注解<br> @EnableEurekaServer</li>
</ol>
<p>配置<br>    spirng.application.name server需要么<br>    eureka.clinet.service-url.default-zone ？？？<br>    eureka.clinet.registry-with-eureka 如果有集群，是否注册到其他eureka服务<br>    eureka.client.fetch-registry</p>
<p>自我保护模式<br>数据中心<br>环境</p>
<ol start="2">
<li>eureka clent<br>依赖<br> spring-cloud-starter-eureka<br>注解<br> @EnableEurekaClinet  只能被eureka服务中心发现<br> @EnalbeDisconveryClient  可以被其他服务注册中心发现</li>
</ol>
<p>配置<br>    spring.application.name 指定服务名称<br>    eureka.client.service-url.default-zone<br>    eureka.clent.instance.perfer-ip-address<br>    eureka.client.instance-id  指定服务实例id,默认为 主机名:服务名:端口</p>
<ol start="3">
<li>ribbon 编程式服务间调用、负载均衡<br>依赖<br> spring-cloud-starter-ribbon</li>
</ol>
<p>注解<br>    @LoadBalanced<br>    @RibbonClient</p>
<ol start="4">
<li>feign 声明式服务间调用<br>注解<br> @EnableFeignClients<br> @FeignClient</li>
</ol>
<p>配置<br>    spring.</p>
<p>feign对hystrix的支持<br>feign中callback及callbackfactory的属性设置</p>
<ol start="5">
<li><p>hystrix 熔断处理<br>@HystrixCommand</p>
</li>
<li><p>网关<br>注解<br> @EnableEuulProxy  组合注解</p>
</li>
</ol>
<p>配置<br>    zuul.routes.<em><strong>.path<br>    zuul.routes.</strong></em>.service-id/url</p>
<ol start="7">
<li>config</li>
</ol>
<ol start="8">
<li><p>sleuth 全链路追踪</p>
</li>
<li><p>log<br>ESK  ES、LogStash、Kibana</p>
</li>
</ol>
<p>turbine</p>
<p>通过在不同环境中配置 port，来启动多个spingboot实例  @Import<br>spring mvc Resolver<br>启动异步 @EnableAsync 方法使用@Async(调用方与执行方在两个service里)<br>@Transaction rollbackfor 默认为受检异常<br>starter核心 auto-configuration<br>session、Token、JWT<br>@Mappper<br>springboot parent、dependencies</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>spring-configuration</title>
    <url>/2021/09/03/Spring/spring-configuration/</url>
    <content><![CDATA[<p>spring-configuration-metadata.json<br>    提供spring configuration元数据</p>
<p>spring-boot-configuation-processor<br>    自动生成spring-configuation-processor.json文件</p>
<p>dependency optional true<br>    不传递依赖，需要使用才添加依赖</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2020/07/14/Spring/spring/</url>
    <content><![CDATA[<ul>
<li>MATE-INF<br>  spring.factories</li>
<li>profile / @  spring-boot-starter-parent<br>  手动重新引入maven依赖<br>  父级pom对所有子级生效，子级覆盖父级，子级优先级更高</li>
<li>spring-boot-devtools</li>
</ul>
<p>service实现多个接口，则用任一接口都可注入该对象</p>
<ol>
<li><p>spring IOC<br>加载</p>
<ol>
<li>加载配置文件、读取配置</li>
<li>扫描包</li>
<li>实例化、放入容器</li>
<li>自动注入<br>初始化</li>
<li>请求映射</li>
</ol>
</li>
<li><p>Spring MVC</p>
<ol>
<li><p>加载配置文件、读取配置</p>
</li>
<li><p>扫描包</p>
</li>
<li><p>实例化、放入容器</p>
</li>
<li><p>自动注入</p>
</li>
<li><p>请求映射</p>
</li>
<li><p>请求分发、参数封装、校验等</p>
</li>
</ol>
</li>
</ol>
<p>入口<br>ClassPathXmlApplicationContext<br>AnnotationConfigApplicationContext</p>
<p>注入方式</p>
<ol>
<li>@Controller @Service @Repository @Commonent</li>
<li>@Bean</li>
<li>@Import</li>
<li>FactoryBean</li>
</ol>
<p>注解驱动<br>IOC</p>
<ol>
<li><p>@Configuration<br>配置类相当于配置文件<br>@Bean相当于bean标签，返回值相当于bean标签class，方法名作为默认key，也可自定义<br>@Configuration被@Component注解，本身相当于一个bean</p>
</li>
<li><p>@ComponentScan<br>相当于&lt;context:component-scan /&gt;标签<br>includeFilters、excludeFilters 相当于标签属性  includeFilters 需要将userDefaultFilters置为false<br>@ComponentScans 配置多个<br>自定义TypeFilter<br>3.@Scope<br>Prototype(多实例)、Singleton（单例）、Request、Session<br>Singleton 容器启动会创建对象放入容器<br>Prototype 每次获取时创建新的对象、不会管理</p>
</li>
<li><p>@Lazy<br>针对单例bean，在第一次调用的时候创建并放入容器</p>
</li>
<li><p>@Conditional spring4.x新增<br>按照一定的条件进行判断，满足条件创建bean并放入容器<br>实现Condition接口</p>
</li>
<li><p>@Import<br>value为class，容器中注入该类对象，key为class全限类名<br>实现ImportSelector接口, 返回全限类名数组<br>实现ImportBeanDefinitionRegistrar接口，实现自定义注册BeanDefinition</p>
</li>
<li><p>FactoryBean 接口<br>默认获取到的是getObject返回的bean，加&amp;前缀获取本身</p>
</li>
<li><p>生命周期 自定义<br>xml配置 bean标签属性：init-method destroy-method， @Bean属性 initMethod destroyMethod<br>Bean 实现 InitalizBean、DisposingBean 接口<br>使用@PostConstruct @PreDestroy 注解<br>Bean实现BeanPostProcessor接口 spring 底层对BeanPostProcessor的使用</p>
</li>
<li><p>@Value<br>字面量<br>SPEL、 #{}<br>${} 取配置文件的值  @PropertySource/@PropertySources 指定读取的配置文件， 相当于xml中的&lt;context:property-placeholder /&gt;</p>
</li>
<li><p>自动装配<br>@Autowired 先按类型匹配，如果找到多个，按属性名为key匹配 required 属性指定是否必须<br>@Primary 按类型匹配多个时，注入@Primary注解的bean，而不使用属性名，可使用@Qualifier注入其他bean<br>@Qualifier 按类型匹配多个时，指定按照key去匹配<br>@Resource JSR250 java规范 默认按属性名称注入，可自定义key，无法和@Pramiry、@Qualifier 组合使用，没有required属性<br>@Inject JSR330 java规范 需要添加依赖 javax.inject, 和 @Autowired 规则一样，没有required属性</p>
<p>@Autowired<br>标注在方法上，spring创建容器时会调用标注了该注解的方法  可以 @Bean + 方法参数，注解可省略<br>标注在构造器上 一样  如果只有一个有参构造器，该注解可以省略<br>标注在参数 一样<br>Aware<br>创建对象的时候，调用相应的方法，实现注入<br>使用PostProcessor实现<br>@Profile spring 提供的根据当前环境，动态激活和切换一系列组件的功能<br>激活 默认为”default”<br>虚拟机 -Dspring.profiles.active=<br>代码 applicationContext.getEnvironmet.setProfile() 需要容器创建前设置</p>
</li>
</ol>
<p>AOP<br>切面、切点、通知<br><a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a> @EnableAspectJAutoProxy</p>
<ol>
<li>@Befor @After @AfterReturning @AfterThrowing @Around @PointCut @Aspect @EnableAspectJAutoProxy JointPoint必须是第一个参数</li>
<li>@EnableAspectJAutoProxy -&gt; @Import -&gt; ImportBeanDefinitionRegistrar</li>
</ol>
<p>事务<br>@Transactional <a href="tx:annotation-driver">tx:annotation-driver</a> @EnableTranscationManagement<br>配置事务管理器 PlatformTransactionManage DataSourceTransactionManager</p>
<p>事件<br>@EventListener EventListenerMethodPostPossector, 可在方法上使用<br>@Commonent  +  ApplicationListener</p>
<p>Web Sevlet3.0+以上支持注解<br>Web三大组件 Servlet Filter Listener<br>@WebSevlet<br>@WebFilter<br>@WebListener<br>@WebInitParam<br>ServletContainerInitializer<br>异步请求    支持、开启、配置</p>
<p>MVC<br>@EnableWebMvc  &lt;mvc:annotation-driver /&gt;<br>WebMvcConfigurer接口的方法相当于xml里面的mvc配置</p>
<p>过滤器、拦截器</p>
<p>refresh</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA 配置</title>
    <url>/2021/11/16/default/IDEA-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>since InteilJ IDEA 2021.2.3.</p>
</blockquote>
<h3 id="换行显示"><a href="#换行显示" class="headerlink" title="换行显示"></a>换行显示</h3><blockquote>
<p>Settings -&gt; Editor -&gt; General =&gt; Soft Wraps</p>
</blockquote>
<p>可以设置要换行显示的文件格式</p>
<h3 id="文件末尾不加空行"><a href="#文件末尾不加空行" class="headerlink" title="文件末尾不加空行"></a>文件末尾不加空行</h3><blockquote>
<p>Settings -&gt; Editor -&gt; General =&gt; On Save</p>
</blockquote>
<p>ensure every saved file ends with a line break</p>
<h3 id="side-by-side"><a href="#side-by-side" class="headerlink" title="side-by-side"></a>side-by-side</h3><blockquote>
<p>Settings -&gt; Appearance &amp; Behavior -&gt; Appearance =&gt; Tool Windows</p>
</blockquote>
<p>Side-by-side layout on the left/right<br>左上、左下/右上、右下 显示为一行两列还是两行一列</p>
<h3 id="左侧隐藏文件-文件夹"><a href="#左侧隐藏文件-文件夹" class="headerlink" title="左侧隐藏文件/文件夹"></a>左侧隐藏文件/文件夹</h3><blockquote>
<p>Settings -&gt; Editor -&gt; File Types =&gt; Ignored Files and Folders</p>
</blockquote>
<h3 id="编辑页标签"><a href="#编辑页标签" class="headerlink" title="编辑页标签"></a>编辑页标签</h3><blockquote>
<p>Settings -&gt; Editor -&gt; General -&gt; Editor Tabls</p>
</blockquote>
<p>靠右显示、按字典序、修改标记、不显示关闭标签（Shift + 左键 = 关闭）、上限50</p>
<h3 id="打开项目不打开ReadMe"><a href="#打开项目不打开ReadMe" class="headerlink" title="打开项目不打开ReadMe"></a>打开项目不打开ReadMe</h3><blockquote>
<p>Settings -&gt; Advanced Setting =&gt; Startup</p>
</blockquote>
<p>Open README.md file if there are no open files on project startup</p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>OAS</title>
    <url>/2020/07/14/default/OAS/</url>
    <content><![CDATA[<h2 id="OAS"><a href="#OAS" class="headerlink" title="OAS"></a>OAS</h2><p>OpenAPI Specification, 开放API声明，是一个API规范，用于描述一整套API接口。</p>
<h2 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h2><p>一个流行的API框架，以OAS为基础，对整个API的开发周期都提供了相应的解决方案，几乎支持所有语言。</p>
<h2 id="springfox-swagger"><a href="#springfox-swagger" class="headerlink" title="springfox-swagger"></a>springfox-swagger</h2><p>用于将swagger集成到spring中来，前身是swagger-springmvc。生成多个json文件。</p>
<h2 id="springfox-swagger2"><a href="#springfox-swagger2" class="headerlink" title="springfox-swagger2"></a>springfox-swagger2</h2><p>生成一个json文件。</p>
<h2 id="springfox-swagger-ui"><a href="#springfox-swagger-ui" class="headerlink" title="springfox-swagger-ui"></a>springfox-swagger-ui</h2><p>页面</p>
<h2 id="springdoc-openapi"><a href="#springdoc-openapi" class="headerlink" title="springdoc-openapi"></a>springdoc-openapi</h2>]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>apache common</title>
    <url>/2020/04/05/default/apache%20common/</url>
    <content><![CDATA[<p>一、Commons BeanUtils<br>说明：针对Bean的一个工具集。由于Bean往往是有一堆get和set组成，所以BeanUtils也是在此基础上进行一些包装。 </p>
<p>二、Commons CLI<br>说明：这是一个处理命令的工具。比如main方法输入的string[]需要解析。你可以预先定义好参数的规则，然后就可以调用CLI来解析。 </p>
<p>三、Commons Codec<br>说明：这个工具是用来编码和解码的，包括Base64，URL，Soundx等等。用这个工具的人应该很清楚这些，我就不多介绍了。 </p>
<p>四、Commons Collections<br>说明：你可以把这个工具看成是java.util的扩展。 </p>
<p>五、Commons Configuration<br>说明：这个工具是用来帮助处理配置文件的，支持很多种存储方式 </p>
<p>六、Commons DBCP<br>说明：Database Connection pool, Tomcat就是用的这个，不用我多说了吧，要用的自己去网站上看说明。 </p>
<p>七、Commons DbUtils<br>说明：我以前在写数据库程序的时候，往往把数据库操作单独做一个包。DbUtils就是这样一个工具，以后开发不用再重复这样的工作了。值得一体的是，这个工具并不是现在流行的OR-Mapping工具（比如Hibernate），只是简化数据库操作，比如 </p>
<p>八、Commons HttpClient<br>说明：这个工具可以方便通过编程的方式去访问网站。 </p>
<p>九、Commons IO<br>说明：可以看成是java.io的扩展，我觉得用起来非常方便。 </p>
<p>十、Commons JXPath<br>说明：Xpath你知道吧，那么JXpath就是基于Java对象的Xpath，也就是用Xpath对Java对象进行查询。这个东西还是很有想像力的。 </p>
<p>十一、Commons Lang<br>说明：这个工具包可以看成是对java.lang的扩展。提供了诸如StringUtils, StringEscapeUtils, RandomStringUtils, Tokenizer, WordUtils等工具类。 </p>
<p>十二、Commons Logging<br>说明：你知道Log4j吗？ </p>
<p>十三、Commons Math<br>说明：看名字你就应该知道这个包是用来干嘛的了吧。这个包提供的功能有些和Commons Lang重复了，但是这个包更专注于做数学工具，功能更强大。 </p>
<p>十四、Commons Net<br>说明：这个包还是很实用的，封装了很多网络协议。 </p>
<ol>
<li>FTP </li>
<li>NNTP </li>
<li>SMTP </li>
<li>POP3 </li>
<li>Telnet </li>
<li>TFTP </li>
<li>Finger </li>
<li>Whois </li>
<li>rexec/rcmd/rlogin </li>
<li>Time (rdate) and Daytime </li>
<li>Echo </li>
<li>Discard </li>
<li>NTP/SNTP </li>
</ol>
<p>十五、Commons Validator<br>说明：用来帮助进行验证的工具。比如验证Email字符串，日期字符串等是否合法。 </p>
<p>十六、Commons Virtual File System<br>说明：提供对各种资源的访问接口。支持的资源类型包括 </p>
<ol>
<li>CIFS </li>
<li>FTP </li>
<li>Local Files </li>
<li>HTTP and HTTPS </li>
<li>SFTP </li>
<li>Temporary Files </li>
<li>WebDAV </li>
<li>Zip, Jar and Tar (uncompressed, tgz or tbz2) </li>
<li>gzip and bzip2 </li>
<li>res </li>
<li>ram<br>这个包的功能很强大，极大的简化了程序对资源的访问。 </li>
</ol>
<p>十七、Commons Transaction<br>说明：提供持久层事务支持 </p>
<p>十六、Commons Proxy<br>说明： 动态代理，拦截器一类的东西 </p>
<p>十八、Commons pool<br>说明： 创建新的对象并初始化的操作，可能会消耗很多的时间。<br>在需要频繁创建并使用这些对象的场景中，为了提供系统性能，通常的做法是，创建一个对象池，将一定数量的对象缓存到这个对象池中。<br>需要使用时直接从对象池中取出对象，使用完后将对象扔回到对象池中即可。<br>Apache的commons pool组件是我们实现对象池化技术的良好助手。 </p>
<p>十九、Commons Launcher<br>说明：创建跨平台可执行程序 </p>
<p>二十、Commons Bean Scripting Framework（BSF）<br>说明：是一个支持在Java应用程序内调用脚本语言 (Script)，并且支持脚本语言直接访问Java对象和方法的一个开源项目。有了它 , 你就能在java application中使用javascript, Python, XSLT, Perl, tcl, ……等一大堆scripting language<br>. 反过来也可以，就是在这些scripting language中调用任何已经注册过了的JavaBean,java object。它提供了完整的API实现通过Java访问脚本语言的引擎。 </p>
<p>二十一、Commons chain<br>说明： 可以在你需要定义和执行一些顺序操作的时候采用Commons Chain。 </p>
<p>二十二、Commons Compress<br>说明： 是一个压缩、解压缩文件的类库。可以操作ar, cpio, Unix dump, tar, zip, gzip, XZ, Pack200 and bzip2格式的文件，功能比较强大 </p>
<p>二十三、Commons Discovery<br>说明： 组件被用以查找可插拔接口的实现实例，它提供了一种通用的实例化这些实现的方式，而且可以管理单例（工厂）的生命周期。 </p>
<p>二十四、 commons exec<br>说明： Apache Commons Exec 是 Apache 上的一个 Java 项目，提供一些常用的方法用来执行外部进程，如下面代码所示： </p>
<p>String line = &quot;AcroRd32.exe /p /h &quot; + file.getAbsolutePath();<br>CommandLine commandLine = CommandLine.parse(line);<br>DefaultExecutor executor = new DefaultExecutor();<br>executor.setExitValue(1);<br>ExecuteWatchdog watchdog = new ExecuteWatchdog(60000);<br>executor.setWatchdog(watchdog);<br>int exitValue = executor.execute(commandLine); </p>
<p>二十五、commons jelly<br>说明：Jelly能够把XML转换成可执行代码,所以Jelly是一个基于XML与Java的脚本和处 理引擎。 Jelly借鉴了JSP定指标签，Velocity, Cocoon和Xdoclet中的脚本引擎的许多优点。Jelly可以用在命令行，Ant或者Servlet之中 </p>
<p>二十六、Commons FileUpload<br>上传下载组件 </p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2020/04/05/default/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li><p>添加远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add &lt;远程仓库名称 一般默认为origin&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>删除远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote remove &lt;远程仓库名称&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>更新/设置远程仓库地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote set-url &lt;远程仓库名称&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>添加远程仓库地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote set-url --add &lt;远程仓库名称&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>设置用户名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>设置邮箱</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>全局设置用户名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>全局设置邮箱</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>其他命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init ...</span><br><span class="line">git add ...</span><br><span class="line">git commit -m &quot;...&quot;</span><br><span class="line">git status</span><br><span class="line">git diff 文件名</span><br><span class="line">git log </span><br><span class="line">git reset --hard HEAD^ / 版本号</span><br><span class="line">git reflog </span><br><span class="line">git checkout -- 文件名</span><br><span class="line">git checkout 分支名</span><br><span class="line">git remote add origin 远程仓库路径</span><br><span class="line">git push -u origin master</span><br><span class="line">git push origin master</span><br><span class="line">git clone</span><br><span class="line">git checkout -b 分支名 = git branch 分支名 + git checkout 分支名 （创建并切换分支）</span><br><span class="line">git merge 分支名</span><br><span class="line">git branch -d</span><br><span class="line">git merge -no-ff -m</span><br><span class="line">git stash</span><br><span class="line">git stash list</span><br><span class="line">git stash apply</span><br><span class="line">git stash drop</span><br><span class="line">git stash pop</span><br><span class="line">git remote</span><br><span class="line">git remote -v</span><br><span class="line">git checkout -b 分支名 origin/分支名</span><br><span class="line">git pull</span><br><span class="line">git branch --set-upstream 分支名 origin/分支名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git init &lt;repo&gt;</span><br><span class="line">git add &lt;file&gt; [ &lt;file&gt; ... ]</span><br><span class="line">git commit -m &lt;message&gt;</span><br><span class="line">git status</span><br><span class="line">git diff &lt;file&gt;</span><br><span class="line">git log [--pretty=oneline] （提交历史）</span><br><span class="line">git reset --hard HEAD^ / HEAD~&lt;num&gt; / &lt;commit id&gt;</span><br><span class="line">git reflog （命令历史）</span><br><span class="line">git diff -- HEAD &lt;file&gt;</span><br><span class="line">git checkout -- &lt;file&gt;</span><br><span class="line">git rm &lt;file&gt;</span><br><span class="line">git remote add origin &lt;URL&gt;</span><br><span class="line">git push -u orgin &lt;branch&gt;</span><br><span class="line">git clone &lt;URL&gt;</span><br><span class="line">git checkout -b &lt;branch&gt; = git branch &lt;branch&gt; + git checkout &lt;branch&gt; = git switch - c &lt;branch&gt;</span><br><span class="line">git branch</span><br><span class="line">git checkout &lt;branch&gt;</span><br><span class="line">git merge &lt;branch&gt;</span><br><span class="line">git branch -d &lt;branch&gt;</span><br><span class="line">git switch &lt;branch&gt;</span><br><span class="line">git log --graph</span><br><span class="line">git merge --no-ff [-m &lt;message&gt;] &lt;branch&gt;</span><br><span class="line">git stash</span><br><span class="line">git stash list</span><br><span class="line">git stash apply</span><br><span class="line">git stash drop</span><br><span class="line">git stash pop</span><br><span class="line">git stash apply stash@&#123;&lt;num&gt;&#125;</span><br><span class="line">git cherry-pick &lt;commit id&gt;</span><br><span class="line">git branch -D &lt;branch&gt;</span><br><span class="line">git remote</span><br><span class="line">git remote -v</span><br><span class="line">git checkout -b &lt;branch&gt; origin/&lt;branch&gt;</span><br><span class="line">git pull</span><br><span class="line">git branch --set-upstream &lt;branch&gt; origin/&lt;branch&gt;</span><br><span class="line">git rebase</span><br><span class="line">git tag &lt;tag&gt;</span><br><span class="line">git tag</span><br><span class="line">git tag &lt;tag&gt; &lt;commit id&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>restful返回值疑问</title>
    <url>/2021/11/12/default/restful%E8%BF%94%E5%9B%9E%E5%80%BC%E7%96%91%E9%97%AE/</url>
    <content><![CDATA[<p>最近发现项目请求响应这块有点不友好，主要有两个地方：</p>
<ol>
<li>对响应做了包装，但是没有用http本身的status，在每次发生错误的时候，得在浏览器请求中一个个点击排除；</li>
<li>前端对接口调用出了问题，提示并不明确，也需要后端去排查。</li>
</ol>
<p>对于后端响应处理，主要有两种方式：</p>
<ol>
<li>直接使用http状态码返回，但是http状态码有限；</li>
<li>对响应做包装，统一返回，会出现上面问题1。</li>
</ol>
<p>所以可以使用http+包装的形式，使用http状态码表示是哪一类问题，使用包装返回具体错误码。</p>
<p>概念问题</p>
<ol>
<li>Http状态码：web服务器对客户端请求做出的响应。如果请求没有到达服务器，则没有http response。</li>
<li>自定义异常的作用只是为返回值？</li>
</ol>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>xml</title>
    <url>/2020/07/14/default/xml/</url>
    <content><![CDATA[<h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><pre><code>xmlns:
    定义标签，定义默认命名空间。
    命名空间可防止在任何元素的开始标签上。
xmlsns:xsi
    xml schema instance
    使用dtd实现，用来描述xsd。
    业界默认使用&quot;http://www.w3.org/2001/XMLSchema-instance&quot;。
xsi:schemaLocation
    指定xsd文件的位置。
    形式为“key value”，中间用空格分开，key为命名空间的值，value为xsd文件的位置。
</code></pre>
<h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h2><pre><code>document type definition
验证xml文件的规范性。
可内部定义，也可外部引入，也可内外结合。外部引入分为私有（SYSTEM）和公共（PUBLIC）。
</code></pre>
<h2 id="XSD"><a href="#XSD" class="headerlink" title="XSD"></a>XSD</h2><pre><code>xml schema definition
基于XML的DTD代替者。
</code></pre>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>websocket</title>
    <url>/2020/04/05/default/websocket/</url>
    <content><![CDATA[<ul>
<li>socket 与 websocket<br>socket 网络层的抽象接口，用来实现计算机之间的通信。不同的操作系统做了不同的实现。<br>java中的socket与serverSocket应该是对操作系统的实现做了封装。<br>WebSocket是应用层协议，基于http，全双工通信模式，用来实现浏览器和服务器的长连接。</li>
</ul>
<p>背景<br>    后端： spring boot + websocket<br>    前端： vue + websocket + stomp</p>
<p>心跳配置<br>    后端： [n1, n2]<br>        n1表示 后端给前端发送ping的间隔<br>        n2表示 前端应该给后端发送ping的间隔<br>    前端： [m1, m2]<br>        m1表示 前端发送给后端ping的间隔<br>        m2表示 前端检查后端消息发送的间隔</p>
<p>心跳frame<br>    心跳帧的数据为 0x0A(\n)</p>
<p>解释<br>    心跳要客户端和服务端都要接收和发送数据，否则心跳不能维持，必须保证四个数字都不能为0。<br>    前端发送ping，间隔取 n2,m1 最大值，打印为ping<br>    后端定时器间隔取 n1,n2 最小值，读间隔取 m1,n2 最大值 乘3, 写间隔取 m2, n1 最大值，定时器执行，lastWriteTime为上次发送消息的时间（只有发送Message才会更新），lastReadTime为接收消息的时间<br>    前端检验间隔取 n1,m2 最大值<br>    前端接收后端发送心跳，打印为pong</p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>类之间关系</title>
    <url>/2020/07/13/default/%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>面向对象 类之间的关联</p>
<h2 id="泛化（Generalization）-is-a"><a href="#泛化（Generalization）-is-a" class="headerlink" title="泛化（Generalization） is a"></a>泛化（Generalization） is a</h2><p>表现为继承或实现关系。具体形式为类与类之间的继承管理，接口与接口之间的继承关系，类对接口的实现关系。</p>
<ul>
<li>继承：实线 + 三角空心箭头，从子类指向父类。</li>
<li>实现：虚线 + 三角空心箭头，从实现类指向接口。</li>
</ul>
<h2 id="关联（Association）-has-a"><a href="#关联（Association）-has-a" class="headerlink" title="关联（Association） has a"></a>关联（Association） has a</h2><p>表现为全局变量。可以是单向，也可以是双向。</p>
<ul>
<li>实线 + 普通箭头，从主类指向被关联类。</li>
</ul>
<h3 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h3><p>强的关联关联。强调一个是整体，一个是部分，但不是组成部分。</p>
<ul>
<li>空心菱形 + 实线 + 普通箭头，从主类指向被关联类。</li>
</ul>
<h3 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h3><p>比聚合关系强的关系。强调部分是整体的组成部分，部分和整体拥有一致的生命周期。</p>
<ul>
<li>实心菱形 + 实线 + 普通箭头，从主类指向被关联类。</li>
</ul>
<h2 id="依赖（Dependency）-use-a"><a href="#依赖（Dependency）-use-a" class="headerlink" title="依赖（Dependency） use a"></a>依赖（Dependency） use a</h2><p>表示一个类依赖于另一个类。具体形式为局部变量，静态方法调用，方法参数。</p>
<ul>
<li>虚线 + 普通箭头，从主类指向被依赖类。</li>
</ul>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>项目分层</title>
    <url>/2020/09/04/default/%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B1%82/</url>
    <content><![CDATA[<h2 id="项目分层"><a href="#项目分层" class="headerlink" title="项目分层"></a>项目分层</h2><ul>
<li>阿里规约</li>
</ul>
<p><img src="/images/pasted-5.png" alt="upload successful"></p>
<ul>
<li>终端显示层<br>前端、JSP</li>
<li>开放接口<br>RPC接口、http接口</li>
<li>web层<br>负责请求转发、基本参数校验</li>
<li>service层<br>负责具体的业务逻辑处理、复用性低</li>
<li>manager层  <br>通用业务处理。可以是 1.第三方接口的封装。2.service层的通用业务。3.dao层的组合服用。</li>
<li>dao层  <br>数据访问</li>
</ul>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/2021/11/11/default/%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>减轻数据库的压力。</p>
<h3 id="选择考虑"><a href="#选择考虑" class="headerlink" title="选择考虑"></a>选择考虑</h3><p>本地缓存/分布式缓存。<br>轻量级<br>线程安全<br>高并发<br>过期</p>
<h2 id="成员变量、静态变量"><a href="#成员变量、静态变量" class="headerlink" title="成员变量、静态变量"></a>成员变量、静态变量</h2><p>本地缓存，性能一般，线程不安全，可以配合线程池实现过期。</p>
<h2 id="guavaCache"><a href="#guavaCache" class="headerlink" title="guavaCache"></a>guavaCache</h2><p>本地缓存，性能高，轻量级，线程安全，支持高并发，一个实例过期时间只能配置一个。</p>
<h2 id="EhCache"><a href="#EhCache" class="headerlink" title="EhCache"></a>EhCache</h2><p>hibernate 默认的缓存。</p>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>分布式缓存</p>
<h2 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h2><p>分布式缓存</p>
<h2 id="springCache"><a href="#springCache" class="headerlink" title="springCache"></a>springCache</h2><p>对缓存使用的抽象。</p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
  </entry>
  <entry>
    <title>Session、Cookie、Token、JWT</title>
    <url>/2020/09/11/web/Session%E3%80%81Cookie%E3%80%81Token%E3%80%81JWT/</url>
    <content><![CDATA[<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>会话，在服务端保存用户信息。</p>
<h3 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>服务器保存用户信息，导致session占据过多的内存。</li>
<li>网站采用集群部署，需要考虑session共享的问题。</li>
<li>多个应用共享session时，需要考虑蛞蝓问题。</li>
<li>如果交由cookie处理，需要考虑浏览器禁止cookie或不支持cookie的问题。</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>浏览器实现的一种数据存储功能。在客户端保存信息。</p>
<h3 id="填坑-1"><a href="#填坑-1" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>移动端对cookie支持不是很好。</li>
<li>容易被篡改，需要验证。</li>
<li>存储大小限制。</li>
<li>存储个数限制。</li>
<li>无法跨域。</li>
</ul>
<h2 id="Cookie-VS-Session"><a href="#Cookie-VS-Session" class="headerlink" title="Cookie VS Session"></a>Cookie VS Session</h2><ul>
<li>安全性</li>
<li>存取值的类型</li>
<li>有效期</li>
<li>存储大小</li>
</ul>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>令牌。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>用户通过用户名密码</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>无状态 （负载均衡器可以将请求转发到任意服务器）</li>
<li>可扩展 （可以扩展为第三方应用程序）</li>
<li>安全性 （可以蛞蝓）</li>
</ul>
<h3 id="填坑-2"><a href="#填坑-2" class="headerlink" title="填坑"></a>填坑</h3><ul>
<li>需要加密。</li>
<li>token传输方式。（header、payload、url）</li>
</ul>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>Json Web Token 是一个轻量级的认证规范，这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。其本质是一个token，是一种紧凑的URL安全方法，用于在网络通信的双方之间传递。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Header.Payload.Signature</p>
<h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><p>JSON对象，描述JWT的元数据。</p>
<h5 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h5><p>实际需要传递的数据。JWT官方规定了7个字段，供选用。</p>
<table>
<thead>
<tr>
<th>name</th>
<th></th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>iss</td>
<td>issuer</td>
<td>签发人</td>
</tr>
<tr>
<td>exp</td>
<td>expiration time</td>
<td>过期时间</td>
</tr>
<tr>
<td>sub</td>
<td>subject</td>
<td>主题</td>
</tr>
<tr>
<td>aud</td>
<td>audience</td>
<td>受众</td>
</tr>
<tr>
<td>nbf</td>
<td>not before</td>
<td>生效时间</td>
</tr>
<tr>
<td>iat</td>
<td>issued at</td>
<td>签发时间</td>
</tr>
<tr>
<td>jti</td>
<td>jwt id</td>
<td>编号</td>
</tr>
</tbody></table>
<h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>对前两部分的签名，防止数据篡改。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>对于SSO来说，每个系统都需要去CAS系统认证，如果使用jwt的话，可以通过算法来验签，而不需要通过数据库或者http接口验证。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 缺点</title>
    <url>/2021/06/24/%E5%85%83/Hexo-%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h2 id="分类-标签"><a href="#分类-标签" class="headerlink" title="分类/标签"></a>分类/标签</h2><p>每篇文章的分类、标签都是输入的，而不是选择的，导致后面会忘记前期添加过哪些数据。</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>用markdown的表格做数据很别扭，没有直接用表单，来生成表格来的舒服。</p>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>Heox文章规范</title>
    <url>/2020/07/15/%E5%85%83/Heox%E6%96%87%E7%AB%A0%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<blockquote>
<p>在此列举出一些规则，之后编写文章时都应遵循这些规则。该规则逐渐丰富。</p>
</blockquote>
<ul>
<li>文章最高使用二级标题，逐级递减，不适用一级标题。</li>
<li>文章添加分类，根据Hexo的描述，使用二级分类。</li>
</ul>
<p><img src="/images/pasted-0.png" alt="upload successful"></p>
<ul>
<li>缩进，还没有找到好的缩进方式。</li>
</ul>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>web发展</title>
    <url>/2020/09/11/web/web%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ol>
<li>web项目<ol>
<li>创建空项目，创建对应的文件夹，如果选择ide创建，则会默认创建文件夹，及选择的web版本。</li>
<li>配置文件编译输出位置，及编译输出目录，归档方式<br>exploded 文件夹<br>archive war包形式</li>
<li>配置运行环境，即tomcat，配置发布方式，发布路径。<br>端口配置和访问路径是怎么生效的呢？？？</li>
<li>静态文件是热加载，改动java文件需要重启服务。</li>
<li>添加需要的jar包。</li>
<li>servlet2.x 规范： web.xml WEB-INF classes lib</li>
<li>必要时需要tomcat配置（如端口）。IDE怎么实现界面配置改的端口。</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>model1模式<br>jsp + javabean</p>
</li>
<li><p>model2模式 （MVC）<br>jsp + servlet + javabean</p>
</li>
<li><p>maven，项目管理工具<br>通过maven，可以优化项目创建目录，打包方式，jar包管理。</p>
</li>
<li><p>servlet3.0规范<br>基于注解， 省略web.xml</p>
</li>
<li><p>maven tomcat 插件</p>
</li>
</ol>
<p>web.xml  serlvet 规范？？？</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/2020/03/28/%E5%85%83/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h1><blockquote>
<p>GitHub Pages 允许开发者自定义项目的首页，代替直接展示代码的方式。</p>
</blockquote>
<h2 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h2><blockquote>
<p>GitHub Pages 默认的静态网站生成工具，通过项目中的相应的配置文件，可以自动打包部署。</p>
</blockquote>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><blockquote>
<p>静态网站生成工具，可以通过配置使GitHub支持。</p>
</blockquote>
<h2 id="Jekyll-VS-Hexo"><a href="#Jekyll-VS-Hexo" class="headerlink" title="Jekyll VS Hexo"></a>Jekyll VS Hexo</h2><ul>
<li>本地开发预览<blockquote>
<p>Jekyll 需要搭建完整的Ruby环境。<br>Hexo 需要搭建NodeJS环境。</p>
</blockquote>
</li>
<li>迁移<blockquote>
<p>GitHub Pages中对Jekyll的支持，使得我们太多去关心Jekyll的配置以及插件，这会在迁移过程中造成一定的影响。因为不知道配置是什么，及使用了哪些插件。<br>Hexo的配置是自定义的。  </p>
</blockquote>
<h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><blockquote>
<p>由于GitHub访问速度问题，也可使用Gitee Pages功能，其概念和GitHub概念相似。  </p>
</blockquote>
<h3 id="GitHub-Pages-VS-Gitee-Pages"><a href="#GitHub-Pages-VS-Gitee-Pages" class="headerlink" title="GitHub Pages VS Gitee Pages"></a>GitHub Pages VS Gitee Pages</h3><blockquote>
<p>Gitee 支持Jekyll、Hexo、Hugo，GitHub只支持Jekyll。<br>GitHub 支持自动打包部署，检测到代码提交时执行。Gitee个人免费版不知道自动打包部署，需要手动进行。<br>GitHub 支持自定义域名。Gitee个人免费版不支持。<br>GitHub 只支持master、gh-pages分支，当使用根路径访问时只支持master分支。Gitee支持任意分支。</p>
</blockquote>
<h2 id="自动打包部署"><a href="#自动打包部署" class="headerlink" title="自动打包部署"></a>自动打包部署</h2><blockquote>
<p>对于支持自动打包部署的情况，只需要提交源码到对应的分支就行，会自动打包并部署。<br>而不支持自动打包部署的情况，需要在本地通过命令生成部署到对应的分支。而将源码提交到另一个分支。</p>
</blockquote>
</li>
</ul>
<h1 id="Hexo-搭建过程"><a href="#Hexo-搭建过程" class="headerlink" title="Hexo 搭建过程"></a>Hexo 搭建过程</h1><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><blockquote>
<p>hexo init命令需要空文件夹，git clone会生成一个不为空的文件夹，所以创建过程中需要按以下步骤进行。</p>
</blockquote>
<ol>
<li>初始化hexo项目<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx hexo init &lt;dir name&gt;</span><br></pre></td></tr></table></figure>
PS: 如不指定目录名称，则在当前文件夹下初始化，要求该文件夹为空。</li>
<li>初始化git仓库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li>关联远程仓库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;url&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><blockquote>
<p>项目目录下的_config.yml为站点配置文件，themes/?/_config.yml为主题配置文件。将主题文件复制到source/_data/next.yml进行修改。</p>
</blockquote>
<ol>
<li>网站配置<br>其中 language为主题要求的值。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">&lt;title&gt;</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&lt;subtitle&gt;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&lt;description&gt;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">&lt;keywords&gt;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">&lt;author&gt;</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/shanghai</span></span><br></pre></td></tr></table></figure></li>
<li>URL 配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">&lt;url&gt;</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year:month/:category/:post_title/</span></span><br></pre></td></tr></table></figure></li>
<li>发布配置<br>可配置多个<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;url&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li>
<li>主题配置<br>使用最新NexT主题<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure></li>
<li>CNAME配置<br>如需自定义域名，且手动打包部署，则CNAME配置应跳过渲染。相对路径为source。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">CNAME</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><ol>
<li>菜单配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br></pre></td></tr></table></figure></li>
<li>样式配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure></li>
<li>pjax配置<br>页面局部刷新功能<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
添加依赖<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-pjax themes/next/source/lib/pjax</span><br></pre></td></tr></table></figure></li>
<li>其他配置<br>每个配置的地方都有注释说明。</li>
</ol>
<ul>
<li>图标 favicon</li>
<li>头像 avatar</li>
<li>代码高亮样式 highlight_theme</li>
<li>局部页面刷新 pjax</li>
<li>中英文之间空格 pangu</li>
<li>阅读进度条 reading_progress</li>
<li>github_banner</li>
<li>书签 bookmark</li>
<li>评论 gitalk</li>
<li>公式 math</li>
<li>搜索 search</li>
<li>RSS</li>
<li>捐赠 reward</li>
</ul>
<h1 id="文章与页面"><a href="#文章与页面" class="headerlink" title="文章与页面"></a>文章与页面</h1><ol>
<li>新建文章<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
layout为scaffolds中定义的模板，默认为post</li>
<li>新建页面<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page archives/categories/tags/about</span><br></pre></td></tr></table></figure>
在各自index.md中修改其type为主题菜单配置中名称，除about外，其它都不需要编辑。</li>
<li>搜索页面<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-gengerator-searchdb</span><br></pre></td></tr></table></figure>
站点配置中新增<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">    <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
主题配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>404页面</li>
</ol>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>语法</title>
    <url>/2021/11/11/%E5%85%83/%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li>标题、列表 下一行前面不要空格<blockquote>
<p>示例</p>
<blockquote>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p> 有空格</p>
</blockquote>
</blockquote>
</li>
</ol>
<blockquote>
<blockquote>
<h4 id="标题-1"><a href="#标题-1" class="headerlink" title="标题"></a>标题</h4><p>没有空格</p>
</blockquote>
</blockquote>
<ol start="2">
<li>列表完了之后要空一行</li>
</ol>
<blockquote>
<p>示例</p>
<blockquote>
<ul>
<li>aaa<br>123123</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>aaa</li>
</ul>
</blockquote>
</blockquote>
<p>123123</p>
<blockquote>
<blockquote>
<ul>
<li>ccc</li>
</ul>
</blockquote>
</blockquote>
<ol start="3">
<li>列表嵌套<br>子列表前面加四个空格</li>
</ol>
<blockquote>
<p>示例</p>
<blockquote>
<ul>
<li>1 - 1<ul>
<li>1 - 2 - 1</li>
<li>1 - 2 - 2</li>
</ul>
</li>
<li>1 - 2</li>
</ul>
</blockquote>
</blockquote>
<ol start="4">
<li>段落 使用空行<blockquote>
<p>示例<br>1 - 1<br>1 - 2</p>
<p>2 - 1</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>计算机求解任何问题都离不开程序设计，而程序设计的实质是数据表示和数据处理，数据表示的核心是数据结构，数据处理的核心是算法。所以 程序 = 数据结构 + 算法。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>数据<br>信息的载体，在计算机科学中指所有能输入到计算机中并能被计算机程序识别和处理的符号集合。</li>
<li>数据元素<br>数据的基本单位，通常作为一个整体进行考虑和处理。</li>
<li>数据项<br>数据元素中不可分割的最小单位。</li>
<li>数据结构<br>相互之间存在一种或多种特定关系的数据元素的集合。<ul>
<li>逻辑结构<br>指数据元素之间逻辑关系的整体。面向要解决的问题。</li>
<li>物理结构<br>又称为存储结构，是数据的逻辑结构在计算机中的表示。面向计算机。</li>
</ul>
</li>
<li>结构<br>数据元素相互之间的关系称为结构。</li>
<li>元素/结点<br>数据元素在计算机中的映像。</li>
<li>数据类型<br>一组值的集合以及定义于这个值集上的一组操作的总称。</li>
<li>抽象数据类型（ADT）<br>是一个数据结构以及定义在该结构上的一组操作的总称。<ul>
<li>原子类型<br>变量的值是不可分解的。</li>
<li>固定聚合类型<br>值由确定数目的成分按某种结构组成。</li>
<li>可变聚合类型<br>值由不确定数目的成分按某种结构组成。</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构。<br>数据结构通常指数据的逻辑结构。</p>
<p>逻辑结构根据数据元素之间关系的不同特性分类：</p>
<ul>
<li>集合： 数据元素之间属于同一个集合。</li>
<li>线性结构： 数据元素之间存在一对一的线性关系。</li>
<li>树形结构： 数据元素之间存在一对多的层次关系。</li>
<li>图状结构： 数据元素之间存在多对多的任意关系。</li>
</ul>
<p>集合是数据元素之间关系极为松散的一种结构，因此也可以用其它结构来表示它。</p>
<p>根据数据元素之间关系的不同表示方法，顺序映象和非顺序映象，得到两种不同的存储结构：顺序存储结构和链式存储结构。<br>顺序存储结构： 把逻辑上相邻的结点存储在物理位置相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现。 通常借助数组来实现。<br>链式存储结构： 结点间的关系由附加的指针字段来表示。 通常借助指针来实现。</p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>抽象数据类型和数据类型实质上是一个概念。抽象的意义在于数据类型的数学抽象特性，且抽象数据类型的范畴更长，不局限于处理器已定义并实现的数据类型。<br>抽象数据类型通常包含定义、表示和实现3个部分。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>解决问题的方法或过程。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>输入</li>
<li>输出</li>
<li>有限行</li>
<li>确定性</li>
<li>可行性</li>
</ul>
<h3 id="算法与程序"><a href="#算法与程序" class="headerlink" title="算法与程序"></a>算法与程序</h3><p>程序是对一个算法使用某种程序设计语言的具体实现。算法可用任何一种程序设计语言实现。并不是所有的程序都是算法（有限性）。</p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ul>
<li>分治法</li>
<li>动态规划</li>
<li>贪心算法</li>
<li>回溯法</li>
<li>分支限界法</li>
</ul>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>计算机中最重要的资源是时间资源和空间资源，其概念类同，计量方法相似，且空间复杂性分析相对简单，所以更注重时间算法复杂性的分析。<br>通常有三种情况：最好情况、最坏情况、平均情况。使用O表示。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo admin后台管理</title>
    <url>/2020/07/15/%E5%85%83/hexo-admin%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>使用hexo搭建博客之后，通过在编辑器里面来记录文章总归不是一个好的方式，而hexo admin提供了后台管理的页面来通过页面管理文章。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-admin</span><br></pre></td></tr></table></figure>
<p>安装好之后会在根目录下生成一个配置文件，该配置文件可以保存页面settings中的配置。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>管理页面中deploy功能需要添加配置。</p>
<ol>
<li>在_config.yml 中添加amdin发布命令的脚本路径。</li>
<li>创建脚本文件。</li>
</ol>
<p>PS: 该功能没有实现 </p>
<h2 id="线上"><a href="#线上" class="headerlink" title="线上"></a>线上</h2><p>github Pages是静态网站，不支持。支持其它动态的服务器。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>hexo admin 可以在编辑器内复制图片，图片将保存在images文件夹下，可自定义。<br>windows复制的图片需要去掉...\。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol>
<li>Posts页面没有分类，所有文章放在一起，看起来比较乱。</li>
<li>新建文章能否按照分类按文件夹存放。</li>
<li>添加分类和标签时只能输入，不能选择。</li>
<li>不能编辑文章的描述，该描述影响列表页面的内容。</li>
</ol>
<p>PS：<br>（1）. 可以在文章编辑界面上方修改文章路径。<br>（2）. 可以在_config.yml中添加 metadata - description 支持。</p>
]]></content>
      <categories>
        <category>元</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-哈希表</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8811%EF%BC%89-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表，将关键码映射为散列表中适当存储位置的函数称为散列函数，所得的存储位置称为散列地址。</p>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><h3 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h3><p>H(key) = a * key + b (a、b为常熟)<br>特点： 单调、均匀、不会产生冲突。<br>适用于事先知道关键码的分布，且关键码集合不是很大且连续性较好的情况。</p>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>H(key) = key % p (p为某个适当的正整数)<br>最简单、最常用的构造散列函数的方法，且不要求事先知道关键码的分布。</p>
<h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p>根据关键码在各个位上的分布情况，选取分布比较均匀的若干位组成散列地址。<br>适用于事先知道关键码的分布且关键码中有若干位分布较均匀的情况。</p>
<h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>对关键码平方后，按散列表大小，取中间的若干位作为散列地址。<br>通常用在事先不知道关键码的分布且关键码的位数不是很大的情况。</p>
<h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p>将关键码从左到右分割称位数相等的几部分，然后叠加求和，取后几位作为散列地址。<br>叠加方法：<br>    移位叠加： 将各部分的最后一位对齐相加。<br>    间界叠加： 从一端向另一端沿各部分分界来回折叠后，最后一位对齐相加。<br>适用于关键码的位数很多，且关键码的每一位分布都不均匀的情况。事先不需要知道关键码的分布。</p>
<h2 id="处理冲突方法"><a href="#处理冲突方法" class="headerlink" title="处理冲突方法"></a>处理冲突方法</h2><h3 id="开放定址法-（闭散列表）"><a href="#开放定址法-（闭散列表）" class="headerlink" title="开放定址法 （闭散列表）"></a>开放定址法 （闭散列表）</h3><p>关键码得到的散列地址一旦产生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p>
<ul>
<li>线性探测法<br>  从冲突位置的下一个位置起，依次寻找空的散列地址。 Hi = (H(key) + di) % m</li>
<li>二次探测法</li>
<li>随机探测法</li>
</ul>
<h3 id="拉链法-（开散列表）"><a href="#拉链法-（开散列表）" class="headerlink" title="拉链法 （开散列表）"></a>拉链法 （开散列表）</h3><p>将所有散列地址相同的记录存储在一个单链表中，称为同义词子表，在散列表中存储的是所有同义词子表的头指针。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="拉链哈希表"><a href="#拉链哈希表" class="headerlink" title="拉链哈希表"></a>拉链哈希表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class HashTable&lt;E&gt; &#123;</span><br><span class="line">    Node[] tables;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-堆</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8812%EF%BC%89-%E5%A0%86/</url>
    <content><![CDATA[<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li>完全二叉树。</li>
<li>每个结点的值都小于或等于其左右孩子结点的值（小根堆）。</li>
<li>每个结点的值都大于或等于其左右孩子结点的值（大根堆）。</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>优先队列<br>在优先队列中，元素被赋予优先级。<br>当访问元素时，具有最高优先级的元素最先出队。<br>通常采用堆数据结构来实现。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-二叉排序树</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8810%EF%BC%89-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<p>二叉排序树（Binary Sort Tree）, 又称二叉搜索/查找树（Binary Search Tree）。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ol>
<li>左子树上所有结点的值小于[等于]它根节点的值。</li>
<li>右子树上所有结点的值大于[等于]它根节点的值。</li>
<li>左右子树也均是二叉排序树。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>查找<br>平均查找长度： 每个结点的深度的总和/总结点数。</li>
<li>插入<br>新插入的结点一定是一个新添加的叶子结点，并且时查找不成功时查找路径上访问的最后一个结点的子结点。</li>
<li>删除<ol>
<li>删除结点为叶子结点，直接删除</li>
<li>删除结点只有一个孩子结点，则继承给删除结点的父节点。</li>
<li>删除结点有两个孩子结点。<br>1.</li>
</ol>
</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="平衡二叉搜索树（AVL）"><a href="#平衡二叉搜索树（AVL）" class="headerlink" title="平衡二叉搜索树（AVL）"></a>平衡二叉搜索树（AVL）</h3><p>每个结点的左右子树的高度差绝对值最多为1。</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li>LL 右旋</li>
<li>RR 左旋</li>
<li>LR 左旋 -&gt; LL 右旋</li>
<li>RL 右旋 -&gt; RR 左旋</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入为叶子结点，向上旋转。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>向下旋转为叶子结点, 删除。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>结点是红色或者黑色。</li>
<li>根节点是黑色。</li>
<li>所有叶子结点都是黑色（叶子结点是Null结点）。</li>
<li>每个红色结点的两个叶子结点都是黑色（路径中不能有两个连续的红色结点）。</li>
<li>从任一结点到其每个叶子结点的路径都包含相同数目的黑色结点。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-B-树</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8813%EF%BC%89-B-%E6%A0%91/</url>
    <content><![CDATA[<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ol>
<li>所有的叶子结点都出现在同一层，并且不带信息。叶子结点的双亲称为终端结点。</li>
<li>树中每个系结点至多有m棵子树。</li>
<li>若根节点不是终端结点，则至少有两棵子树。</li>
<li>除根结点之外的所有非终端结点至少有 m/2 棵子树。</li>
<li>所有的非终端结点都包含数据。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>查找</li>
<li>插入</li>
<li>删除</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>3阶的B-树。</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>一个结点包含一个或者两个关键码。</li>
<li>每个内部结点有2个孩子（包含一个关键码）或3个孩子（包含两个关键码）。</li>
<li>所有叶子结点都在树的同一层。</li>
</ol>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>查找从根节点开始，如果根节点不包含被查找的关键码k，那么查找就在可能包含关键码k的子树中继续进行。存储在根节点中的关键码确定哪一个子树是正确的子树。</p>
<h3 id="2-3-4"><a href="#2-3-4" class="headerlink" title="2-3-4"></a>2-3-4</h3><p>2-3-4 树是4阶的B-树。</p>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ol>
<li>2结点包含一个元素和两个儿子。</li>
<li>3结点包含两个元素和三个儿子。</li>
<li>4结点包含三个元素和四个儿子。</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h4><p>1，具有m棵子树的结点含有m个关键码，即每一个关键码对应一颗子树。<br>2. 关键码Ki是它所对应的子树的根节点中最大/最小的关键码。<br>3. 所有的终端结点包含了全部的关键码信息，以及指向关键码记录的指针。<br>4. 各终端结点按关键码的大小次序链在一起，形成单链表，并设置头指针。</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><p>B*树是B+树的变体，在B+树的非根结点和非叶子结点在添加指向兄弟的指针。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-线性表</title>
    <url>/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%881%EF%BC%89-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>线性表是线性结构的典型代表。是一种最基本、最简单的数据结构，数据元素直接仅具有单一的前驱和后继关系。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>是n（n&gt;=0）个具有相同类型的数据元素的有限序列。<br>相邻两个元素之间存在序偶关系。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>返回长度</li>
<li>获取指定位置元素</li>
<li>返回第一个匹配的元素</li>
<li>获取前驱</li>
<li>获取后继</li>
<li>在指定位置插入元素</li>
<li>删除指定位置的元素</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>用一段地址连续的存储单元一次存储线性表的数据元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要确定数组的长度，来分配固定长度的数组空间。<br>只要确定了存储顺序的起始地址，计算任一元素的存储地址时间是相等的。</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>用指针将存储线性表中数据元素的结点串联起来。只包含后继结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; head;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果以Node来实现链表，则需要一个空头结点。如果以List来实现，则List本身充当了空头节点，且可以添加其它属性。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul>
<li>头插法 在链表头部插入元素</li>
<li>尾插法 在链表尾部插入元素</li>
</ul>
<h3 id="循环列表"><a href="#循环列表" class="headerlink" title="循环列表"></a>循环列表</h3><p>将尾结点的后继指向头结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; head;</span><br><span class="line">    Node&lt;E&gt; last;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>包含前驱结点和后继结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; head;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序表VS链表"><a href="#顺序表VS链表" class="headerlink" title="顺序表VS链表"></a>顺序表VS链表</h3><ul>
<li>时间性能<br>顺序表： 随机访问快<br>链表： 插入和删除快</li>
<li>空间性能<br>顺序表： 需要预先分配一定长度的储存空间。<br>链表： 不需要预分配空间。</li>
</ul>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>用数组来表示单链表，用数组元素的下标来模拟单链表的指针。<br>由于它是利用数组定义的，属于静态存储分配，因此叫做静态链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class List&lt;E&gt; &#123;</span><br><span class="line">    Node[] elements;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        int cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入和删除时只需修改游标（cur），但是没有解决存储分配带来的表长难以确定问题。</p>
<h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>将数组和指针结合起来，将数组中存储数据元素的单元改为存储指向该元素的指针。</p>
<p>保持了顺序表随机存取的优点，改进了插入和删除操作的时间性能，但是没有解决存储分配带来的表长难以确定问题。</p>
<p>Java中对象中存储的就是指针。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>线性表合并 O(m * n)<br>有序线性表合并 O(m + n)</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>大整数求和（顺序表）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-栈</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89-%E6%A0%88/</url>
    <content><![CDATA[<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>限定仅在表尾（栈顶）进行插入和删除操作的线性表。<br>具有后进先出（LIFO）的特性。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取长度</li>
<li>出栈</li>
<li>入栈</li>
<li>获取栈顶元素</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Stack&lt;E&gt; &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两栈共享空间：<br>    使用一个数组来存储两个栈，一个栈的栈底尾数组的始端，另一个栈的栈底为该数组的末端，每个栈从各自的端点向中间延伸。</p>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>通常用单链表实现。<br>使用头插法，将头指针指向栈顶元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Stack&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; node;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序栈-VS-链栈"><a href="#顺序栈-VS-链栈" class="headerlink" title="顺序栈 VS 链栈"></a>顺序栈 VS 链栈</h3><ul>
<li>时间性能<br>实现基本操作都只需要常数时间。</li>
<li>空间性能<br>顺序栈： 初始化时需要确定长度，有存储个数限制和空间浪费问题。<br>链栈： 每个元素都需要一个指针域，产生了结构性开销。</li>
</ul>
<p>使用过程中元素个数变化较大时，适合用链栈；反之，适合使用顺序栈。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>进制转换<br>表达式求值，括号匹配<br>递归</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-队列</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>只允许在一端（队头）进行插入操作，在另一端（队尾）进行删除操作的线性表。<br>具有先进先出（FIFO）的特性。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取队列长度</li>
<li>获取对头元素</li>
<li>出队</li>
<li>入队</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>可优化出队操作的开销，需要设置对头、队尾两个指针。<br>可用一个数据元素的空间，来解决队空和队满的判定。或添加一个标志。或者使用个数判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Queue&lt;E&gt; &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链队列"><a href="#单链队列" class="headerlink" title="单链队列"></a>单链队列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Queue&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; front;</span><br><span class="line">    Node&lt;E&gt; rear;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环队列-VS-链队列"><a href="#循环队列-VS-链队列" class="headerlink" title="循环队列 VS 链队列"></a>循环队列 VS 链队列</h3><ul>
<li>时间性能<br>实现基本操作都只需要常数时间O(1)。</li>
<li>空间性能<br>循环队列： 初始化时需要确定长度，有存储个数限制和空间浪费问题。<br>链队列： 每个元素都需要一个指针域，产生了结构性开销。</li>
</ul>
<p>使用过程中元素个数变化较大时，适合用链队列；反之，适合使用循环队列。</p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Queue&lt;E&gt; &#123;</span><br><span class="line">    Node&lt;E&gt; front;</span><br><span class="line">    Node&lt;E&gt; rear;</span><br><span class="line">    </span><br><span class="line">    class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>阻塞队列<br>当队列为空时，获取元素的操作将被阻塞，直到其它线程往队列中插入新的元素。<br>当队列是满是，插入元素的操作将被阻塞，直到其它线程从队列中取出元素。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-串</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89-%E4%B8%B2/</url>
    <content><![CDATA[<p>字符串一般简称串。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>由零个或多个字符组成的有限序列。</p>
<h2 id="串VS线性表"><a href="#串VS线性表" class="headerlink" title="串VS线性表"></a>串VS线性表</h2><ul>
<li>逻辑结构： 串的数据对象约束为字符集。</li>
<li>操作： 线性表已单个元素作为操作对象，串以串的整体作为操作对象。</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>长度：串中字符的数目。<br>空串：零个字符的串<br>子串：串中任意个连续的字符组成的子序列。<br>主串：包含子串的串。<br>位置：字符在序列中的序号。<br>空格串： 由一个或多个空格组成的串。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>复制</li>
<li>判断是否为空</li>
<li>获取长度</li>
<li>拼接</li>
<li>字串</li>
<li>指定位置之后第一次出现字串的位置</li>
<li>替换</li>
<li>指定位置插入/删除</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h3><p>C中超过长度截断。Java中不允许超过已分配长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">    char[] value;</span><br><span class="line">    int length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆分配存储"><a href="#堆分配存储" class="headerlink" title="堆分配存储"></a>堆分配存储</h3><p>C中使用malloc和free控制内存，实际是基于复制实现。</p>
<h3 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h3><p>每个结点可以存放一个字符，也可以存放多个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class String &#123;</span><br><span class="line">    Node head;</span><br><span class="line">    Node tail;</span><br><span class="line">    int length;</span><br><span class="line">    </span><br><span class="line">    class Node &#123;</span><br><span class="line">        char[] value;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><ul>
<li>BF算法（brute force 暴力）</li>
<li>KMP算法</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-数组</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%885%EF%BC%89-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>由类型相同的数据元素构成的有序集合，每个数据元素称为一个数组元素（简称元素），每个元素受n（n&gt;=1）个线性关系的约束，每个元素在n个线性关系中的序号称为该元素的下标，并称该数组为n维数组。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>数据元素本身可以具有某种结构，但属于同一数据类型。<br>一维数据可以看作一个线性表，二维数据可以看作线性表的线性表，以此类推。所以，数组是线性表的推广。<br>数组一般不做插入和删除操作。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>初始化</li>
<li>赋值</li>
<li>取值</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><ul>
<li>按行优先存储</li>
<li>按列优先存储</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h3><p>矩阵是很多科学与工程计算问题中的处理对象。<br>特殊矩阵： 有很多值相同的元素并且由一定的分布规律。（为多个值相同的元素只分配一个存储空间）<br>稀疏矩阵： 有很多零元素。（对零元素不分配存储空间）</p>
<h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>在一个n阶方阵中，有a<sub>ij</sub>=a<sub>ji</sub>。</p>
<h4 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h4><p>主对角线以上为常熟c，为下三角矩阵，主对角线以下为常数c，为上三角矩阵。</p>
<h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p>所有非零元素都集中在以主对角线为中心的带状区域，除了主对角线和它的上下若干条对角线的元素外，所有其它元素都为零。</p>
<h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h4><p>零元素居多的矩阵。</p>
<ul>
<li>三元组顺序表</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>三元组-矩阵转置<br>三元组-快速转置<br>矩阵相加<br>矩阵相乘</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-广义表</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%886%EF%BC%89-%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是线性表的推广，允许元素拥有其自身结构。是一种非连续性的数据结构。<br>任何一个非空列表，其表头可能是原子，也可能是列表。其表尾一定是列表。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>原子 广义表中的单个元素。</li>
<li>子表 广义表中的广义表。</li>
<li>表头 当广义表非空时，第一个元素为表头。</li>
<li>表尾 除表头元素外，其余元素组成的表。</li>
</ul>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><ul>
<li>创建</li>
<li>复制</li>
<li>获取表的长度</li>
<li>获取表的深度</li>
<li>判断表是否为空</li>
<li>获取表头元素</li>
<li>获取表尾元素</li>
<li>插入元素</li>
<li>删除第一个元素</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>广义表中的数据元素可以拥有不同的结构，难以用顺序存储结构表示。</p>
<h3 id="头尾链表存储"><a href="#头尾链表存储" class="headerlink" title="头尾链表存储"></a>头尾链表存储</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class GList&lt;E&gt; &#123;</span><br><span class="line">    boolean isAtom;</span><br><span class="line">    E item;</span><br><span class="line">    GList&lt;E&gt; head, tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展式链表存储"><a href="#扩展式链表存储" class="headerlink" title="扩展式链表存储"></a>扩展式链表存储</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class GList&lt;E&gt; &#123;</span><br><span class="line">    boolean isAtom;</span><br><span class="line">    E item;</span><br><span class="line">    GList&lt;E&gt; head;</span><br><span class="line">    GList&lt;E&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>m元多项式</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>递归</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-图</title>
    <url>/2021/11/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%889%EF%BC%89-%E5%9B%BE/</url>
    <content><![CDATA[<p>图的存储结构应根据具体问题的要求来设计，文中列出的是常用的存储结构。</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>在图结构中，任意两个顶点之间都可能有关系。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>图是由顶点的有穷非空集合和顶尖之间边的集合组成。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>查找顶点在图中位置</li>
<li>获取顶点值</li>
<li>设置顶点值</li>
<li>获取第一个邻接顶点</li>
<li>获取下一个邻接顶点</li>
<li>添加新顶点</li>
<li>删除顶点及相关的弧</li>
<li>添加弧</li>
<li>删除弧</li>
<li>遍历</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>深度优先遍历<br>广度优先遍历</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>图没有顺序存储结构，但可借助数组表示元素之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum GraphType &#123; DG, DN, UNG, UDN &#125; // 有向图，有向网，无向图，无向网</span><br></pre></td></tr></table></figure>
<h3 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class GNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    GNode[] next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个结点的度都不一样。若按最大度来存储，则可能造成很大的空间浪费；若按结点各自的度来存储，给操作带来不便。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>用一维数组存储顶点的信息，用二维数组存储图中边的信息，存储顶点之间的邻接关系的二维数组称为邻接矩阵。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    V[] vs;</span><br><span class="line">    Arc[][] as;</span><br><span class="line">    int vexnum, arcnum;</span><br><span class="line">    GraphType type;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        int adj; // 对无权图，用0、1表示是否相邻，对有权图，则为权值。</span><br><span class="line">        A item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>对图中每个顶点建立一个单链表，第i个单链表的结点表示依附于顶点vi的边（对有向图是以顶点vi为尾的弧）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    VNode[] vs;</span><br><span class="line">    GraphType type;</span><br><span class="line">    int vexum, arcnum; </span><br><span class="line">    </span><br><span class="line">    class VNode&lt;V, A&gt; &#123;</span><br><span class="line">        V item;</span><br><span class="line">        Arc&lt;A&gt; firstArc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        A item;</span><br><span class="line">        Arc&lt;A&gt; next;</span><br><span class="line">        int adjvex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>有向图的存储结构。将有向图的邻接表和逆邻接表结合起来的一种链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    VNode[] vs;</span><br><span class="line">    int vexnum, arcnum;</span><br><span class="line">    </span><br><span class="line">    class VNode&lt;V&gt; &#123;</span><br><span class="line">        V item;</span><br><span class="line">        Arc&lt;A&gt; firstIn, firstOut;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        Arc&lt;A&gt; head, tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链接多重表"><a href="#链接多重表" class="headerlink" title="链接多重表"></a>链接多重表</h3><p>无向图的存储结构。每一条边用一个结点表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Graph&lt;V, A&gt; &#123;</span><br><span class="line">    VNode[] vs;</span><br><span class="line">    int vexnum, arcnum;</span><br><span class="line">    </span><br><span class="line">    class VNode&lt;V&gt; &#123;</span><br><span class="line">        V item;</span><br><span class="line">        Arc&lt;A&gt; firstIn, firstOut;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Arc&lt;A&gt; &#123;</span><br><span class="line">        Arc&lt;A&gt; head, tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>深度/广度优先遍历<br>最小生成树<br>    普利姆算法<br>    克鲁斯卡尔算法<br>有向无环图 拓扑排序<br>最短路径</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-二叉树</title>
    <url>/2021/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%887%EF%BC%89-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>二叉树适合计算机存储和处理。且所有的树结构都可以转为二叉树。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>n（n&gt;=0）个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>每个结点最多有两棵子树，不存在度大于2的结点。</li>
<li>二叉树是有序的，即使只有一棵子树，也要区分是左子树还是右子树。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取深度</li>
<li>获取根节点</li>
<li>获取结点的值</li>
<li>给结点赋值</li>
<li>获取左孩子结点</li>
<li>获取后孩子结点</li>
<li>获取兄弟结点</li>
<li>在指定位置插入孩子结点</li>
<li>删除指定位置的孩子结点</li>
<li>遍历</li>
</ul>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><ul>
<li>斜树<br>所有结点都只有左子树称为左斜树，所有结点都只有右子树称为右斜树。</li>
<li>满二叉树<br>所有分支结点都存在左右子树，且所有的叶子结点都在同一层上。</li>
<li>完全二叉树<br>对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。<br>满二叉树必定是完全二叉树。</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul>
<li>先序 根 - 左 - 右</li>
<li>中序 左 - 根 - 右</li>
<li>后序 左 - 右 - 根</li>
<li>层序 广度优先，从上到下，从左到右</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>使用一维数组存储所有结点，按完全二叉树层序遍历顺序存储。<br>某结点存储位置为i，则其左孩子存储位置为2<em>i，右孩子存储位置为2</em>i+1。<br>会造成存储空间的浪费。<strong>顺序存储结构一般仅适用于存储完全二叉树。</strong></p>
<h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p>二叉树每个结点对应一个链表结点，数据元素包含左右孩子的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BiTNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; leftChild;</span><br><span class="line">    Node&lt;E&gt; rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h3><p>二叉树每个结点对应一个链表结点，数据元素包含父节点指针及左右孩子的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BiTNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; parent;</span><br><span class="line">    Node&lt;E&gt; leftChild;</span><br><span class="line">    Node&lt;E&gt; rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线索链表"><a href="#线索链表" class="headerlink" title="线索链表"></a>线索链表</h3><p>按照某种遍历次序对二叉树进行遍历，可以把二叉树中的所有结点排成一个线性序列。<br>一个具有n个结点的二叉链表，在2n个指针域中只有n-1个指针用来存储孩子结点的地址，存在n+1个空指针域。<br>因此，可以使用空指针域存储某种遍历序列中的前驱和后继结点。<br>指向前驱和后继结点的执政称为<strong>线索</strong>，加上线索的二叉树称为线索二叉树，加上线索的二叉链表称为线索链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BiTNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; left, right;</span><br><span class="line">    boolean leftFlag, rightFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在线索链表中，对任意结点，若存在左孩子结点，则左指针指向左孩子结点，否则指向该结点的前驱线索；右指针同理。数据元素包含左右指针，左右指针存放数据标志位。</p>
<p>二叉树遍历次序有4种，相应有四种线索链表：前序线索链表、中序线索链表、后序线索链表、层序线索链表。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>哈夫曼树、哈夫曼编码</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>遍历 - 递归<br>遍历 - 非递归算法<br>线索二叉树的遍历<br>深度</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-树</title>
    <url>/2021/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%888%EF%BC%89-%E6%A0%91/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>有n个结点的有限集合。<br>或者是空树，空树中不包含任何结点；或者是非空树，有且仅有一个特定的根节点，其余结点可分为m个互不相交的有限集，其每一个又是一棵树，且称为根的子树。<br>树的定义是递归的。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建</li>
<li>清空</li>
<li>判断是否为空</li>
<li>获取深度</li>
<li>获取根节点</li>
<li>获取结点的值</li>
<li>给结点赋值</li>
<li>获取父节点</li>
<li>获取最左孩子结点</li>
<li>获取右兄弟结点</li>
<li>在指定位置插入孩子结点</li>
<li>删除指定位置的孩子结点</li>
<li>遍历</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul>
<li>前序遍历 根-左-右</li>
<li>后序遍历 左-右-根</li>
<li>层序遍历 树的广度遍历，从上到下，从左到右</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>静态链表。数组存放所有树结点，数据元素包含父节点在数组中的下标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    int parentCur;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode[];</span><br></pre></td></tr></table></figure>

<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>多重链表: 数据元素包含所有子节点的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多重链表的长度由树的度决定，会造成很大一部分的空间浪费。实际中不宜采用</p>
<p>孩子链表: 数据元素包含一个链表，链接所有子节点的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode&lt;E&gt; firstChilde;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双亲孩子表示法"><a href="#双亲孩子表示法" class="headerlink" title="双亲孩子表示法"></a>双亲孩子表示法</h3><p>双亲表示法+孩子链表表示法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode&lt;E&gt; parent;</span><br><span class="line">    TreeNode&lt;E&gt; firstChilde;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>二叉链表表示法。数据元素包含<em>结点的第一个子结点</em>及<em>右兄弟结点</em>的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    TreeNode&lt;E&gt; nextSibling;</span><br><span class="line">    TreeNode&lt;E&gt; firstChilde;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>遍历<br>深度<br>回溯</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-疑难解答</title>
    <url>/2021/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88X%EF%BC%89-%E7%96%91%E9%9A%BE%E8%A7%A3%E7%AD%94/</url>
    <content><![CDATA[<h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><table>
<thead>
<tr>
<th>结构</th>
<th>数据元素名称</th>
<th>数据元素关系</th>
</tr>
</thead>
<tbody><tr>
<td>线性结构</td>
<td>数据元素</td>
<td>前驱、后继</td>
</tr>
<tr>
<td>树结构</td>
<td>结点</td>
<td>双亲结点、孩子结点、兄弟结点</td>
</tr>
<tr>
<td>图结构</td>
<td>顶点</td>
<td>邻接</td>
</tr>
<tr>
<td>索引</td>
<td>记录</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="数组是一种数据结构么"><a href="#数组是一种数据结构么" class="headerlink" title="数组是一种数据结构么"></a>数组是一种数据结构么</h2><p>是一种数据结构。<br>数组是最基础的数据结构，所以几乎所有的程序设计语言都把数组设定为固定的基础变量类型。<br>在Java中，数据的ADT由底层实现，操作方式不同于其它的操作方式，有它独特的操作方式。如直接赋值，下标访问，初始化等。<br>当数组维度为1时，退化为顺序表。</p>
<h2 id="物理结构-存储结构"><a href="#物理结构-存储结构" class="headerlink" title="物理结构/存储结构"></a>物理结构/存储结构</h2><p>有说法：常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等。（百度百科：数据结构）<br>也有说法： 数据元素之间的关系有两种不同的表示方法：顺序映象和非顺序映象，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。（百度百科：存储结构）</p>
<p>根据物理结构的定义：数据及其逻辑结构在计算机中的表示。而其逻辑结构指的是数据元素之间的关系，即通过该元素，如何找到接下来的元素，即顺序存储和链式存储。<br>对于顺序存储，其关联元素位置由当前位置计算得出，不需要存储。而链式存储，关联元素位置需要存储。</p>
<p>所以，数据的存储结构就是指顺序存储结构和链式存储结构。</p>
<h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><p>树、二叉树、森林是不同的数据结构。二叉树并不是树的一种特殊情况，而是平行的概念，都属于树结构。<br>树、二叉树其定义与性质都不相同。<br>如果二叉树只是在树的定义上，新增了一条或多条，则二叉树可以理解为一种特殊的树。</p>
<h2 id="线性结构与线性表"><a href="#线性结构与线性表" class="headerlink" title="线性结构与线性表"></a>线性结构与线性表</h2><p>线性结构只有线性表么，队列、栈只是一种特殊的线性表，数组与广义表是线性表的推广，不属于线性结构，所以线性结构只有线性表。<br>一维数组也是线性结构。<br>所以线性结构不只是线性表。那还有其它的线性结构么？ - 串</p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><p>抽象数据类型是与程序设计语言相关的。每种语言对同一种数据结构所定义的抽象数据类型是不一致的。<br>抽象数据类型在面向对象中相当于接口，其不同的实现方式相当于实现类。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-树形结构</title>
    <url>/2021/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><p>层次的嵌套结构。树形结构的外层和内层有相似的结构。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>结点：数据元素<br>结点的度： 结点所拥有子树的个数<br>树的度： 树中个结点度的最大值<br>叶子结点： 度为0的结点<br>分支结点： 度不为0的结点<br>树的深度：树中所有结点的最大层数<br>层序编号：按照从上到下，从左到右的次序依次编号<br>有序树： 结点的各子树从左到右是有次序的。交换了结点各子树的相对位置，则构成不同的树。<strong>在数据结构中讨论的树一般是有序树</strong><br>森林： m棵互不相交的树的集合</p>
<h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><ul>
<li>二叉树</li>
<li>树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-图状结构</title>
    <url>/2021/11/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89-%E5%9B%BE%E7%8A%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h2><p>数据元素对于关系的前驱和后继个数不加限制，即任意的关系，称为图形结构。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>顶点： 数据元素<br>简单图： 不存在顶点到其自身的边，且同一条边不重复出现<br>无向图： 任意两个顶底之间的边都是无向边<br>弧: 有向边<br>邻接：任意两个顶点存在边，则两个顶点互为邻接点<br>依附：边依附于顶点<br>无向完全图：无向图中，任意两个顶点之间都存在边<br>有向完全图： 有向图中，任意两顶点之间存在方向互为相反的两条弧<br>顶点的度： 无向图中，依附于该顶点的边的个数<br>顶点的入度： 有向图中，以该顶点为弧头的弧的个数<br>顶点的出度： 有向图中，以该顶点为弧为的弧的个数</p>
<p>权：对边赋予有意义的数值量<br>网：边上带权的图称为网</p>
<p>路径： 两顶点之间的路径是一个顶点序列<br>路径长度： 路径上边的数目<br>回路/环： 第一个顶点和最后一个顶点相同的路径<br>简单路径： 顶点不重复出现的路径<br>简单回路： 除了第一个和最后一个顶点，其余顶点不重复出现的回路</p>
<p>连通图： 无向图中，若任意的两个顶点之间有路径，则称该图是连通图<br>连通分量： 非连通图的极大连通子图<br>强连通图： 有向图中，对任意结点i、j，从顶点i到j均有路径，则称该有向图是强连通图<br>强连通分量： 非强连通图的极大强连通子图</p>
<p>生成树：…<br>生成森林：…</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>深度优先遍历<br>广度优先遍历</p>
<h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><ul>
<li>邻接矩阵<br>用一维数组存储顶点的信息，用二维数组存储图中边的信息，存储顶点之间的邻接关系的二维数组称为邻接矩阵。</li>
<li>邻接表</li>
<li>十字链表</li>
<li>链接多重表</li>
<li>最小生成树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-排序</title>
    <url>/2021/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>排序的目的： 便于查找。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>记录： 数据元素。</li>
<li>趟： 将待排序的记录序列扫描一遍称为一趟。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>稳定排序 相等的记录排序前后相对位置不变。</li>
<li>不稳定排序 相等的记录排序前后相对位置可能改变。</li>
</ul>
<ul>
<li>内部排序 待排序记录放在内存中的排序过程。</li>
<li>外部排序 待排序记录数量很大，排序过程中需对外存进行访问的排序过程。</li>
</ul>
<h2 id="内部排序算法"><a href="#内部排序算法" class="headerlink" title="内部排序算法"></a>内部排序算法</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>依次将待排序序列中的每一个记录插入到一个已经排好序的序列中，直到全部记录都排好序。</p>
<p>当序列中的记录基本有序，或待排序记录较少时，是最佳的排序方式。数据量大时效率低。</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先将整个待排序记录序列分割成若干个子序列，在子序列中分别进行直接插入排序，待整个序列基本有序时，对全体记录进行一次直接插入排序。<br>是对直接插入排序的一种改进。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>两两比较相邻记录，如果反序则交换，直到没有反序的记录为止。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>首先选一个轴值，将待排序的记录划分为独立的两部分，然后分别对这两部分重复该过程，知道整个序列有序。<br>是对冒泡排序的一种改进。</p>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>第i趟排序在待排序序列中选取关键码最小的记录，并和第i个记录交换，作为有序序列的第i个记录。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>将待排序的记录序列构造称一个堆，然后将堆顶记录移走，并将剩余的记录再调整成堆，直到堆中只有一个记录为止。<br>是对简单选择排序的一种改进。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将若干有序序列逐步归并，最终归并为一个有序序列。<br>二路归并排序： 归并排序中最简单的排序方法，两两归并。</p>
<h3 id="桶式排序"><a href="#桶式排序" class="headerlink" title="桶式排序"></a>桶式排序</h3><p>假设待排序记录的值都在 0~m-1之间，设置m个桶，首先将值为i的记录分配到第i个桶中，然后再将各个桶中的记录依次收集起来。</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>将关键码看成由若干个子关键码复合而成，然后借助分配和收集操作采用LSD方法进行排序。</p>
<h2 id="各排序算法比较"><a href="#各排序算法比较" class="headerlink" title="各排序算法比较"></a>各排序算法比较</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th>稳定排序</th>
<th>平均时间复杂度</th>
<th>最坏时间复杂度</th>
<th>空间复杂度</th>
<th>简单性</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td>稳定</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>简单算法</td>
</tr>
<tr>
<td>希尔排序</td>
<td>不稳定</td>
<td>O(n*logn)~O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>改进算法</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>稳定</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>简单算法</td>
</tr>
<tr>
<td>快速排序</td>
<td>不稳定</td>
<td>O(n*logn)</td>
<td>O(n^2)</td>
<td>O(logn)~O(n)</td>
<td>改进算法</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>不稳定</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>简单算法</td>
</tr>
<tr>
<td>堆排序</td>
<td>不稳定</td>
<td>O(n*logn)</td>
<td>O(n*logn)</td>
<td>O(1)</td>
<td>改进算法</td>
</tr>
<tr>
<td>归并排序</td>
<td>稳定</td>
<td>O(n*logn)</td>
<td>O(n*logn)</td>
<td>O(n)</td>
<td>改进算法</td>
</tr>
<tr>
<td>桶式排序</td>
<td>稳定</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(m)</td>
<td>简单算法</td>
</tr>
<tr>
<td>基数排序</td>
<td>稳定</td>
<td>O(d(n+m))</td>
<td>O(d(n+m))</td>
<td>O(m)</td>
<td>改进算法</td>
</tr>
</tbody></table>
<p>n越小，采用简单排序算法约合适，n越大，采用改进算法约合适。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-索引</title>
    <url>/2021/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%85%AD%EF%BC%89-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>如果数据规模很大或者需要长期保存，则必须以文件的形式存储在外存。<br>索引是为了加快查找速度而设计的一种数据结构，索引技术是组织大型数据库及磁盘文件的一种重要技术。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li><p>记录 数据元素</p>
</li>
<li><p>文件 指存储在外存上的记录集合</p>
</li>
<li><p>索引 将关键码与它对应的记录相关联的过程。一个索引隶属于一个文件，由多个索引项组成。</p>
</li>
<li><p>索引项 至少包含关键码和关键码对应的记录在存储器中的位置等信息。</p>
</li>
<li><p>静态索引 文件创建时生成索引结构，只有当文件再组织是才发生改变。</p>
</li>
<li><p>动态索引 文件创建是生成的索引，在文件执行插入、删除等操作时，索引结构本身也随之发生改变。</p>
</li>
<li><p>线性索引/索引表 索引项组织为线性结构。</p>
</li>
<li><p>树形索引 索引项组织为树形结构。</p>
</li>
<li><p>多级索引 对索引再建立一个索引。</p>
</li>
</ul>
<h2 id="线性索引技术"><a href="#线性索引技术" class="headerlink" title="线性索引技术"></a>线性索引技术</h2><ul>
<li>稠密索引</li>
<li>分开索引</li>
<li>多重表</li>
<li>倒排表</li>
</ul>
<h2 id="树形索引"><a href="#树形索引" class="headerlink" title="树形索引"></a>树形索引</h2><p>树形索引多用于动态索引，常采用链式存储结构实现。<br>二叉排序树时一种最基本的树形索引，许多其它索引都是从它发展而来的。</p>
<ul>
<li>2-3树</li>
<li>B-树</li>
<li>B+树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-查找表</title>
    <url>/2021/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%9F%A5%E6%89%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>查找表是由同一种数据元素构成的集合。<br>集合中的元素之间存在着完全松散的关系，也可以用其它数据结构来表示它。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol>
<li>查询某个特定的数据元素是否在表中；</li>
<li>检索某个特定的数据元素的各种属性；</li>
<li>在查找表中插入一个数据元素；</li>
<li>从查找表中删除某个数据元素。</li>
</ol>
<ul>
<li>静态查找表 只有查找操作，没有插入删除的查找表</li>
<li>动态查找表 有插入删除的查找表</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>关键码 可以标识一个记录的数据项</li>
<li>键值 关键码的值</li>
<li>主关键码 可以唯一地标识一个记录的关键码</li>
<li>此关键码 不能唯一标识一个记录的关键码</li>
<li><strong>查找结构</strong> 面向查找操作的数据结构</li>
</ul>
<h2 id="查找结构"><a href="#查找结构" class="headerlink" title="查找结构"></a>查找结构</h2><ul>
<li>线性表 适用于静态查找<ul>
<li>顺序表的查找</li>
<li>有序表的查找</li>
<li>折半查找技术</li>
<li>分块查找/索引顺序表查找</li>
</ul>
</li>
<li>树表 适用于动态查找<ul>
<li>二叉排序树</li>
<li>B-树</li>
</ul>
</li>
<li>散列表 均使用<ul>
<li>散列技术</li>
</ul>
</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>关心整体性能。<br>平均查找长度。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-分治法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89-%E5%88%86%E6%B2%BB%E6%B3%95/</url>
    <content><![CDATA[<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同。递归地解这些子问题，然后将各子问题的解合并到原问题的解。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>归并排序</li>
<li>快速排序</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-动态规划</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>与分治法类型，也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。<br>与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。</p>
<p>如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。为了达到这个目的，可以用一个表记录所有已解决的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>找出最优解的性质，并刻画其结构特征；</li>
<li>递归地定义最优值；</li>
<li>以自底向上的方式计算出最优值；</li>
<li>根据计算最优值是得到的信息，构造最优解。</li>
</ol>
<h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><h3 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h3><p>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p>
<h3 id="重叠子问题性质"><a href="#重叠子问题性质" class="headerlink" title="重叠子问题性质"></a>重叠子问题性质</h3><p>每次产生的子问题并不总是新问题，有些子问题被反复计算多次。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>矩阵连乘</li>
<li>最长公共子序列</li>
<li>0-1背包问题</li>
<li>最优二叉搜索树</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-贪心算法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%883%EF%BC%89-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>贪心算法总是做出在当前看来最好的选择。贪心算法并不从整体最优考虑，它所做出的选择只是在某种意义上的局部最优选择。贪心算法得到的最终结果也是整体最优的。</p>
<h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><p>贪心算法通过一系列的选择得到问题的解。它所做出的每一个选择都时当前状态下的最好选择，即贪心选择。</p>
<h3 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h3><p>指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。</p>
<h3 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h3><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</p>
<h2 id="贪心-VS-动态规划"><a href="#贪心-VS-动态规划" class="headerlink" title="贪心 VS 动态规划"></a>贪心 VS 动态规划</h2><p>都要求问题具有最优子结构性质。</p>
<p>在动态规划算法中，每步所做出的选择往往依赖于相关子问题的解。因而只有解出相关子问题后，才能做出选择。<br>而在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择，然后再去解做出这个选择后产生的相应的子问题。</p>
<p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做出依次贪心选择就将所求问题简化为规模更小的子问题。</p>
<p>0-1背包问题与背包问题。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>哈夫曼编码</li>
<li>单源最短路径<br>  给定带权有向图G=(V, E)，其中每条边的权时非负实数。另外，还给定V中的一个顶点，称为源。计算从源到所有其它各顶点的最短路长度（路上各边权之和）。</li>
<li>最小生成树<ul>
<li>Prim 算法</li>
<li>Kruskal 算法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-回溯法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%884%EF%BC%89-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>从开始结点（根节点）出发，以深度优先方式搜索整个解空间。这个开始结点称为活结点，同时也称为当前的扩展结点。在当前扩展结点处，搜索向纵深方向移至一个新结点。这个新节点成为新的活结点，并称为当前扩展结点。如果在当前扩展结点处不能再向纵深方向移动，则当前扩展结点就称为死结点。此时，应往回移动（回溯）至最近的活结点处，并使这个活结点成为当前扩展结点。回溯法以这种工作方式递归地再解空间中搜索，直至找到所要求的解或解空间中已无活结点时为止。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>针对所给问题，定义问题的解空间；</li>
<li>确定易于搜索的解空间结构；</li>
<li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li>
</ol>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ul>
<li>递归回溯 用递归方法实现回溯法。</li>
<li>迭代回溯 用树的非递归深度优先遍历算法，可将回溯法表示为一个非递归迭代过程。</li>
</ul>
<h2 id="解空间树"><a href="#解空间树" class="headerlink" title="解空间树"></a>解空间树</h2><ul>
<li>子集树<br>当所给问题是从n各元素的集合S中找出S满足某种性质的子级时，相应的解空间树称为子集树。<br>通常有2^n+1个结点，2^n个叶子结点。遍历需要Ω(2^n)计算时间。</li>
<li>排列树<br>当所给问题时确定n各元素满足某种性质的排列时，相应的解空间树称为排列树。<br>通常有n!个叶子结点。遍历需要Ω(n!)计算时间。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>0-1背包问题</li>
<li>最大团问题</li>
<li>图的m着色问题</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法设计-分支限界法</title>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%EF%BC%885%EF%BC%89-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>以广度优先或以最小耗费/最大效益有限的方式搜索问题的解空间树。每一个活结点只有依次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点将被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。</p>
<h2 id="分支限界-VS-回溯"><a href="#分支限界-VS-回溯" class="headerlink" title="分支限界 VS 回溯"></a>分支限界 VS 回溯</h2><p>都是在解空间树上搜索问题解的算法。</p>
<p>回溯法的求解目标时找出解空间树中满足约束条件的所有解。而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p>
<p>求解目标不同，导致堆解空间树的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树。而分支限界法以广度优先或以最小耗费优先的方式搜索解空间树。</p>
<h2 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h2><ul>
<li>队列式分支限界法<br>将活结点表组织成一个队列，并按队列的FIFO原则选取下一个结点为当前扩展结点。</li>
<li>优先队列式分支限界法<br>将活结点的表组织成一个优先队列，并按优先队列中规定的结点优先级选取优先级最高的下一个结点成为当前扩展结点。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>单源最短路径问题</li>
<li>0-1背包问题</li>
<li>最大团问题</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>CPU</title>
    <url>/2020/07/15/%E7%94%9F%E6%B4%BB/CPU/</url>
    <content><![CDATA[<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>CPU架构是CPU厂商给属于同一系列的CPU产品定的一个规范，是区分不同类型的CPU的重要标识。  <br>主流架构有inter公司、AMD公司的×86架构，IBM公司的PowerPC架构，ARM公司的ARM架构。</p>
<h2 id="厂商"><a href="#厂商" class="headerlink" title="厂商"></a>厂商</h2><h3 id="桌面"><a href="#桌面" class="headerlink" title="桌面"></a>桌面</h3><p>Inter，AMD，IBM，龙芯（国产）, VIA威盛（台湾）等。</p>
<h3 id="笔记本"><a href="#笔记本" class="headerlink" title="笔记本"></a>笔记本</h3><p>Inter，AMD，IBM，龙芯（国产）, VIA威盛（台湾）等。</p>
<h3 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h3><p>高通，联发科，华为，三星等。</p>
<h2 id="品牌"><a href="#品牌" class="headerlink" title="品牌"></a>品牌</h2><ul>
<li><p>inter<br>酷睿 core i3/i5/i7/i9<br>赛扬 Celeron<br>奔腾 Pentium<br>至强 Xeon 服务器<br>安腾 Itanium 服务器 </p>
<blockquote>
<p>性能： 酷睿 &gt; 奔腾 &gt; 赛扬</p>
</blockquote>
</li>
<li><p>AMD<br>闪龙 Sempron 新一代低端<br>速龙 Athlon 低端   <br>炫龙 Turion 笔记本 <br>羿龙 Phenom 中高端 <br>皓龙 Opteron 高端 <br>锐龙 Ryzen 3/5/7/9 可以与inter core系列抗衡  </p>
</li>
<li><p>高通<br>骁龙</p>
</li>
<li><p>联发科<br>天玑<br>helio</p>
</li>
<li><p>三星<br>Exynos</p>
</li>
<li><p>华为<br>麒麟</p>
</li>
<li><p>苹果<br>A</p>
</li>
</ul>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>基本一年更新一次，如酷睿系列、高通骁龙系列</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>显卡</title>
    <url>/2020/07/20/%E7%94%9F%E6%B4%BB/%E6%98%BE%E5%8D%A1/</url>
    <content><![CDATA[<h2 id="厂商"><a href="#厂商" class="headerlink" title="厂商"></a>厂商</h2><ul>
<li>AMD Radeon （镭龙） (A卡)</li>
<li>NVIDIA GeForce (精视)（N卡）</li>
<li>Inter（核显）</li>
</ul>
<h2 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h2><h3 id="NVIDIA"><a href="#NVIDIA" class="headerlink" title="NVIDIA"></a>NVIDIA</h3><h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><ul>
<li>GT 中低端</li>
<li>GTX 中高端<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4>代数 + 级别<h4 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h4></li>
<li>Ti 加强版<h4 id="顶级版"><a href="#顶级版" class="headerlink" title="顶级版"></a>顶级版</h4></li>
<li>Titan **</li>
</ul>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><h4 id="前缀-1"><a href="#前缀-1" class="headerlink" title="前缀"></a>前缀</h4><ul>
<li>RX （新命名）</li>
<li><del>R5/R7/R9  分别表示低端、中端、高端</del><h4 id="数字-1"><a href="#数字-1" class="headerlink" title="数字"></a>数字</h4>代数 + 级别<h4 id="后缀-1"><a href="#后缀-1" class="headerlink" title="后缀"></a>后缀</h4></li>
<li>D Dragon 中国特供版</li>
<li><del>X  加强版</del><h4 id="顶级版-1"><a href="#顶级版-1" class="headerlink" title="顶级版"></a>顶级版</h4></li>
<li>RX Vega **</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>电磁波</title>
    <url>/2020/07/20/%E7%94%9F%E6%B4%BB/%E7%94%B5%E7%A3%81%E6%B3%A2/</url>
    <content><![CDATA[<h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><ul>
<li>无线电波</li>
<li>红外线</li>
<li>紫外线</li>
<li>可见光</li>
<li>γ射线</li>
<li>X 射线</li>
</ul>
<h2 id="可见光原理"><a href="#可见光原理" class="headerlink" title="可见光原理"></a>可见光原理</h2><p>人类肉眼上的色素分子的谐振频率在可见光的范围之内。</p>
<h3 id="夜视仪原理"><a href="#夜视仪原理" class="headerlink" title="夜视仪原理"></a>夜视仪原理</h3><p>通过将低频电磁波放大到可见光的频率范围内，使人肉眼可见。</p>
<h2 id="无线电传输"><a href="#无线电传输" class="headerlink" title="无线电传输"></a>无线电传输</h2><h3 id="声音"><a href="#声音" class="headerlink" title="声音"></a>声音</h3><p>声音是通过声波传输，声波属于机械波，不是电磁波。</p>
<h3 id="wifi"><a href="#wifi" class="headerlink" title="wifi"></a>wifi</h3><h3 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h3><h3 id="无线电"><a href="#无线电" class="headerlink" title="无线电"></a>无线电</h3><p>高频比低频传输的远。</p>
<h4 id="发射"><a href="#发射" class="headerlink" title="发射"></a>发射</h4><ul>
<li>发射任务<ol>
<li>将声音转换为电信号。</li>
<li>产生一定功率的高频振荡。</li>
<li>用音频信号控制高频振荡的某一参数，即调制。<br> 4. 发送电磁波。</li>
</ol>
</li>
<li>发射机组成<br>话筒，高频振荡器，调制器，高频放大器，发射天线，电源。<h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4></li>
<li>接收任务<ol>
<li>根据频率选择要接收的信号。</li>
<li>从高频电磁波中取出音频资源，即解调。</li>
<li>信号输出到播放设备。</li>
</ol>
</li>
</ul>
<h3 id="微波炉"><a href="#微波炉" class="headerlink" title="微波炉"></a>微波炉</h3><p>水分子本征频率在微波的频率范围内。<br>通过 磁控管 产生微波，带动水分子振荡，水分子振荡越激烈，温度越高。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-线性结构</title>
    <url>/2021/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><p>有序数据元素的集合。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>集合中必存在唯一的“第一个元素”；</li>
<li>集合中必存在唯一的“最后的元素”；</li>
<li>除最后元素外，其它数据元素均有唯一的“后继”；</li>
<li>除第一个元素外，其它数据元素均有唯一的“前驱”。</li>
</ol>
<h2 id="常用结构"><a href="#常用结构" class="headerlink" title="常用结构"></a>常用结构</h2><ul>
<li>线性表<ul>
<li>顺序表</li>
<li>单链表</li>
<li>循环链表</li>
<li>双向链表</li>
<li>静态链表</li>
</ul>
</li>
<li>栈</li>
<li>队列</li>
</ul>
<h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>不是线性结构，是由线性结构组成。</p>
<ul>
<li>数组</li>
<li>广义表</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>计算机</title>
    <url>/2020/07/14/%E7%94%9F%E6%B4%BB/%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="冯诺依曼体系"><a href="#冯诺依曼体系" class="headerlink" title="冯诺依曼体系"></a>冯诺依曼体系</h2><p>输入设备、输出设备、计算器、存储器、控制器</p>
<h2 id="电脑组成部分"><a href="#电脑组成部分" class="headerlink" title="电脑组成部分"></a>电脑组成部分</h2><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>存储设备<br>优点：空间大<br>缺点：读写速度慢  </p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>临时储存区域<br>优点：读写速度大于硬盘，差不多10倍<br>缺点：空间小，断电清除  </p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>中央处理器，运算器、控制器</p>
<ul>
<li>多核CPU与多个CPU  <br>多核CPU成本高，但是性能好，多个CPU成本低，但性能差</li>
</ul>
<h3 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h3><p>显示芯片、显存、相关电路组成</p>
<ul>
<li>集成显卡<br>电路集成在主板上，一般与CPU共用内存</li>
<li>独立显卡<br>单独的显卡主板、显存</li>
<li>核芯显卡<br>CPU与GPU合二为一</li>
</ul>
<h3 id="其它设备"><a href="#其它设备" class="headerlink" title="其它设备"></a>其它设备</h3><p>风扇  <br>电源  <br>显示器  <br>打印机  </p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>C 介绍</title>
    <url>/2021/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>为了编写Unix系统，早期使用汇编语言，为了编写Unix系统，创建了C。但其发展早已超出了作为Unix操作系统的初衷。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>1973年 C语言诞生。<br>1978 K&amp;R 《The C Programming Language》 出版。<br>1983 ANSI（American National Standards Institute 美国国家标准学会）成立C标准委员会，建立C语言的标准。<br>1989 ANSI发布了第一个完整的C标准 ANSI X3.159-1989，简称C89。<br>1990 ISO（International Standard Organization 国际标准化组织）发布了 ISO/IEC 9899:1990，内容与C89一致，简称 C90。<br>1999 ISO发布了ISO/IEC 9899:1999， 简称 C99。<br>2011 ISO发布了ISO/IEC 9899:2011， 简称 C11。<br>2018 ISO发布了ISO/IEC 9899:2018， 简称 C18。</p>
<h2 id="基于C的语言"><a href="#基于C的语言" class="headerlink" title="基于C的语言"></a>基于C的语言</h2><p>C++：包含了所有C的特性，增加了类和其它特性以支持面向对象编程。<br>Java：基于C++，所以也继承了许多C的特性。<br>C#：由C++和Java发展起来的一门语言。<br>Prel: 脚本语言，发展过程中采取了许多C的特性。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>运行速度快、高效 </li>
<li>功能强大</li>
<li>灵活 为了系统编程设计，但不是只能编写系统。非法的操作在C中是允许的。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>危险性高</li>
<li>没有模块化</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>数据类型</li>
<li>流程控制语句</li>
<li>函数</li>
<li>编译 预处理阶段对程序文本进行宏替换、包含其它源文件以及进行条件编译。</li>
<li>处理大部分计算机能够处理的对象，如字符、数字、地址。</li>
<li>不提供直接处理复合对象的操作。</li>
<li>单线程</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>C 标准库</title>
    <url>/2021/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C-%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<h2 id="标准输入输出-lt-stdio-h-gt"><a href="#标准输入输出-lt-stdio-h-gt" class="headerlink" title="标准输入输出 &lt;stdio.h&gt;"></a>标准输入输出 &lt;stdio.h&gt;</h2><p>stdio standard input and output</p>
<p>stdin 标准输入<br>stdout 标准输出<br>stderr 标准错误输出</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>int getchar(void)</td>
<td>从标准输入（一般是键盘）中一次读取一个字符</td>
</tr>
<tr>
<td>int putchar(int)</td>
<td>将字符送至标准输出上</td>
</tr>
<tr>
<td>int printf(char *format, arg1, …)</td>
<td>格式化输出</td>
</tr>
<tr>
<td>int scanf(char *format, …)</td>
<td>格式化输入</td>
</tr>
<tr>
<td>int sscanf(char *string, char *format, arg1, …)</td>
<td>从一个字符串中读取字符序列</td>
</tr>
<tr>
<td>FILE *fopen(char *name, char *mode)</td>
<td>打开文件</td>
</tr>
<tr>
<td>int getc(FILE *fp)</td>
<td>从文件中返回下一个字符</td>
</tr>
<tr>
<td>int putc(int c, FILE *fp)</td>
<td>将字符写入文件中</td>
</tr>
<tr>
<td>int fscanf(FILE *fp, char *format,…)</td>
<td>文件格式化输入</td>
</tr>
<tr>
<td>int fprintf(FILE *fp, char *format,…)</td>
<td>文件格式化输出</td>
</tr>
<tr>
<td>int fclose(FILE *fp)</td>
<td>关闭文件</td>
</tr>
<tr>
<td>int feeor(FILE *fp)</td>
<td>流中出现错误，返回非零值</td>
</tr>
<tr>
<td>int feof(FILE *fp)</td>
<td>到达文件结尾，返回非零值</td>
</tr>
<tr>
<td>char *fgets(char *line, int maxline, FILE *fp)</td>
<td>从文件中读取下一个输入行，并放在字符数组中</td>
</tr>
<tr>
<td>int fput(char *line, FILE *fp)</td>
<td>将字符串写入到文件中</td>
</tr>
</tbody></table>
<h2 id="字符串操作-lt-string-h-gt"><a href="#字符串操作-lt-string-h-gt" class="headerlink" title="字符串操作 &lt;string.h&gt;"></a>字符串操作 &lt;string.h&gt;</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>strcat(char *s, char *t)</td>
<td>将t指向的字符串连接到s指向的字符串的末尾</td>
</tr>
<tr>
<td>strncat(char *s, char *t, int n)</td>
<td>将t指向的字符串中前n个字符连接到s指向的字符串的末尾</td>
</tr>
<tr>
<td>strcmp(char *s, char *t)</td>
<td>比较字符串大小</td>
</tr>
<tr>
<td>strncmp(char *s, char *t, int n)</td>
<td>比较字符串前n个字符大小</td>
</tr>
<tr>
<td>strcpy(char *s, char *t)</td>
<td>将t指向的字符串复制到s指向的位置</td>
</tr>
<tr>
<td>strlen(char *s)</td>
<td>返回s指向的字符串的长度</td>
</tr>
<tr>
<td>strchr(char *s, int c)</td>
<td>在s指向的字符串中查找c，返回第一次出现的位置的指针</td>
</tr>
<tr>
<td>strrchr(char *s, int c)</td>
<td>在s指向的字符串中查找c，返回最后一次出现的位置的指针</td>
</tr>
</tbody></table>
<h2 id="字符操作-lt-ctype-h-gt"><a href="#字符操作-lt-ctype-h-gt" class="headerlink" title="字符操作 &lt;ctype.h&gt;"></a>字符操作 &lt;ctype.h&gt;</h2><p>isalpha<br>isupper<br>islower<br>isdigit<br>isalnum<br>isspace<br>toupper<br>tolower</p>
<h2 id="通用-lt-stdlib-h-gt"><a href="#通用-lt-stdlib-h-gt" class="headerlink" title="通用 &lt;stdlib.h&gt;"></a>通用 &lt;stdlib.h&gt;</h2><p>atof<br>malloc<br>calloc<br>free<br>exit<br>system<br>frand</p>
<h2 id="数学函数-lt-math-h-gt"><a href="#数学函数-lt-math-h-gt" class="headerlink" title="数学函数 &lt;math.h&gt;"></a>数学函数 &lt;math.h&gt;</h2><p>sin<br>cos<br>atan2<br>exp<br>log<br>log10<br>pow<br>sqrt<br>fabs</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>C 语法</title>
    <url>/2021/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数据类型、运算符、表达式"><a href="#数据类型、运算符、表达式" class="headerlink" title="数据类型、运算符、表达式"></a>数据类型、运算符、表达式</h2><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><ul>
<li>数字及字母组成，以字母开头。</li>
<li>“_”被看作是字母，用来命名较长的变量名。</li>
<li>库例程的名字通常以下划线开头，因此变量不要以下划线开头。</li>
<li>严格区分大小写。</li>
<li>关键字不能用作变量，关键字中的字符小写。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>名称</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字符型</td>
<td>一个字节</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>所用机器中整数的最自然长度</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点型</td>
<td>-</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型</td>
<td>-</td>
</tr>
</tbody></table>
<h4 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h4><p>short/long 限定整型： short通常为16位，long通常为32位。<br>signed/unsigned: 限定char类型或任何整型。不带限定符的对象是否带符号取决于具体机器实现。<br>long double ： 表示高精度的浮点数。浮点型的长度取决于具体的实现。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="define"><a href="#define" class="headerlink" title="define"></a>define</h4><p>定义： #define 常量名 常量值 （宏定义）<br>常量类型通过后缀可以判断。无符号常量以u/U结尾。<br>const: 变量的值不能被修改。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举是一个常量整型值的列表。<br>定义： enum 枚举名 { 常量名[=值]… }<br>没有显示指定，第一个值为0，显示指定部分值，按最后一个指定值递增。</p>
<h4 id="define-VS-enum"><a href="#define-VS-enum" class="headerlink" title="define VS enum"></a>define VS enum</h4><p>enum常量值可以自动生成。<br>调试程序可以以符号形式打印出枚举变量的值。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>所有变量必须先声明后使用。<br>初始化表达式 变量名的后面紧跟一个等号以及一个表达式。<br>默认情况下，外部变量与静态变量将被初始化为0。未经显示初始化的自动变量的值为未定义值。</p>
<p>限定符<br>const 指定变量的值不能被修改。数组中所有元素的值都不能被修改。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>算术  + - * / %</li>
<li>关系  &gt; &gt;= &lt; &lt;=</li>
<li>相等性  == !=</li>
<li>逻辑  &amp;&amp; || （短路功能） ！</li>
<li>自增/自减  ++ –</li>
<li>按位  &amp; | ! ^ &lt;&lt; &gt;&gt; ~ （只能作用与整型）（算术移位/逻辑移位）</li>
<li>赋值  =</li>
<li>三元  ?:</li>
</ul>
<p>优先级<br><img src="/images/pasted-7.png" alt="upload successful"></p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>算术类型转换 运算时两个操作数类型不同，进行运算钱把“较低”的类型提升为“较高”的类型。（float不会自动转换为double）<br>赋值类型转换 超出的高位部分将被丢弃。<br>强制类型转换 显示类型转换 （类型名）表达式</p>
<p>char类型是较小的整型，因此在算术表达式中可以自由使用char类型的变量。</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>用运算符将运算对象连接起来的式子。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>语句： 表达式后加上一个分号（；）。分号是语句结束符。<br>程序块： 复合语句，把一组声明和语句用一对花括号（{}）括在一起。</p>
<ul>
<li>if-else 用于条件判定。</li>
<li>else-if 用于多路判定。</li>
<li>switch 多路判定语句，使用常量表达式。</li>
<li>while 循环体执行前对终止条件进行测试。</li>
<li>for 循环体执行前对终止条件进行测试；包含continue时可以和while转换。（包含简单的初始化和变量递增时更合适）</li>
<li>do-while 循环体执行后对终止条件进行测试，循环体被至少执行一次。</li>
<li>break 从switch中跳出，或在for、while、do-while最内层跳出。</li>
<li>continue 使for、while、do-while开始下一次的循环。</li>
<li>goto 跳到标号处执行。适合深度嵌套的处理过程。尽可能少的使用。</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名(参数声明表) &#123;</span><br><span class="line">    声明和语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果函数定义中省略了返回值类型，则默认为int类型。</li>
<li>声明函数参数类型及返回值类型。 返回值类型 函数名（参数类型）;。</li>
<li>没有声明过的函数会被隐式声明，返回值被假定为int类型，但并不对其参数进行假设。</li>
<li>函数不能嵌套定义。</li>
<li>没有参数使用void进行声明。</li>
<li>支持变长参数 … 。</li>
</ul>
<ul>
<li>自动变量 局部作用域变量。控制流进入变量作用域是系统自动为其分配存储空间，并在离开作用域时释放空间的一类变量。</li>
<li>外部变量 在函数外定义的全局变量。作用域：变量的定义处开始，到本程序文件的结尾。</li>
<li>内部变量 局部变量，指在一个函数内部或复合语句内部定义的变量。</li>
<li>全局变量 对所有程序文件都是可见的。</li>
</ul>
<h3 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h3><p>定义C中变量/函数的范围和声明周期。包括auto、register、static、extern。</p>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>只能修饰局部变量，局部变量的默认值。</p>
<h4 id="register"><a href="#register" class="headerlink" title="register"></a>register</h4><p>变量使用频率较高，将变量放在机器的寄存器上，使得程序更小，执行速度更快。但编译器可以忽略此选项。<br>register 声明只适用于自动变量以及函数的形式参数。</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li>静态变量 声明对象的作用域限定于被编译源文件的剩余部分。</li>
<li>静态函数 除了函数声明所在的文件外，其它文件都无法访问。</li>
<li>局部静态变量 一直占据存储空间。</li>
</ul>
<h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><p>只声明外部变量，不能初始化。<br>用于提供一个全局变量的引用。<br>声明后可在外部变量定义前使用该变量，或由其它源文件做定义。</p>
<h3 id="main函数参数"><a href="#main函数参数" class="headerlink" title="main函数参数"></a>main函数参数</h3><ul>
<li>int argc</li>
<li>char *argv[]</li>
</ul>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>包含函数声明和宏定义，被多个源文件中引用共享。<br>主要用于保存程序的声明。</p>
<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>预处理器是编译过程中单独执行的第一个步骤。</p>
<ul>
<li>文件包含 处理 #include 指令。</li>
<li>宏替换  替换 #define 变量。</li>
<li>条件包含  预处理执行的过程中进行计算。</li>
</ul>
<h2 id="指针、数组"><a href="#指针、数组" class="headerlink" title="指针、数组"></a>指针、数组</h2><p>指针： 一种保存变量地址的变量。<br>间接引用运算符： *。<br>取址运算符： &amp;。<br>void指针表示 无类型指针，没有特定的类型，因此可以指向任何类型的数据。参数声明表示可以是任意类型的指针。</p>
<h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><p>C中以传值的方式将参数值传递给被调用函数，被调用函数不能直接修改主调函数中变量的值。<br>指针参数使得被调用函数能够访问和修改主调函数中对象的值。<br>指针参数： 类型 *参数名， 。<br>返回指针： 类型 *函数名(…) {…} 。</p>
<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>数组： 存储在相邻内存区域中的对象组成的集合。<br>数组定义： 类型 变量[长度]; 。<br>指针加1： 指向指针所指对象的下一个对象。<br>通过数组和下标实现的表达式可等价的通过指针和偏移量实现。<br>当把数组作为参数传递给函数时，实际传递的是该数组第一个元素的地址，即一个存储地址值的变量，即指针。所以函数定义中，形参 char c[] 和 char *c 是等价的。<br>也可以将子数组的起始位置的指针传给函数，即将数组的一部分传递给了函数。</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>相同类型的指针之间的赋值运算。<br>指针同整数之间的加法和减法运算。<br>指向相同数组中元素的两个指针间的减法或比较运算。<br>将指针赋值为0或指针与0之间的比较运算。</p>
<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>存储指针的数组。指向指针的指针。<br>定义: 类型 *变量名[长度] 。<br>初始化： 字面量初始化。</p>
<h3 id="复杂声明"><a href="#复杂声明" class="headerlink" title="复杂声明"></a>复杂声明</h3><p>指针的指针 ： 类型 **参数名<br>数组的指针 ： 类型 (*参数名)[长度]<br>指针数组 ： 类型 *参数名[长度]<br>函数返回指针 : 类型 *函数名(…)<br>函数指针 ： 类型 (*函数名)(参数…)<br>？？？ ： 类型 (*(*函数名())[])()<br>？？？ ： 类型 (*(*函数名[长度])())[长度]</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>结构是一个或多个变量的集合。将一组相关的变量看作一个单元而不是各自读离的实体，因此有助于组织复杂的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct [结构标记] &#123;</span><br><span class="line">    类型 结构成员;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构成员、结构标记和普通变量可以采用相同名字而不会冲突。<br>声明： struct {…} x, y, z; 与基本类型变量声明一致。<br>成员运算符： . 。<br>初始化： 定义时初始化， 赋值初始化（结构名.成员）。<br>结构可以嵌套。</p>
<h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><p>向函数传参</p>
<ul>
<li><p>传递结构成员</p>
</li>
<li><p>传递结构  值传递，在函数里修改成员并不会影响原结构</p>
</li>
<li><p>传递结构指针<br>返回结构： struct 结构名 函数名(…) 。</p>
</li>
<li><p>结构数组</p>
</li>
<li><p>结构指针 struct 结构名 *函数名(…)</p>
</li>
<li><p>类型定义  typedef， 用来建立新的数据类型名。</p>
</li>
</ul>
<h2 id="联合-共用体"><a href="#联合-共用体" class="headerlink" title="联合/共用体"></a>联合/共用体</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union 共用体名 &#123;</span><br><span class="line">    类型 成员;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。<br>共用体的所有成员占用同一段内存，占用的内存等于最长的成员占用的内存。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>CRLF</title>
    <url>/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CRLF/</url>
    <content><![CDATA[<h1 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h1><blockquote>
<p>How/Why</p>
</blockquote>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul>
<li>windows 使用crlf回车换行</li>
<li>linux使用lf换行</li>
<li>macos 之前使用cr回车，现在使用lf换行</li>
</ul>
<h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><ul>
<li>idea 编辑文件使用系统默认换行符即可。</li>
<li>git默认配置 atuocrlf=true，检出/提交时会自动转换换行符。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>原码、补码、反码</title>
    <url>/2020/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/</url>
    <content><![CDATA[<h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>用二进制表示，用最高位表示符号。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>直观。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>负数的运算通过累加器来实现，原码的方式不支持减法。</p>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>正数的反码是其本身，负数的反码是除符号位，其它位取反。</p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ul>
<li>符号位与数值一起参与运算</li>
<li>循环进位（最高位相加有进位时，送到最低位相加）</li>
<li>结果也是反码。<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4>解决减法问题<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li>
</ul>
<p>+0 和 -0 有两种表示方法。</p>
<h4 id="循环进位"><a href="#循环进位" class="headerlink" title="循环进位"></a>循环进位</h4><ul>
<li>两个正数相加，进位表示溢出</li>
<li>两个负数相加，若结果不溢出，产生进位</li>
<li>一正一负相加，若结果为负，没有进位，若结果为正，产生进位。</li>
</ul>
<p>反码加法按照 循环进位 的法则来算才能保证其正确性。</p>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>正数的补码是其本身，负数的补码符号位不变，其余各位取反，最后+1。</p>
<h4 id="运算-1"><a href="#运算-1" class="headerlink" title="运算"></a>运算</h4><ul>
<li>符号位参与运算</li>
<li>最高位相加后若出现进位，则舍弃</li>
<li>结果也是补码<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4>解决 +0 -0问题，有更大的表示范围。</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="模"><a href="#模" class="headerlink" title="模"></a>模</h3><p>计量系统的计数范围，如时针的模是12。</p>
<h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>两个正数a,b，如果除以正数m所得余数相同，则称a，b对于模同余。</p>
<h3 id="负数取模"><a href="#负数取模" class="headerlink" title="负数取模"></a>负数取模</h3><p>x mod y = x - y * ⌈x / y⌉ (向上取整) </p>
<h3 id="补码、反码"><a href="#补码、反码" class="headerlink" title="补码、反码"></a>补码、反码</h3><p>补码、反码和原码同余，只是模不同。</p>
<p>在不考虑溢出的情况下，如果a、b同余，则 a + c = b + c。所以，负数的加法可以通过反码、补码来计算。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2020/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>最近做小数计算，发现double比long的最大值大了好多，甚至float最大值都比long最大值大，而float是32位存储空间，long是64位存储空间，带着这个疑问，进行深入探索。<br>PS: 本文所提到的所有类型，以Java语言为准。</p>
</blockquote>
<h2 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>存储空间(bit)</th>
<th>存储范围</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1</td>
<td>0/1</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>-128~127</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>0~65536</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>-2,147,483,648~2,147,483,647</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>-9,223,372,036,854,775,808~9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>-3.4028235E38~3.4028235E38</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>-1.7976931348623157E308~1.7976931348623157E308</td>
</tr>
</tbody></table>
<h3 id="long"><a href="#long" class="headerlink" title="long"></a>long</h3><p>想要保存比long最大值还大的整数，使用BigInteger，性能会有所降低。</p>
<h3 id="double-VS-long"><a href="#double-VS-long" class="headerlink" title="double VS long"></a>double VS long</h3><ul>
<li>double和long都是64位，double最大值远大于long最大值<blockquote>
<p>存储方式不一样，double中可以使用阶数存储。<br>double 64位 = 1位符号 + 11位阶码（带符号） + 52位尾数</p>
</blockquote>
</li>
<li>E308，为何是308次方<blockquote>
<p>log(2^(2^10-1)) 大于308小于309。 2^10-1: 阶码最大值，阶码首位为符号，正数从0开始。log(2^X): 计算机中2为阶底，转为以10为阶底。</p>
</blockquote>
</li>
<li>double有效数字为16位，long有效数字为19<blockquote>
<p>使用阶数存储，但是需要丢失末尾的精确度，会四舍五入。<br>2^52 = 4,503,599,627,370,496, 最大值为16位数，所以有效数字为16位。</p>
</blockquote>
</li>
</ul>
<h3 id="float-VS-int"><a href="#float-VS-int" class="headerlink" title="float VS int"></a>float VS int</h3><p>与double、long同理</p>
<h2 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h2><p>二进制浮点数算术标准。Java中float，double都符合该标准。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>计算机科学与技术</title>
    <url>/2021/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>计算机科学： 研究计算机及周围各种现象和规律的科学。亦即研究计算机系统结构、程序系统（即软件）、人工智能以及计算本身性质和问题的学科。<br>计算机技术： 指计算机领域中所御用的技术方法和技术手段，或指其硬件技术、软件技术及应用技术。</p>
<h2 id="计算机语言分类"><a href="#计算机语言分类" class="headerlink" title="计算机语言分类"></a>计算机语言分类</h2><blockquote>
<ul>
<li>解释型语言：运行时翻译成机器语言。效率比较低，依赖解释器。</li>
<li>编译型语言：运行前需要专门的编译过程，把程序编译为机器语言的文件。程序执行效率高，依赖编译器。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>系统语言：用来书写系统程序的程序设计语言。</li>
<li>脚本语言：用来控制软件应用程序。解释型语言。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>静态语言：强类型语言，变量类型在编译期就能确定。</li>
<li>动态语言：弱类型语言，变量类型在运行期才能确定。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>通用语言： 不专用于某一个特定的应用领域。</li>
<li>专用语言： 用于某些特定领域的程序设计语言。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>面向过程： 分析出解决问题所需的步骤，用函数实现步骤，使用时依次调用。</li>
<li>面向对象： 把构成问题的事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</li>
</ul>
</blockquote>
<h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><ul>
<li>1936，图灵机，一种抽象的计算模型。</li>
<li>1946-2，第一台计算机问世，ENIAC。第一代计算机（电子管）。面向机器编程。</li>
<li>1951，汇编语言。</li>
<li>1954，第二代计算机（晶体管）。面向机器编程。</li>
<li>1956，IPL。Information Processing Language。</li>
<li>1957，Fortran formula translation， 第一个编译型语言。</li>
<li>1958，第三代计算机（集成电路）。操作系统、高级编程语言的基础。</li>
<li>1958，LISP。List，Processor，基于列表处理。</li>
<li>1964，Simula 67 面向对象的起源。</li>
<li>1970，第四代计算机（大规模/超规模继承电路）。</li>
<li>1970，Pascal 主要在教学领域。第一个结构化程序设计语言。</li>
<li>1971，Basic</li>
<li>1971-1，第一个4位微处理器芯片Inter 4004，微型计算机时代。</li>
<li>1972，C。初衷为编写Unix操纵系统，发展远不止于此。</li>
<li>1973，Unix操作系统。</li>
<li>1978-6，16位微处理器芯片Inter 8086。</li>
<li>1983，C++ 命令式面向对象语言，以Simula 67 的方式对命令式的编程的面向对象扩展。</li>
<li>1983，Objective-C 另一个对C进行面向对象扩展的语言。</li>
<li>1985，MicroSoft发布Windows 1.0。</li>
<li>1987，PERL。</li>
<li>1989，Internet从军用转向民用。</li>
<li>1990/1991-8-6，HTML。Web服务器：超文本服务器，存储超文本文件的服务器。第一个浏览器。</li>
<li>1991，Python 面向对象解释式脚本语言。</li>
<li>1993，Ruby 纯面向对象解释式脚本语言。</li>
<li>1993，CGI（Common Gateway Interface）。</li>
<li>1995-5，Java。Applet用于浏览器客户端，EE用于浏览器服务端，ME用于小型设备。</li>
<li>1995-6，PHP Web服务器脚本语言。</li>
<li>1995-12，JavaScript 浏览器脚本语言。</li>
<li>2001，C# .net平台主语言。</li>
<li>2001，Visual Basic.net</li>
<li>2003，Groovy</li>
<li>2003，Scala</li>
<li>2009，Go</li>
<li>2011，Dart</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>数字化、信息化。<br>本文网络指计算机网络。</p>
<h3 id="三网"><a href="#三网" class="headerlink" title="三网"></a>三网</h3><ul>
<li>电信网络 提供电话、电报、传真等服务。</li>
<li>有线电视网络 利用光缆或同轴电缆来传送广播电视信号或本地播放的电视信号的网络。提供各种电视节目。</li>
<li>计算机网络 计算机通信网。能够迅速传送数据，获取各种资料。</li>
</ul>
<h3 id="三网融合"><a href="#三网融合" class="headerlink" title="三网融合"></a>三网融合</h3><p>相互渗透，互相兼容，并逐步整合称为全世界统一的信息通信网络。</p>
<h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>网络 由若干结点和连接这些结点的链路组成。</li>
<li>互联网 网络的网络。网络把计算机连接在一起，而互联网把网络连接在一起。</li>
<li>因特网 世界上最大的互联网络。</li>
<li>网络互联 硬件+软件。</li>
<li>ISP 因特网服务提供商（Internet Service Provider）。</li>
</ul>
<h3 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h3><ol>
<li>第一阶段： 从单个网络ARPANET向互联网发展。</li>
<li>第二阶段： 三级结构的互联网。主干网、地区网、校园网/企业网。</li>
<li>第三阶段： 多层次ISP结构的互联网。</li>
</ol>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>计算机通信： 主机A的某个进程和主机B的另一个进程进行通信。</p>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ul>
<li>C/S 客户-服务器模式。</li>
<li>p2p 对等方式（peer to peer）。</li>
</ul>
<h3 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h3><ul>
<li>电路交换 整个报文的比特流连续地从源点直达重点。</li>
<li>报文交换 整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li>
<li>分组交换 单个分组传送到相邻结点（整个报文的一部分），存储下来后查找转发表，转发到下一个结点。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="按网络作用范围"><a href="#按网络作用范围" class="headerlink" title="按网络作用范围"></a>按网络作用范围</h3><ul>
<li>广域网WAN Wide Area Network</li>
<li>城域网MAN Metropolitan Area Network</li>
<li>局域网LAN Local Area Network</li>
<li>个人区域网PAN Personal Area Network</li>
</ul>
<h3 id="按使用者"><a href="#按使用者" class="headerlink" title="按使用者"></a>按使用者</h3><ul>
<li>公用网</li>
<li>专用网</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>速率 传输数据的速率。</li>
<li>带宽 网络的通信线路传送数据的能力。表示在单位时间内从网络的某一点到另一点所能通过的最高数据率。</li>
<li>吞吐量 单位时间内通过某个网络的数据量。</li>
<li>时延 数据从网络的一端传送到另一端的时间。总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延。</li>
<li>时延带宽积 传播时延 * 带宽。</li>
<li>往返时间RTT Round-Trip Time。从数据发送方发送数据开始，到发送方收到来自接收方的确认。</li>
<li>利用率 </li>
</ul>
<h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>为进行网络中的数据交换而建立的规则、标准或约定，称为网络协议。主要由以下三要素组成：</p>
<ul>
<li>语法 数据与控制信息的结构或格式。</li>
<li>语义 需要发出何种控制信息，完成何种动作以及做出何种响应。</li>
<li>同步 事件实现顺序的详细说明。</li>
</ul>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>各层之间是独立的、灵活性好、结构上可分隔开、易于实现和维护、能促进标准化工作。</p>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>把计算机网络的各层及其协议的集合，称为网络的体系结构。即计算机的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义。<br>体系结构是抽象的，而实现则是具体的。</p>
<h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI/RM: 开放系统互联模型（Open Systems Interconnection Reference Model）。</p>
<ul>
<li>⑦ 应用层 用户接口</li>
<li>⑥ 表示层 数据的表现形式，特定功能的实现</li>
<li>⑤ 会话层 对应用回话的管理同步</li>
<li>④ 传输层 可靠与不可靠的传输，传输前的错误检测，监控。</li>
<li>③ 网络层 提供逻辑地址，选路</li>
<li>② 数据链路层 成帧，用MAC地址访问媒介，错误检测与修正</li>
<li>① 物理层 设备之间的比特流传输，物理接口，电气特性。</li>
</ul>
<p>OSI七层模型只获得了一些理论研究的成果，以失败告终。</p>
<h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><ul>
<li>应用层 应用层+表示层+会话层</li>
<li>传输层</li>
<li>网络互联层</li>
<li>网络接口层 数据链路层+物理层</li>
</ul>
<p>实际事实标准。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>一般用来表示向某一个方向传送信息的媒体。<br>根据双方信息交互方式分类：</p>
<ul>
<li>单工通信 只能有一个方向的通信而美誉反方向的交互。（无线电广播、有线电广播、电视广播）</li>
<li>半双工通信 通信的双方都可以发送信息，单不能双方同时发送。</li>
<li>全双工通信 通信的双方可以同时发送和接受信息。</li>
</ul>
<h3 id="适配器-网卡"><a href="#适配器-网卡" class="headerlink" title="适配器/网卡"></a>适配器/网卡</h3><p>适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的。而适配器和计算机之间的通信是通过计算机主板上的I/O总线以并行传输方式进行的。</p>
<h3 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h3><p>非对称数字用户线ADSL技术是用数字技术对现有模拟电话用户线进行改造。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>是一种计算机局域网技术。</p>
<h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><p>PPP point to point protocol 点对点协议。<br>PPPOE PPP Over Ethernet 以太网上的点对点协议。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>任务：为分组交换网上的不同主机提供通信服务。<br>协议： IP</p>
<p>正向查询： 域名 -&gt; IP<br>反向查询： IP -&gt; 域名</p>
<h3 id="网段"><a href="#网段" class="headerlink" title="网段"></a>网段</h3><table>
<thead>
<tr>
<th>网段</th>
<th>最大网络数</th>
<th>ip范围</th>
<th>最大主机数</th>
<th>私有ip范围</th>
<th>子网掩码</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>2^7-2</td>
<td>1.0.0.0-126.255.255.255</td>
<td>2^24-2</td>
<td>10.0.0.0-10.255.255.255</td>
<td>255.0.0.0</td>
</tr>
<tr>
<td>B</td>
<td>2^14</td>
<td>128.0.0.0-191.255.255.255</td>
<td>2^16-2</td>
<td>172.16.0.0-127.31.255.255</td>
<td>255.255.0.0</td>
</tr>
<tr>
<td>C</td>
<td>2^21</td>
<td>192.0.0.0-223.255.255.255</td>
<td>2^8-2</td>
<td>192.168.0.0-192.168.255.255</td>
<td>255.255.255.0</td>
</tr>
</tbody></table>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>任务： 向两个主机中进程之间的通信提供通用的数据传输服务。<br>协议： TCP、UDP</p>
<ul>
<li>TCP 传输控制协议 提供面向连接的，可靠的数据传输服务。数据传输的单位是报文段。</li>
<li>UDP 用户数据报协议 提供无连接的，不可靠的数据传输服务。数据传输的单位是用户数据报。</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>任务： 通过应用进程间的交互来完成特定网络应用。<br>协议： 应用进程间通信和交互的规则。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>Domain Name System，域名系统。</p>
<h4 id="域名空间结构"><a href="#域名空间结构" class="headerlink" title="域名空间结构"></a>域名空间结构</h4><ul>
<li>. 便于分级管理，根域。</li>
<li>顶级域名/一级域名</li>
<li>二级域名</li>
<li>主机名</li>
</ul>
<h4 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h4><p>递归查询： 成功相应/失败相应。允许向其它DNS插叙<br>迭代查询： 服务器收到一次查询返回一次结果，结果不定。</p>
<h2 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h2><p>无线局域网 WLAN<br>无线城域网 WMAN<br>无线局域网标准 IEEE 802.11 凡使用802.11系列协议的局域网又称为WiFI。</p>
<h2 id="移动通信"><a href="#移动通信" class="headerlink" title="移动通信"></a>移动通信</h2><p>种类： 蜂窝移动通信（使用最多）、卫星移动通信、集群移动通信、无绳电话通信…<br>第一代蜂窝移动通信：1G<br>第二代蜂窝移动通信：2G…</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="TCP-IP连接"><a href="#TCP-IP连接" class="headerlink" title="TCP/IP连接"></a>TCP/IP连接</h3><p>三次握手，四次挥手</p>
<h3 id="常见协议端口"><a href="#常见协议端口" class="headerlink" title="常见协议端口"></a>常见协议端口</h3><ul>
<li>FTP 文件传输协议 20 21</li>
<li>SSH 安全shell协议 22</li>
<li>telnet 远程登录协议 23</li>
<li>DNS 域名系统 53</li>
<li>HTTP 超文本传输协议 80</li>
<li>HTTPS 43</li>
<li>SMTP 简单邮件传输协议 25</li>
<li>POP3 邮局协议3代 110</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>进制转换</title>
    <url>/2020/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="十进制-gt-二进制"><a href="#十进制-gt-二进制" class="headerlink" title="十进制 -&gt; 二进制"></a>十进制 -&gt; 二进制</h2><p>除二取余，余数倒序。</p>
<h2 id="二进制-gt-十进制"><a href="#二进制-gt-十进制" class="headerlink" title="二进制 -&gt; 十进制"></a>二进制 -&gt; 十进制</h2><p>按权展开相加。</p>
<h2 id="二进制-gt-八进制"><a href="#二进制-gt-八进制" class="headerlink" title="二进制 -&gt; 八进制"></a>二进制 -&gt; 八进制</h2><p>3位二进制数按权展开相加得到一位八进制数。</p>
<h2 id="八进制-gt-二进制"><a href="#八进制-gt-二进制" class="headerlink" title="八进制 -&gt; 二进制"></a>八进制 -&gt; 二进制</h2><p>八进制数同故宫除2取余法，得到二进制数，每个八进制为三个二进制，不足时在最左边补零。</p>
<h2 id="二进制-gt-十六进制"><a href="#二进制-gt-十六进制" class="headerlink" title="二进制 -&gt; 十六进制"></a>二进制 -&gt; 十六进制</h2><p>4位二进制数按权展开相加得到一位十六进制数。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一-定义"><a href="#一-定义" class="headerlink" title="一. 定义"></a>一. 定义</h2><pre><code>对其他对象提供一种代理以控制对这个对象的访问。
</code></pre>
<h2 id="二-原理"><a href="#二-原理" class="headerlink" title="二. 原理"></a>二. 原理</h2><pre><code>在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
动态代理实际上是JDK在运行期动态创建class字节码并加载的过程。
</code></pre>
<h2 id="三-JDK-静态代理"><a href="#三-JDK-静态代理" class="headerlink" title="三. JDK 静态代理"></a>三. JDK 静态代理</h2><pre><code>代理类与目标类实现同一个接口，调用目标对象的方法时，改为调用代理类的方法，通过代理类及反射来调用目标对象的方法，这样就可以通过在调用目标方法前后进行统一的逻辑处理。
在编译器就已经创建好代理对象。
</code></pre>
<ol>
<li>创建接口。</li>
<li>创建目标类。</li>
<li>创建代理类，通过构造方法注入目标类对象。</li>
<li>实例化目标类，传入目标类对象实例化代理类，调用代理类方法。<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4> 编译时产生class字节码文件，可以直接使用，效率高。    <h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4> 扩展性不足。<h2 id="四-JDK-动态代理"><a href="#四-JDK-动态代理" class="headerlink" title="四. JDK 动态代理"></a>四. JDK 动态代理</h2> 在运行期动态创建代理对象。<br> 采用JDK反射技术，基于接口，动态创建的代理类和目标类实现同一个接口，如果没有接口，则无法进行动态代理。<br> 动态代理实际上是JDK在运行期动态创建class字节码并加载的过程</li>
<li>创建接口。</li>
<li>创建目标类。</li>
<li>创建处理器，实现InvocationHandler接口，实现invoke方法。</li>
<li>通过Proxy.newProxyInstance()方法创建动态代理实例。<br> 参数1：接口的类加载器<br> 参数2：代理需要实现的接口数组<br> 参数3：InvocationHandler实例</li>
<li>调用动态代理实例的方法。<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4> 反射机制在生成类的过程中比较高效。<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4> 执行时通过发射调用目标类接口方法较慢。<br> 只能代理有接口实现的类。<h2 id="五-CGLIB代理"><a href="#五-CGLIB代理" class="headerlink" title="五. CGLIB代理"></a>五. CGLIB代理</h2> 采用底层字节码技术（asm），基于继承，因此无法代理final类，static方法，final方法。<br> // TODO 具体实现细节<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4> asm在生成类之后的相关代理类执行过程中比较高效。<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4> asm生成类的过程比较慢。</li>
</ol>
<p><em><strong>END</strong></em></p>
]]></content>
  </entry>
  <entry>
    <title>设计模式-工厂</title>
    <url>/2021/12/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<h2 id="简单工厂-静态工厂"><a href="#简单工厂-静态工厂" class="headerlink" title="简单工厂/静态工厂"></a>简单工厂/静态工厂</h2><p>将创建对象的操作解耦，以便扩展。<br>严格来说，不是一种设计模式。</p>
<h3 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        String type = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductA();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductB();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单工厂实现"><a href="#简单工厂实现" class="headerlink" title="简单工厂实现"></a>简单工厂实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product ac = SimpleFactory.createProduct(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ac.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul>
<li>简单工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<br>解耦。客户端只关系参数，而不关系产品的创建。</li>
<li>缺点<br>简单工厂使用了static，无法继承扩展。</li>
</ul>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。<br>相比于简单工厂，不同的工厂类创建产品的过程可能是不一样的。</p>
<h3 id="一般实现-1"><a href="#一般实现-1" class="headerlink" title="一般实现"></a>一般实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        String type = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductA();</span><br><span class="line">                <span class="comment">// product.doingA();</span></span><br><span class="line">                <span class="comment">// product.doingB();</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ProductB();</span><br><span class="line">                <span class="comment">// product.doingC();</span></span><br><span class="line">                <span class="comment">// product.doingA();</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> ProductA();</span><br><span class="line">        <span class="comment">// product.doingA();</span></span><br><span class="line">        <span class="comment">// product.doingB();</span></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> ProductB();</span><br><span class="line">        <span class="comment">// product.doingC();</span></span><br><span class="line">        <span class="comment">// product.doingA();</span></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> AFactory();</span><br><span class="line">        Product product = factory.createProduct();</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><ul>
<li>抽象工厂</li>
<li>具体工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>抽象出抽象工厂、抽象产品；</li>
<li>创建具体产品，具体工厂；</li>
<li>实现具体工厂创建产品；</li>
<li>修改客户端调用方式。</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<br>解耦，典型的解耦框架。<br>灵活性增强，扩展时只需添加新的工厂及产品，无需修改现有类。</li>
<li>缺点<br>产品过多会导致类很多。<br>抽象产品只能创建一种产品。（可用抽象工厂模式改善）</li>
</ul>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul>
<li>客户端从要知道创建哪个产品，改为要知道用哪个工厂创建产品，意义何在<br>对象的创建是复杂的过程，客户端只需知道产品是由谁创建的，而不需关系是怎么创建的。</li>
<li>工厂所创建对象的过程到底是不是复杂的<br>我觉得不一定是很复杂的过程，但总归不是new一个对象那么简单。如果只是new，那用简单工厂就可以实现了。而每个工厂创建的过程应该是不尽相同的，由此产生了差异化，从而需要抽象工厂的角色。</li>
<li>抽象工厂与抽象产品是同级的概念，其各自可以有多级，每有一级抽象工厂，就可以有一次抽象产品与之对应（也可以用上级抽象产品对应）。</li>
<li>具体工厂可以是一个简单工厂，直接new对象，或者通过类型new不同的对象。</li>
<li>只有一个具体工厂的情况<br>存在多个产品，如果后续还可能扩展，则使用工厂方法，如后续不太可能扩展，则使用简单工厂。<br>只有一个产品，那可以考虑使用其他的模式，或者不使用。</li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>提供一个创建一组相关或相互依赖对象的接口，且无须指定所要产品的具体类，得到同族的不同等级的产品。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>产品等级结构 产品的继承结构。</li>
<li>产品族 指由同一个工厂生产的，位于不同产品等级结构中的一组产品。</li>
</ul>
<h3 id="模式实现-1"><a href="#模式实现-1" class="headerlink" title="模式实现"></a>模式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product1</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1A</span> <span class="keyword">extends</span> <span class="title">Product1</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1B</span> <span class="keyword">extends</span> <span class="title">Product1</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product2</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2A</span> <span class="keyword">extends</span> <span class="title">Product2</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2B</span> <span class="keyword">extends</span> <span class="title">Product2</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    Product1 product1;</span><br><span class="line">    Product2 product2;</span><br><span class="line">    Factory factory;</span><br><span class="line">    Product (Factory factory) &#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">constitute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.product1 = factory.createProduct1();</span><br><span class="line">        <span class="keyword">this</span>.product2 = factory.createProduct2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Product1 <span class="title">createProduct1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Product2 <span class="title">createProduct2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product1 <span class="title">createProduct1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product1 product1 = <span class="keyword">new</span> Product1A();</span><br><span class="line">        <span class="comment">// product1.doingA();</span></span><br><span class="line">        <span class="comment">// product1.doingB();</span></span><br><span class="line">        <span class="keyword">return</span> product1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product2 <span class="title">createProduct2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product2 product2 = <span class="keyword">new</span> Product2A();</span><br><span class="line">        <span class="comment">// product2.doingA();</span></span><br><span class="line">        <span class="comment">// product2.doingB();</span></span><br><span class="line">        <span class="keyword">return</span> product2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product1 <span class="title">createProduct1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product1 product1 = <span class="keyword">new</span> Product1B();</span><br><span class="line">        <span class="comment">// product1.doingC();</span></span><br><span class="line">        <span class="comment">// product1.doingA();</span></span><br><span class="line">        <span class="keyword">return</span> product1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product2 <span class="title">createProduct2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product2 product2 = <span class="keyword">new</span> Product2B();</span><br><span class="line">        <span class="comment">// product2.doingC();</span></span><br><span class="line">        <span class="comment">// product2.doingA();</span></span><br><span class="line">        <span class="keyword">return</span> product2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> Product(<span class="keyword">new</span> AFactory());</span><br><span class="line">        product.constitute();</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line">        product = <span class="keyword">new</span> Product(<span class="keyword">new</span> BFactory());</span><br><span class="line">        product.constitute();</span><br><span class="line">        <span class="comment">// product.doing();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h3><ul>
<li>抽象工厂</li>
<li>具体工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
</ul>
<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><ol>
<li>从产品出抽象出相关或有依赖关系的产品族；</li>
<li>抽象出产品等级结构；</li>
<li>创建抽象工厂及具体工厂；</li>
<li>返回抽象工厂，创建产品族产品并使用。</li>
</ol>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<br>保证客户端始终只使用同一个产品族中的对象。</li>
<li>缺点<br>产品族扩展困难，要增加一个系列的某一产品，既要修改抽象工厂，又要修改具体工厂。</li>
</ul>
<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><ul>
<li>当系统中只存在一个等级结构的产品时，抽象工厂模式退化为工厂方法模式。</li>
<li>一组相关或相互依赖的对象，那么这些对象是怎么使用的呢？怎么才能表现出相关或相互依赖的特性？<br>在Head First中，有一个更大的对象，产品是对象的一部分，客户端实际需要的是一个大产品，而抽象工厂创建的是每个小产品，最后由大产品的容器进行组装返回给客户端。<br>还有其它形式？</li>
</ul>
<h2 id="工厂方法-与-抽象工厂"><a href="#工厂方法-与-抽象工厂" class="headerlink" title="工厂方法 与 抽象工厂"></a>工厂方法 与 抽象工厂</h2><ul>
<li>实现方式 工厂方法使用继承，抽象工厂使用组合。</li>
<li>使用方式 实例化一个工厂方法的工厂，由工厂创建产品对象；实例化一个抽象工厂的工厂，然后将它传入一个针对抽象类型的方法中，由该方法创建产品（使用工厂方法模式）并进行组装。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>Calender (工厂方法) ？<br>Collection (抽象工厂) ？</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-策略</title>
    <url>/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>指对象有某个行为，但是在不同的场景中，该行为有不同的算法实现。<br>行为型模式。</p>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (ca) &#123;</span><br><span class="line">            result = computeA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            result = computeB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = computeC();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeA</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeB</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的条件，调用不同的方法。</p>
<h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (ca) &#123;</span><br><span class="line">            result = computeA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            result = computeB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = computeC();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeA</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeB</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computeC</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">        <span class="keyword">int</span> result = strategy.compute();</span><br><span class="line">        <span class="comment">// doing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context c = <span class="keyword">new</span> Context(<span class="keyword">new</span> StrategyA());</span><br><span class="line">        <span class="comment">// 根据条件设置具体的策略</span></span><br><span class="line">        <span class="keyword">if</span> (ca) &#123;</span><br><span class="line">            c.setStrategy(<span class="keyword">new</span> StrategyA());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            c.setStrategy(<span class="keyword">new</span> StrategyB());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.setStrategy(<span class="keyword">new</span> StrategyC());</span><br><span class="line">        &#125;</span><br><span class="line">        c.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象出统一接口，根据不同的条件使用对应的对象，调用接口的方法。<br>if可以使用switch代替，也可以将由工厂模式完成，实现工厂+策略的组合使用。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>策略接口</li>
<li>策略具体实现类</li>
<li>容器类/上下文</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>将调用的不同方法抽象出策略接口</li>
<li>将不同方法调整为具体策略实现类</li>
<li>将策略接口注入到之前的上下文对象中</li>
</ol>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点<br>算法、行为可以动态改变<br>扩展性良好，只需新增策略类<br>可以避免if判断</li>
<li>缺点<br>需要暴露所有策略类<br>每个策略都会产生一个新类，造成类过多</li>
</ul>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul>
<li>概念中的算法与行为，行为对应的是接口的方法，而接口的方法是不变的，即行为是不变的，变的只是行为的实现，即算法。</li>
<li>容器类存在的意义<ol>
<li>客户端与策略类解耦，改变、新增策略只需修改客户端代码。</li>
<li>根据定义，对象有某个行为，该对象应为上下文对象，而不是客户端对象，客户端只是调用上下文对象的方法，而不关心具体实现。</li>
</ol>
</li>
<li>客户端根据条件设置对应的策略，所以客户端需要知道所有的策略实现。</li>
<li>容器类与策略接口的关系应根据情况确定（持有（能否修改），参数传递）。</li>
</ul>
<h2 id="源码中的使用"><a href="#源码中的使用" class="headerlink" title="源码中的使用"></a>源码中的使用</h2><ul>
<li>JDK<br>Comparator - Collections<br>RejectedExecutionHandler - ThreadPoolExecutor</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-设计原则</title>
    <url>/2021/12/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ol>
<li><p>装饰器模式 （在不改变原有方法的基础上，对原有方法进行增强）</p>
<p> mybatis 二级缓存 CachingExecutor.java </p>
</li>
<li><p>代理模式 （在不改变原有方法的基础上，对原有方法进行增强）</p>
<p> spring aop</p>
</li>
<li><p>适配器模式 （接口的转换）</p>
<p> spring validation  SpringValidatorAdapter.java</p>
</li>
<li><p>工厂模式 （隐藏具体的实现细节，具体实现应该一系列步骤）</p>
<p> MyBatis  SqlSessionFactory.java</p>
</li>
</ol>
<p>代理模式 装饰器模式</p>
<ul>
<li>对设计模式调用的理解<br>之前对设计模式中调用方式，new个对象，然后再将这个对象作为参数在new对象，对这种调用方式不太理解，<br>今天突然想到，比如说要对方法做增强，那是谁想要增强呢—调用者，而且调用者也必然要知道要对那个对象做增强，做怎么样的增强，按这个理解这种调用方式就ok了<br>在运行时期，应该是通过配置，接口调用或者其他形式来实现的</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>log</title>
    <url>/2021/09/03/%E9%A1%B9%E7%9B%AE/log/</url>
    <content><![CDATA[<ol>
<li><p>log path的配置，一般只输出指定路径的日志，那mybatis的日志和启动时打印的日志为什么不在此列</p>
</li>
<li><p>判断当前日志是否可用？？？</p>
</li>
<li><p>日志Facade<br> jcl commons-logging (已停止更新)</p>
<pre><code> 默认使用log4j的实现，找不到则使用jul的实现。
</code></pre>
<p> slf4j (simple log facade for java)</p>
</li>
<li><p>日志实现<br> jul (java.util.logging jdk1.4 开始提供)<br> log4j<br> logback</p>
<pre><code> logback-core
 logback-classic
 logback-access
</code></pre>
<p> log4j2</p>
<pre><code> log4j-api
 log4j-core
</code></pre>
</li>
<li><p>集成使用<br> 部分集成使用需要添加额外适配包</p>
<ol>
<li>jcl+log4j2<br> log4j-jcl</li>
<li>jcl+logback<br> jcl-over-slf4j</li>
<li>slf4j+jul<br> slf4j-jdk14</li>
<li>slf4j+log4j<br> slf4j-log4j12</li>
<li>slf4j+log4j2<br> log4j-slf4j-impl</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>课程</title>
    <url>/2021/11/05/%E9%A1%B9%E7%9B%AE/%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1上"><a href="#1上" class="headerlink" title="1上"></a>1上</h2><ul>
<li>计算机科学与技术导论</li>
<li>高数Ⅰ</li>
<li>程序设计（C）</li>
</ul>
<h2 id="1下"><a href="#1下" class="headerlink" title="1下"></a>1下</h2><ul>
<li>高数Ⅱ</li>
<li>线性代数</li>
<li>面向对象程序设计（C++）</li>
</ul>
<h2 id="2上"><a href="#2上" class="headerlink" title="2上"></a>2上</h2><ul>
<li>概率统计</li>
<li>离散数学</li>
<li>电子技术基础</li>
<li>数据结构（C）</li>
<li>Java程序设计</li>
<li>汇编语言程序设计</li>
</ul>
<h2 id="2下"><a href="#2下" class="headerlink" title="2下"></a>2下</h2><ul>
<li>统一建模语言（UML）</li>
<li>数据库系统</li>
<li>C#程序设计</li>
<li>计算机网络</li>
<li>数字图像处理（Matlab）</li>
<li>算法设计与分析</li>
<li>智能信息处理（Fortran？）</li>
</ul>
<h2 id="3上"><a href="#3上" class="headerlink" title="3上"></a>3上</h2><ul>
<li>J2EE架构与开发</li>
<li>Unix系统原理与应用</li>
<li>Web技术与应用</li>
<li>操作系统</li>
<li>计算机组成原理</li>
<li>软件工程</li>
<li>信息安全概论</li>
</ul>
<h2 id="3下"><a href="#3下" class="headerlink" title="3下"></a>3下</h2><ul>
<li>编译原理</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>项目经验</title>
    <url>/2020/09/04/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><ul>
<li><p>琏课堂 </p>
<ul>
<li>项目时间 2018.5 ~ …</li>
<li>参与时间 2018.8 ~ 2019.11.29</li>
<li>项目描述</li>
<li>主要职责</li>
</ul>
</li>
<li><p>PIS 到站提醒 </p>
<ul>
<li>项目时间 2019.4.17 ~ 2020.4.17</li>
<li>参与时间 2019.4.17 ~ 2019.11.26</li>
<li>项目描述
  </li>
</ul>
</li>
<li><p>军乐保小程序  </p>
<ul>
<li>项目时间 2019.9.17 ~ 2019.11.25 </li>
<li>参与时间 2019.9.17 ~ 2019.11.25 </li>
<li>项目描述</li>
<li>主要职责</li>
</ul>
</li>
<li><p>东电云 </p>
<ul>
<li>项目时间 2019.9.9 ~ 2020.7.17</li>
<li>参与时间 2019.9.9 ~ 2020.7.17</li>
<li>项目描述</li>
<li>主要职责</li>
</ul>
</li>
<li><p>电厂仿真</p>
<ul>
<li>项目时间 2020.5.9 ~ …</li>
<li>参与时间 2020.5.9 ~ …</li>
<li>项目描述</li>
<li>主要职责</li>
</ul>
</li>
<li><p>OA/CRM/ERP<br>基础功能模块： 用户管理，权限管理<br>OA（Office Automation）: 办公自动化<br>流程<br>CRM（Customer Relationship Mnagement）：客户关系管理<br>客户管理，联系人管理，项目管理，权限管理，任务管理<br>ERP（Enterprise Resource Planning）: 企业资源计划<br>物资资源管理（物流），人力资源管理（人流），财务资源管理（财流），信息资源管理（信息流）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>AQS</title>
    <url>/2020/07/27/Java/%E5%B9%B6%E5%8F%91/AQS/</url>
    <content><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AbstractQueuedSyncrinizer<br>通过双向链表方式实现。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul>
<li>CountDownLatch</li>
<li>Semaphore</li>
<li>CyclicBarrier</li>
<li>ReentrantLock</li>
<li>Condition</li>
<li>FutureTask</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>CAS</title>
    <url>/2020/07/23/Java/%E5%B9%B6%E5%8F%91/CAS/</url>
    <content><![CDATA[<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>Compare And Swap。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>CAS是一种无锁算法，CAS有3个操作数，主内存值V，工作内存值A，要修改的新值B。当且仅当A和V相同时，将主内存值V改为B，否则什么都不做。  <br>valueOffset: 主内存地址的偏移量。  <br>value：使用volatile关键字保证可见性。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>ABA问题。JDK1.5提供了AtomicStampedReference类来解决，纪录值的版本。</li>
<li>循环时间长开销大。长时间不成功会一直自旋。</li>
<li>只能保证一个共享变量的原子操作。JDK1.5提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里进行CAS操作。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Executor</title>
    <url>/2020/09/10/Java/%E5%B9%B6%E5%8F%91/Executor/</url>
    <content><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java5引入，用于控制线程的启动、执行和关闭。  <br>基于生产者-消费者模式实现。</p>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><h3 id="Executor-1"><a href="#Executor-1" class="headerlink" title="Executor"></a>Executor</h3><p>接口，定义了线程池执行的方法，接收Runnale作为参数，无放回值。</p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>ExecutorService的子类接口，定义了线程池的生命周期。定义了submit方法，返回Future对象。及其它方法。</p>
<h3 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h3><p>ExecutorService 的抽象实现类，对ExecutorService中定义的方法做了默认的实现。</p>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>工具类，提供了一些常用的线程池，常用的线程池创建线程的工厂类。</p>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>常用的线程池，继承自AbastractExecutorService</p>
<h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p>可定时、周期执行的线程池，继承自ThreadPoolExecutor</p>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>可完成拆分合并的线程池，继承自AbstractExecutorService</p>
<h2 id="Executor-VS-Thread"><a href="#Executor-VS-Thread" class="headerlink" title="Executor VS Thread"></a>Executor VS Thread</h2><ul>
<li>性能</li>
<li>同一管理，线程间竞争</li>
<li>扩展性</li>
</ul>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>直接提交任务，而不保持。</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>无界队列，可以对无限多的任务排队</p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>延时队列，延时提交</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>有界队列，可以指定队列的长度。</p>
<h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p>ThreadPoolExecutor是最常用的线程池，该线程池创建需要以下参数。 </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>int</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>long</td>
<td>空闲线程保留最长时间</td>
</tr>
<tr>
<td>timeUnit</td>
<td>java.util.concurrent.TimeUnit</td>
<td>时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>java.util.concurrent.BlockingQueue</td>
<td>指定使用哪一种BlockingQueue</td>
</tr>
<tr>
<td>threadFactory</td>
<td>java.util.concurrent.ThreadFactory</td>
<td>指定线程池创建线程的工厂，默认工厂类为Executors.defaultThreadFactory</td>
</tr>
<tr>
<td>handler</td>
<td>java.util.concurrent.RejectedExecutionHandler</td>
<td>指定当任务超限后的处理方式，默认处理类为AbortPolicy</td>
</tr>
</tbody></table>
<h3 id="jdk提供的线程池"><a href="#jdk提供的线程池" class="headerlink" title="jdk提供的线程池"></a>jdk提供的线程池</h3><table>
<thead>
<tr>
<th>pool</th>
<th>corePoolSize</th>
<th>maximumPoolSize</th>
<th>keepAliveTime</th>
<th>timeUnit</th>
<th>workQueue</th>
<th>threadFactory</th>
<th>handler</th>
</tr>
</thead>
<tbody><tr>
<td>newFixedThreadPool</td>
<td>参数指定</td>
<td>参数指定</td>
<td>0</td>
<td>TimeUnit.MILLISECONDS</td>
<td>LinkedBlockingQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>TimeUnit.MILLISECONDS</td>
<td>LinkedBlockingQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
<tr>
<td>newCachedThreadPool</td>
<td>0</td>
<td>Integer.MAX_VALUE</td>
<td>60</td>
<td>TimeUnit.SECONDS</td>
<td>SynchronousQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>参数指定</td>
<td>Integer.MAX_VALUE</td>
<td>0</td>
<td>NANOSECONDS</td>
<td>DelayedWorkQueue</td>
<td>Executors.defaultThreadFactory/参数指定</td>
<td>AbortPolicy</td>
</tr>
</tbody></table>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>当调用executor.execute提交一个任务时，按照如下顺序处理： </p>
<ol>
<li>如果当前线程数量少于核心线程数，则创建一个新的线程。</li>
<li>如果当前线程数量大于等于核心线程数，但缓冲队列未满，则将新的任务添加到缓冲队列中，按照FIFO原则依次等待执行。</li>
<li>如果当前线程数量大于等于核心线程数，且缓冲队列已满，但当前数量小于最大线程数，则创建新的线程。</li>
<li>如果当前线程数量等于最大线程数，则调用handle方法处理。</li>
</ol>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li>RUNNING （初始状态）</li>
<li>SHUTDOWN （调用shutdown，等待任务执行完毕）</li>
<li>STOP （调用shutdownNow）</li>
<li>TIDYING （所有任务已终止）</li>
<li>TERMINATED （彻底终止）</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>RUNNING -&gt; SHUTDOWN -&gt; TIDYING -&gt; TERMINATED<br>RUNNING -&gt; STOP -&gt; TIDYING -&gt; TERMINATED</p>
<h2 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h2><table>
<thead>
<tr>
<th>类</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>AbortPolicy</td>
<td>throw new RejectedExecutionException</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>直接运行runable.run()</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>丢弃</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃队列头部任务</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Future</title>
    <url>/2020/09/10/Java/%E5%B9%B6%E5%8F%91/Future/</url>
    <content><![CDATA[<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>非阻塞模型。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/images/pasted-6.png" alt="upload successful"></p>
<h3 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture</h3><p>同时继承接口Runnable和Future。</p>
<h3 id="SchedualedFuture"><a href="#SchedualedFuture" class="headerlink" title="SchedualedFuture"></a>SchedualedFuture</h3><p>延时、定时执行。</p>
<h3 id="ForkJoinFuture"><a href="#ForkJoinFuture" class="headerlink" title="ForkJoinFuture"></a>ForkJoinFuture</h3><p>可被拆分、合并。</p>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>可以被显式完成。  </p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li>NEW</li>
<li>COMPLETING</li>
<li>NORMAL</li>
<li>EXCEPTIONAL</li>
<li>CANCELLED</li>
<li>INTERRUPTING</li>
<li>INTERRUPTED</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>NEW -&gt; COMPLETING -&gt; NORMAL<br>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL<br>NEW -&gt; CANCELLED<br>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2020/07/27/Java/%E5%B9%B6%E5%8F%91/JUC/</url>
    <content><![CDATA[<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>java.utils.concurrent</p>
<h2 id="autmic"><a href="#autmic" class="headerlink" title="autmic"></a>autmic</h2><ul>
<li>AutmicInteger</li>
<li>AutmicBoolean</li>
<li>AutmicLong</li>
<li>AutmicReference</li>
<li>LongAdder</li>
<li>AutmicIntegerArray</li>
<li>AutmicLongArray</li>
<li>AutmicReferenceArray</li>
<li>AutmicStampledReference</li>
</ul>
<h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><ul>
<li>CopyOnWriteArrayList</li>
<li>CopyOnWroteArraySet</li>
<li>ConcurrentSkipListSet</li>
<li>ConcurrentMap</li>
<li>ConcurrentSkipListMap</li>
</ul>
<h2 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h2><ul>
<li>Lock</li>
<li>ReentrantLock</li>
<li>ReadWriteLock</li>
</ul>
<h2 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h2><h2 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>netty</title>
    <url>/2020/09/18/Java/%E5%B9%B6%E5%8F%91/netty/</url>
    <content><![CDATA[<h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><h3 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h3><p>线程池，继承自 ScheduledExecutorService。  <br>用做服务器时有两个线程池，分别为接收连接线程池与工作线程池。用作客户端时有一个线程池。  <br>具体实现类有NioEventLoop、DefaultEventLoop、EpollEventloop。</p>
<h3 id="AbstractBootstrap"><a href="#AbstractBootstrap" class="headerlink" title="AbstractBootstrap"></a>AbstractBootstrap</h3><p>启动类。服务器启动类为ServerBootstrap，客户端启动类为Bootstrap。</p>
<h4 id="group"><a href="#group" class="headerlink" title="group"></a>group</h4><p>指定线程池。</p>
<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>指定通道，根据通道可以判断是服务器/客户端、TCP/UDP。</p>
<h4 id="childHandle"><a href="#childHandle" class="headerlink" title="childHandle"></a>childHandle</h4><p>指定消息的处理器。</p>
<h4 id="option、childOption"><a href="#option、childOption" class="headerlink" title="option、childOption"></a>option、childOption</h4><p>通过常量指定TCP/UDP协议的相关配置。如backlog、keepalive等。</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>绑定端口。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>netty的通道。</p>
<h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>继承自Future。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>nio</title>
    <url>/2020/09/18/Java/%E5%B9%B6%E5%8F%91/nio/</url>
    <content><![CDATA[<h2 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h2><p>io通过流来传输数据，而nio通过channel与buffer传输。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>通道。Stream是单向的，而channel是双向的。</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>缓冲区。</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>管理channel。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>synchronized</title>
    <url>/2020/09/17/Java/%E5%B9%B6%E5%8F%91/synchronized/</url>
    <content><![CDATA[<h2 id="synchronized使用及编译"><a href="#synchronized使用及编译" class="headerlink" title="synchronized使用及编译"></a>synchronized使用及编译</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>编译时添加ACC_SYNCHRONIZED标记。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>默认添加try-finally，编译生成一条monitorenter指令和两条monitorexit指令。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果synchronized作用的对象是非静态方法或者对象，则它取得锁是对象锁；如果synchronized作用的对象是静态方法或者类，则它取得的锁是类锁。类锁与对象锁是两把不同的锁。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>重量级锁依赖于系统的同步函数，在linux上使用mutex互斥锁，最底层实现依赖于futex。这些同步函数都涉及到用户态和内核态的切换，进程的上下文切换，成本较高。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>在JVM中，对象在内存中除了本身的数据外还会有对象头，对于普通对象而言，其对象头有两类信息：mark word和类型指针，对于数据而言含会有一份记录数据长度的数据。  <br>类型指针是指向该对象所属类对象的指针。mark word用于存储对象的HashCode、GC分代年龄、锁状态等信息，在32位系统中位32字节，64位系统中为64字节。  <br>Java中任意对象都可以用作锁，锁信息可以存在对象头中。  <br>mark word中存储数据根据锁类型改变，当对象为无状态锁时，存储hashCode，当对象为偏向锁时，存储线程id，当对象为轻量级锁时，存储线程栈中Lock Record的指针，当对象为重量级锁时，存储堆中的monitor对象的指针。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>传统意义上的锁，利用操作系统底层的同步机制实现Java中的线程同步。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>在运行时，同步块中的代码不存在竞争，不同的线程交替执行同步块中的代码。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在运行时，只有一个线程会调用相关同步方法。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>volatile</title>
    <url>/2020/07/23/Java/%E5%B9%B6%E5%8F%91/volatile/</url>
    <content><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>保证了所有线程对这个变量操作时的可见性。</li>
<li>禁止指令重排序。<br>PS: volatile只能保证对单次读/写的原子性，像i++属于复杂指令。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>读 当读一个volatile变量时，会将本地内存的值置为无效，直接从主内存中读取。</li>
<li>写 当写一个volatile变量时，JMM会把本地变量的值刷新到主内存。</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>指令屏障。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>并发模拟</title>
    <url>/2020/07/21/Java/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<ul>
<li>PostMan 请求模拟工具</li>
<li>Apache Bench 网站性能测试工具</li>
<li>Apache JMeter 压力测试工具</li>
<li>Semaphore、CountDownLatch 通过代码模拟测试 </li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/2020/07/21/Java/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>操作系统通过时间片算法来并行执行各个程序。  <br>并发编程是指在同一台处理器上，并发处理多个任务。</p>
</blockquote>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>操作系统进行资源分配的最小单位。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>操作系统能够进行运算调度的最小单位。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>表示一种公共资源或共享数据，同一时间，只允许一个线程访问。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>内存的一部分，用来缓冲输入或输出的数据。</p>
<h2 id="并发编程解决的问题"><a href="#并发编程解决的问题" class="headerlink" title="并发编程解决的问题"></a>并发编程解决的问题</h2><ul>
<li>线程间的通信问题<blockquote>
<p>通信方式</p>
</blockquote>
<ul>
<li>数据共享 通过读写公共内存中的公共状态来隐式进行通信。</li>
<li>消息传递 通过明确的发送消息来显式进行通信（Java中典型的消息传递方式是wait()和notify()）。</li>
</ul>
</li>
<li>线程间的同步问题<blockquote>
<p>同步 指程序用于控制不同线程之间操作发生相对顺序的机制。</p>
</blockquote>
</li>
</ul>
<h2 id="计算机内存模型"><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h2><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>随着CPU技术的发展，CPU的执行速度越来越快，而内存的速度没有多大变化，于是，为了提高CPU利用率，在CPU和内存之间增加高速缓存。  <br>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可分为一级缓存（L1），二级缓存（L2），部分高端CPU还具有三级缓存（L3）。  <br>多CPU/多核CPU每个核心都含有一套L1（L1、L2）缓存，而共享L2（L3）缓存。  <br>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为操作系统引入了一个新的问题—缓存一致性，从而带来更高的复杂度。</p>
<h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>MSI、MESI、MOSI、Synapse、Firefly、Dragon Protocol</p>
<h4 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h4><h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><ul>
<li>M Modified 修改</li>
<li>E Exclusive 独享</li>
<li>S Shared 共享</li>
<li>I Invalid 无效<h5 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h5>高速缓存行数据状态有四种，引起数据状态转换的操作也有四种，所以共有16中状态转换的情况。<br><img src="/images/pasted-1.png" alt="upload successful"><blockquote>
<p>CPU高速缓存通过总线连接，总线还连接了主存。<br>对于Local Read 和 Local Write 操作，不经过总线，不会被其它CPU控制器监听到。<br>对于Remote Read 和 Remote Write 操作，需要其它CPU共同参与，所以这两个操作所有CPU控制器都能监听到，并能知道是不是自己发出的。</p>
</blockquote>
</li>
</ul>
<h5 id="允许状态图"><a href="#允许状态图" class="headerlink" title="允许状态图"></a>允许状态图</h5><p>对于任意给定的高速缓存对，给定高速缓存行的允许状态如图。<br><img src="/images/pasted-2.png" alt="upload successful"></p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是编译器和处理器在执行程序时为了提供性能而做的一些优化。</p>
<p><img src="/images/pasted-4.png" alt="upload successful"></p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="编译器优化的重排序"><a href="#编译器优化的重排序" class="headerlink" title="编译器优化的重排序"></a>编译器优化的重排序</h4><p>编译器在不改变单线程程序语音的前提下，可以重新安排语句的执行顺序。</p>
<h4 id="指令集并行的重排序"><a href="#指令集并行的重排序" class="headerlink" title="指令集并行的重排序"></a>指令集并行的重排序</h4><p>如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
<h4 id="内存系统的重排序"><a href="#内存系统的重排序" class="headerlink" title="内存系统的重排序"></a>内存系统的重排序</h4><p>由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>重排序需要遵循一定的规则，不然其结果可能会影响程序的执行结果。</p>
<h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>数据依赖： 如果两个操作同时访问一个变量，其中一个操作时写操作，此时这两个操作就构成了数据依赖。</p>
<h4 id="控制依赖性"><a href="#控制依赖性" class="headerlink" title="控制依赖性"></a>控制依赖性</h4><h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h4><p>不管如果重排序，都必须保证代码在单线程下的运行正确。</p>
<h3 id="并发重排序"><a href="#并发重排序" class="headerlink" title="并发重排序"></a>并发重排序</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>如果代码中存在控制依赖的时候，会影响指令序列执行的并行度。因此，编译器和处理器会猜测（Speculation）执行来客服控制的相关性，所以重排序破坏了程序顺序规则。<br>程序顺序规则：指定执行顺序于实际代码中的执行顺序时一致的，但是处理器和编译器会进行冲重排序，只要最后的记过不会改变，该重排序就是合理的。  <br>在单线程程序中，由于as-if-serial的存在，对存在控制依赖的操作重排序，不会改变执行结果，但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。  <br>PS：一个线程里面的条件依赖于另一个线程里面的数据。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>内存屏障 Java编译器在适当的位置插入内存屏障指令来禁止特定类型的处理器重排序。</li>
</ul>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据JVM规范，JVM内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈五个部分。</p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li>不可见<blockquote>
<p>多个线程从主存中读取数据，其中一个线程的修改对其它线程不可见。</p>
</blockquote>
</li>
</ul>
<p>使用volatile关键字，表示只能从主存中读取，修改后写回主存。</p>
<ul>
<li>竞争<blockquote>
<p>多个线程同时修改同一份数据。</p>
</blockquote>
</li>
</ul>
<p>使用synchronized关键字，对数据加锁，释放锁之前其它线程不能访问。</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>Java Memory Model，Java内存模型,定义了JVM在计算机内存中的工作方式。JVM是整个计算机虚拟模型，所以JMM属于JVM。  <br>在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，JMM就是为了屏蔽系统和硬件的差异。  </p>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>JMM用来描述JVM是如何和计算机内存交互的。而JVM是计算机的一个模型，自然包含内存结构。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>定义程序中各个变量的访问规则。</p>
<h3 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h3><p>JMM规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对象工作内存中的变量，线程间变量值的传递均需要在主内存中来完成。</p>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<h3 id="内存交互操作"><a href="#内存交互操作" class="headerlink" title="内存交互操作"></a>内存交互操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>作用于主内存的变量，把一个变量标识为一条线程独占状态。</td>
</tr>
<tr>
<td>unlock</td>
<td>作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。</td>
</tr>
<tr>
<td>read</td>
<td>作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。</td>
</tr>
<tr>
<td>load</td>
<td>作用于工作内存的变量，把read操作从主内存中得到的变量值存入工作内存的变量副本中。</td>
</tr>
<tr>
<td>use</td>
<td>作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时会执行这个操作。</td>
</tr>
<tr>
<td>assign</td>
<td>作用于工作内存的变量，把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时会执行这个操作。</td>
</tr>
<tr>
<td>store</td>
<td>作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作。</td>
</tr>
<tr>
<td>write</td>
<td>作用于主内存的变量，把store操作从工作内存中一个变量的值传送到主内存的变量中。</td>
</tr>
</tbody></table>
<p>对这8种指定的使用，有以下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li>
<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li>
<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li>
<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>
<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>
</ul>
<h3 id="特新"><a href="#特新" class="headerlink" title="特新"></a>特新</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指一个操作是不可终端的，即使是在多个线程一起执行的情况下，一个操作一旦考试执行，就不会收到其它线程的干扰。<br>JMM内存交互操作，在操作系统里都是不可分隔的单元。被synchronized关键字或其它锁包裹起来的操作也可以认为是原子的。从一个线程观察另一个线程时，看到的都是一个个原子性的操作。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>指在多线程情况下，当一个线程修改了某一个共享变量的值之后，其它线程是否能够立即知道这个修改。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句指“线程内表现为串行的语义”（as-if-serial），后半句值“指令重排序”和普通变量的”工作内存与主内存同步延迟“的现象。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>JMM使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。  <br>重排序需要遵循happens-before规则。</p>
<ul>
<li>程序次序规则(Program Order Rule)：在同一个线程中，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操纵。准确的说是程序的控制流顺序，考虑分支和循环等。</li>
<li>管理锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面（时间上的顺序）对同一个锁的lock操作。</li>
<li>volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面（时间上的顺序）对该变量的读操作。</li>
<li>传递性(Transitivity)：如果操作A 先行发生于操作B，操作B 先行发生于操作C，那么可以得出A 先行发生于操作C。</li>
<li>线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则(Thread Termination Rule)：线程的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时事件的发生。Thread.interrupted()可以检测是否有中断发生。</li>
<li>对象终结规则(Finilizer Rule)：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()的开始。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>锁</title>
    <url>/2020/07/23/Java/%E5%B9%B6%E5%8F%91/%E9%94%81/</url>
    <content><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>在计算机科学中，锁于互斥时一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。</p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。  <br>在Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>对于同一个数据的并发操作，乐观锁认为自己在使用数据的时候不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新乐这个数据。  <br>乐观锁在Java中是通过无锁编程来实现，最常采用的是CAS算法。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>乐观锁多用在读多写少的情况下。</li>
<li>悲观锁多用在读少写多的情况下。</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h3 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h3><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别的线程占用，那么此线程就无法获取到这把锁，该线程会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁（spinlock）。</p>
<h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><p>自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<h2 id="无锁、偏向锁、轻量级锁、重量级锁"><a href="#无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="无锁、偏向锁、轻量级锁、重量级锁"></a>无锁、偏向锁、轻量级锁、重量级锁</h2><h2 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>指多个线程按照申请锁的顺寻来获取锁，线程直接进入队列中排队，队列的第一个线程才能获取锁。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>等待锁的线程不会饿死。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>整体吞吐效率相对非公平锁低，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>指多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾排队。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>减少唤起线程的开销，整体的吞吐量高。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>处于等待队列中的线程可能会饿死。</p>
<h2 id="可重入锁、非可重入锁"><a href="#可重入锁、非可重入锁" class="headerlink" title="可重入锁、非可重入锁"></a>可重入锁、非可重入锁</h2><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入该线程的内层方法会自动获取锁。（前提是锁对象得是同一个对象或者class。）</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>可一定程度上避免死锁。</p>
<h2 id="独享锁、共享锁"><a href="#独享锁、共享锁" class="headerlink" title="独享锁、共享锁"></a>独享锁、共享锁</h2><h3 id="独享锁"><a href="#独享锁" class="headerlink" title="独享锁"></a>独享锁</h3><p>也叫排他锁、互斥锁，指该锁一次只能被一个线程所持有，获得该锁的线程既能读数据也能写数据。</p>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>该锁可被多个线程共享，获得共享锁的线程只能读数据，不能写数据。一个线程对某数据加了共享锁后，其它线程只能添加共享锁，不能加独享锁。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>对象导论</title>
    <url>/2021/11/30/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%881%EF%BC%89%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<p>计算机革命起源于机器，因此，编程语言的产生也始于对机器的模仿。<br>计算机并非只是机器那么简单，计算机是头脑延伸的工具，同时还是一种不同类型的表达媒体。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Sun对Java的设计目标：“我们关系的是，减少开发健壮代码所需的事件以及困难。” – 为程序员减少复杂性。</p>
<h2 id="1-1-抽象过程"><a href="#1-1-抽象过程" class="headerlink" title="1.1 抽象过程"></a>1.1 抽象过程</h2><p>所有编程语言都提供抽象机制。<br>建立机器模型（位于“解空间”）和实际待解决问题的模型（位于“问题空间”）之间的关联。<br>面向对象思想实质：程序可以通过添加新类型的对象使本身适用于某个特定问题。<br>OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。<br>OOP与计算机的联系：每个对象看起来都有点像一台微型计算机，具有状态和操作，用户可以要求对象执行这些操作。<br>对象具有状态、行为和标识。每一个对象在内存中都有一个唯一的地址。</p>
<h2 id="1-2-每个对象都有一个接口"><a href="#1-2-每个对象都有一个接口" class="headerlink" title="1.2 每个对象都有一个接口"></a>1.2 每个对象都有一个接口</h2><p>创建抽象数据类型（类）使面向对象程序设计的基本概念之一。<br>在面向对象程序设计中，实际进行的是创建新的数据类型，但事实上所有的面向对象程序设计语言都使用class关键词来表示数据类型。即类型和类是等价的。<br>类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。</p>
<h2 id="1-3-每个对象都提供服务"><a href="#1-3-每个对象都提供服务" class="headerlink" title="1.3 每个对象都提供服务"></a>1.3 每个对象都提供服务</h2><p>将对象看作“服务提供者”。程序本身向用户提供服务，它将通过调用其它对象提供的服务来实现这一目的。<br>有助于提供对象的内聚性。</p>
<h2 id="1-4-被隐藏的具体实现"><a href="#1-4-被隐藏的具体实现" class="headerlink" title="1.4 被隐藏的具体实现"></a>1.4 被隐藏的具体实现</h2><p>访问权限控制。</p>
<h2 id="1-5-复用具体实现"><a href="#1-5-复用具体实现" class="headerlink" title="1.5 复用具体实现"></a>1.5 复用具体实现</h2><p>组合（has-a）、继承（is-a）。<br>组合与继承的使用选择：首先考虑组合，因为更加灵活。</p>
<h2 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6 继承"></a>1.6 继承</h2><p>两个类型可以有相同的特性和行为，但是其中一个类型可能必另一个含有更多的特性，并且可以处理更多的消息（或以不同的方式来处理消息）。<br>基类与导出类产生差异方法：在导出类中添加新方法（is-like-a），改变现有基类方法的行为（is-a）。<br>导出类与基类具有相同的类型，但表示完全相同的类型。</p>
<h2 id="1-7-伴随多态的可转换对象"><a href="#1-7-伴随多态的可转换对象" class="headerlink" title="1.7 伴随多态的可转换对象"></a>1.7 伴随多态的可转换对象</h2><p>处理类型的层次结构使，经常把一个对象不当作它所属的特定类型来对待，而是将其当作基类的对象来堆到。从而可以编写出不依赖于特定类型的代码。<br>编译器不可能产生传统意义上的函数调用。<br>前期绑定：编译器将产生对一个具体函数名字的调用，而运行时将这个调用解析到将要被执行代码的绝对地址。<br>后期绑定/动态绑定：当向对象发送消息时，被调用的代码直到运行时才能确定。<br>Java中为了执行后期绑定，使用一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址。<br>C++中使用virtual关键字来实现后期绑定。而在Java中，动态绑定是默认行为。</p>
<h2 id="1-8-单根继承结构"><a href="#1-8-单根继承结构" class="headerlink" title="1.8 单根继承结构"></a>1.8 单根继承结构</h2><p>终极基类：Object。<br>在OOP中，C++使用多根继承。<br>单根继承保证所有对象都具备某些功能。</p>
<h2 id="1-9-容器"><a href="#1-9-容器" class="headerlink" title="1.9 容器"></a>1.9 容器</h2><p>创建一种新的对象类型，持有对其它对象的引用。可以用数组来实现相同的功能。这个类型通常被称为容器/集合。<br>Java类库以不同的含义使用“集合”这个术语。<br>参数化类型是一个编译器可以自动定制作用于特定类型上的类。</p>
<h2 id="1-10-对象的创建和生命周期"><a href="#1-10-对象的创建和生命周期" class="headerlink" title="1.10 对象的创建和生命周期"></a>1.10 对象的创建和生命周期</h2><p>对象创建位置：堆栈、堆。<br>堆栈：容易控制、牺牲了灵活性。<br>堆： 直到运行时才知道需要多少对象，及他们的生命周期，具体类型。<br>Java完全采用了动态内存分配方式。<br>C++必须通过编程方式来确定合适销毁对象。Java提供了“垃圾回收器”机制。</p>
<h2 id="1-11-异常处理：处理错误"><a href="#1-11-异常处理：处理错误" class="headerlink" title="1.11 异常处理：处理错误"></a>1.11 异常处理：处理错误</h2><p>Java内置了一场处理，并且强制要求必须使用。是唯一可接受的错误报告方式。<br>异常处理并不是面向对象的特征，尽管在面向对象语言中异常常被表示成一个对象。</p>
<h2 id="1-12-并发编程"><a href="#1-12-并发编程" class="headerlink" title="1.12 并发编程"></a>1.12 并发编程</h2><p>同一时刻处理多个任务。<br>Java的并发是内置于语言的。</p>
<h2 id="1-13-Java与Internet"><a href="#1-13-Java与Internet" class="headerlink" title="1.13 Java与Internet"></a>1.13 Java与Internet</h2><p>Java促使计算机编程语言向前迈进了革命性的一步。 – 解决了在万维网（World Wide Web）上的程序设计问题。<br>C/S结构：过去所作的，都是针对某个问题发明一个单独的解决方案，所以每一次都要发明一个新的方案。这些方案难以开发且难以使用，而且用户对每一个方案都要学习新的接口。<br>客户端编程：在客户端浏览器中运行程序的能力。<br>Web最初的B/S设计是为了能够提供交互性的内容，但是其交互性完全由服务器提供。通过Web服务器提供的通用网关接口（Common Gateway Interface, CGI）实现。<br>客户端编程方式：<br>    1. 插件<br>    2. 脚本语言 JavaScript不需要插件。可以解决80%问题。<br>    3. Java Applet 需要插件，JRE环境。用来解决剩下的20%问题。<br>    4. FLash 几乎所有浏览器都支持。备选方案。<br>    5. C#.NET<br>    6. Intranet 企业内部网。<br>服务端编程：过去，Python、C++使用CGI，Java使用servlet。将重点放在数据存储及业务逻辑上。</p>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>本章介绍了面向对象的一些基本特征，并将Java中的实现方式与其它OOP语言（主要是C++）做了对比，体现出Java语言的优势。<br>理解本章内容需要过程编程及面向对象背景有一定的了解，从而更能感受到面向对象的优势。如果一上来就使用面向对象，甚至Java，则感觉不知所云。<br>之前也阅读过第一章内容，但是感觉云里雾里。刚好前段时间又重新学习了一下C，在回过头来看，有些概念就很容易理解了。<br>另一方面，需要对web的发展，以及Java诞生时的历史背景有所了解，这样才更能理解Java对于其它OOP语言来说，它的绝对优势是什么。我想这也是第14节用了比其它小节更多篇幅来描述Java与Internet关系的原因吧。<br>每一种语言，都有它流行的原因，也有它不得已而为之的地方。例如C++，它之所以流行是因为它完全向前兼容了C，而这也是它里面有些语法令人诟病的地方。Java同样也是。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>一切都是对象</title>
    <url>/2021/12/01/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%882%EF%BC%89%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>Java是杂合型语言。 –允许多种编程风格。</p>
<h2 id="2-1-用引用操纵对象"><a href="#2-1-用引用操纵对象" class="headerlink" title="2.1 用引用操纵对象"></a>2.1 用引用操纵对象</h2><p>每种编程语言都有自己的操纵内存中元素的方式。Java中一切都被视为对象，因此可采用单一固定的语法。操纵的标识符实际上是对象的一个“引用”。<br>引用不一定需要一个对象与之关联。</p>
<h2 id="2-2-必须由你创建所有对象"><a href="#2-2-必须由你创建所有对象" class="headerlink" title="2.2 必须由你创建所有对象"></a>2.2 必须由你创建所有对象</h2><p>通常使用new操作符来将一个新的对象和创建的引用相关联。<br>对象存储位置：寄存器（处理器内部）、堆栈、堆、常量存储（ROM）、非RAM存储（流对象、持久化对象）。<br>基本类型需要特殊对待，置于堆栈中。<br>基本类型所占存储空间大小是不变的。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>大小</th>
<th>最小值</th>
<th>最大值</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1bit</td>
<td>-</td>
<td>-</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>16bit</td>
<td>Unicode 0</td>
<td>Unicode 2^16-1</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>8bit</td>
<td>-128</td>
<td>+127</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>16bit</td>
<td>-2^15</td>
<td>+2^15-1</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>32bit</td>
<td>-2^31</td>
<td>+2^31-1</td>
<td>Int</td>
</tr>
<tr>
<td>long</td>
<td>64bit</td>
<td>-2^63</td>
<td>+2^63-1</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>32bit</td>
<td></td>
<td></td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>64bit</td>
<td></td>
<td></td>
<td>Double</td>
</tr>
<tr>
<td>void</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>Void</td>
</tr>
</tbody></table>
<p>高精度数字：BigInteger、BigDecimal。支持任意精度。使用方法调用取代运算符，运算速度慢。<br>数组：几乎所有的程序设计语言都支持数组。<br>安全性史Java的主要目标之一，确保数组会被初始化，使用时进行范围检查。以内存开销及运行时的下标检查为代价。<br>创建数组对象时，实际创建了一个引用数组。数组中的每个对象都为null。</p>
<h2 id="2-3-永远不需要销毁对象"><a href="#2-3-永远不需要销毁对象" class="headerlink" title="2.3 永远不需要销毁对象"></a>2.3 永远不需要销毁对象</h2><p>在大多数程序设计语言中，变量生命周期的概念，占据了程序设计工作中非常重要的部分。<br>作用域定义了在其内定义的变量名的可见性和生命周期。作用域由花括号的位置决定。在作用域里定义的变量只可用于作用域结束之前。<br>Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。<br>Java垃圾回收器，用来监视new创建的所有对象，并辨别那些不会在被引用的对象。</p>
<h2 id="2-4-创建新的数据类型：类"><a href="#2-4-创建新的数据类型：类" class="headerlink" title="2.4 创建新的数据类型：类"></a>2.4 创建新的数据类型：类</h2><p>从历史发展角度来看，大多数面向对象的程序设计语言习惯用关键字class来表示创建新的数据类型。<br>class关键字之后紧跟着的是新类型的名称。<br>可以在类中设置两种类型的元素：字段（数据成员）和方法（成员函数）。<br>在Java中所作的全部工作就是定义类，产生那些类的对象，以及发送消息给这些对象。<br>每个对象都有用来存储其字段的空间，普通字段不能在对象间共享。<br>点号操作符：引用对象的成员。<br>基本类型变量，即使没有初始化，Java确保获得一个默认值（只有成员变量）。</p>
<h2 id="2-5-方法、参数和返回值"><a href="#2-5-方法、参数和返回值" class="headerlink" title="2.5 方法、参数和返回值"></a>2.5 方法、参数和返回值</h2><p>方法的基本组成包括：名称、参数、返回值和方法体。<br>方法签名（方法名+参数列表）唯一地标识出某个方法。<br>Java中的方法只能作为类的一部分创建，只有通过对象/类才能调用。<br>点号操作符：调用方法。对象名.方法名(参数列表)。<br>调用方法的行为通常被称为发送消息给对象。即向对象发送消息。<br>方法参数传递的实际是引用（除基本类型），且引用的类型必须正确。<br>return： 1. 离开此方法；2. 此方法产生了一个值。若返回类型是void，return关键字的作用只是用来退出方法。</p>
<h2 id="2-6-构建一个Java程序"><a href="#2-6-构建一个Java程序" class="headerlink" title="2.6 构建一个Java程序"></a>2.6 构建一个Java程序</h2><p>名字管理对任何程序设计语言来说，都是一个重要问题。<br>C++类将函数包于其类，从而避免于其他类中的函数名相冲突。C++允许全局数据和全局函数的存在，使用名字空间来解决。<br>Java采用域名反转的方式，保证类库生成不会于其它名字混淆的名字。Java语言本身解决了同一个文件内的每个类都有唯一的标识符。<br>Java消除了“向前引用”问题：可以在类中使用在该类的后面定义的类。<br>使用import准确引入位于其它文件中的类，消除混淆情况。可以使用通配符“*”。<br>当创建类是，就是在描述那个类的对象的外观与行为。执行new创建对象时，数据存储空间才会被分配，其方法才供外界调用。<br>static： 1. 为特定域分配的那一存储空间；2. 方法不于包含它的那个类的任何对象关联（没有创建对象，也能调用方法）。<br>类数据、类方法，代表那些数据和方法只能是作为整个类，而不是类的某个特定对象而存在的。<br>引用static变量：1. 对象.变量名； 2. 类.变量名（推荐）。 调用static方法：1. 对象.方法名(…)； 2. 类.方法名(…)（推荐）。<br>当static作用于某个字段是，会改变数据创建的方式。static作用于方法，区别不大。</p>
<h2 id="2-7-第一个Java程序"><a href="#2-7-第一个Java程序" class="headerlink" title="2.7 第一个Java程序"></a>2.7 第一个Java程序</h2><p>在每个程序文件的开头，声明import语句，引入在文件代码中需要用到的额外类（java.lang会自动被导入到每一个Java文件中）。<br>创建一个独立运行的程序，文件中必须存在某个类于该文件同名，且那个类包含一个main方法。<br>main方法参数args用来存储命令行参数。<br>编译（javac命令）、运行（java命令）Java程序必须要有Java开发环境JDK。</p>
<h2 id="2-8-注释和嵌入式文档"><a href="#2-8-注释和嵌入式文档" class="headerlink" title="2.8 注释和嵌入式文档"></a>2.8 注释和嵌入式文档</h2><p>块注释：以“/*”开头，以“*/”结束，中间可以跨多行。源于C/C++。<br>单行注释：“//”。源于C++。<br>Java为实现代码同文档连接起来，使用一种特殊的注释语法来标记文档，还需要一个工具（javadoc，JDK安装的一部分）来提取注释，并将其转换成有用的形式。<br>javadoc输出的是一个HTML文件。<br>注释文档：以“/**”开头，以“*/”结束。可以使用嵌入式文档HTML和文档标签。<br>文档标签有独立文档标签（以”@“字符开头的命令，至于注释行”*“之后最前面）和行内文档标签（以”@“开头，括在花括号内）。<br>三种类型的注释文档，分别对应于注释位置后面的三种元素：类、域和方法。</p>
<h2 id="2-9-编码风格"><a href="#2-9-编码风格" class="headerlink" title="2.9 编码风格"></a>2.9 编码风格</h2><p>类的首字母要大写。<br>使用”驼峰风格“</p>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>本章讲述Java程序的基本组成部分，以及编写一个程序时所需要注意的地方，另外还有与其它语言的对比。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>操作符</title>
    <url>/2021/12/02/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%883%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<p>在最底层，Java中的数据是通过使用操作符来操作的。</p>
<h2 id="3-1-更简单的打印语句"><a href="#3-1-更简单的打印语句" class="headerlink" title="3.1 更简单的打印语句"></a>3.1 更简单的打印语句</h2><p>静态导入static import。</p>
<h2 id="3-2-使用Java操作符"><a href="#3-2-使用Java操作符" class="headerlink" title="3.2 使用Java操作符"></a>3.2 使用Java操作符</h2><p>操作符作用于操作数，接受一个或多个参数，并生成一个新值。参数形式与普通方法调用不同。<br>副作用：操作符改变操作数自身的值。<br>能改变其操作数的操作符，最普遍的用途是用来产生副作用。使用有副作用的操作符和没有副作用的操作符，生成的值没有什么区别。<br>几乎所有的操作符都只能操作基本类型。例外的操作符是“=”、“==”、“！=”，这些能操作所有的对象。String类支持“+”、“+=”操作符。</p>
<h2 id="3-3-优先级"><a href="#3-3-优先级" class="headerlink" title="3.3 优先级"></a>3.3 优先级</h2><p>当一个表达式中存在多个操作符时，操作符的优先级决定了各部分的计算顺序。<br>最简单的规则是先乘除后加减。程序员经常会忘记其他优先级规则，所以应该用括号明确规定计算顺序。</p>
<h2 id="3-4-赋值"><a href="#3-4-赋值" class="headerlink" title="3.4 赋值"></a>3.4 赋值</h2><p>// TODO<br>“=”：将右边的值附给左边的变量。<br>别名现象：是Java操作对象的一种基本方式.(对象传递的是引用，出现不同的名字)。</p>
<h2 id="3-5-算术操作符"><a href="#3-5-算术操作符" class="headerlink" title="3.5 算术操作符"></a>3.5 算术操作符</h2><p>包括”+”, “-“, “<em>“, “/“, “%”。整数除法会直接去掉结果的小数位。<br>操作符简化：”+=”, “-=”, “</em>=”, “/=”, “%=”。<br>一元加减号：编译器自动识别，规范加括号。（eg：x = a*(-b)）。<br>一元减号用于改变数据的符号. 一元加号只是为了与一元减号对应，但可以将较小类型的操作数提升为int。</p>
<h2 id="3-6-自动递增和递减"><a href="#3-6-自动递增和递减" class="headerlink" title="3.6 自动递增和递减"></a>3.6 自动递增和递减</h2><p>递增、递减是两种快捷运算。Java提供了大量的快捷运算，是编码更方便。</p>
<ul>
<li>“i++”,”++i”,”i–”,”–i”</li>
<li>除涉及赋值的操作符以外，唯一具有”副作用”的操作符.</li>
<li>前缀：先执行运算，在生成值.</li>
<li>后缀：先生成值，在执行运算.</li>
</ul>
<h2 id="3-7-关系操作符"><a href="#3-7-关系操作符" class="headerlink" title="3.7 关系操作符"></a>3.7 关系操作符</h2><ul>
<li>“&gt;”, “&lt;”, “&gt;=”, “&lt;=”, “==”, “!=”</li>
<li>返回<strong>true</strong>/<strong>false</strong></li>
<li>equals ：默认比较引用，重写比较内容，不适合用于基本类型.</li>
<li>==：比较引用.</li>
</ul>
<h2 id="3-8-逻辑操作符"><a href="#3-8-逻辑操作符" class="headerlink" title="3.8 逻辑操作符"></a>3.8 逻辑操作符</h2><ul>
<li>“&amp;&amp;”, “||”, “!”</li>
<li>短路(潜在的性能提升).</li>
</ul>
<h2 id="3-9-直接常量"><a href="#3-9-直接常量" class="headerlink" title="3.9 直接常量"></a>3.9 直接常量</h2><ul>
<li>“0x?”(十六进制)，”0?”(十进制)，”?l/L”(浮点型)，”?d/D”(双精度型)</li>
<li>指数记数：e 代表 “10的幂次”.</li>
</ul>
<h2 id="3-10-按位操作符"><a href="#3-10-按位操作符" class="headerlink" title="3.10 按位操作符"></a>3.10 按位操作符</h2><ul>
<li>“&amp;”, “|”, “~”, “^”</li>
<li>可与”=”联合使用.</li>
</ul>
<h2 id="3-11-移位操作符"><a href="#3-11-移位操作符" class="headerlink" title="3.11 移位操作符"></a>3.11 移位操作符</h2><ul>
<li>“&lt;&lt;”(左移，低位补0), “&gt;&gt;”(有符号右移，高位正插0，负插1), “&gt;&gt;&gt;”(无符号右移，高位插0)</li>
<li>只可用来处理整数类型.</li>
<li>可与”=”联合使用.</li>
</ul>
<h2 id="3-12-三元操作符"><a href="#3-12-三元操作符" class="headerlink" title="3.12 三元操作符"></a>3.12 三元操作符</h2><ul>
<li>boolean-exp ? value0 : value1;</li>
</ul>
<h2 id="3-13-字符串操作符"><a href="#3-13-字符串操作符" class="headerlink" title="3.13 字符串操作符"></a>3.13 字符串操作符</h2><ul>
<li>“+”， “+=”.</li>
<li>String 重载了 “+”，”+=”.</li>
<li>操作符重载：java不能实现自己的重载操作符.</li>
<li>如果表达式以一个字符串起头，那么后续所有操作数都必须是字符串类型（编译器会把双引号内的字符序列自动转成字符串）.</li>
</ul>
<h2 id="3-14-使用操作符时常犯的错误"><a href="#3-14-使用操作符时常犯的错误" class="headerlink" title="3.14 使用操作符时常犯的错误"></a>3.14 使用操作符时常犯的错误</h2><h2 id="3-15-类型转换操作符"><a href="#3-15-类型转换操作符" class="headerlink" title="3.15 类型转换操作符"></a>3.15 类型转换操作符</h2><ul>
<li>类型转换：（cast）.</li>
<li>向上转型：强制类型转换.</li>
<li>向下转型：不必显示地进行转换.</li>
<li>截尾：向下取整.</li>
<li>舍入：Math.round()，四舍五入.</li>
<li>对基本数据类型进行执行算术运算或按位运算，只要类型比int小，在运算之前，会自动转换成int，最终结果就是int型，如果要把结果赋值给较小的类型，就必须使用类型转换.</li>
</ul>
<h2 id="3-16-Java没有sizeof"><a href="#3-16-Java没有sizeof" class="headerlink" title="3.16 Java没有sizeof"></a>3.16 Java没有sizeof</h2><ul>
<li>sizeof()操作符：返回数据分配的字节数.</li>
<li>Java不需要sizeof，因为所有类型在所有机器中的大小是相同的.</li>
</ul>
<h2 id="3-17-操作符小结"><a href="#3-17-操作符小结" class="headerlink" title="3.17 操作符小结"></a>3.17 操作符小结</h2><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>C中明确比较了操作符的优先级，而Java则建议使用括号来明确优先级。<br>除了字符串重载（+=）及赋值（=）操作符，其它操作符的操作数都是基本类型。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>控制执行流程</title>
    <url>/2021/12/02/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%884%EF%BC%89%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>就像有知觉的生物一样，程序必须在执行过程中控制它的世界，并做出选择。在Java中，你要使用执行控制语句来做出选择。</p>
<h2 id="4-1-true和false"><a href="#4-1-true和false" class="headerlink" title="4.1 true和false"></a>4.1 true和false</h2><p>所有条件语句都利用表达式的真或假来决定执行路径。</p>
<h2 id="4-2-if-else"><a href="#4-2-if-else" class="headerlink" title="4.2 if-else"></a>4.2 if-else</h2><p>控制程序流程最基本的形式。<br>else是可选的。</p>
<h2 id="4-3-迭代"><a href="#4-3-迭代" class="headerlink" title="4.3 迭代"></a>4.3 迭代</h2><ul>
<li>while</li>
<li>do-while</li>
<li>for</li>
<li>逗号操作符：Java中唯一用到的地方就是for循环的控制表达式.用逗号操作符隔开的语句，均会独立执行.</li>
</ul>
<h2 id="4-4-Foreach语法"><a href="#4-4-Foreach语法" class="headerlink" title="4.4 Foreach语法"></a>4.4 Foreach语法</h2><ul>
<li>不必创建int变量去访问项构成的序列进行计数，foreach将自动产生每一项.</li>
</ul>
<h2 id="4-5-return"><a href="#4-5-return" class="headerlink" title="4.5 return"></a>4.5 return</h2><ul>
<li>指定一个方法的返回值.</li>
<li>退出当前方法.</li>
</ul>
<h2 id="4-6-break-和-continue"><a href="#4-6-break-和-continue" class="headerlink" title="4.6 break 和 continue"></a>4.6 break 和 continue</h2><ul>
<li>break：强行退出循环，不执行循环中剩余的语句.</li>
<li>continue：停止执行当前的迭代，然后退回循环起始处，开始下一次迭代.</li>
</ul>
<h2 id="4-7-goto"><a href="#4-7-goto" class="headerlink" title="4.7 goto"></a>4.7 goto</h2><ul>
<li>goto是Java的保留字，但Java中没有goto.Java中使用相同机制的<strong>标签</strong>，作为中断迭代语句的一种方法.</li>
<li>标签：label：(后面紧跟冒号的标识符).</li>
<li>Java中使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue.</li>
</ul>
<h2 id="4-8-switch"><a href="#4-8-switch" class="headerlink" title="4.8 switch"></a>4.8 switch</h2><ul>
<li>选择因子：int(byte，char，short 会自动转型为int)，enum.</li>
<li><strong>JDK1.7 中新增String作为选择因子.</strong></li>
<li>实现多路选择.</li>
</ul>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>初始化与清理</title>
    <url>/2021/12/03/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%885%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<p>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。<br>初始化和清理正是设计安全的两个问题。</p>
<h2 id="5-1-用构造器确保初始化"><a href="#5-1-用构造器确保初始化" class="headerlink" title="5.1 用构造器确保初始化"></a>5.1 用构造器确保初始化</h2><p>创建对象时，如果其内具有构造器，Java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。<br>构造器命名：与类名相同，所以”每个方法首字母小写”的编程风格不适用于构造器。1. 不会与其它方法冲突；2. 编译器直到该调用哪个方法。<br>构造器有助于减少错误，并使代码更易于阅读。从概念上讲，初始化与创建使彼此独立的，在Java中，捆绑在一起，两者不能分离。<br>构造器没有返回值，与void不同。new表达式返回了对新建对象的引用，但构造器本省并没有返回任何值。</p>
<h2 id="5-2-方法重载"><a href="#5-2-方法重载" class="headerlink" title="5.2 方法重载"></a>5.2 方法重载</h2><p>目的：为了让方法名相同而形式参数不同的构造器同时存在。<br>方法重载是构造器所必需的，但亦可用于其他方法。<br>区分：参数类型列表，参数顺序(代码难以维护)，涉及基本类型的重载(易混淆)，返回值(为了副作用而调用就会忽略其返回值 ×)。</p>
<h2 id="5-3-默认构造器"><a href="#5-3-默认构造器" class="headerlink" title="5.3 默认构造器"></a>5.3 默认构造器</h2><p>如果类中没有构造器，编译器会自动创建一个默认构造器。<br>如果已有构造器，则不会创建。</p>
<h2 id="5-4-this关键字"><a href="#5-4-this关键字" class="headerlink" title="5.4 this关键字"></a>5.4 this关键字</h2><p>为了能用简便，面向对象的语法来编写代码，编译器做了一些幕后工作，他把”所操作对象的引用”作为第一个参数传给方法(注：一般是通过对象的引用来调用方法，编译之后通过对象来调用)。<br>只能在方法内部使用，表示对”调用方法的那个对象”的引用。<br>如果在方法内部，调用同一个类的另一个方法，则不必使用this，直接调用即可。<br>需要返回当前对象的引用时，return this；。<br>将当前对象作为参数传递给其他对象。<br>在构造器中调用构造器(只能调用一个，且必须将构造器的调用至于最起始处)。<br>static方法：没有this的方法。</p>
<h2 id="5-5-清理：终结处理和垃圾回收"><a href="#5-5-清理：终结处理和垃圾回收" class="headerlink" title="5.5 清理：终结处理和垃圾回收"></a>5.5 清理：终结处理和垃圾回收</h2><p>finalize()。<br>对象可能不被垃圾回收。<br>垃圾回收并不等于”析构”。<br>垃圾回收只与内存有关。<br>引用计数：常用开说明垃圾收集的工作方式。<br>复制式回收器：效率低(1,空间大；2，复制)。<br>标记-清扫 模式。</p>
<h2 id="5-6-成员初始化"><a href="#5-6-成员初始化" class="headerlink" title="5.6 成员初始化"></a>5.6 成员初始化</h2><p>局部变量必须进行初始化。<br>类的数据成员(全局变量)，基本类型会默认有一个初始值，对象引用会获得特殊值null。<br>指定初始化：定义的时候直接赋值或通过方法调用赋值。</p>
<h2 id="5-7-构造器初始化"><a href="#5-7-构造器初始化" class="headerlink" title="5.7 构造器初始化"></a>5.7 构造器初始化</h2><p>通过构造器来进行初始化(无法阻止自动初始化的进行，它将在构造器调用之前发生)。<br>变量定义的先后顺序决定了初始化的顺序。<br>静态数据初始化：只有在第一个对象创建(或者第一次访问静态数据)的时候，才会被初始化，仅执行一次。<br>显式的静态数据初始化：静态代码块。<br>非静态实例初始化：普通代码块(匿名内部类的chu’shi’hua)。<br>构造器没有显式地使用static，但也是静态方法。<br>对象的创建过程<br>  1.当诗词创建对象或者类的静态方法/静态域首次被访问时，Java解释器查找类路径，定位.class文件。<br>  2.载入.class，有关静态初始化的所有动作被执行(首次加载时进行一次)。<br>  3.用new操作符创建对象，在堆上为对象分配足够的存储空间。<br>  4.存储空间清零，为对象中的全局变量赋值。<br>  5.执行所有出现于字段定义处的初始化动作。<br>  6.执行构造器。</p>
<h2 id="5-8-数组初始化"><a href="#5-8-数组初始化" class="headerlink" title="5.8 数组初始化"></a>5.8 数组初始化</h2><p>数组：相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列.通过方括号下标操作符来定义和使用的。<br>编译器不允许指定数组的大小。<br>初始化表达式：由一对花括号括起来的值组成。在这种情况下，存储空间的分配(等价于使用new)由编译器负责。<br>固有成员length，只能访问不能修改。<br>可变参数列表。</p>
<h2 id="5-9-枚举类型"><a href="#5-9-枚举类型" class="headerlink" title="5.9 枚举类型"></a>5.9 枚举类型</h2><p>枚举类型的实例是常量，按照命名惯例使用大写字母表示(多个单词用下划线隔开)。<br>为了使用enum，需要创建一个该类型的引用，并将其赋值给某个实例。<br>编译器自动添加toString()，ordinal()(声明顺序)，values()(按声明顺序，产生由常量构成的数组)方法。<br>与switch配合使用。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>访问权限控制</title>
    <url>/2021/12/04/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%886%EF%BC%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>复用类</title>
    <url>/2021/12/04/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%887%EF%BC%89%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>多态</title>
    <url>/2021/12/04/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%888%EF%BC%89%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2021/12/04/Java/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%EF%BC%889%EF%BC%89%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>编程思想</category>
      </categories>
  </entry>
  <entry>
    <title>vue</title>
    <url>/2021/07/29/JS/vue/</url>
    <content><![CDATA[<ul>
<li>ES6在语言的层面上实现了模块化。浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li>
</ul>
<p>VUE项目打包后通过nginx代理找不到js/css文件</p>
<ul>
<li><p>nginx代理后路径为 root 路径 + location 路径</p>
</li>
<li><p>需要修改VUE static 打包路径为 location 路径 + static (相对路径)</p>
</li>
<li><p>需要修改VUE index.html 打包路径为 location 路径下的index.html  或者 修改 nginx 配置 try_files 为 location 路径/index.html</p>
<p>  __dirname ： js文件当前绝对路径（仅在js文件中有效）<br>  path： node 内置模块<br>  index: 打包后 index.html 文件路径 （绝对路径）<br>  assetRoot: 指向包含应用程序的所有静态资源的根目录<br>  assetsSubDirectory: 静态资源要存放的路径， 相对于 assetRoot 的路径<br>  assetsPublicPath: 代表打包后，index.html里面引用资源的的地址 （相对路径/绝对路径）</p>
</li>
</ul>
<p>eslint 文件/设置中 区别，关系<br>-文件：运行项目后，通过控制台才发现语法错误。<br>-设置：在开发过程中，就根据ESlint规则修改代码。（不必支持项目）<br>IDEA中配置：Setting -&gt;Preferences -&gt; Languages &amp; Frameworks -&gt; JavaScript -&gt; Code Quality Tools -&gt; Eslint ，然后勾选Enable单选框。</p>
<pre><code>    IDEA webpack配置
- 当在“设置/首选项”|语言和框架|JavaScript|Webpack中打开项目或编辑指定的webpack.config.js时，IntelliJ IDEA在后台分析配置，并根据收到的信息，正确理解项目解析根和解析别名。由于对项目配置的理解，IntelliJ IDEA为JavaScript文件中的导入和导出符号提供了更精确的代码完成。
</code></pre>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
</search>
