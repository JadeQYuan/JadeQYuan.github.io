## 一. 定义
	对其他对象提供一种代理以控制对这个对象的访问。
## 二. 原理
	在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
	动态代理实际上是JDK在运行期动态创建class字节码并加载的过程。
## 三. JDK 静态代理
	代理类与目标类实现同一个接口，调用目标对象的方法时，改为调用代理类的方法，通过代理类及反射来调用目标对象的方法，这样就可以通过在调用目标方法前后进行统一的逻辑处理。
	在编译器就已经创建好代理对象。
1. 创建接口。
2. 创建目标类。
3. 创建代理类，通过构造方法注入目标类对象。
4. 实例化目标类，传入目标类对象实例化代理类，调用代理类方法。
#### 优点
	编译时产生class字节码文件，可以直接使用，效率高。	
#### 缺点
	扩展性不足。
## 四. JDK 动态代理
	在运行期动态创建代理对象。
	采用JDK反射技术，基于接口，动态创建的代理类和目标类实现同一个接口，如果没有接口，则无法进行动态代理。
	动态代理实际上是JDK在运行期动态创建class字节码并加载的过程
1. 创建接口。
2. 创建目标类。
3. 创建处理器，实现InvocationHandler接口，实现invoke方法。
4. 通过Proxy.newProxyInstance()方法创建动态代理实例。
	参数1：接口的类加载器
	参数2：代理需要实现的接口数组
	参数3：InvocationHandler实例
5. 调用动态代理实例的方法。
#### 优点
	反射机制在生成类的过程中比较高效。
#### 缺点
	执行时通过发射调用目标类接口方法较慢。
	只能代理有接口实现的类。
## 五. CGLIB代理
	采用底层字节码技术（asm），基于继承，因此无法代理final类，static方法，final方法。
	// TODO 具体实现细节
#### 优点
	asm在生成类之后的相关代理类执行过程中比较高效。
#### 缺点
	asm生成类的过程比较慢。
	
***END***
