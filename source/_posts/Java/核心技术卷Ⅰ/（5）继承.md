title: 继承
description: 继承
categories: 
  - Java
  - 核心技术卷I
author: Jade
date: 2022-01-12 21:00:00
---

{% markmap %}

## 5.1 类、超类和子类
- 关键字extends表明正在构造的新类派生于一个已存在的类。
- 已存在的类称为超类、基类或父类；新类称为子类、派生类或孩子类。
- super不是要给对象的引用，不能将super赋给另一个对象变量，它指示一个指示编译器调用超类方法的特殊关键字。
- 如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认的构造器。
- 一个对象变量可以指示多种实际类型的现象被称为多态。
- 在运行时能够自动地选择调用哪个方法的现象称为动态绑定。

- 继承并不仅限于一个层次。由一个公共类派生出来的所有类的集合被称为继承层次。
- 在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链。

- 有一个用来判断是否应该设计为继承关系的简单规则，就是“is-a”规则，它标名子类的每个对象也是超类的对象。
- is-a规则的另一种表述法是置换法则。它表明程序中出现超累对象的任何地方都可以用子类对象置换。
- 在Java程序设计语言中，对象变量是多态的。
- 在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。
- 所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。

- 如果是private方法、static方法、final方法或者构造器，编译器可以准确地知道应该调用哪个方法。静态绑定。
- 虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。

- 不允许扩展的类被称为final类。
- 如果在定义类的时候使用了final修饰符就表明这个类是final类。
- 类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法。
- final类中的所有方法自动地成为final方法。
- 将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。

- 将一个类型强制转换成另外一个类型的过程被称为类型转换。
- 进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。
- 在进行类型转换之前，先查看一下是否能够成功地转换。instanceof。

- 从某种角度看，祖先类更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。abstract。
- 为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。
- 除了抽象方法之外，抽象类还可以包含具体数据和具体方法。
- 扩展抽象类由两种选择：1. 将子类标记为抽象类； 2. 定义全部的抽象方法。
- 类即使不含抽象方法，也可以将类声明为抽象类。
- 抽象类不能被实例化。
- 可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。

- 超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。protected。
- 在实际应用中，要谨慎使用protected属性。（通过派生类可以进行访问）
- 受保护的方法更具有实际意义。

## 5.2 Object：所有类的超类
- Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。
- 如果没有明确地指出超类，Object就被认为是这个类的超类。
- 在Java中，只有基本类型不是对象。
- Object类中的equals方法用于检测一个对象是否等于另外要给对象。
- 在Object类中，这个方法将判断两个对象是否具有相同的引用。
- Java语言规范要求equals方法具有：自反性、对称性、传递性、一致性、对于任意非空引用x，x.equals(null)返回false。
- 散列码是由对象导出的一个整型值。
- 如果重新定义equals方法，就必须重新定义hashCode方法。
- toString方法用于返回表示对象值的字符串。

## 5.3 泛型数组列表
- 在许多程序设计语言中，特别是在C语言中，必须在编译时就确定整个数组的大小。
- 在Java中，允许在运行时确定数组的大小。
- 使用参数类型来增加安全性。

## 5.4 对象包装器和自动装箱
- 所有的基本类型都有一个与之对应的类。这些类称为包装器。
- 对象包装器类时不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。
- 对象包装器类时final，因此不能定义它们的子类。
- 自动装箱。自动拆箱。
- 装箱和拆箱时编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用，虚拟机只是执行这些字节码。
- 对象包装器另一个好处：可以将某些基本方法放置在包装器中。

## 5.5 参数数量可变的方法
- Java SE5.0提供了用可变的参数数量调用的方法（...）。

## 5.6 枚举类
- 在比较两个枚举类型的值时，永远不需要调用equals，而直接使用==就可以了。
- 可以在枚举类型中添加一些构造器、方法和域。
- 所有的枚举类型都是Enum的子类。它们继承了这个类的许多方法。
- 每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组。

## 5.7 反射
- 反射库提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵Java代码的程序。

- 在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。
- 可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class。
- 获取Class类对象的方法：getClass、Class.forName、.class。
- 一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。（int.class）
- 虚拟机为每个类型管理一个Class对象。

- 异常有两种类型：未检查异常和已检查异常。
- 对于一个已检查异常，只需要提供一个异常处理器。

- 反射最重要的内容---检查类的结构。
- Filed、Method、Constructor分别用于描述类的域、方法和构造器。

- 利用反射机制可以查看在编译时还不清楚的对象域。Field类中的get方法。

- Array.newInstance构造新数组。

- 反射机制允许调用任意方法。Method.invoke。
- 建议仅在必要的时候才使用Method对象，而最好使用接口和内部类。
- 使用接口进行回调会使得代码的执行速度更快，更易于维护。

## 5.8 继承设计的技巧
- 将公共操作和域放在超类。
- 不要使用受保护的域。
- 使用继承实现is-a关系。
- 除非所有继承的方法都有意义，否则不要使用继承。
- 在覆盖方法时，不要改变预期的行为。 关键在于，在覆盖子类中方法时，不要偏离最初的设计想法。
- 使用多态，而非类型信息。
- 不要过多的使用反射。

{% endmarkmap %}
