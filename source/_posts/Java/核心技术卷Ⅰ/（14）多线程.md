title: 多线程
description: 多线程
categories: 
  - Java
  - 核心技术卷I
author: Jade
date: 2022-01-14 11:00:00
---

{% markmap %}

## 14.0 序
- 操作系统中的多任务： 在同一刻运行多个程序的能力。
- 并发执行的进程数目并不是由CPU数目制约的。
- 多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。
- 通常，每一个任务称为一个线程，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序。
- 多进程与多线程本质的区别在于每个进程拥有自己的一整套便来给你，而线程则共享数据。共享变量是线程之间的通信比进程之间的通信更有效、更容易。
- 在有些操作系统中，与进程相比较，线程更轻量级，创建、销毁一个线程比启动新进程的开销要小得多。

## 14.1 什么是线程
- AWT的事件分派线程一直并行运行，以处理用户界面的事件。
- 在一个单独的线程中执行一个任务。Runnable。

## 14.2 中断线程
- stop方法可以终止线程，但是已弃用。
- interrupt方法可以用来请求终止线程。
- 当对一个线程调用interrupt方法时，线程的中断状态将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。
- 如果线程被阻塞，就无法检测中断状态。当在一个被阻塞的线程上调用interrupt方法时，阻塞调用将会被InterruptedException异常中断。
- 没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过时引起它的注意。被中断的线程可以决定如何响应中断。

## 14.3 线程状态
- New 新创建。
- Runnable 可运行。
- Blocked 被阻塞。
- Waiting 等待。
- Timed waiting 计时等待。
- Terminated 被终止。

- 现在所有的桌面以及服务器操作系统都使用抢占式调度。但是像手机这样的小型设备可能使用协作式调度。
- 在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行（这就是为什么称这个状态为可运行而不是运行）。

## 14.4 线程属性
- 在Java程序设计语言中，每一个线程有一个优先级。默认情况下，一个线程继承它的父线程的优先级。
- 线程的优先级时高度依赖于系统的。

- 守护线程的唯一用途时为其他线程提供服务。
- 标识该线程为守护线程或用户线程。这一方法必须在线程启动之前调用。

- 线程的run方法不能抛出任何被检测的异常，但是，不被检测的异常会导致线程终止。
- 不需要任何catch子句来处理可以被传播的异常。在线程死亡之前，异常被传递到一个未捕获异常的处理器。

- 如果不安装默认的处理器，默认的处理器为空。如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。
- 线程组是一个可以统一管理的线程集合。现在引入了更好的特性用于线程集合的操作，建议不要在自己的程序中使用线程组。

## 14.5 同步
- 竞争条件。
- 有两种机制防止代码块受并发访问的干扰。synchronized、Lock。
- synchronized关键字自动提供一个锁以及相关的条件。
- 一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。
- 如果使用锁，就不能使用带资源的try语句。
- 通常，可能想要保护若干个操作来更新或检查共享对象的代码块。
- 公平锁、常规锁。
- 条件对象（条件变量）。await、signalAll。
- 从1.0版开始，Java中的每一个对象都有一个内部锁。如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。
- 内部对象锁只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll/notify方法解除等待线程的阻塞状态。
- 将静态方法声明为synchronized也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。
- 内部锁和条件存在一些局限。
- 有时使用一个对象的锁来实现额外的原子操作，实际上称为客户端锁定。
- 监视器。
- volatile。
- finale变量。可以安全地访问一个共享域。
- 原子性。java.util.concurrent.atomic。
- 死锁。
- 线程局部变量。ThreadLocal。
- 线程在调用lock方法来获得另一个线程所持有的锁的时候，很可能发生阻塞。tryLock。
- 读/写锁。ReentrantReadWriteLock。
- stop方法天生就不安全。suspend方法会经常导致死锁。

## 14.6 阻塞队列
- 对于许多线程问题，可以通过使用一个或多个队列以优雅且安全的方式将其形式化。
- 生产者线程向队列插入元素，消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。
- 当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列导致线程阻塞。
- 阻塞队列的变种：LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue、DelayQueue。

## 14.7 线程安全的集合
- ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue。
- 集合返回弱一致性的迭代器。这意味着迭代器不一定能反映出它们被构造之后的所有的修改，但是它们不会将同一个值返回两次，也不会抛出ConcurrentModificationException异常。

- CopyOnWriteArrayList和CopyOnWriteArraySet是线程安全的集合，其中所有的修改线程对底层数组进行赋值。

- 任何集合类通过使用同步包装器变成线程安全的。
- 应该确保没有任何线程通过原始的非同步方法访问数据结构。最便利的方法是确保不保存任何指向原始对象的引用，简单地构造一个集合并立即传递给包装器。

## 14.8 Callable与Future
- Runnable封装一个异步运行的任务。Callable接口是一个参数化的类型。Future返回异步计算的结果。

## 14.9 执行器
- 构建一个新的线程是有一定代价的，因为设计与操作系统的交互。如果程序中创建了大量的生命周期很短的线程，应该使用线程池。
- 另一个使用线程池的理由是减少并发线程的数目。创建大量线程会大大降低性能甚至使虚拟机崩溃。
- 执行器（Executor）类有许多静态工厂方法用来构建线程池。
- newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool、newSingleThreadScheduledExecutor。
- 调用submit返回Future； 提交Runnable； 提交Callable。

- 控制一组相关任务： shutdownNow、invokeAny、invokeAll。

- Java SE 7中新引入了fork-join框架，专门用来支持计算密集型任务。
- fork-join框架使用了一种有效的智能方法来平衡可用线程的工作负载。这种方法称为工作密取。

## 14.10 同步器
- java.util.concurrent包包含了几个帮助管理相互合作的线程集的类。这些机制具有为线程之间的共用集结点模式提供的预置功能。
- CyclicBarrier，允许线程集等待直至其中预定数目的线程到达一个公共障栅，然后可以选择执行一个处理障栅的动作。
- CountDownLatch，允许线程集等待直到计算器减为0。
- Exchanger，允许两个线程在要交换的对象准备好时交换对象。
- Semaphore，允许线程集等待直到被允许继续运行为止。
- SynchronousQueue，允许一个线程把对象交给另一个线程。

- 同步队列是一种将生产者和消费者线程配对的机制。当一个线程调用SynchronousQueue的put方法时，它会阻塞直到另一个线程调用take方法为止，反之亦然。
- 即使SynchronousQueue类实现了BlockingQueue接口，概念上讲，它依然不是要给队列。它没有包含任何元素，它的size方法总是返回0.

## 14.11 线程与Swing
- Swing不是线程安全的。如果试图在多个线程中操纵用户界面的元素，那么用户界面可能崩溃。
- 将线程与Swing一起使用时，必须遵循两个简单的原则。
- 如果一个动作需要花费很长事件，在一个独立的工作器线程中做这件事不要在事件分配线程中作。
- 除了事件分配线程，不要在任何线程中接触Swing组件。（单一线程规则）
- EventQueue、SwingWorker。

{% endmarkmap %}
