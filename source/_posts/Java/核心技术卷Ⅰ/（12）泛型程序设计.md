title: 泛型程序设计
description: 泛型程序设计
categories: 
  - Java
  - 核心技术卷I
author: Jade
date: 2022-01-13 21:00:00
---

{% markmap %}

## 12.1 为什么要使用泛型程序设计
- 泛型程序设计（Generic programming）意味着编写的代码可以被很多不同类型的对象所重用。
- 在Java中增加泛型类之前，泛型程序设计使用继承实现的。

## 12.2 定义简单泛型类
- 一个泛型类就是具有一个或多个类型变量的类。
- 类定义中的类型变量指定方法的返回类型以及域和局部变量的类型。

## 12.3 泛型方法
- 可以定义一个带有类型参数的简单方法。

## 12.4 类型变量的限定
- 有时，类或方法需要对类型变量加以约束。extends。
- 限定类型用&分隔，而逗号用来分隔类型变量。
- 在Java的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中第一个。

## 12.5 泛型代码和虚拟机
- 虚拟机没有泛型类型对象。所有的对象都属于普通类。
- 无论何时定义一个泛型类型，都自动提供了一个响应的原始类型。
- 擦除类型变量，并替换为限定类型（无限定的变量用Object）。

- 当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。
- 泛型方法擦除，桥方法。
- 虚拟机中没有泛型，只有普通的类和方法。
- 所有的类型参数都用它们的限定类型替换。
- 桥方法被合成来保持多态。
- 为保持类型安全性，必要时插入强制类型转换。
- 设计Java泛型类型时，主要目标时允许泛型代码和遗留代码之间能够互操作。

## 12.6 约束与局限性
- 不能用基本类型实例化参数类型。（类型擦除，擦除之后，只有Object类型的域，而Object不能存储基本类型的值）
- 运行时类型查询只适用于原始类型。
- 不能创建参数化类型的数组。
- Varargs警告。 =>  @SafeVarargs。
- 不能实例化类型变量。
- 泛型类的静态上下文中类型变量无效。
- 不能抛出或捕获泛型类的实例。
- 注意擦除后的冲突。
- 要想支持擦除的转换，就需要强制限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。

## 12.7 泛型类型的继承规则
- 永远可以将参数化类型转换为一个原始类型。
- 泛型类可以扩展或实现其它的泛型类。

## 12.8 通配符类型
- 通配符类型： ? 。
- 通配符限定域类型变量限定十分类似。但是可以指定一个超类型限定。
- 可以使用无限定的通配符。与原始类型有很大不同。
- 通配符捕获。

## 12.9 反射和泛型
- 现在，Class类是泛型的。
- 类型参数十分有用，这是因为它允许Class\<T\>方法的返回类型更加具有针对性。
- 有时，匹配泛型方法中的Class\<T\>参数的类型变量很有实用价值。
- 擦除的类仍然保留一些泛型祖先的微弱记忆。
- 为了表达泛型类型声明，Java SE 5.0在java.lang.reflect包中提供了一个新的接口Type。
- Type接口包含了子类型： Class类、TypeVariable接口、WildcardType接口、ParameterizedType接口、GenericArrayType接口。

{% endmarkmap %}
