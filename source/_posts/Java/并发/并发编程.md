title: 并发编程
categories:
  - Java
  - 并发
tags:
  - How
description: 并发编程
author: Jade
date: 2020-07-21 13:50:00
---
> 操作系统通过时间片算法来并行执行各个程序。  
> 并发编程是指在同一台处理器上，并发处理多个任务。

## 相关概念
### 进程
操作系统进行资源分配的最小单位。
### 线程
操作系统能够进行运算调度的最小单位。
### 临界区
表示一种公共资源或共享数据，同一时间，只允许一个线程访问。
### 缓冲区
内存的一部分，用来缓冲输入或输出的数据。

## 并发编程解决的问题
- 线程间的通信问题
> 通信方式
	 - 数据共享 通过读写公共内存中的公共状态来隐式进行通信。
	 - 消息传递 通过明确的发送消息来显式进行通信（Java中典型的消息传递方式是wait()和notify()）。
- 线程间的同步问题
> 同步 指程序用于控制不同线程之间操作发生相对顺序的机制。

## 计算机内存模型

### 高速缓存
随着CPU技术的发展，CPU的执行速度越来越快，而内存的速度没有多大变化，于是，为了提高CPU利用率，在CPU和内存之间增加高速缓存。  
按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可分为一级缓存（L1），二级缓存（L2），部分高端CPU还具有三级缓存（L3）。  
多CPU/多核CPU每个核心都含有一套L1（L1、L2）缓存，而共享L2（L3）缓存。  
基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为操作系统引入了一个新的问题---缓存一致性，从而带来更高的复杂度。
### 缓存一致性协议
MSI、MESI、MOSI、Synapse、Firefly、Dragon Protocol
#### MESI
##### 状态
- M Modified 修改
- E Exclusive 独享
- S Shared 共享
- I Invalid 无效
##### 状态转换图
高速缓存行数据状态有四种，引起数据状态转换的操作也有四种，所以共有16中状态转换的情况。
![upload successful](/images/pasted-1.png)
> CPU高速缓存通过总线连接，总线还连接了主存。  
> 对于Local Read 和 Local Write 操作，不经过总线，不会被其它CPU控制器监听到。
> 对于Remote Read 和 Remote Write 操作，需要其它CPU共同参与，所以这两个操作所有CPU控制器都能监听到，并能知道是不是自己发出的。

##### 允许状态图
对于任意给定的高速缓存对，给定高速缓存行的允许状态如图。
![upload successful](/images/pasted-2.png)

## 重排序
重排序是编译器和处理器在执行程序时为了提供性能而做的一些优化。

![upload successful](/images/pasted-4.png)
### 类型
#### 编译器优化的重排序
编译器在不改变单线程程序语音的前提下，可以重新安排语句的执行顺序。
#### 指令集并行的重排序
如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
#### 内存系统的重排序
由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
### 原则
重排序需要遵循一定的规则，不然其结果可能会影响程序的执行结果。
#### 数据依赖性
数据依赖： 如果两个操作同时访问一个变量，其中一个操作时写操作，此时这两个操作就构成了数据依赖。
#### 控制依赖性
#### as-if-serial
不管如果重排序，都必须保证代码在单线程下的运行正确。
### 并发重排序
#### 问题
如果代码中存在控制依赖的时候，会影响指令序列执行的并行度。因此，编译器和处理器会猜测（Speculation）执行来客服控制的相关性，所以重排序破坏了程序顺序规则。  
程序顺序规则：指定执行顺序于实际代码中的执行顺序时一致的，但是处理器和编译器会进行冲重排序，只要最后的记过不会改变，该重排序就是合理的。  
在单线程程序中，由于as-if-serial的存在，对存在控制依赖的操作重排序，不会改变执行结果，但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。  
PS：一个线程里面的条件依赖于另一个线程里面的数据。
#### 解决方案
- 内存屏障 Java编译器在适当的位置插入内存屏障指令来禁止特定类型的处理器重排序。

## JVM内存模型
### 分类
根据JVM规范，JVM内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈五个部分。
### 问题
- 不可见
> 多个线程从主存中读取数据，其中一个线程的修改对其它线程不可见。

使用volatile关键字，表示只能从主存中读取，修改后写回主存。
- 竞争
> 多个线程同时修改同一份数据。

使用synchronized关键字，对数据加锁，释放锁之前其它线程不能访问。


## JMM
Java Memory Model，Java内存模型,定义了JVM在计算机内存中的工作方式。JVM是整个计算机虚拟模型，所以JMM属于JVM。  
在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，JMM就是为了屏蔽系统和硬件的差异。  
### 内存模型
JMM用来描述JVM是如何和计算机内存交互的。而JVM是计算机的一个模型，自然包含内存结构。
### 目标
定义程序中各个变量的访问规则。
### 主内存和工作内存
JMM规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对象工作内存中的变量，线程间变量值的传递均需要在主内存中来完成。

![upload successful](/images/pasted-3.png)

### 内存交互操作
|操作|说明|
|-|-|
|lock|作用于主内存的变量，把一个变量标识为一条线程独占状态。|
|unlock|作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。|
|read|作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。|
|load|作用于工作内存的变量，把read操作从主内存中得到的变量值存入工作内存的变量副本中。|
|use|作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时会执行这个操作。|
|assign|作用于工作内存的变量，把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时会执行这个操作。|
|store|作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作。|
|write|作用于主内存的变量，把store操作从工作内存中一个变量的值传送到主内存的变量中。|

对这8种指定的使用，有以下规则：
- 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
- 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
- 不允许一个线程将没有assign的数据从工作内存同步回主内存
- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作
- 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
- 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
- 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
- 对一个变量进行unlock操作之前，必须把此变量同步回主内存

### 特新
#### 原子性
指一个操作是不可终端的，即使是在多个线程一起执行的情况下，一个操作一旦考试执行，就不会收到其它线程的干扰。
JMM内存交互操作，在操作系统里都是不可分隔的单元。被synchronized关键字或其它锁包裹起来的操作也可以认为是原子的。从一个线程观察另一个线程时，看到的都是一个个原子性的操作。
#### 可见性
指在多线程情况下，当一个线程修改了某一个共享变量的值之后，其它线程是否能够立即知道这个修改。
#### 有序性
如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句指“线程内表现为串行的语义”（as-if-serial），后半句值“指令重排序”和普通变量的”工作内存与主内存同步延迟“的现象。

### happens-before
JMM使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。  
重排序需要遵循happens-before规则。
- 程序次序规则(Program Order Rule)：在同一个线程中，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操纵。准确的说是程序的控制流顺序，考虑分支和循环等。
- 管理锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面（时间上的顺序）对同一个锁的lock操作。
- volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面（时间上的顺序）对该变量的读操作。
- 传递性(Transitivity)：如果操作A 先行发生于操作B，操作B 先行发生于操作C，那么可以得出A 先行发生于操作C。
- 线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。
- 线程终止规则(Thread Termination Rule)：线程的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
- 线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时事件的发生。Thread.interrupted()可以检测是否有中断发生。
- 对象终结规则(Finilizer Rule)：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()的开始。

<p style="text-align: center"><strong>END</strong></p>