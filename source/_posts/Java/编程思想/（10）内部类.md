title: 内部类
description: 内部类
categories: 
  - Java
  - 编程思想
author: Jade
date: 2021-12-13 21:00:00
---

{% markmap %}

## 10.0 序
- 可以将一个类的定义放在另一个类的定义内部，这就是内部类。

## 10.1 创建内部类
- 在外部类方法中使用内部类，与使用普通类没什么不同。
- 外部类有一个方法，该方法返回一个指向内部类的引用。
- 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，必须具体地指明这个对象的类型。

## 10.2 链接到外部类
- 当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。
- 内部类拥有其外围类的所有成员的访问权。
- 构建内部类对象时，需要一个指向其外围类对象的引用。

## 10.3 使用.this与.new
- 需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型。
- 必须使用外部类的对象来创建内部类的对象。在new表达式中提供对外部类对象的引用。这也解决了内部类名字作用域的问题。
- 如果创建嵌套类（静态内部类），不需要对外部类对象的引用。

## 10.4 内部类与向上转型
- 当将内部类向上转型为其基类，尤其时转型为一个接口的时候，内部类就有了用武之地。
- 从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。
- 内部类（某个接口的实现）能够完全不可见，并且不可用，所得到的只是指向基类或接口的引用，所以能够很方便的隐藏实现细节。
- private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。

## 10.5 在方法和作用域内的内部类
- 理由： 1. 实现了某类型的接口，可以创建并返回对其的引用。 2. 解决复杂的问题，创建一个类来辅助解决方案，且不希望这个类是公共可用的。
- 在方法的作用域内创建一个完整的类，被称作局部内部类。
- 可以在任意的作用域（{}）内嵌入一个类。

## 10.6 匿名内部类
- 将返回值的生成与表示这个返回值的类的定义结合在一起，且这个类是匿名的。
- 匿名内部类基类需要一个有参数的构造器，只需简单地传递合适的参数给基类的构造器即可。
- 匿名内部类末尾的分号，并不是用来标记此内部类结束的，标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类。
- 在匿名内部类中定义字段是，还能够对其执行初始化操作。
- 如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的。
- 匿名类中不可能有命名构造器，但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果。限制：不能重载实例初始化方法。
- 匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。如果是实现接口，也只能实现一个接口。
- 匿名内部类实现工厂： 1. 产品构造器私有化； 2. 将工厂声明为产品的static域； 3. 使用匿名内部类实例化工厂。

## 10.7 嵌套类
- 如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为嵌套类。
- 要创建嵌套类的对象，并不需要其外围类的对象。
- 不能从嵌套类的对象中访问非静态的外围类对象。
- 普通的内部类不能有static成员，也不能包含嵌套类。但是嵌套类可以包含这些。
- 在一个普通的内部类中，通过一个特殊的this引用可以链接到其外围类对象。嵌套类没有这个特殊的this引用，使得它类似于一个static方法。
- 嵌套类可以作为接口的一部分。如果想创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。
- 一个内部类能透明地访问所有它嵌入的外围类的成员。

## 10.8 为什么需要内部类
- 每个内部类都能独立的继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
- 内部类允许继承多个非接口类型（类或抽象类）。
- 内部类特性：
  1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。
  2. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
  3. 创建内部类对象的时刻并不依赖于外围类对象的创建。
  4. 内部类并没有“is-a”关系，它就是一个独立的实体。

- 闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。 -- 内部类是面向对象的闭包。
- 通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。
- 通过内部类提供的闭包功能实现回调，比指针更灵活、更安全。
- 回调的价值在于灵活性，可以在运行时动态地决定需要调用什么方法。

- 应用程序框架是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，已解决特定问题。 -- 模板方法。
- 控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统称为事件驱动系统。
- 内部类允许： 1. 控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。 2. 内部类能够很容易地访问外围类的任意成员，所以可以避免这种实现变的笨拙。
- 命令模式。

## 10.9 内部类的继承
- 内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类时，必须使用外围类对象调用super，才能提供必要的引用。

## 10.10 内部类可以被覆盖吗
- 当继承了某个外围类时，内部类并没有发生变化，子类的内部类与基类的内部类是连个完全独立的实体，各自在自己的命名空间内。
- 继承某个外围类的时候，可以明确地继承某个内部类。

## 10.11 局部内部类
- 局部内部类不能有访问说明符，因为它不是外围类的一部分。
- 局部内部类可以访问当前代码块内的常量，以及此外围类的所有成员。
- 使用局部内部类而不使用匿名内部类的理由： 1. 需要一个已命名的构造器，或需要重载构造器； 2. 需要不止一个该内部类的对象。

## 10.12 内部类标识符
- 规则： 外围类名字 + “$” + 内部类的名字。
- 编译器为匿名内部类产生一个数字作为其标识符。

## 10.13 总结
- 比起面向对象编程中其他概念来说，接口和内部类更深奥复杂。

{% endmarkmap %}

## 理解
- 本章有几个概念，外部类、外围对象、外围类，感觉傻傻分不清。不知道是不是翻译的问题，为什么用的名词不统一。
- 内部类的具体使用场景需要慢慢感受。
