title: 复用类
description: 复用类
categories: 
  - Java
  - 编程思想
author: Jade
date: 2021-12-04 20:00:00
---

复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情。
使用类而不破坏现有程序代码。 1. 组合； 2. 继承。
继承是面向对象程序设计的基石之一。

## 7.1 组合语法
将对象引用置于新类中。
组合对象初始化：1. 在定义对象的地方；2. 在类的构造器中；3. 使用对象之前； 4. 使用实例初始化（代码块）。

## 7.2 继承语法
继承是所有OOP语言和Java语言不可缺少的组成部分。
当创建一个类时，总是在继承。除非已明确指出要从其他类中继承，否则就是在隐式地从Java的标准跟类Object进行继承。
继承声明式通过在类主体的左边花括号之前，书写后面紧随基类名称的关键字extends而实现的。会自动得到基类中所有域和方法。
Java中用super关键字表示超类的意思，当前类就是从超类继承的来。
在继承的过程中，并不一定非得使用基类的方法，也可以在导出类中添加新方法。
在构造器中调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需要的所有知识和能力。Java会自动在导出类的构造器中插入对基类构造器的调用。
如果没有默认的基类构造器，或想调用一个带参数的基类构造器，就必须用super显式地编写调用基类构造器的语句，并且配以适当的参数列表。

## 7.3 代理
Java没有提供对代理的直接支持。
这是继承域组合之间的中庸之道，将一个成员对象置于所要构造的类中（就像组合），与此同时在新类中暴露了该成员对象的所有方法（就像继承）。

## 7.4 结合使用组合和继承
虽然编译器强制要求初始化基类，并且要求在构造器起始处就要这么做，但是并不监督必须将成员对象也初始化。
try-finally。
手动清理时注意清理顺序。一般来说与生成顺序相反。
如果Java的基类拥有多个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本（与C++不同）。无论是在该层或者它的基类中对方法进行定义，重载机制都可以正常工作。
Java SE5.0 新增加了@Override注解表示覆写每个方法。可以防止在不想重载时而意外地进行了重载。

## 7.5 在组合与继承之间选择
组合和继承都允许在新的类中放置子对象，组合是显式做，继承是隐式地做。
组合技术通常用于想在新类中使用现有类地功能而非它地接口这种情形。即在新类中嵌入某个对象，让其实现所需要的功能，但类中的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口。
在继承地时候，使用某个现有类，并开发一个它的特殊版本。

## 7.6 protected关键字
就类用户而言，这是private的，但对于任何继承于此类的导出类或其他任何位于同一个包内的类来说，它却是可以访问的。
尽管可以创建protected域，但最好的方式还是将域保持为private，应当一直保留“更改底层实现”的权利，然后通过protected方法来控制类的继承者的访问权限。

## 7.7 向上转型
“为新的类提供方法”并不是继承技术最重要的方面，其最重要的方面是用来表现新类和基类之间的关系。这种关系可以用“新类是现有类的一种类型”这句话加以概括。
这个描述并非只是一种解释继承的华丽的方式，这直接是有语言所支撑的。
传统类的继承图的绘制方法：将根置于页面的顶端，然后逐渐向下。
由导出类转型成基类，在继承图上是向上移动的，因此一般成为向上转型。
在向上转型的过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们。
慎用。

## 7.8 final关键字
根据上下文环境，Java的关键字final的含义存在着细微的区别，但通常指的是“这是无法改变的”。
final可用于 数据、方法和类。

编译时常量（带有恒定初始值）： final 基本类型/基本类型计算式。必须在定义的时候对其进行赋值。
一个既是static又是final的域只占据一段不能改变的存储空间。
对于基本类型，final使数值恒定不变；而用于对象引用，final使引用恒定不变。对象自身是可以被修改的。
static final 基本类型：用大写表示，用下划线分隔单词。
看起来，使引用成为final没有使基本类型成为final的用处大。

空白final，指被声明为final但未给定处置的域。
编译器确保空白final在使用前必须被初始化。
空白final在关键字final的使用上提供了更大的灵活性。

Java允许在参数列表中以声明的方式将参数指明为final。意味着无法在方法中更改参数引用所指向的对象。或无法修改基本类型的参数。
这一特性主要用来向匿名内部类传递数据。

final方法：1. 锁定方法，以防继承。确保在继承中使方法行为保持不变，并且不会被覆盖；2. 效率（早期版本）。
类中所有的private方法都隐式地指定为是final的。
覆盖只有在某方法是基类的接口的一部分是才会出现。如果某方法是private，只不过是具有相同的名称而已。

当将某个类的整体定义为final时，表明了你不打算继承该类，而且也不允许别人这样做。
final类的域可以根据需要选择为是或不是final。不论类是否被定义为final，相同的规则都适用于定义为final的域。
final类中的方法都隐式指定为是final的。可以添加final修饰词，但没有任何意义。

要预见类是如何被复用的一般是很困难的。

## 7.9 初始化及类的加载
在许多传统语言中，程序是作为启动过程的一部分立刻被加载的。然后是初始化，紧接着程序开始运行。
Java采用了一种不同的加载方式。每个类的编译代码都存在于它自己的独立的文件中，该文件只在需要使用程序代码时才会被加载。
构造器也是static方法。类是在任何static成员被访问时加载的。
加载顺序：基类static - 导出类static - 初始化 - 基类构造器 - 导出类构造器 - 实例变量 - 其余部分。

## 理解
继承和组合都能从现有类型生成新类型。组合一般是将现有类型作为新类型底层实现的一部分来加以复用，而继承复用的是接口。
程序开发是一个增量过程。
继承是面向对象的基础，但是每个语言的实现却并不相同。