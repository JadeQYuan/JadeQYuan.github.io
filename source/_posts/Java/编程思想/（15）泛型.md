title: 泛型
description: 泛型
categories: 
  - Java
  - 编程思想
author: Jade
date: 2021-12-20 15:00:00
---

{% markmap %}

## 15.0 序
- 一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。
- 在面向对象编程语言中，多态算是一种泛化机制。这种灵活性大多数时候也会有一些性能损耗。
- 有时候，拘泥于单继承体系，会使程序受限太多。有的时候，即便使用了接口，对程序的约束也还是太强。
- 泛型实现了参数化类型的概念，使代码可以应用于多种类型。
- 泛型在编程语言中出现时，最初的目的是希望类或方法能够具备最广泛的表达能力。通过解耦类或方法与所使用的类型之间的约束。
- Java中的泛型并没有这么高的追求。

## 15.1 与C++的比较
- 设计Java的灵感主要来自C++。尽管如此，学习Java时，基本上可以不用参考C++。除非与C++的比较可以加深理解。
- Java中的泛型需要与C++进行一番比较。理解C++模板的某些方面，有助于理解泛型的基础。

## 15.2 简单泛型
- 有许多原因促成了泛型的出现，而最引人注目的一个原因，就是为了创造容器类。
- 泛型的主要目的之一是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。
- Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。

- 有了泛型，能够仅一次方法调用就能返回多个对象。同时，在编译期就能确保类型安全。
- 元组（数据传送对象、信使）：将一组对象直接打包存储于其中的一个单一对象。这个对象容器允许读取其中元素，但是不允许向其中存放新的对象。
- 通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型。
- 可以读取，随心所欲的使用，但是无法赋值。使用 public final修饰。
- 利用继承机制实现长度更长的元组。
- 为了使用元组，只需定义一个长度适合的元组，将其作为方法的返回值，然后在return语句中创建该元组，并返回即可。

- 使用泛型实现内部链式存储机制。
- 使用末端哨兵来判断何时为空。

- 使用泛型构建一个可以应用于各种类型的对象的工具。

## 15.3 泛型接口
- 生成器，一种专门负责创建对象的类。是工厂方法的一种应用（生成器不需要参数，而工厂方法一般需要参数）。
- 基本类型无法作为类型参数。 -- 自动装箱、自动拆箱。
- 适配器。

## 15.4 泛型方法
- 可以在类中包含参数化方法。是否拥有泛型方法，与其所在的类是否是泛型类没有关系。
- 泛型方法使得该方法能够独立于类而产生变化。
- 如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法。对于一个static方法而言，无法访问泛型类的类型参数。
- 使用泛型类时，必须在创建对象的时候指定类型参数的值。而使用泛型方法的时候，通常不必指明参数类型，编译器会进行类型参数推断。

- 使用泛型类无法进行泛型推断。 -- 创建工具类，定义泛型方法，简化部分工作。 -- 额外复杂度。
- 类型推断只对赋值操作有效，其他时候并不起作用。
- 在泛型方法中，可以显式地指明类型。必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内。
- 显式指明类型时，如果时定义在该方法的类的内部，必须在点操作符之前使用this关键字。如果是static方法，必须在点操作符之前加上类名。
- 只有在编写非赋值语句时，才需要显式指明类型。

- 泛型方法与可变参数列表能够很好的共存。

- 有了类型参数推断，再加上static方法，可以重新编写之前的元组工具，使其成为更通用的工具类库。

- 用Set来表达数学中的关系式。并集、交集、差集、补集。

## 15.5 匿名内部类
- 泛型可以应用于内部类以及匿名内部类。

## 15.6 构建复杂类型
- 泛型的一个重要好处是能够简单而安全地创建复杂的模型。

## 15.7 擦除的神秘之处
- 在泛型代码内部，无法获得任何有关泛型参数类型的信息。
- Java泛型是使用擦除来实现的。使用泛型时，任何具体的类型信息都被擦除了。

- C++中，当模板被实例化时，模板代码知道其模板参数的类型。Java必须给定泛型类的边界，重用extends关键字。
- 泛型类型参数将擦除到它的第一个边界。
- 希望代码能够跨多个类工作时，使用泛型才有所帮助。

- 擦除不是一个语言特性，是Java的泛型实现的一种折中。
- 擦除减少了泛型的泛化性。
- 在基于擦除的实现中，泛型类被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型。
- 泛型类型只有在静态类型检查期间才出现，在此之后，程序中所有的泛型类型都将被擦除，替换为它们的非泛型上界。
- 擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“迁移兼容性”。

- 擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作之中。例如转型、instanceof操作和new表达式。
- 擦除和迁移兼容性意味着，使用泛型并不是强制的。
- 当希望将类型参数不要仅仅当作Object处理时，需要付出额外努力来管理边界。
- Java SE5提供了@SuppressWarnings注解关闭警告。

- 泛型最令人困惑的方面源自：可以表示没有任何意义的事物。
- 对于在泛型中创建数组，使用Array.newInstance是推荐的方式。
- 即便擦除在方法或类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性。
- 因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点。
- 在泛型中的所有动作都发生在边界处。对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。

## 15.8 擦除的补偿
- 擦除丢失了在泛型代码中执行某些操作的能力。任何在运行时需要知道确切类型信息的操作都将无法工作。
- 有时必须通过引入类型标签来对擦除进行补偿。这意味着需要显式传递类型的Class对象，以便在类型表达式中使用。
- 编译器将确保类型标签可以匹配泛型参数。

- 无法创建一个new T()。在C++中，这种操作很自然、很直观，并且很安全。在编译期受到检查。
- Java中的解决方案是传递一个工厂对象，并使用它来创建新的实例。最便利的工厂对象就是Class对象。
- Sun建议使用显式的工厂，并将限制其类型，使得只能接受实现了这个工厂的类。
- 另一种方式是模板方法设计模式。

- 不能创建泛型数组。一般的解决方案是使用ArrayList。这将获得数组的行为，以及由泛型提供的编译期的类型安全。
- 可以定义一个泛型数组引用，但是永远都不能创建这个确切类型的数组（包括类型参数）。
- 创建一个Object数组，并将其转型为泛型数组类型。这可以编译，但是不能运行，将产生ClassCaseException。
- 所有数组无论它们持有的类型如何，都具有相同的结构（每个数组槽位的尺寸和数组的布局）。
- 成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型。
- 最好是在集合内部使用Object[]，使用数组元素时，添加一个对T的转型。
- Java SE5标准类库的源代码，从Object数组到参数化类型的转型遍及各处
- 即使在Java类库源代码中出现了某些惯用法，也不能表示这就是正确的解决之道。

## 15.9 边界
- 边界使得可以在用于泛型的参数类型上设置限制条件。
- 尽管可以强制规定泛型可以应用的类型，但是其潜在的一个更重要的效果是可以按照自己的边界类型来调用方法。
- extends关键字在泛型边界上下文环境中和在普通情况下所具有的意义是完全不同的。
- 在继承的每个层次上添加边界限制。
- 通配符被限制为单一边界。

## 15.10 通配符
- 可以向导出类型的数组赋予基类型的数组引用。 -- 向上转型不合适用在这里。
- 数组的行为是它可以持有其它对象。数据对象可以保留有关它们包含的对象类型的规则。
- 对数组的赋值，在运行时可以发现插入了不正确的类型，但是泛型的主要目标之一是将这种错误检测移入到编译期。
- 试图使用泛型容器来代替数组。 -- 编译错误。
- 与数组不通过，泛型没有内建的协变类型。数组在语言中是完全定义的，因此可以内建了编译期和运行时的检查。
- 在两个类型之间建立某种类型的向上转型关系，这是通配符所允许的。 -- 丢失向其中床底任何对象的能力。

- ArrayList，add接受一个具有泛型参数类型的参数，但是contains和indexOf接受Object类型的参数。
- 编译器将直接拒绝对参数列表中设计通配符的方法的调用。

- 超类型通配符，可以声明通配符是由某个特定类的任何基类来界定的。
- 不能对泛型类型给出一个超类型边界（\<T super MyClass\>）。使得可以安全地传递一个类型对象到泛型类型中。
- 超类型边界放松了在可以向方法传递的参数上所作的限制。

- 使用无界通配符好像等价于使用原生类型。
- 在处理多个泛型参数时，有时允许一个参数可以是任何类型（使用无界通配符），同时为其它参数确定某种特定类型。
- 原生类型将持有任何类型的组合，而通配符将持有具有某种具体类型的同构集合。
- 编译器何时关注原生类型和设计无界通配符的类型之间的差异？ -- 示例。
- 使用确切类型代替通配符类型的好处是，可以用泛型参数来做更多的事。
- 使用通配符必须接受范围更宽的参数化类型作为参数。

- 有一种情况特别需要使用\<?\>而不是原生类型。
- 如果向一个使用\<?\>的方法传递原生类型，编译器可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。这被称为捕获转换。
- 捕获转换只有在方法内部，且需要使用确切的类型的情况下可以工作。

## 15.11 问题
- 基本类型不能作为类型参数。 -- 包装器类及自动装箱。
- 自动包装机制不能应用于数组。

- 一个类不能实现同一个泛型接口的两种变体。由于擦除的原因，这两个变体会成为相同的接口。

- 使用带有泛型类型参数的转型或instanceof不会由任何效果。
- 有时，泛型没有消除对转型的需要，这就会由编译器产生警告，而这个警告是不恰当的。

- 由于擦除的原因，重载方法就产生相同的类型签名。
- 当被擦除的参数不能产生唯一的参数列表时，必须提供明显有区别的方法名。

- 基类劫持了接口。

## 15.12 自限定的类型
- 古怪的循环泛型（CRG）的本质：基类用导出类替代其参数。
- CRG意味着泛型基类变成了一种其所有导出类的公共功能的模板。在所产生的类中将使用确切类型而不是基类型。

- 自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。
- 自限定的参数意义：可以保证类型参数必须与正在被定义的类相同。
- 自限定限制只能强制作用于继承关系。
- 如果使用自限定，就应该了解这个类所使用的类型参数将于使用这个参数的类具有相同的基类型。

- 自限定的价值在于它们可以产生协变参数类型（方法参数类型会随子类而变化）。
- 如果不适用自限定，将重载参数类型。如果使用了自限定，只能获得某个方法的一个版本，它将接受确切的参数类型。

## 15.13 动态类型安全
- Java SE5的Collections中有一组工具，可以解决向之前的代码传递泛型容器，从而可能会破坏容器的类型检查问题。
- 工具：checkedCollection、checkedList、checkedMap、checkedSet、checkedSortedMap、checkedSortedSet。

## 15.14 异常
- 由于擦除的原因，将泛型应用于异常是非常受限的。
- catch语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。
- 泛型类也不能直接或间接继承自Throwable。
- 类型参数可能会在一个方法的throws子句中用到，这使得可以编写随检查型异常的类型而发生变化大的泛型代码。

## 15.15 混型
- 混型基本概念是：混合多个类的能力，以产生一个可以表示混型中所有类型的类。
- 混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。
- 如果在混型中修改某些东西，这些修改会应用于混型所应用的所有类型之上。

- 在C++中，使用多重继承的最大理由，就是为了使用混型。
- 对于混型来说，更有趣、更优雅的方式是使用参数化类型，因为混型就是继承自其类型参数的类。
- 在C++中，可以很容易的创建混型，因为C++能够记住其模板参数的类型。 -- Java泛型不允许这样，擦除会忘记基类类型。

- 一种更常见的推荐解决方案是使用接口来产生混型效果。 -- 使用代理。

- 可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器的继承结构。
- 装饰器只是对由混型提出的问题的一种局限的解决方案。

- 可以使用动态代理来创建一种比装饰器更贴近混型模型的机制。
- 通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。
- 仍旧不如C++的方式好，因为在调用方法之前，必须先向下转型。但是，它更接近于真正的混型。

## 15.16 潜在类型机制
- 潜在类型机制是一种代码组织和复用机制。
- 两种支持潜在类型机制的语言实例是Python（动态类型语言）和C++（静态类型语言）。
- Java没有对这种特性的支持。

## 15.17 对缺乏潜在类型机制的补偿
- 通过反射使用潜在类型机制。但是将所有的类型检查都转移到了运行时。
- 反射和可变参数，内建的Iterable接口。
- 用适配器仿真潜在类型机制。

## 15.18 将函数对象用作策略
- 函数对象就是在某种程度上行为像函数的对象。
- 函数对象的价值在于，与普通方法不同，它们可以传递出去，并且还可以拥有在多个调用之间持久化的状态。
- 在C++中，潜在类型机制将在调用函数是负责协调各个操作，但是在Java中，需要编写函数对象来将泛型方法适配为特定的需求。
- 适配器模式和策略模式的结合。

## 15.19 总结

{% endmarkmap %}
