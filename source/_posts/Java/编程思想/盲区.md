title: 盲区
description: 盲区
categories: 
  - Java
  - 编程思想
author: Jade
date: 2021-11-30 18:00:00
---

## 1.1 抽象过程
- 面向对象与面向过程的区别。 函数调用/对象。

## 1.2 抽象数据类型
- 在面向对象程序设计中，使用class表示数据类型。即数据类型和类是等价的。
- 字段：数据成员；方法： 成员函数。 成员 = 字段+函数+内部类？

## 2.8 javadoc
- 自动生成文档，使用方面比源码更加方便。

## 3 操作符
- 除了“=”可用于对象，“+=”、“=”可用于字符串。其它情况都是基本数据类型。
- 使用操作符会自动提升类型。
- 操作符优先级建议使用括号来明确表示。

## 5.4 this
- 必须使用this情况： 1. 构造器初始化变量名区分； 2. return this;； 3. 构造器调用其它构造器； 4. this作为参数； 5. 泛型方法显式类型说明。

## 5.5 垃圾回收器
- 自适应的、分代的、停止-复制、标记-清除 式垃圾回收器。
- 垃圾回收本身也有开销。

## 5.6 成员初始化
- 自动初始化，在调用构造器之前进行。
- 每个对象都有相同的初值。

## 5.8 数组
- Java不允许下标越界，通过每次在访问数组的时候检查边界实现。检查是需要开销的。

## 5.10 速度
- Java 的速度问题是涉足某些特定编程领域的障碍。

## 6.1 CLASSPATH
- 运行时通过参数指定CLASSPATH或者通过环境变量配置。

## 6.2 protected
- protected处理的是继承的概念。也提供了包访问权限。

## 6.3 封装
- 访问权限的控制常被称为是具体实现的隐藏。把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作封装。其结果是一个同时带有特征和行为的数据类型。

## 7.8 final
- private方法被隐式声明为final。

## 7.9 初始化顺序
- 基类 static - 导出类 static - 初始化 - 基类构造器 - 导出类构造器 - 实例变量 - 其余部分。
- 构造器也是static方法。

## 8.2 动态绑定
- Java中除了static方法和final方法外，其他的所有方法都是后期绑定，且会自动发生。
- 想要实现动态绑定，就必须具有某种机制，在运行时判断对象的类型。

## 8.3 构造器和多态
- 准则：构造器只用来初始化，避免调用其它方法。

## 8.4 协变返回类型
- 在导出类的被覆盖方法可以返回基类的返回类型的某种导出类型。

## 9.2 包访问权限接口
- 实现包访问权限的接口，其方法必须声明为public。

## 9.7 接口中的域
- 如果是常量或常量表达式，则在类加载阶段赋值并放入常量池。如果是非常量表达式，则在类初始化阶段赋值。

## 9.8 嵌套接口
- 实现了一个private接口的内部类，同样可以被实现为public类，但是只能被其自身所使用。
- 实现一个private接口只是一种方式，强制该接口中的方法定义不要添加任何类型信息（不允许向上转型）。
- 返回对private接口的引用的public方法，只有以各种方式可用，就是将返回值交给有权使用它的对象。

## 11.13 Foreach与迭代器
- Iterable接口被foreach用来在序列中移动。

## 12.9 异常的限制
- 当覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常。
- 异常限制对构造器不起作用。
- 派生类构造器的异常说明必须包含基类构造器的异常说明。
- 派生类构造器不能捕获基类构造器抛出的异常。
- 强制派生类遵守基类方法的异常说明。
- 派生类方法可以不抛出异常，即使它是基类所定义的异常。
- 异常说明本身并不属于方法类型的一部分，因此不能基于异常说明来重载方法。

## 14.3 instance of|isInstance|isAssignableFrom
- instance of 只能与命名类型比较，无法比较class对象。
- isInstance动态测试对象是否是该类实例。
- isAssignableFrom 针对子类class与父类class。

## 15.2 元组
- 元组（数据传送对象、信使）：将一组对象直接打包存储于其中的一个单一对象。这个对象容器允许读取其中元素，但是不允许向其中存放新的对象。

## 15.4 泛型方法
- 泛型推断只对赋值操作有效。 JAVA SE7？