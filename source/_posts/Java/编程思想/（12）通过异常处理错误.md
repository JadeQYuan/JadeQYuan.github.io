title: 通过异常处理错误
description: 通过异常处理错误
categories: 
  - Java
  - 编程思想
author: Jade
date: 2021-12-15 21:00:00
---

{% markmap %}

## 12.0 序
- Java的基本理念是“结构不佳的代码不能运行”。
- 发现错误的理想时机是在编译阶段。
- 编译期间并不能找出所有的错误，余下的问题必须在运行期间解决。这就需要错误源能通过某种方式，把适当的信息传递给某个接收者，该接收者将知道如何正确处理这个问题。
- 改进的错误恢复机制是提供代码健壮性的最强有力的方式。
- Java的主要目标之一是创建供他人使用的程序构件。Java使用异常来提供一致的错误报告模型，使得构件能够与客户端代码可靠地沟通问题。
- Java中的异常处理的目的在于通过使用少于目前数量的代码来简化大型、可靠的程序的生成。
- 异常处理是Java中唯一正式的错误报告机制，并且通过编译器强制执行。

## 12.1 概念
- C以及其他早期语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的基础之上，而并不属于语言的一部分。
- 通常会返回某个特殊值或者设置某个标志，并且假定接收者将对这个返回值或标志进行检查，以判定是否发生了错误。
- 用强制规定的形式来消除错误处理过程中随心所欲的因素。往往能够降低错误处理代码的复杂度。
- 把“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。

## 12.2 基本异常
- 异常情形是指阻止当前方法或作用域继续执行的问题。普通问题是指在当前环境下能得到足够的信息，总能够处理这个错误。
- 当抛出异常后，首先，将使用new在堆上创建异常对象；然后，当前的执行路径被终止，从当前环境中弹出对异常对象的引用，异常处理机制接管程序，执行异常处理程序。
- 异常处理程序的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。
- 创建一个代表错误信息的对象，并且将它从当前环境中抛出，把错误信息传播到更大的环境中，这被称为抛出一个异常。
- 异常允许强制程序停止运行，并报告出现了什么问题，或者强制程序处理问题，并返回到稳定状态。
- 标准异常构造器： 默认构造器；接受字符串作为参数。
- 使用new创建了异常对象之后，此对象的引用将传给throw。
- 可以简单地把异常处理堪称一种不同的返回机制。
- 能够抛出任意类型的Throwable对象，它使异常类型的根类。通常，对于不同类型的错误，要抛出相应的异常。
- 错误信息可以保存在异常对象或者用异常类的名称来暗示。通常，异常对象中仅有的信息就是异常类型，除此之外不包含任何有意义的内容。

## 12.3 捕获异常
- 监控区域使一段可能产生异常的代码，并且后面跟着处理这些异常的代码。
- 如果在方法内部抛出了异常，且不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。这个块称为try块。
- 对于不支持异常处理的程序语言，要想仔细检查错误，就得在每个方法调用的前后加上设置和错误检查的代码，甚至在每次调用同以方法时也得这么做。
- 有了异常处理机制，可以把所有哦动作放在try块里，然后只需在一个地方就可以捕获所有异常。这意味着程序更容易编写和阅读。
- 抛出的异常必须在某处得到处理，这个地点就是异常处理程序。而且针对每个要捕获的异常，得准备相应的处理程序。
- 异常处理程序紧跟在try块之后，以关键字catch表示。
- 在try块内部，许多不同的方法调用可能会产生类型相同的异常，只需要提供一个针对此类型的异常处理程序。
- 异常处理理论上由两种基本模型： 终止模型、恢复模型。
- Java支持终止模型。程序无法返回到异常发生的地方继续执行。
- 恢复模型意思是异常处理程序的工作时修正错误，然后重新尝试调用出问题的方法。
- Java实现类似恢复的行为：遇见错误时不能抛出异常，而是调用方法来修正该错误；或把try块放在while循环里。
- 恢复模型导致耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码。

## 12.4 创建自定义异常
- Java可以自己定义异常类来表示程序中可能会遇到的特定问题。
- 要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承。
- 对异常来说，最重要的部分是类名。

## 12.5 异常说明
- Java提供了异常说明，能以礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型，然后进行相应的处理。
- 异常说明属于方法声明的一部分，紧跟在形式参数列表之后。
- 异常说明使用了附件的关键字throws，后面接一个所有潜在异常类型的列表。
- 代码必须与异常说明一致。可以声明方法将抛出异常，实际上却不抛出。
- 在编译时被强制检查的异常称为被检查的异常。

## 12.6 捕获所有异常
- 可以只写一个异常处理程序来捕获所有类型的异常。
- Throwable方法： getMessage、getLocalizedMessage、toString、printStackTrace、fillInStackTrace。
- getStackTrace方法返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一帧。
- 有时希望把刚捕获的异常重新抛出。调用fillInStackTrace更新异常信息。有关原来异常发生点的信息会丢失，类似于捕获之后抛出另一种异常。
- 在捕获一个异常后抛出另一个异常，并且希望把原始异常信息保存下来，这被称为异常链。
- Java SE5之后，Throwable的子类可以在构造器中接受一个cause对象作为参数，用来表示原始异常。
- Throwable的子类中，只有三种基本的异常类提供了带cause参数的构造器： Error（用于Java虚拟机报告系统错误）、Exception、RuntimeException。
- 如果要把其他类型的异常链接起来，应该使用initCause方法而不是构造器。

## 12.7 Java标准异常
- Throwable用来表示任何可以作为异常被抛出的类。分为两种类型：Error、Exception。
- Error用来表示编译时和系统错误。
- Exception是可以被抛出的基本类型。
- 运行时异常都是从RuntimeException类继承未来，也被称为“不受检查异常”。这种异常属于错误，将被自动捕获。代表的是编程错误。
- 不应把Java的异常处理机制当成是单一用途的工具。

## 12.8 使用finally进行清理
- finally子句总能被执行。
- 对于没有垃圾回收和析构函数自动调用机制的语言来说，finally非常重要。
- Java中当要把除内存之外的资源恢复到它们的初始状态时，就要用到finally子句。
- 如果把finally子句和带标签的break及continue配合使用，在Java里就没有必要使用goto语句了。
- 因为finally子句总是会执行，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行。
- 用某些特殊的方式使用finally子句，会导致异常丢失。 1. 在finally中抛异常； 2. 在finally中return。

## 12.9 异常的限制
- 当覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常。
- 异常限制对构造器不起作用。
- 派生类构造器的异常说明必须包含基类构造器的异常说明。
- 派生类构造器不能捕获基类构造器抛出的异常。
- 强制派生类遵守基类方法的异常说明。
- 派生类方法可以不抛出异常，即使它是基类所定义的异常。
- 异常说明本身并不属于方法类型的一部分，因此不能基于异常说明来重载方法。
- 在继承和覆盖的过程中，某个特定方法的“异常说明的接口”不是变大了而是变小了。这恰好和类接口在继承时的情形相反。

## 12.10 构造器
- 如果构造器在其执行过程中半途而废，也许该对象的某些部分还没有被成功创建，而这些部分在finally子句中却是要被清理的。
- 对于在构造阶段可能会抛异常，并且要求清理的类，最安全的使用方式是使用嵌套的try子句（try嵌套try）。

## 12.11 异常匹配
- 抛出异常的时候，异常处理系统会按照代码的书写顺序找出最近的处理程序。
- 找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。
- 查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序。

## 12.12 其他可选方式
- 异常处理的一个重要原则是“只有在知道如何处理的情况下才捕获异常”。
- 异常处理的一个重要目标是把错误处理的代码同错误发生的地点相分离。
- 被检查的异常强制在可能还没准备好处理错误的适合被迫加上catch子句，导致了“吞食则有害”的问题。
- 异常处理历史、Java发明了“被检查的异常”，及作者观点。
- 反射和泛型用来补偿静态类型检查所带来的过多限制。
- 处理被检查的异常：1. 传递给控制台； 2. 转换为不检查的异常。

## 12.13 异常使用指南
- 再恰当的级别处理问题。
- 解决问题并且重新调用产生异常的方法。
- 进行少许修补，然后绕过异常发生的地方继续执行。
- 用别的数据进行计算，以代替方法预计会返回的值。
- 把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。
- 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。
- 终止程序。
- 进行简化。
- 让类库和程序更安全。

## 12.14 总结
- 异常是Java程序设计不可分隔的一部分，如果不了解如何使用，只能完成很有限的工作。
- Java坚定地强调将所有的错误都已异常形式报告。

{% endmarkmap %}

## 理解
- 12.6 Throwable的子类在构造器都可以接受一个cause对象作为参数。在Throwable子类中，只有三种基本的异常类提供了带cause参数的构造器。这里冲突了？？？
- 使用initCause方法而不是构造器？？？
