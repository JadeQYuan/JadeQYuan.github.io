title: 并发
description: 并发
categories: 
  - Java
  - 编程思想
author: Jade
date: 2021-12-28 14:00:00
---

{% markmap %}

## 21.0 序
- 顺序编程，即程序中的素有事物在任意时刻都只能执行一个步骤。
- 并发具有可论证的确定性，但是实际上具有不可确定性。
- 尽管Java SE5在并发方面做出了显著的改进，但是仍旧没有像编译期验证或检查型异常这样的安全网。
- 无法选择何时Java程序中出现线程。Servlet具有天生的多线程性。

## 21.1 并发的多面性
- 并发编程令人困惑的一个主要原因是：使用并发时需要解决的问题由多个，而实现并发的方式也有多种，并且这两者之间没有明显的映射关系。
- 用并发解决的问题大体上可以分为“速度”和“设计可管理性”两种。

- 并发是用于多处理器编程的基本工具。
- 并发通常是提高运行在单处理器上程序的性能。
- 从性能的角度看，如果没有任务会阻塞，那么在单处理器机器上使用并发就没有任何意义。
- 在单处理器系统中的性能提高的常见示例是事件驱动的编程。
- 实现并发最注解的方式是在操作系统级别使用进程。进程是运行在它自己的地址空间内的自包容的程序。
- 某些编程语言被设计为可以将并发任务彼此隔离，这些语言通常被称为函数型语言。
- Java采取了更加传统的方式，在顺序型语言的基础上提供对线程的支持。
- 线程机制是在由执行程序表示的单一进程中创建任务。这种方式产生的一个好处是操作系统的透明性。
- 对于不支持多任务的OS，除非在Java中添加多线程机制，否则就会打破“编写一次，到处运行”的要求。

- 在单CPU机器上使用多任务的程序在任意时刻仍旧只在执行一项工作。
- 并发提供了一个重要的组织结构上的好处：程序设计可以极大地简化。
- Java中的线程机制是抢占式的，这表示调度机制会周期性地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。
- 在协作式系统中，每个任务都会自动地放弃控制，这要求程序员要有意识地在每个任务中插入某种类型的让步语句。
- 协作式系统的优势是双重的：上下文切换的开销通常比抢占式系统要低廉许多，并且对可以同时执行的线程数量在理论上没有任何限制。
- 并发需要付出代价，包含复杂性代价，但是这些代价在与程序设计、资源负载均衡以及用户方便使用方面的改进相比，就显得微不足道了。
- 通常，线程使你能够创建更加松散耦合的设计。

## 21.2 基本的线程机制
- 并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务（子任务）中的每一个都将由执行线程来驱动。
- 一个线程就是在进程中的一个单一的顺序控制流。因此，单个进程可以拥有多个并发执行的任务。
- 多任务和多线程往往使使用多处理器系统的最合理方式。

- 线程可以驱动任务，因此需要一种描述任务的方式，这可以由Runnable接口来提供。
- 静态方法Thread.yield是对线程调度器（Java线程机制的一部分，可以将CPU从一个线程转移给另一个线程）的一种建议。这完全是选择性的。

- 将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。
- 如果机器上由多个处理器，线程调度器将会在这些处理器之间默默地分发线程。
- 线程调度机制是非确定性的。
- 每个Thread都“注册”了它自己，因此确实有一个对它的引用，而且在它的任务退出其run并死亡之前，垃圾回收器无法清除它。

- Java SE5的java.util.concurrent包中的执行器（Executor）将为你管理Thread对象，从而简化了并发编程。
- Executor在客户端和任务执行之间提供了一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。
- Executor允许管理异步任务的执行，而无须显式地管理线程的声明周期。
- 非常常见的情况是，单个的Executor被用来创建和管理系统中所有的任务。
- 在任何线程池中，现有线程在可能的情况下，都会被自动复用。
- CachedThreadPool、FixedThreadPool、SingleThreadExecutor。

- Runnable是执行工作的独立任务，但是它不返回任何值。
- 在Java SE5中引入的Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call中返回的值。
- 必须使用ExecutorService.submit调用Callable。会产生参数化Future对象。

- 影响任务行为的一种简单方法是调用sleep，这将是任务中止执行给定的时间。
- Java SE5引入了更加显式的sleep版本，TimeUnit。还可以被用来执行转换。

- 线程的优先级将该线程的重要性传递给了调度器。
- CPU处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先级最高的线程先执行。优先级不会导致死锁。
- 在绝大多数时间里，所有线程都应该以默认的优先级运行。
- 使用getPriority来读取现有线程的优先级，通过setPriority来修改。 -- 设置位置。
- 唯一可移植的方法是当调整优先级的时候，只是用MAX_PRIORITY、NORM_PRIORITY、MIN_PRIORITY。

- yield只是一个暗示，没有任何机制保证它将会被采纳。
- 当调用yield是，也是在建议具有相同优先级的其他线程可以运行。

- 后台（daemon）线程是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。
- 必须在线程启动之前调用setDaemon方法，才能把它设置为后台线程。
- 一个后台线程创建的任何线程都将被自动设置为后台线程。
- 后台线程finally子句可能不会执行。

- 任务直接从Thread类继承。
- 另一种惯用法是自管理的Runnable。
- 有时通过使用内部类来将线程代码隐藏在类中。

- 执行的任务与驱动它的线程之间有一个差异，对Thread类实际没有任何控制权。
- 创建任务。并通过某种方式将一个线程附着到任务上，以使得这个线程可以驱动任务。
- 在Java中，Thread类自身不执行任何操作，它只是驱动赋予它的任务。
- 将任务从线程中分离出来是很有意义的。

- 一个线程可以在其他线程之上调用join方法，其效果是等待一段时间直到第二个线程结束才继续执行。
- 对join方法的调用可以被中断，做法是在调用线程上调用interrupt方法，这时需要用到try-catch子句。

- 使用线程的动机之一就是建立有响应的用户界面。

- ~~线程组持有一个线程集合。~~

- 由于线程的本质特性，不能捕获从线程中逃逸的异常。
- 一旦异常逃出任务的run方法，它就会向外传播到控制台，除非采取特殊的步骤捕获这种错误的异常。
- Thread.UncaughtExceptionHandler是Java SE5中的新接口，允许在每个Thread对象上都附着一个异常处理器。
- Thread.UncaughtExceptionHandler.uncaughtException会在线程因未捕获的异常而临近死亡时被调用。

## 21.3 共享受限资源
- 共享公共资源的任务观察该资源的终止信号。这可以消除所谓竞争条件。
- 在Java中，递增不是原子性操作。

- 基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。意味着在给定时刻只允许一个任务访问共享资源。
- 通常通过在代码前面加上一条锁语句来实现的。因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量（mutex）。
- 线程调度机制并不是确定性的。
- Java以提供关键字synchronized的形式，为防止资源冲突提供了内置支持。
- 共享资源一般是以对象形式存在的内存片段，但也可以是文件、输出/输出端口，或者是打印机。
- 所有对象都自动含有单一的锁。针对每个类，也有一个锁（作为类的Class对象的一部分）。
- 每个访问邻接共享资源的方法都必须被同步，否则它们就不会正确地工作。
- Java SE5的java.util.concurrent类库还包含有定义在locks中的显式的互斥机制。Lock对象必须被显式地创建、锁定和释放。
- 使用Lock对象时的惯用法：对lock的调用，必须放置在finally子句中带有unlock的try-finally语句中。return语句必须在try子句中出现，以确保unlock不会过早发生。
- 显式的Lock对象在加锁和释放锁方面，相对于内建的synchronized锁来说，还赋予了更细粒度的控制力。

- 原子操作是不能被线程调度机制中断的操作。
- volatile关键字确保了应用中的可视性。
- 同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile的。
- 对域中的值赋值和返回操作通常都是原子性的。

- Java SE5引入了诸如AtomicInteger、AtomicLong、AtomicReference等特殊的原子性变量类。
- 有时，只是希望防止多个线程同时访问方法内部的部分代码而不是整个方法。通过这种方式分离出来的代码段被称为临界区。同步控制块。
- 还可以使用显式的Lock对象来创建临界区。

- synchronized块必须给定一个在其上进行同步的对象。并且最合理的方式是，使用其方法正在被调用的当前对象。

- 线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。
- 创建和管理线程办呢滴存储可以由java.lang.ThreadLocal类来实现。
- ThreadLocal对象通常当作静态域存储。

## 21.4 终结任务
- 在某些情况下，任务必须更加突然地终止。

- 线程状态：新建（new）、就绪（Running）、阻塞（Blocked）、死亡（Dead）。
- 进入阻塞状态： 1. 调用sleep； 2. 调用wait； 3. 任务在等待某个输入/输出完成； 4. 等待锁释放。 调用join？
- ~~使用suspend和resume来阻塞和唤醒线程，可能导致死锁。stop方法不释放线程获得的锁。~~

- Thread类包含interrupt方法，这个方法将设置线程的终端状态。
- 如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出InterruptedException。
- 当抛出InterruptedException异常或者该任务调用Thread.interrupted时，中断状态将被复位。
- Thread.interrupted提供了离开run循环而不抛出异常的第二种方式。
- 在Executor上调用shutdownNow，将发送一个interrupt调用给它启动的所有线程。
- submit将返回一个通配符泛型Future，可以在其上调用cancel，并因此可以使用它来中断某个特定任务。
- 不能中断正在试图获取synchronized锁或者试图执行I/O操作的线程。 -- 关闭任务在其上发生阻塞的底层资源。 -- 被阻塞的nio通道会自动地响应中断。
- 同一个互斥可以被同一个任务多次获得。 -- 可重入锁。
- 只要任务以不可中断的方式被阻塞，那么都有潜在的会锁住程序的可能。
- Java SE5并发类库中添加了一个特性，即在ReentrantLock上阻塞的任务具备可以被中断的能力。

- 在线程上调用interrupt时，中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部时。
- 如果只能通过在阻塞上调用抛出异常来退出，无法总是可以离开run循环。
- 如果调用interrupt以停止某个任务，那么在run循环碰巧没有产生任何阻塞调用的情况下，需要第二种方式来退出。 -- 中断状态。
- 可以通过调用interrupted来检查中断状态，还可以清除中断状态。

## 21.5 线程之间的协作
- 当任务协作时，关键问题时这些任务之间的握手。为了实现这种握手，使用了相同的基础特性：互斥。
- 互斥能够确保只有一个任务可以相应某个信号，这样就可以根除任何可能的竞争条件。

- wait使你可以等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力。通常，这种条件由另一个任务来改变。
- wait会在等待外部世界产生变化的时候将任务挂起，并且只有在notify或notifyAll发生时，这个任务才会被唤醒并去检查所产生的变化。
- wait提供了一种在任务之间对活动同步的方式。
- 调用sleep时锁没有被释放，调用yield也是。调用wait时，线程的执行被挂起，对象上的锁被释放。
- 由两种形式的wait。 1. 指定时间； 2. 无限等待，直到线程接受到notify或notifyAll消息。
- wait、notify、notifyAll时基类Object的一部分，而不是Thread的一部分。因为这些方法操作的锁也是所有对象的一部分。
- 只能在同步控制方法或同步控制块里调用wait、notify、notifyAll。
- 可以让另一个对象执行某种操作以维护其自己的锁。要这么做的话，必须首先得到对象的锁。
- 必须用一个检查感兴趣的条件的while循环包围wait。这很重要。本质就是要检查所感兴趣的特定条件，并在条件不满足的情况下返回到wait中。
- 当两个线程使用notify/wait或notifyAll/wait进行协作时，有可能会错过某个信号。 -- 防止在变量上产生竞争条件。

- 使用notify时，在众多等待同一个锁的任务中只有一个会被唤醒。必须保证被唤醒的是恰当的任务。
- 当notifyAll因某个特定锁而被调用时，只有等待这个锁的任务才会被唤醒。
- 在典型的生产者-消费者实现中，应使用先进先出队列来存储被生产和消费的对象。
- 使用互斥并允许任务挂起的基本类是Condition。await、signal、signalAll。
- 与使用notifyAll相比，signalAll是更安全的方式。
- Lock产生Condition对象，这个对象被用来管理任务间的通信。但是不包含任何有关处理状态的信息，因此需要管理额外的表示处理状态的信息。

- wait和notify方法以一种非常低级的方式解决了任务互操作问题，即每次交互时都握手。
- 使用同步队列来解决协作问题，同步队列在任何时刻都只允许一个任务插入或移除元素。 -- java.util.concurrent.BlockingQueue接口。
- LinkedBlockingQueue，无界队列。 ArrayBlockingQueue，具有固定的尺寸。
- 如果消费者任务试图从队列中获取对象，而该队列此时为空，那么这些队列可以挂起消费者任务，当有更多元素可用时恢复消费者任务。
- 阻塞队列可以解决非常大量的问题，而其方式与wait与notifyALl相比，则简单并可靠得多。
- 同步由队列（其内部是同步的）和系统的设计隐式地管理了。
- 使用显式的wait和notifyAll时存在的类和类之间的耦合被消除了，因为每个类都只和它的BlockingQueue通信。

- 通过输入/输出在线程间进行通信通常很有用。提供线程功能的类库以管道的形式对线程间的输入/输出提供了支持。
- 在Java中输入/输出类库中对应物就是PipedWriter类和PipedReader类。
- 管道基本上就是一个阻塞队列，存在于多个引入BlockingQueue之前的Java版本中。

## 21.6 死锁
- 哲学家就餐问题时一个经典的死锁例证。
- 当四个条件同时满足时，就会发生死锁。 1. 互斥； 2. 请求和保持； 3. 不可抢占； 4. 循环等待。
- 要防止死锁，只需破坏其中一个即可。在程序中，最容易的方法是破坏第4个条件。

## 21.7 新类库中的构件
- Java SE5的java.util.concurrent引入了大量设计用来解决并发问题的新类。
- CountDownLatch。 被用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。
- CyclicBarrier。 CountDownLatch是只出发一次的事件，而CyclicBarrier可以多次重用。
- DelayQueue。 这是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。
- PriorityBlockingQueue。 优先级队列，具有可阻塞的读取操作。
- ScheduledExecutor。 可以将Runnable对象设置为在将来的某个时刻执行或每隔规则的时间重复执行。
- Semaphore。 允许n个任务同时访问一个资源。
- Exchanger。 是两个任务之间交换对象的栅栏。当这些任务进入栅栏时，它们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。

## 21.8 仿真
- 并发最有趣也最令人兴奋的用法就是创建仿真。通过使用并发，仿真的每个构件都可以成为其自身的任务，这使得仿真更容易编程。
- 银行出纳员仿真。
- 饭店仿真。
- 分发工作。

## 21.9 性能调优
- 在Java SE5的java.util.concurrent类库中存在着数量庞大的用于性能提高的类。

- 比较各类互斥技术。synchronized、Lock、Atomic。
- 微基准测试：通常指在隔离的、脱离上下文环境的情况下对某个特性进行性能测试。
- 只有在互斥存在竞争的情况下，才能看到真正的性能差异，因此必须有多个任务尝试访问互斥代码区。
- 编译器看到synchronized关键字时，有可能会执行特殊的优化。
- 模板方法。将所有共用代码都放置到基类中，并将所有不同的代码隔离在导出类的实现中。
- FixedThreadPool，在测试过程中防止产生任何额外的开销。丢弃第一次结果，因为它包含了初始线程的创建。
- CyclicBarrier，确保所有的任务在声明每个测试完成之前都已经完成。
- 使用Lock通常会比使用synchronized要高效许多，而且synchronized的开销看起来变化范围太大，而Lock相对比较一致。
- 代码被阅读的次数远多于被编写的次数。 -- 代码的可读性至关重要。
- 以synchronized关键字入手，只有在性能调优时才替换为Lock对象这种做法，是具有实际意义的。
- Atomic对象只有在非常简单的情况下才有用，这些情况通常包括只有一个要被修改的Atomic对象，并且这个对象独立于其他所有的对象。
- 以更加传统的互斥方式入手，只有在性能方面的需求能够明确指示时，再替换为Atomic。

- 容器是所有编程中的基础工具，这其中包括并发编程。
- Java 1.2中，新的容器类库是不同步的，并且Collections类提供了各种static的同步的装饰方法，从而来同步不同类型的容器。
- Java SE5特别添加了新的容器，通过使用更灵巧的技术来消除加锁，从而提高线程安全的性能。
- 免锁容器背后的通用策略是：对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可。
- 修改是再容器数据结构的某个部分的一个单独的副本（有时是整个数据结构的副本）上执行的，并且这个副本再修改过程中是不可见的。
- CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap、ConcurrentLinkedQueue。
- 只要是从免锁容器中读取，它就会比其synchronized对应物快许多，因为获取和释放锁的开销被省掉了。
- ConcurrentHashMap使用了一种不同的技术，可以明显地最小化写入所造成的影响。

- 尽管Atomic对象将执行原子性操作，但是某些Atomic类还允许执行所谓的乐观加锁。 -- compareAndSet方法。
- 通过使用Atomic来替代synchronized或Lock，可以获得性能上的好处。
- 如果compareAndSet操作失败会发生什么？

- ReadWriteLock可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。
- 应该使用更直观的同步，并且只有在必需时再引入ReadWriteLock。

## 21.10 活动对象
- Java中的线程机制看起来非常复杂并难以正确使用。有一种可替换的方式被称为活动对象或行动者。
- 每个对象都维护者它自己的工作器线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻都只能运行其中的一个。
- 有了活动对象，就可以串行化消息而不是方法，这意味着不再需要要给防备一个任务在其循环的中间被中断这种问题了。
- 当向一个活动对象发送消息时，这条消息会转变为一个任务，该任务会被插入到这个对象的队列中，等待再以后的某个时刻运行。
- Java SE5的Future在实现这种模式时将排上用场。
- 没有直接的编译器支持。 -- 基于代理。
- 代理编程，把对象和相对容易的并发解决方案结合了起来。

## 21.11 总结
- 线程的一个额外好处时它们提供了轻量级的执行上下文切换，而不是重量级的进程上下文切换。
- 因为一个给定进程内的所有线程共享相同的内存空间，轻量级的上下文切换只是改变了程序的执行序列和局部变量。进程切换必须改变所有内存空间。
- 活锁：多个运行各自任务的线程使得整体无法完成。
- 需要明智地使用可用的加锁机制。

{% endmarkmap %}