title: 初始化与清理
description: 初始化与清理
categories: 
  - Java
  - 编程思想
author: Jade
date: 2021-12-03 19:00:00
---

随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。
初始化和清理正是设计安全的两个问题。

{% markmap %}

## 5.1 用构造器确保初始化
- 创建对象时，如果其内具有构造器，Java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。
- 构造器命名：与类名相同，所以"每个方法首字母小写"的编程风格不适用于构造器。1. 不会与其它方法冲突；2. 编译器直到该调用哪个方法。
- 构造器有助于减少错误，并使代码更易于阅读。从概念上讲，初始化与创建使彼此独立的，在Java中，捆绑在一起，两者不能分离。
- 构造器没有返回值，与void不同。new表达式返回了对新建对象的引用，但构造器本身并没有返回任何值。

## 5.2 方法重载
- 方法重载：对相同的概念使用相同的名字。
- 在Java和C++中，构造器是强制重载方法的一个原因。构造器的名字已经由类名确定。
- 方法重载是构造器所必需的，但亦可用于其他方法。
- 每个重载的方法都必须有一个独一无二的参数类型列表（参数类型、参数顺序（会使代码难以维护））。
- 基本类型当作参数会先提升类型，然后传参。
- 根据返回值无法区分方法重载。为了副作用而调用就会忽略其返回值。

## 5.3 默认构造器
- 如果类中没有构造器，编译器会自动创建一个默认构造器。
- 如果已有构造器，则不会创建。

## 5.4 this关键字
- 为了能用简便、面向对象的语法来编写代码，编译器做了一些幕后工作，把"所操作对象的引用"作为第一个参数传给方法(方法在内存中只有一份)。
- 只能在方法内部使用，表示对"调用方法的那个对象"的引用。
- 使用高级语言的原因之一就是它会帮我们做一些事情。如传递对当前对象的引用（this），所以除非必要，则不用使用this。
- 必须使用this的情况：1. 需要返回当前对象的引用时，return this;。2. 将当前对象作为参数传递给其他对象。3. 在构造器中调用构造器(只能调用一个，且必须将构造器的调用至于最起始处)。4. 参数名和数据成员名称相同时，使用this来代表数据成员。
- static方法：没有this的方法（不用将当前对象引用作为第一个参数传给方法）。
- static主要用途：没有创建任何对象的前提下，使用类本身调用。
- static不是面向对象的？

## 5.5 清理：终结处理和垃圾回收
- 程序员都了解初始化的重要性，但常常会忘记同样也重要的清理工作。Java有垃圾回收器负责回收无用对象占据的内存资源。
- 在C++中，对象一定会被销毁（析构函数）。而在Java中，对象并非总是被垃圾回收。1. 对象可能不被垃圾回收；2. 垃圾回收不等于析构；3. 垃圾回收只与内存有关。
- 垃圾回收本身也有开销。
- 不论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。
- 本地方法（在Java中调用非Java代码的方式）通过某种创建对象方式以外的方式为对象分配了存储空间，需要在finalize()方法来释放。
- 本地方法目前只支持C/C++，但它们可以调用其它任何语言的代码，相当于可以调用任何代码。
- Java不允许创建局部对象。C++局部对象销毁动作发生在}为边界。

- 在堆上分配对象的代价十分高昂，涉及到对象销毁后重新利用内存。
- Java垃圾回收器对于对象创建速度有明显的提高。Java从堆分配空间的速度，可以和其它语言从堆栈上分配空间的速度相媲美。
- 引用计数：常用来说明垃圾收集的工作方式。
- 更快的模式：从堆栈和静态存储区考试，遍历所有引用。
- Java虚拟机采用自适应的垃圾回收技术，如何处理找到的存活对象，却决于不同的虚拟机实现。有一种做法是“停止-复制”。
- 停止-复制问题：1. 得有两个堆，空间大（按需分配几款较大的内存）； 2. 可能只有少量垃圾，甚至没有垃圾（转到标记-清扫）。
- 标记-清扫：从堆栈和静态存储区考试，遍历所有引用，标记存活对象，全部标记工作完成之后，清理动作才会开始，清理过程中，没有标记的对象将被释放，不会发生任何复制动作。 -- 希望得到连续空间就得重新整理。
- 垃圾回收动作发生的同时，程序将会被暂停（停止-复制、标记-清扫）。
- 在Java虚拟机中，内存分配以较大的“块”为单位。如果对象较大，会占用单独的块。
- 每个块都有相应的代数来记录它是否存活。清理时，大型对象不会被复制，只是增加代数。
- 自适应：Java虚拟机监视结果，自动切换“停止-复制”与“标记-清扫”。
- 自适应的、分代的、停止-复制、标记-清扫 式垃圾回收器。
- Java虚拟机中有许多附加技术用以提升速度。如HotSpot中的JIT（Just-In-Time）。

## 5.6 成员初始化
- Java尽力保证：所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。
- 类的数据成员(全局变量)，基本类型会默认有一个初始值，对象引用会获得特殊值null。
- 可以在定义类成员变量的地方为其赋值。可以调用方法。方法可以带参，但是参数必须时已初始化的。
- 每个对象都有相同的初值。

## 5.7 构造器初始化
- 通过构造器来进行初始化(无法阻止自动初始化的进行，它将在构造器调用之前发生)。
- 变量定义的先后顺序决定了初始化的顺序。
- 静态数据只占用一份存储区域。static关键字不能应用于局部变量，只能作用于域。
- 静态数据在第一次访问静态数据（构造器也是static方法）时被初始化。
- 显式的静态数据初始化：静态代码块。
- 非静态实例初始化：普通代码块(匿名内部类的初始化)。
- 构造器没有显式地使用static，但也是静态方法。

## 5.8 数组初始化
- 数组是相同类型的，用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。通过方括号下标操作符来定义和使用。
- 声明数组时编译器不允许指定数组的大小（只是创建了一个数组的引用并未该引用分配了空间，并没有给数组本身分配空间）。
- 初始化表达式：由一对花括号括起来的值组成。在这种情况下，存储空间的分配(等价于使用new)由编译器负责。
- 所有数组都有一个固有成员length，用来获知数组内包含了多少个元素。只能访问不能修改。
- Java不允许下标越界，一旦越界，就会出现运行时错误。通过每次在访问数组的时候检查边界实现，检查是需要开销的，且无法禁用。
- 可以用new在数组里创建元素（只能用在数组被定义之处），也可以用花括号括起来的列表来初始化对象数组（可以在任何地方使用）。
- 使用可变参数，指定参数时，编译器会自动填充为数组，获取的仍旧是个数组。
- int数组的class： [I。
- 应该只在重载方法的一个版本上使用可变参数列表，或者压根不使用。（可变参数列表使得重载过程变得复杂了，每一种情况，编译器都会使用自动包装机制来匹配重载的方法，然后调用最明确匹配的方法。）

## 5.9 枚举类型
- 枚举类型的实例是常量，按照命名惯例使用大写字母表示(多个单词用下划线隔开)。
- 为了使用enum，需要创建一个该类型的引用，并将其赋值给某个实例。
- 创建enum时，编译器自动添加toString()，ordinal()(声明顺序)，values()(按声明顺序，产生由常量构成的数组)方法。
- 与switch配合使用。

{% endmarkmap %}

## 理解
- Java的速度问题是涉足某些特定编程领域的障碍。
- Java中付出了一定的开销，来保证代码的安全性，使使用更简单。这种权衡使得Java更加面向上层应用开发，而更加使底层开发者望而却步。
